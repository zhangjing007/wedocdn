/*!
 * LMV v7.37.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelAlignmentService =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelAlignmentService/ModelAlignmentService.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/ModelAlignmentService/AlignedItemNucleus.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignedItemNucleus.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignedItemNucleus; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;
var avp = av.Private;

// All data that is stored by the service per aligned item.
var AlignedItemNucleus = /*#__PURE__*/function () {

  function AlignedItemNucleus(alignedItemID) {_classCallCheck(this, AlignedItemNucleus);
    this.init(alignedItemID);
  }_createClass(AlignedItemNucleus, [{ key: "init", value: function init(

    alignedItemID) {
      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = undefined;

      // {LMVMatrix4} Initially assume null = "no alignment transform set".
      this.transform = null;

      // {bool} whether alignment is locked
      this.isLocked = false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = undefined;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = undefined;

      // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
      this.versionUrn = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.versionUrn;

      // viewable part id - name of the specific viewable, e.g. "Second Floor"
      this.viewablePartId = alignedItemID === null || alignedItemID === void 0 ? void 0 : alignedItemID.viewablePartId;

      // {Region[]} - optional array of 2D regions.
      this.regions = undefined;
    }

    // Returns true if alignment/lock state is the same as for new items that the backend doesn't know about.
  }, { key: "isDefaultState", value: function isDefaultState() {
      return !this.transform && !this.isLocked && !this.regions;
    } }, { key: "resetToDefaultState", value: function resetToDefaultState()

    {
      this.transform = null;
      this.isLocked = false;
      this.regions = null;
    }

    // Init new item before saving a transform for the first time
    //  @param {string}     versionUrn - base64-encoded versionUrn
    //  @param {LmvMatrix4} transform
  }, { key: "createNew", value: function createNew(alignedItemID, transform) {
      this.init();
      this.versionUrn = alignedItemID.versionUrn;
      this.viewablePartId = alignedItemID.viewablePartId;
      this.transform = transform;
      return this;
    }

    // Set from data that we got from alignment service
  }, { key: "load", value: function load(data) {

      // Note: The serivce works with unencoded versionUrns, e.g. 'urn:adsk.wipstg:fs.file:vf.vSenZnaYQAOAZqzHB54kLQ?version=1'.
      //       However, the rest of LMV usually uses encoded ones. So, we only use the decoded ones when receiving or sending service data.
      this.versionUrn = avp.toUrlSafeBase64(data.versionUrn);

      // {string} viewable part id - name of the specific viewable, e.g. "Second Floor"
      this.viewablePartId = data.viewablePartId;

      if (data.regions) {
        this.regions = data.regions.map(function (region) {
          // If region contains a matrix (and it should), convert it into LmvMatrix
          if (region.transform) {
            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);
          }

          // Convert array into THREE.Box2
          region.boundingBox = new THREE.Box2().set(
          { x: region.boundingBox[0], y: region.boundingBox[1] },
          { x: region.boundingBox[2], y: region.boundingBox[3] });


          return region;
        });
      }

      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = data.checksum;

      // {bool} whether alignment is locked
      this.isLocked = data.isLocked || false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = data.updatedAt;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = data.updatedBy;

      // Create LmvMatrix4 from float array
      this.transform = Array.isArray(data === null || data === void 0 ? void 0 : data.transform) ? new avp.LmvMatrix4(true).fromArray(data === null || data === void 0 ? void 0 : data.transform) : null;

      return this;
    }

    // If this item actually exists on the server, there must be a checksum provided by the backend.
    // If there is none, this indicates that the item does not exist on the server yet.
  }, { key: "existsOnServer", value: function existsOnServer() {
      return Boolean(this.checksum);
    }

    // Convert into object that we can serialize into a json request body
  }, { key: "toObject", value: function toObject() {
      return {
        checksum: this.checksum,
        isLocked: this.isLocked,
        transform: this.transform && Array.from(this.transform.elements),
        regions: this.regions ? this.regions.map(function (r) {
          var region = Object.assign({}, r);

          // If region contains a matrix (and it should), convert it to number array first
          if (region.transform) {
            region.transform = Array.from(region.transform.elements);
          }

          // Convert THREE.Box2 into a flat array.
          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];
          return region;
        }) : undefined,
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn), // alignmentService requires decoded urns
        viewablePartId: this.viewablePartId };

    } }]);return AlignedItemNucleus;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentCache.js":
/*!************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentCache.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentCache; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

// Helper class to implement batching and caching of alignment items (alignment transforms, locked-flags, and possible other service-specific data). 
//
// Main purpose is to provide implementation of loadTransform/saveTransform in a way that
// we don't fire a single request per call. Instead, all transforms can be prefetched in a single batch and loadTransform gets them from memory as soon as available.
var AlignmentCache = /*#__PURE__*/function () {

  // The actual content of cached items is left to the client. The cache cannot add items itself.
  //
  // @param {async function(string[])} fetchItems - Async function to make batch requests. On success it returns a map from versionUrn to data items.
  function AlignmentCache(fetchItems) {_classCallCheck(this, AlignmentCache);

    // Keep callback to fetch items
    this._fetchItems = fetchItems;

    // AlignmentItems in memory. Indexed by alignedItemId key.
    this.cache = {};

    // If the alignment for an urn is not in memory, but already requested, this[urnToRequestIndex] gives us the index
    // of the corresponding request in this.pendingRequests.
    this.urnToRequestIndex = {};

    // For each pending fetchItems-call, this array contains a promise that resolves when the request is finished.
    this.pendingRequests = [null];
  }_createClass(AlignmentCache, [{ key: "clear", value: function clear()

    {
      this.cache = {};
    }

    // Prefetch alignment items for a given list of urns and add them to the cache.
  }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIds) {var _this = this;var needsLoad, requestIndex, promise, result;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                // Skip urls that we already know
                needsLoad = function needsLoad(alignedItemId) {return !_this.cache[alignedItemId.toString()];};
                alignedItemIds = alignedItemIds.filter(needsLoad);

                // If all is in cache, we are done here
                if (alignedItemIds.length) {_context.next = 4;break;}return _context.abrupt("return");case 4:



                // find free request index
                requestIndex = 1;
                while (this.pendingRequests[requestIndex]) {requestIndex++;}

                // Mark all urns as pending and allow finding the request for a given urn
                alignedItemIds.forEach(function (alignedItemId) {return _this.urnToRequestIndex[alignedItemId.toString()] = requestIndex;});

                // Do the actual request
                promise = this._fetchItems(alignedItemIds);

                // Keep promise so that later fetchSingleItem() calls to any of the urns can return it.
                this.pendingRequests[requestIndex] = promise;

                // Wait for request result
                _context.next = 11;return promise;case 11:result = _context.sent;

                // remove promise from pendingRequests
                this.pendingRequests[requestIndex] = null;


                // If fetching succeeded, add results to cache.
                // Otherwise, do nothing: It's up to the client to deal with errors
                if (result) {
                  alignedItemIds.forEach(function (alignedItemId) {
                    var key = alignedItemId.toString();
                    _this.cache[key] = result[key];
                  });
                }

                // Mark urn as resolved and not pending anymore. Note that this always needs to happen, no matter whether successful or not.
                alignedItemIds.forEach(function (alignedItemId) {
                  // Use delete here to keep the dictionary cleaner. 
                  // Although it's a bit slower than setting to undefined, this doesn't matter here,
                  // because the the call frequency is not critically high.
                  delete _this.urnToRequestIndex[alignedItemId.toString()];
                });case 15:case "end":return _context.stop();}}}, _callee, this);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Return immediately whatever we have in cache
  }, { key: "getCachedItem", value: function getCachedItem(alignedItemId) {
      var key = alignedItemId.toString();
      return this.cache[key];
    } }, { key: "getItem", value: function () {var _getItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      alignedItemId) {var item, key, requestIndex;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                // Return from memory if possible
                item = this.getCachedItem(alignedItemId);if (!
                item) {_context2.next = 3;break;}return _context2.abrupt("return",
                item);case 3:


                // Ideally, this item should already be handled by a pending batch request.
                // If so, we just wait for it to finish.
                key = alignedItemId.toString();
                requestIndex = this.urnToRequestIndex[key];if (!
                requestIndex) {_context2.next = 10;break;}_context2.next = 8;return (

                  this.pendingRequests[requestIndex]);case 8:_context2.next = 12;break;case 10:_context2.next = 12;return (



                  this.fetchItems([alignedItemId]));case 12:return _context2.abrupt("return",

                this.getCachedItem(alignedItemId));case 13:case "end":return _context2.stop();}}}, _callee2, this);}));function getItem(_x2) {return _getItem.apply(this, arguments);}return getItem;}() }, { key: "setItem", value: function setItem(


    alignedItemId, item) {
      var key = alignedItemId.toString();
      this.cache[key] = item;
    } }]);return AlignmentCache;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentService.js":
/*!**************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentService.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentService; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
/* Interface for alignment service implementations. */var
AlignmentService = /*#__PURE__*/function () {

  function AlignmentService() {_classCallCheck(this, AlignmentService);}

  /**
                                                                          * Changes to false if any connection errors happened. As long as it returns true, you can safely assume that
                                                                          * any returned results from getTransform() reflect the latest service state. 
                                                                          */_createClass(AlignmentService, [{ key: "isWorking", value: function isWorking()
    {return true;} }, { key: "clearCache", value: function clearCache()

    {}

    /**
       * Fetch alignment data for a batch of urns. This can be used to avoid individual requests for individual loadTransform()/isAlignmentLocked() calls. 
       *  @param {string[]} urns
       *  @throws {Object} error
       */ }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      urns) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case "end":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()

    /**
                                                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                 * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                 * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
                                                                                                                                                                                                                                                                                 */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt("return",
                null);case 1:case "end":return _context2.stop();}}}, _callee2);}));function loadTransform(_x2, _x3) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                             * Direct access to cached transform in memory: If a transform was loaded by loadTransform or fetch() before, this function allows to get it directly
                                                                                                                                                                                             * within a sync function. However, note that it might return undefined if the transform state is not in memory yet.
                                                                                                                                                                                             *  
                                                                                                                                                                                             * NOTE: Once a transform was loaded, the AlignmentService implementation has to ensure that the result is cached and can be obtained again by this function.
                                                                                                                                                                                             * 
                                                                                                                                                                                             * @returns {LmvMatrix|null|undefined} - Null: "not set", undefined: "not in memory yet".
                                                                                                                                                                                             */ }, { key: "getTransform", value: function getTransform(
    versionUrn, viewablePartId) {
      return null;
    }

    /**
       * Direct access to cached isLocked flag.
       * @returns {bool|undefined} - undefined: "not in memory yet".
       */ }, { key: "getIsLocked", value: function getIsLocked(
    versionUrn, viewablePartId) {
      return false;
    }

    /**
       * @param {string} versionUrn            - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
       * @param {string} [viewablePartId]      - encoded viewableName of the model.
       * @param {LmvMatrix4|null} transform    - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
       * @throws {Object}         error        - some implementation may throw. error.msg should provide an error message.
       */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId, transform) {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:case "end":return _context3.stop();}}}, _callee3);}));function saveTransform(_x4, _x5, _x6) {return _saveTransform.apply(this, arguments);}return saveTransform;}()

    /**
                                                                                                                                                                                                                                                                                                                                            * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                            * @throws {Object}
                                                                                                                                                                                                                                                                                                                                            */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:case "end":return _context4.stop();}}}, _callee4);}));function lockAlignment(_x7, _x8) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()

    /**
                                                                                                                                                                                                                                                                                                                             * Remove alignment lock, so that aligning is possible. We don't expose it per UI.
                                                                                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                             * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                             * @throws {Object}
                                                                                                                                                                                                                                                                                                                             */ }, { key: "unlockAlignment", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:case "end":return _context5.stop();}}}, _callee5);}));function unlockAlignment(_x9, _x10) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}()

    /**
                                                                                                                                                                                                                                                                                                                                   * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                                   * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                   * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                   * @throws {Object}
                                                                                                                                                                                                                                                                                                                                   * @returns {boolean}
                                                                                                                                                                                                                                                                                                                                   */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:case "end":return _context6.stop();}}}, _callee6);}));function isAlignmentLocked(_x11, _x12) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()

    /**
                                                                                                                                                                                                                                                                                                                                          * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                          * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                          * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                          * @param {THREE.Box3} boundingBox  - bounding box of the viewport in model space.
                                                                                                                                                                                                                                                                                                                                          * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                                                                                                          * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                                                                                                          */ }, { key: "saveViewport", value: function () {var _saveViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId, regionId, boundingBox, units) {return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:case "end":return _context7.stop();}}}, _callee7);}));function saveViewport(_x13, _x14, _x15, _x16, _x17) {return _saveViewport.apply(this, arguments);}return saveViewport;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                                                           * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                           * @returns {Object|null}           - Null means that no custom viewport was stored.
                                                                                                                                                                                                                                                                                                                                                                           */ }, { key: "loadViewport", value: function () {var _loadViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:return _context8.abrupt("return",
                null);case 1:case "end":return _context8.stop();}}}, _callee8);}));function loadViewport(_x18, _x19, _x20) {return _loadViewport.apply(this, arguments);}return loadViewport;}()


    /**
                                                                                                                                                                                                 * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                 * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                 * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                 * @returns {object[]}               - Empty array means that no matching viewport was found.
                                                                                                                                                                                                 */ }, { key: "loadViewports", value: function () {var _loadViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:return _context9.abrupt("return",
                []);case 1:case "end":return _context9.stop();}}}, _callee9);}));function loadViewports(_x21, _x22) {return _loadViewports.apply(this, arguments);}return loadViewports;}()


    /**
                                                                                                                                                                                            * @param {string} modelLineageUrn       - encoded lineageUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                            * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
                                                                                                                                                                                            * @param {string} sheetLineageUrn       - encoded lineageUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                            * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                            * @param {string} [regionId]            - A UUID of the sheet's region.
                                                                                                                                                                                            * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                            */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:case "end":return _context10.stop();}}}, _callee10);}));function saveRelationship(_x23, _x24, _x25, _x26, _x27) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                                                                         * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                                                                                                                                                         * 
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                                                                         * @returns {Object[]}
                                                                                                                                                                                                                                                                                                                                                                                                                         */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(
      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:return _context11.abrupt("return",
                null);case 1:case "end":return _context11.stop();}}}, _callee11);}));function getRelationships(_x28, _x29, _x30, _x31) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }]);return AlignmentService;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceLS.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceLS.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceLS; });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var avp = Autodesk.Viewing.Private;

// Prefix used for LocalStorage entries for model-alignment
var keyPrefix = 'Autodesk.Viewing.ModelAlignment';
var APIs = {
  Transform: 'transform',
  Relationship: 'relationship' };


var RelationshipDomain = 'autodesk-construction-alignment';
var RelationshipEntityTypes = {
  Viewable: "viewpart3d",
  Region: "viewpartregion2d" };


var TokenSeparator = '__';

// get LocalStorage key from model version urn
var getKey = function getKey(api, urn) {var viewablePartId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "".concat(keyPrefix).concat(TokenSeparator).concat(api).concat(TokenSeparator).concat(urn).concat(viewablePartId.length ? "".concat(TokenSeparator).concat(viewablePartId) : "");
};

// An single alignment item stored as json in LocalStorage  
var newTransformItem = function newTransformItem(transform) {
  return {
    // Optional: Array of floats
    transform: transform ? transform.elements : null,

    // If true, we forbid changing
    isLocked: false };

};

// Relationship entity ID is defined by lineageUrn + viewablePart + region.
var getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {
  return "lineageUrn=".concat(lineageUrn, "&viewablePart=").concat(viewablePart).concat(region ? "&region=".concat(region) : '');
};

/* Implements model-alignment storage based on LocalStorage. */var
AlignmentServiceLS = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceLS, _AlignmentService);var _super = _createSuper(AlignmentServiceLS);

  function AlignmentServiceLS() {var _this;var localStorage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : avp.LocalStorage;_classCallCheck(this, AlignmentServiceLS);
    _this = _super.call(this);
    _this.localStorage = localStorage;return _this;
  }_createClass(AlignmentServiceLS, [{ key: "getTransform", value: function getTransform(

    versionUrn, viewablePartId) {
      // just read directly from localStorage
      // Note: It's essential to return null (not undefined) if no matrix is set,
      //       because "undefined" would indicate that the state is not in memory yet.
      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);
      return (item === null || item === void 0 ? void 0 : item.transform) || null;
    } }, { key: "getIsLocked", value: function getIsLocked(

    versionUrn, viewablePartId) {
      // item may be null if nothing was saved for this urn so far. In this case, isLocked is always false. 
      var item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);
      return Boolean(item === null || item === void 0 ? void 0 : item.isLocked);
    }

    /**
      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
      * @param {string} [viewablePartId] - encoded viewableName of the model.
      * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
      * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
      */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);return _context.abrupt("return",
                item === null || item === void 0 ? void 0 : item.transform);case 2:case "end":return _context.stop();}}}, _callee, this);}));function loadTransform(_x, _x2) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                                                                                     * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                     * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                     * @param {LmvMatrix4|null} transform  - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
                                                                                                                                                                                                                                                     * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                     */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId, transform) {var item;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.transform = transform;
                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function saveTransform(_x3, _x4, _x5) {return _saveTransform.apply(this, arguments);}return saveTransform;}()


    /**
                                                                                                                                                                                                                                                                 * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                 * @throws {Object}
                                                                                                                                                                                                                                                                 */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.isLocked = true;
                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 3:case "end":return _context3.stop();}}}, _callee3, this);}));function lockAlignment(_x6, _x7) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()


    /**
                                                                                                                                                                                                                                                            * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                            * @throws {Object}
                                                                                                                                                                                                                                                            * @returns {boolean}
                                                                                                                                                                                                                                                            */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:return _context4.abrupt("return",
                this.getIsLocked(versionUrn, viewablePartId));case 1:case "end":return _context4.stop();}}}, _callee4, this);}));function isAlignmentLocked(_x8, _x9) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()


    /**
                                                                                                                                                                                                                                                      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                      * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                      * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                      * @param {THREE.Box3} boundingBox         - bounding box of the viewport in model space.
                                                                                                                                                                                                                                                      * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                      * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                      */ }, { key: "saveViewport", value: function () {var _saveViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId, regionId, boundingBox, transform) {var item, index;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();

                if (!item.regions) {
                  item.regions = [];
                }

                // In case that this regionId already exists in the service, we'll override its content.
                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});

                if (index === -1) {
                  // Otherwise, we'll create a new entry to the array.
                  index = item.regions.length;
                }

                item.regions[index] = {
                  regionId: regionId,
                  boundingBox: boundingBox,
                  transform: transform };


                this.saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 6:case "end":return _context5.stop();}}}, _callee5, this);}));function saveViewport(_x10, _x11, _x12, _x13, _x14) {return _saveViewport.apply(this, arguments);}return saveViewport;}()


    /**
                                                                                                                                                                                                                                                                             * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                             * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                             * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                             * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                             * @returns {Object|null}           - Null means that no custom viewport was stored.
                                                                                                                                                                                                                                                                             */ }, { key: "loadViewport", value: function () {var _loadViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId, regionId) {var viewports, region;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
                viewports = this.loadViewports(versionUrn, viewablePartId);

                region = viewports.find(function (r) {return r.regionId === regionId;});if (

                region) {_context6.next = 4;break;}return _context6.abrupt("return",
                null);case 4:return _context6.abrupt("return",


                region);case 5:case "end":return _context6.stop();}}}, _callee6, this);}));function loadViewport(_x15, _x16, _x17) {return _loadViewport.apply(this, arguments);}return loadViewport;}()


    /**
                                                                                                                                                                                                         * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                         * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                         * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                         * @returns {object[]}               - Empty array means that no matching viewport was found.
                                                                                                                                                                                                         */ }, { key: "loadViewports", value: function () {var _loadViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId) {var item, regions;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
                item = this.loadItem(APIs.Transform, versionUrn, viewablePartId);

                regions = item === null || item === void 0 ? void 0 : item.regions;return _context7.abrupt("return",

                regions || []);case 3:case "end":return _context7.stop();}}}, _callee7, this);}));function loadViewports(_x18, _x19) {return _loadViewports.apply(this, arguments);}return loadViewports;}()


    ////////// Relationship Service //////////////

    /**
    * @param {string} modelLineageUrn       - encoded versionUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
    * @param {string} sheetLineageUrn       - encoded versionUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
    * @param {string} [regionId]            - A UUID of the sheet's region.
    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
    */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, relationshipId, item;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:

                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);
                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);

                relationshipId = Object(uuid__WEBPACK_IMPORTED_MODULE_1__["v4"])();

                // this is how this structure that it is stored in real Relationship service.
                item = {
                  id: relationshipId,
                  entities: [
                  {
                    domain: RelationshipDomain,
                    type: RelationshipEntityTypes.Region,
                    id: sheetEntityId },

                  {
                    domain: RelationshipDomain,
                    type: RelationshipEntityTypes.Viewable,
                    id: modelEntityId }] };




                // In the mock service we save the relationship according to a unique key, just like it's gonna be saved in the relationship service.
                this.saveItem(APIs.Relationship, relationshipId, undefined, item);case 5:case "end":return _context8.stop();}}}, _callee8, this);}));function saveRelationship(_x20, _x21, _x22, _x23, _x24) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()


    /**
                                                                                                                                                                                                                                                                                           * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                           * 
                                                                                                                                                                                                                                                                                           * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                           * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                           * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                           * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                           * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                           * @returns {Object[]}
                                                                                                                                                                                                                                                                                           */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      type, lineageUrn, viewablePartId, regionId) {var results, entityId, keys, i, key, _candidate$entities, itemStr, candidate;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
                results = [];

                entityId = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);

                keys = avp.LocalStorage.getAllKeys();

                // Simulates Relationship Service `search` API. The API can look for relationships according to `domain`, `type` & `entityId`.
                for (i = 0; i < keys.length; i++) {
                  key = keys[i];

                  if (key.indexOf(APIs.Relationship) !== -1) {
                    itemStr = avp.LocalStorage.getItem(key);
                    candidate = itemStr && JSON.parse(itemStr);

                    if (candidate === null || candidate === void 0 ? void 0 : (_candidate$entities = candidate.entities) === null || _candidate$entities === void 0 ? void 0 : _candidate$entities.some(function (entity) {return entity.id === entityId && entity.type === type;})) {
                      results.push(candidate);
                    }
                  }
                }return _context9.abrupt("return",

                results);case 5:case "end":return _context9.stop();}}}, _callee9);}));function getRelationships(_x25, _x26, _x27, _x28) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: "loadItem", value: function loadItem(


    api, urn, viewablePartId) {
      var key = getKey(api, urn, viewablePartId);
      var itemStr = this.localStorage.getItem(key);
      var item = itemStr && JSON.parse(itemStr);

      // Convert array elements into LmvMatrix
      if (item === null || item === void 0 ? void 0 : item.transform) {
        item.transform = new avp.LmvMatrix4(true).fromArray(item.transform);
      }

      if (item === null || item === void 0 ? void 0 : item.regions) {
        item.regions = item.regions.map(function (region) {
          // If region contains a matrix (and it should), convert it into LmvMatrix
          if (region.transform) {
            region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);
          }

          // Convert array into THREE.Box2
          region.boundingBox = new THREE.Box2().set(
          { x: region.boundingBox[0], y: region.boundingBox[1] },
          { x: region.boundingBox[2], y: region.boundingBox[3] });


          return region;
        });
      }

      return item;
    } }, { key: "saveItem", value: function saveItem(

    api, urn, viewablePartId, item) {var _item, _item2;

      // If the item contains a matrix, convert it to number array first
      if ((_item = item) === null || _item === void 0 ? void 0 : _item.transform) {
        item = Object.assign({}, item);

        // Note that the Array.from(...) makes a difference here:
        // TypedArrays (like matrix.elements) are not saved as arrays by JSON-stringify, but as objects,
        // i.e., it would look like '{"0": 1, "1": 1, ... }' 
        // By converting to a JS array, the resulting json contains an actual array, i.e. "[1, 0, 0, ... ]"
        item.transform = Array.from(item.transform.elements);
      }

      if ((_item2 = item) === null || _item2 === void 0 ? void 0 : _item2.regions) {
        item = Object.assign({}, item);
        item.regions = item.regions.map(function (r) {
          var region = Object.assign({}, r);

          // If region contains a matrix (and it should), convert it to number array first
          if (region.transform) {
            region.transform = Array.from(region.transform.elements);
          }

          // Convert THREE.Box2 into a flat array.
          region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];
          return region;
        });
      }

      var key = getKey(api, urn, viewablePartId);
      var itemStr = JSON.stringify(item);
      this.localStorage.setItem(key, itemStr);
    } }]);return AlignmentServiceLS;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"]);


// Implement LocalStorage interface, but just using a plain JS object for storage instead of actual LocalStorage.
var ObjectLocalStorage = /*#__PURE__*/function () {

  function ObjectLocalStorage() {_classCallCheck(this, ObjectLocalStorage);
    this.data = {};
  }_createClass(ObjectLocalStorage, [{ key: "setItem", value: function setItem(

    key, item) {
      this.data[key] = item;
    } }, { key: "getItem", value: function getItem(

    key) {
      return this.data[key];
    } }]);return ObjectLocalStorage;}();


_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"].ObjectLocalStorage = ObjectLocalStorage;

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js":
/*!*********************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceNucleus.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceNucleus; });
/* harmony import */ var _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignedItemNucleus */ "./extensions/ModelAlignmentService/AlignedItemNucleus.js");
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlignmentCache */ "./extensions/ModelAlignmentService/AlignmentCache.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
/* harmony import */ var _NucleusRelationshipAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NucleusRelationshipAPI */ "./extensions/ModelAlignmentService/NucleusRelationshipAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


// Using the cache in the LocalCS implementation is primarily for testing and as a reference implementation
// for other (slower) services.





var isSameTransform = function isSameTransform(tfOld, tfNew) {

  // If both transforms were not set, conisder them equal
  if (!tfOld && !tfNew) {
    return true;
  }

  if (tfOld && tfNew) {
    return tfNew.equals(tfOld);
  }
  return false;
};

// Implements model-alignment storage based on Nucleus backend.
var AlignmentServiceNucleus = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceNucleus, _AlignmentService);var _super = _createSuper(AlignmentServiceNucleus);

  // @param {Object}           options               - Additional initialization options:
  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'
  // @param {string}           [serviceVersion="v1"]
  function AlignmentServiceNucleus() {var _this;var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, AlignmentServiceNucleus);
    _this = _super.call(this);

    // Activate error state if an error occurs
    var onError = _this.onError.bind(_assertThisInitialized(_this));
    options.onError = onError;
    _this.alignmentApi = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["NucleusAlignmentAPI"](options);
    _this.relationshipApi = new _NucleusRelationshipAPI__WEBPACK_IMPORTED_MODULE_4__["NucleusRelationshipAPI"](options);

    // Define function that the cache can use to perform batch requests 
    var fetchItems = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(alignedItemIDs) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  _this.alignmentApi.fetchItems(alignedItemIDs));case 2:return _context.abrupt("return", _context.sent);case 3:case "end":return _context.stop();}}}, _callee);}));return function fetchItems(_x) {return _ref.apply(this, arguments);};}();


    _this.cache = new _AlignmentCache__WEBPACK_IMPORTED_MODULE_2__["default"](fetchItems);return _this;
  }_createClass(AlignmentServiceNucleus, [{ key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      urns) {var itemIds;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                itemIds = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"].fromUrns(urns);_context2.next = 3;return (
                  this.cache.fetchItems(itemIds));case 3:case "end":return _context2.stop();}}}, _callee2, this);}));function fetchItems(_x2) {return _fetchItems.apply(this, arguments);}return fetchItems;}() }, { key: "getTransform", value: function getTransform(


    versionUrn, viewablePartId) {
      // return transform - or undefined if not in cache
      var alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);
      var item = this.cache.getCachedItem(alignedItemID);

      // Note: It's important to distinguish undefined vs. null here:
      //  - If the item does not exists, we don't know the state                                 => return undefined
      //  - If the item exists, but has no transform, we know that no alignment transform is set => return null.
      return item && (item.transform || null);
    } }, { key: "getIsLocked", value: function getIsLocked(

    versionUrn, viewablePartId) {
      // return transform - or undefined if not in cache
      var alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);
      var item = this.cache.getCachedItem(alignedItemID);
      return item ? Boolean(item.isLocked) : undefined;
    } }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:

                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);_context3.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context3.sent;return _context3.abrupt("return",
                item === null || item === void 0 ? void 0 : item.transform);case 5:case "end":return _context3.stop();}}}, _callee3, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}() }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(


      versionUrn, viewablePartId, transform) {var _item;var alignedItemID, item;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);
                // get current item from cache
                _context4.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context4.sent;if (!



                isSameTransform((_item = item) === null || _item === void 0 ? void 0 : _item.transform, transform)) {_context4.next = 6;break;}return _context4.abrupt("return");case 6:



                // Update item in cache or create a new one
                if (item) {
                  item.transform = transform;
                } else {
                  // Transform was not saved before: Create a new item
                  item = new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().createNew(alignedItemID, transform);
                  this.cache.setItem(alignedItemID, item);
                }

                // Note: If the server has changed meanwhile, we will overwrite it.
                //       Ideally, we should have some conflict handling workflow for this case.
                _context4.next = 9;return this.alignmentApi.saveItem(item);case 9:case "end":return _context4.stop();}}}, _callee4, this);}));function saveTransform(_x5, _x6, _x7) {return _saveTransform.apply(this, arguments);}return saveTransform;}() }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(


      versionUrn, viewablePartId) {var alignedItemID, item, isSaved;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);_context5.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context5.sent;if (!



                item.isLocked) {_context5.next = 6;break;}return _context5.abrupt("return");case 6:



                // Note that items may just exist locally. 
                isSaved = item.existsOnServer();

                // If there is no item, we have to create and save it to the service first.
                if (isSaved) {_context5.next = 10;break;}_context5.next = 10;return (
                  this.alignmentApi.saveItem(item));case 10:_context5.next = 12;return (



                  this.alignmentApi.setItemLocked(item, true));case 12:case "end":return _context5.stop();}}}, _callee5, this);}));function lockAlignment(_x8, _x9) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()


    // Only used for testing. In practice, alignment 
  }, { key: "unlockAlignment", value: function () {var _unlockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);_context6.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context6.sent;if (!(



                !item || !item.isLocked)) {_context6.next = 6;break;}return _context6.abrupt("return");case 6:_context6.next = 8;return (



                  this.alignmentApi.setItemLocked(item, false));case 8:case "end":return _context6.stop();}}}, _callee6, this);}));function unlockAlignment(_x10, _x11) {return _unlockAlignment.apply(this, arguments);}return unlockAlignment;}() }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(


      versionUrn, viewablePartId) {var alignedItemID, item;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);_context7.next = 3;return (
                  this.cache.getItem(alignedItemID));case 3:item = _context7.sent;return _context7.abrupt("return",
                Boolean(item === null || item === void 0 ? void 0 : item.isLocked));case 5:case "end":return _context7.stop();}}}, _callee7, this);}));function isAlignmentLocked(_x12, _x13) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: "saveViewport", value: function () {var _saveViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(


      versionUrn, viewablePartId, regionId, boundingBox, transform) {var alignedItemID, item, index;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);
                // get current item from cache
                _context8.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context8.sent;

                // Update item in cache or create a new one
                if (!item) {
                  item = new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().createNew(alignedItemID, transform);
                  this.cache.setItem(alignedItemID, item);
                }

                if (!item.regions) {
                  item.regions = [];
                }

                // In case that this regionId already exists in the service, we'll override its content.
                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});

                if (index === -1) {
                  // Otherwise, we'll create a new entry to the array.
                  index = item.regions.length;
                }

                item.regions[index] = {
                  regionId: regionId,
                  boundingBox: boundingBox,
                  transform: transform };


                // Note: If the server has changed meanwhile, we will overwrite it.
                //       Ideally, we should have some conflict handling workflow for this case.
                this.alignmentApi.saveItem(item);case 10:case "end":return _context8.stop();}}}, _callee8, this);}));function saveViewport(_x14, _x15, _x16, _x17, _x18) {return _saveViewport.apply(this, arguments);}return saveViewport;}() }, { key: "loadViewports", value: function () {var _loadViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(


      versionUrn, viewablePartId) {var alignedItemID, item, regions;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
                alignedItemID = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, viewablePartId);
                // get current item from cache
                _context9.next = 3;return this.cache.getItem(alignedItemID);case 3:item = _context9.sent;

                regions = item === null || item === void 0 ? void 0 : item.regions;return _context9.abrupt("return",

                regions || []);case 6:case "end":return _context9.stop();}}}, _callee9, this);}));function loadViewports(_x19, _x20) {return _loadViewports.apply(this, arguments);}return loadViewports;}() }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(


      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:_context10.next = 2;return (

                  this.relationshipApi.loadItem(type, lineageUrn, viewablePartId, regionId));case 2:return _context10.abrupt("return", _context10.sent);case 3:case "end":return _context10.stop();}}}, _callee10, this);}));function getRelationships(_x21, _x22, _x23, _x24) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(


      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:

                this.relationshipApi.saveItem(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId);case 1:case "end":return _context11.stop();}}}, _callee11, this);}));function saveRelationship(_x25, _x26, _x27, _x28, _x29) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}() }, { key: "onError", value: function onError()


    {
      // Report error state
      this.error = true;
    } }, { key: "isWorking", value: function isWorking()

    {
      return !this.error;
    } }, { key: "clearCache", value: function clearCache()

    {
      this.cache.clear();
    }

    // Primarily for testing: Delete item from backend.
  }, { key: "deleteItem", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(versionUrn, partId) {var itemId, item;return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:

                // If item doesn't exist server-side, do nothing to avoid request error
                itemId = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItemID"](versionUrn, partId);_context12.next = 3;return (
                  this.cache.getItem(itemId));case 3:item = _context12.sent;if (
                item.existsOnServer()) {_context12.next = 6;break;}return _context12.abrupt("return");case 6:if (!





                item.isLocked) {_context12.next = 9;break;}_context12.next = 9;return (
                  this.unlockAlignment(versionUrn, partId));case 9:


                // Remove from cache
                this.cache.setItem(itemId, null);

                // Send delete request
                _context12.next = 12;return this.alignmentApi.deleteItem(itemId);case 12:return _context12.abrupt("return", _context12.sent);case 13:case "end":return _context12.stop();}}}, _callee12, this);}));function deleteItem(_x30, _x31) {return _deleteItem.apply(this, arguments);}return deleteItem;}() }]);return AlignmentServiceNucleus;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./extensions/ModelAlignmentService/ModelAlignmentService.js":
/*!*******************************************************************!*\
  !*** ./extensions/ModelAlignmentService/ModelAlignmentService.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentService; });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentServiceLS */ "./extensions/ModelAlignmentService/AlignmentServiceLS.js");
/* harmony import */ var _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlignmentServiceNucleus */ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.ModelAlignmentService');
var myExtensionName = 'Autodesk.ModelAlignmentService';






/** 
                                                                           * This extension defines the API for managing storage of model alignment transform
                                                                           * on a backend or in local storage. It provides a local-storage based implementation for reference. 
                                                                           * The extension id is: `Autodesk.ModelAlignmentServiceAPI`
                                                                           */var
ModelAlignmentService = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentService, _av$Extension);var _super = _createSuper(ModelAlignmentService);
  function ModelAlignmentService(viewer, options) {_classCallCheck(this, ModelAlignmentService);return _super.call(this,
    viewer, options);
  }return ModelAlignmentService;}(av.Extension);


// Register the extension with the extension manager.
av.theExtensionManager.registerExtension(myExtensionName, ModelAlignmentService);

namespace.AlignmentService = _AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"];
namespace.AlignmentServiceLS = _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.NucleusAlignmentAPI = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["NucleusAlignmentAPI"];
namespace.AlignmentServiceNucleus = _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.AlignedItem = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItem"];

/***/ }),

/***/ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js":
/*!*****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/NucleusAlignmentAPI.js ***!
  \*****************************************************************/
/*! exports provided: AlignedItemID, NucleusAlignmentAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignedItemID", function() { return AlignedItemID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NucleusAlignmentAPI", function() { return NucleusAlignmentAPI; });
/* harmony import */ var _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignedItemNucleus */ "./extensions/ModelAlignmentService/AlignedItemNucleus.js");
/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RequestUtils */ "./extensions/ModelAlignmentService/RequestUtils.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;
var avp = av.Private;

// We use the DefaultSpaceId for all requests
var DefaultSpaceId = 'default';

// For debugging: Display reports of fetched/posted transforms
var DEBUG_OUTPUT = false;

// Only for debugging: Find model name for given encoded urn
var urnToModelName = function urnToModelName(urn) {
  var nodes = LMV_MAIN_VIEW.getVisibleNodes();
  var node = nodes.find(function (node) {return node.getRootNode().urn() == urn;});
  return (node === null || node === void 0 ? void 0 : node.getModelName()) || "Unknown urn: ".concat(urn);
};

// Combines strings to uniquely address an AlignedItem for 2D or 3D.
var AlignedItemID = /*#__PURE__*/function () {

  // @param {string} urn - base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
  // @param {string} viewablePartId - viewable part id - name of the specific viewable, e.g. "Second Floor"
  function AlignedItemID(versionUrn) {var viewablePartId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;_classCallCheck(this, AlignedItemID);

    // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
    this.versionUrn = versionUrn;

    // Only used for 2D: Id of view and region within the model
    this.viewablePartId = viewablePartId;
  }

  // Convert array of urn strings to AlignedItem (if no partIds are needed) 
  //  @param {string[]} 
  _createClass(AlignedItemID, [{ key: "toObject",



    // Convert into object that we can serialize into a json request body
    value: function toObject() {
      return {
        // Note that (unlike most LMV code) alignment service backend works with decoded urns.
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn),

        // Make sure they are set to undefined unless actually specified
        viewablePartId: this.viewablePartId || undefined };

    } }, { key: "toString", value: function toString()

    {
      return "".concat(this.versionUrn).concat(this.viewablePartId ? "__".concat(this.viewablePartId) : '');
    } }], [{ key: "fromUrns", value: function fromUrns(urns) {return urns && urns.map(function (urn) {return new AlignedItemID(urn);});} }]);return AlignedItemID;}();


// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/construction/alignment' for staging)
var getDefaultServiceUrl = function getDefaultServiceUrl(docsEnv) {
  var envConfig = av.EnvironmentConfigurations[av.getEnv()];
  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;
  var envSuffix = docsEnv === 'QA' ? '-dev' : '';
  return baseUrl + '/construction/alignment' + envSuffix;
};

var getDefaultToken = function getDefaultToken() {
  return av.token.accessToken;
};

// Helper class to communicate with Nucleus AlignmentService backend
//
// Note:
//  - All urns must belong to the same projectUrn
//  - Particularly, projectUrn must not change at runtime.
var NucleusAlignmentAPI = /*#__PURE__*/function () {

  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [docsEnv]             - Docs environment. E.g. 'QA'.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'
  // @param {string}           [serviceVersion="v1"]
  // @param {function()}       [onError]
  function NucleusAlignmentAPI()






  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$docsEnv = _ref.docsEnv,docsEnv = _ref$docsEnv === void 0 ? '' : _ref$docsEnv,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl(docsEnv) : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? "v1" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusAlignmentAPI);

    this.projectId = projectId;
    this.getAccessToken = getAccessToken;
    this.onError = onError;

    this.serviceUrl = "".concat(serviceBaseUrl, "/").concat(serviceVersion);

    // Endpoint to read/write alignment items
    this.itemsEndPoint = "/projects/".concat(projectId, "/spaces/").concat(DefaultSpaceId, "/items");

    this.url = this.serviceUrl + this.itemsEndPoint;
  }


  // Batch-request multiple items
  //
  // @param {AlignedItemID[]} items
  // @returns {Object|undefined} A dictionary of AlignedItems, indexed by (encoded) versionUrn. Undefined on failure. 
  _createClass(NucleusAlignmentAPI, [{ key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(items) {var result, body, i, postFix, res, response, loadedItems, _i, alignedItemId, key, data, report, _i2, name, _data;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                result = {};

                // Avoid sending a request if the list is empty anyway.
                if (items.length) {_context.next = 3;break;}return _context.abrupt("return",
                result);case 3:


                // List items in request body
                body = {};
                for (i = 0; i < items.length; i++) {
                  body[i] = items[i].toObject();
                }

                postFix = ':getBatch';_context.next = 8;return (
                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_1__["sendRequestWithRetry"])(this.getAccessToken, this.url + postFix, 'POST', body));case 8:res = _context.sent;if (


                res.success) {_context.next = 12;break;}
                this.onError();return _context.abrupt("return");case 12:



                // get response data (should exist)
                response = res.data;if (
                response) {_context.next = 16;break;}
                // Even if there are no alignments at all, the return value should be an empty object at the minimum
                console.warn('Unepxected request response: items:getBatch should get an empty response');return _context.abrupt("return");case 16:


                loadedItems = response.results;

                // get alignment data from each item.
                // Response is not an array, but the keys for indexing are the same as we used in the body,
                // so that they will just be indexed by array indices into the items array.
                for (_i = 0; _i < items.length; _i++) {

                  // get encoded versionUrn 
                  alignedItemId = new AlignedItemID(items[_i].versionUrn, items[_i].viewablePartId);
                  key = alignedItemId.toString();

                  // Add items to result map, indexed by versionUrn.
                  // data will be null if no data was saved for this item before.
                  // In this case, we return a new "blank" AlignedItem, i.e. no transform and isLocked = false.
                  data = loadedItems && loadedItems[_i];
                  result[key] = data ? new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"]().load(data) : new _AlignedItemNucleus__WEBPACK_IMPORTED_MODULE_0__["default"](alignedItemId);
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  report = {};
                  for (_i2 = 0; _i2 < items.length; _i2++) {
                    name = urnToModelName(items[_i2].versionUrn);
                    _data = loadedItems && loadedItems[_i2];
                    report[name] = _data || 'No alignment';
                  }
                  console.log('Fetch successful:', report);
                }return _context.abrupt("return",

                result);case 20:case "end":return _context.stop();}}}, _callee, this);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Store alignment item or create a new one.
    //
    // Note: Saving an item doesn't include the isLocked-flag, because setting the locked flag within an item-save request is not supported by alignmentService.
    //       Setting the lockFlag requires a separate request to another endpoint.
  }, { key: "saveItem", value: function () {var _saveItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(item) {var body, operation, res, name, report;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                body = item.toObject();

                // Decide which operation to perform:
                //  - POST:   Item doesn't exist on alignment service yet => Create a new one.
                //  - PATCH:  Modify or remove transform of existing item.
                //
                // Note: Even when resetting the transform back to source file transform, we must never send DELETE. Deleting an item would not guarantee
                //       that the transform is always reset to the source file transform: If there is no alignment item for a versionUrn, the alignment transform
                //       is inherited from the previous versions. So, instead of reseting to source-file transform, deleting the item would just 
                //       "reset it to the state of the previous version".
                //
                //       Example:
                //         - Assume model v1 was aligned, then model was updated to v2, and finally v2 was aligned again.
                //         - If we delete the alignment of v2, v2 would then inherit the alignment from v1.
                //         - Expected behavior is: v1 keeps its alignment, but v2 is reset to source-file transform. 
                //           => We still have to store an alignment item, just with transform null. 
                //
                operation = item.existsOnServer() ? 'PATCH' : 'POST';_context2.next = 4;return (
                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_1__["sendRequestWithRetry"])(this.getAccessToken, this.url, operation, body));case 4:res = _context2.sent;if (

                res.success) {_context2.next = 8;break;}
                this.onError();return _context2.abrupt("return");case 8:



                // On success, update item with response from AlignmentService. Transform should usually
                // keep the same, but checksum and timestamp will change.
                if (res.data) {
                  item.load(res.data);
                } else {
                  // item has been deleted from server. So, we must reset its checksum so that we don't try
                  // to send PATCH requests on next change.
                  item.checksum = undefined;

                  // If operation is delete, the response will be empty. In this case, we can keep the cache
                  // item as it is, because it already indicates that no transform is set.
                  operation == 'DELETE' || console.warn('Unexpected request result: POST or PATCH should always respond an update item state');
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  name = urnToModelName(item.versionUrn);
                  report = {
                    model: name,
                    response: res.data,
                    operation: operation };


                  console.log('Transform saved: ', report);
                }case 10:case "end":return _context2.stop();}}}, _callee2, this);}));function saveItem(_x2) {return _saveItem.apply(this, arguments);}return saveItem;}()


    // Note: Removing the alignment item will change the alignment to whatever state was defined by previous versions.
    //       Therefore, actual delete is currently only used for debugging purposes. Resetting alignment is done by
    //       changing the transform to null, but keeping the item live (see saveItem comments for details).
    //
    // @param {AlignedItemID} item
  }, { key: "deleteItem", value: function () {var _deleteItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(item) {var body;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                body = item.toObject();_context3.next = 3;return (
                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_1__["sendRequestWithRetry"])(this.getAccessToken, this.url, 'DELETE', body));case 3:case "end":return _context3.stop();}}}, _callee3, this);}));function deleteItem(_x3) {return _deleteItem.apply(this, arguments);}return deleteItem;}()


    // Send request to lock or unlock an item.
    //
    // Requirements:
    //  - Item must exist server-side and reflect latest state
    //  - It must be ensured that the same item isn't locked/unlocked twice.
    //  - Unlock only works with admin priviledges
    //
    // @param {AlignedItemNucleus} item
    // @param {bool}               lock - whether to lock or unlock
  }, { key: "setItemLocked", value: function () {var _setItemLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(item, lock) {var data, body, postFix, res;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:

                data = item.toObject();
                body = {
                  versionUrn: data.versionUrn,
                  viewablePartId: data.viewablePartId };


                postFix = lock ? ':lock' : ':unlock';_context4.next = 5;return (
                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_1__["sendRequestWithRetry"])(this.getAccessToken, this.url + postFix, 'PATCH', body));case 5:res = _context4.sent;if (
                res.success) {_context4.next = 9;break;}
                this.onError();return _context4.abrupt("return");case 9:



                // update item from server response. This should set the lock flag and update the checksum. 
                item.load(res.data);case 10:case "end":return _context4.stop();}}}, _callee4, this);}));function setItemLocked(_x4, _x5) {return _setItemLocked.apply(this, arguments);}return setItemLocked;}() }]);return NucleusAlignmentAPI;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/NucleusRelationshipAPI.js":
/*!********************************************************************!*\
  !*** ./extensions/ModelAlignmentService/NucleusRelationshipAPI.js ***!
  \********************************************************************/
/*! exports provided: NucleusRelationshipAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NucleusRelationshipAPI", function() { return NucleusRelationshipAPI; });
/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RequestUtils */ "./extensions/ModelAlignmentService/RequestUtils.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avp = av.Private;

// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/bim360/relationship-dev' for QA)
var getDefaultServiceUrl = function getDefaultServiceUrl() {
  var envConfig = av.EnvironmentConfigurations[av.getEnv()];
  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;
  return baseUrl + '/bim360/relationship';
};

var getDefaultToken = function getDefaultToken() {
  return av.token.accessToken;
};

// Relationship entity ID is defined by lineageUrn + viewablePart + region.
var getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {
  return "lineageUrn=".concat(lineageUrn, "&viewablePart=").concat(viewablePart).concat(region ? "&region=".concat(region) : '');
};

var Domain = 'autodesk-construction-alignment';
var EntityTypeViewPart3D = 'viewpart3d';
var EntityTypeRegion2D = 'viewpartregion2d';

// Helper class to communicate with Nucleus Relationship Service backend
//
// Note:
//  - All urns must belong to the same projectUrn
//  - Particularly, projectUrn must not change at runtime.
var NucleusRelationshipAPI = /*#__PURE__*/function () {

  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/bim360/relationship'
  // @param {string}           [serviceVersion="v2"]
  // @param {function()}       [onError]
  function NucleusRelationshipAPI()





  {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref.projectId,_ref$getAccessToken = _ref.getAccessToken,getAccessToken = _ref$getAccessToken === void 0 ? getDefaultToken : _ref$getAccessToken,_ref$serviceBaseUrl = _ref.serviceBaseUrl,serviceBaseUrl = _ref$serviceBaseUrl === void 0 ? getDefaultServiceUrl() : _ref$serviceBaseUrl,_ref$serviceVersion = _ref.serviceVersion,serviceVersion = _ref$serviceVersion === void 0 ? "v2" : _ref$serviceVersion,_ref$onError = _ref.onError,onError = _ref$onError === void 0 ? null : _ref$onError;_classCallCheck(this, NucleusRelationshipAPI);

    this.projectId = projectId;
    this.getAccessToken = getAccessToken;
    this.onError = onError;

    this.serviceUrl = "".concat(serviceBaseUrl, "/").concat(serviceVersion);

    // Endpoint to read/write alignment items
    this.itemsEndPoint = "/containers/".concat(projectId, "/relationships");

    this.url = this.serviceUrl + this.itemsEndPoint;
  }_createClass(NucleusRelationshipAPI, [{ key: "loadItem", value: function () {var _loadItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(

      type, lineageUrn, viewablePartId, regionId) {var id, postFix, res, response, loadedItems;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                id = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);

                postFix = ":search?domain=".concat(Domain, "&type=").concat(type, "&id=").concat(id);_context.next = 4;return (
                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_0__["sendRequestWithRetry"])(this.getAccessToken, this.url + postFix, 'GET'));case 4:res = _context.sent;if (


                res.success) {_context.next = 8;break;}
                this.onError();return _context.abrupt("return");case 8:



                // get response data (should exist)
                response = res.data;if (

                response) {_context.next = 12;break;}
                // Even if there are no alignments at all, the return value should be an empty object at the minimum
                console.warn('Unepxected request response: relationships:search should get an empty response');return _context.abrupt("return");case 12:



                loadedItems = response.results;return _context.abrupt("return",

                loadedItems);case 14:case "end":return _context.stop();}}}, _callee, this);}));function loadItem(_x, _x2, _x3, _x4) {return _loadItem.apply(this, arguments);}return loadItem;}()


    // Store alignment item or create a new one.
  }, { key: "saveItem", value: function () {var _saveItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, item, body, res;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);
                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);

                // this is how this structure that it is stored in real Relationship service.
                item = {
                  entities: [
                  {
                    domain: Domain,
                    type: EntityTypeRegion2D,
                    id: sheetEntityId },

                  {
                    domain: Domain,
                    type: EntityTypeViewPart3D,
                    id: modelEntityId }] };




                body = [item];_context2.next = 6;return (

                  Object(_RequestUtils__WEBPACK_IMPORTED_MODULE_0__["sendRequestWithRetry"])(this.getAccessToken, this.url, 'PUT', body));case 6:res = _context2.sent;if (

                res.success) {_context2.next = 10;break;}
                this.onError();return _context2.abrupt("return");case 10:case "end":return _context2.stop();}}}, _callee2, this);}));function saveItem(_x5, _x6, _x7, _x8, _x9) {return _saveItem.apply(this, arguments);}return saveItem;}() }]);return NucleusRelationshipAPI;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/RequestUtils.js":
/*!**********************************************************!*\
  !*** ./extensions/ModelAlignmentService/RequestUtils.js ***!
  \**********************************************************/
/*! exports provided: Retry, sendRequest, sendRequestWithRetry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Retry", function() { return Retry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendRequest", function() { return sendRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendRequestWithRetry", function() { return sendRequestWithRetry; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper class for retrying requests
var Retry = /*#__PURE__*/function () {

  function Retry() {_classCallCheck(this, Retry);

    // Maximum number of attempts before giving up
    this.maxAttempts = 10;

    // Waiting time in ms for first retry
    this.startDelay = 100;

    // Exponential grow factor for the waiting time per attempt
    this.growFactor = 1.1;
  }

  // Returns the waiting time in ms before retrying.    
  _createClass(Retry, [{ key: "getWaitingTime", value: function getWaitingTime(numFailedAttempts) {
      return numFailedAttempts ? this.startDelay * Math.pow(this.growFactor, numFailedAttempts - 1) : 0;
    }

    // Try the given (async) callback until either successful or until maximum retry count is reached.
    //  - Return value is the last result of callback
    //  - Callback is considered successful if isSuccess(result) is true.
  }, { key: "run", value: function run(callback, isSuccess) {var _this = this;

      return new Promise(function (resolve) {

        // track number of attempts
        var numFailedAttempts = 0;

        var nextTry = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var result, delayInMs;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                      callback());case 2:result = _context.sent;if (!


                    isSuccess(result)) {_context.next = 5;break;}return _context.abrupt("return",
                    resolve(result));case 5:


                    // Give up if we reached the limit
                    numFailedAttempts++;if (!(
                    numFailedAttempts >= _this.maxAttempts)) {_context.next = 8;break;}return _context.abrupt("return",
                    resolve(result));case 8:


                    // schedule next attempt
                    delayInMs = _this.getWaitingTime(numFailedAttempts);
                    window.setTimeout(nextTry, delayInMs);case 10:case "end":return _context.stop();}}}, _callee);}));return function nextTry() {return _ref.apply(this, arguments);};}();

        nextTry();
      });
    } }]);return Retry;}();


// Result is an object { success, response }.
var sendRequest = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(getAccessToken, url, operation) {var body,result,token,_args2 = arguments;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:body = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : null;

            result = {
              success: false,
              data: null };_context2.next = 4;return (


              getAccessToken());case 4:token = _context2.sent;_context2.next = 7;return (

              new Promise(function (resolve) {

                var xhr = new XMLHttpRequest();
                xhr.open(operation, url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.setRequestHeader('accept', 'application/json');
                xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
                xhr.setRequestHeader('Authorization', 'Bearer ' + token);

                // On failure: resolve with result.success == false
                var onFailure = function onFailure() {
                  resolve(result);
                };

                // Parse response as json on success
                var onLoad = function onLoad() {

                  // Even if the request didn't trigger an error callback,
                  // the server response may still indicate an error (e.g. this happens on authorization failure) 
                  if (xhr.status < 200 || xhr.status >= 300) {
                    onFailure();
                    return;
                  }

                  try {
                    // If json parsing succeeds, return success
                    // Some requests (e.g. DELETE) may also get an empty string as result on success, but JSON.parse() would
                    // fail on those. Therefore, we accept empty responses as well and just set data to null for this case. 
                    result.data = xhr.response ? JSON.parse(xhr.response) : null;
                    result.success = true;
                    resolve(result);
                  } catch (e) {
                    // json parsing failed.
                    onFailure();
                  }
                };

                xhr.onload = onLoad;
                xhr.onerror = onFailure;
                xhr.ontimeout = onFailure;
                xhr.onabort = onFailure;

                xhr.send(body && JSON.stringify(body));
              }));case 7:return _context2.abrupt("return", _context2.sent);case 8:case "end":return _context2.stop();}}}, _callee2);}));return function sendRequest(_x, _x2, _x3) {return _ref2.apply(this, arguments);};}();


var sendRequestWithRetry = /*#__PURE__*/function () {var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(getAccessToken, url, operation, body) {var doRequest, isSuccess;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
            doRequest = function doRequest() {return sendRequest(getAccessToken, url, operation, body);};
            isSuccess = function isSuccess(res) {return res.success;};_context3.next = 4;return (
              new Retry().run(doRequest, isSuccess));case 4:return _context3.abrupt("return", _context3.sent);case 5:case "end":return _context3.stop();}}}, _callee3);}));return function sendRequestWithRetry(_x4, _x5, _x6, _x7) {return _ref3.apply(this, arguments);};}();

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ })

/******/ });
//# sourceMappingURL=ModelAlignmentService.js.map