/*!
 * LMV v7.47.0
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Edit2D =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Edit2D/Edit2D.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/CompGeom/bezier.js":
/*!***************************************!*\
  !*** ./extensions/CompGeom/bezier.js ***!
  \***************************************/
/*! exports provided: DefaultTessParams, SetTesselationParams, TesselateCubic, TesselateQuad, getCubeBezierPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTessParams", function() { return DefaultTessParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTesselationParams", function() { return SetTesselationParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateCubic", function() { return TesselateCubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateQuad", function() { return TesselateQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubeBezierPoint", function() { return getCubeBezierPoint; });


var DefaultTessParams = {
  //How many forward iterations to use when approximating Bezier curves
  //More iterations are needed in case the min_seg_len setting below is smaller
  //relative to mesh size. However, the two numbers need to be tuned together
  //so that NUM_ITERATIONS is enough to result in segment lengths desired.

  //Note that those values are tuned for PDF rendering, where text characters
  //are drawn one by one. If a long piece of text is drawn all at once, then
  //its bounding box will be quite large, so the relative min_seg_len will also
  //be too large and the characters will look coarse. In such cases, we will need
  //to better estimate this by using e.g. the font height only.
  numIterations: 100,

  //What fraction of the bounding sbox should be the minimum length of
  //a segment
  minSegLenFraction: 0.05 };


function SetTesselationParams(num_iterations, min_seg_len_fraction) {
  if (num_iterations)
  DefaultTessParams.numIterations = num_iterations;

  if (min_seg_len_fraction)
  DefaultTessParams.minSegLenFraction = min_seg_len_fraction;
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

function adjustMaxdim(maxdim, segLength) {
  if (maxdim > 4 * segLength && segLength > 0) {
    var time = Math.sqrt(maxdim / segLength);
    time = Math.min(4, time);
    maxdim = segLength * time;
  }
  return maxdim;
}

function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3) + distance(px3, py3, px4, py4);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to 1/100 of the bounds
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  //double dt2 = dt*dt;
  var dt3 = dt * dt * dt;

  var pre1 = 3.0 * dt;
  var pre2 = pre1 * dt;
  var pre3 = pre2 + pre2;
  var pre4 = 6.0 * dt3;

  var temp1x = px1 - 2.0 * px2 + px3;
  var temp1y = py1 - 2.0 * py2 + py3;
  var temp2x = 3.0 * (px2 - px3) - px1 + px4;
  var temp2y = 3.0 * (py2 - py3) - py1 + py4;

  var fx = px1;
  var fy = py1;
  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;
  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;
  var ddfx = temp1x * pre3 + temp2x * pre4;
  var ddfy = temp1y * pre3 + temp2y * pre4;
  var dddfx = temp2x * pre4;
  var dddfy = temp2y * pre4;

  var error = 0.0;

  // forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;
    ddfy += dddfy;
    ddfx += dddfx;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) //add segment only if we have reached treshold length
      {
        // line to current
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px4, py4);
}

function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  var dt2 = dt * dt;

  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?
  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?

  var bx = 2.0 * (px2 - px1);
  var by = 2.0 * (py2 - py1);

  var fx = px1;
  var fy = py1;
  var dfx = bx * dt + ax * dt2;
  var dfy = by * dt + ay * dt2;
  var ddfx = 2.0 * ax * dt2;
  var ddfy = 2.0 * ay * dt2;

  var error = 0.0;

  //forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) // how many pixels should each line be?)
      {
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px3, py3);
}

// Cubic Bezier for single points. Note that TesselateCubic is faster by using deltas.
// Result is returned as a new {x,y} or written to optionalTarget.
function getCubeBezierPoint(t, px1, py1, px2, py2, px3, py3, px4, py4, optionalTarget) {

  var result = optionalTarget || { x: x, y: y };

  var k = 1 - t;

  // Bernstein coefficients
  var bp1 = k * k * k;
  var bp2 = 3 * k * k * t;
  var bp3 = 3 * k * t * t;
  var bp4 = t * t * t;

  result.x = bp1 * px1 + bp2 * px2 + bp3 * px3 + bp4 * px4;
  result.y = bp1 * py1 + bp2 * py2 + bp3 * py3 + bp4 * py4;

  return result;
}

/***/ }),

/***/ "./extensions/Edit2D/Actions.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Actions.js ***!
  \**************************************/
/*! exports provided: Actions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return Actions; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.
//
// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. 
// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)


var

Action = /*#__PURE__*/function () {
  function Action(layer) {_classCallCheck(this, Action);
    this.layer = layer;
  }_createClass(Action, [{ key: "undo", value: function undo()

    {
      throw new Error('Abstract method invoked');
    } }, { key: "redo", value: function redo()

    {
      throw new Error('Abstract method invoked');
    }

    // Optional: Can be be implemented to guide what should be selected before/after change.
    // @param {bool} afterUndo - If true, return recommended selection state after undo, otherwise after redo.    
    // @returns {SelectionHint|null}     
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return null;
    } }]);return Action;}();


// Struct for possible return values of getSelectionHint
var SelectioHint =
function SelectioHint() {_classCallCheck(this, SelectioHint);
  // {Shape}
  this.shape = null;

  // {Shape[]} - only needed for multiselect operations
  this.shapes = null;

  // {PolyIndex} - selected vertex
  this.vertex = null;

  // {PolyIndex} - selected edge
  this.edge = null;
};var


AddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);var _super = _createSuper(AddShape);
  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);
    _this = _super.call(this, layer);
    _this.shape = shape;return _this;
  }_createClass(AddShape, [{ key: "undo", value: function undo()

    {
      this.layer.removeShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.addShape(this.shape);
    }

    // After redo, new shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? null : { shape: this.shape };
    } }]);return AddShape;}(Action);var


AddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);var _super2 = _createSuper(AddShapes);

  // @param {Shape[]} shapes
  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);
    _this2 = _super2.call(this, layer);
    _this2.shapes = shapes;return _this2;
  }_createClass(AddShapes, [{ key: "undo", value: function undo()

    {var _this3 = this;
      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this4 = this;
      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});
    }

    // After redo, new shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? null : { shapes: this.shapes };
    } }]);return AddShapes;}(Action);var


MoveShapes = /*#__PURE__*/function (_Action3) {_inherits(MoveShapes, _Action3);var _super3 = _createSuper(MoveShapes);
  function MoveShapes(layer, shapes, dx, dy) {var _this5;_classCallCheck(this, MoveShapes);
    _this5 = _super3.call(this, layer);
    _this5.shapes = shapes;
    _this5.delta = { x: dx, y: dy };

    // Note that transforming back and forth is not always exactly 1:1. 
    _this5.beforeState = _this5.shapes.map(function (s) {return s.clone();});
    _this5.afterState = _this5.shapes.map(function (s) {return s.clone();});

    _this5.afterState.forEach(function (s) {return s.move(dx, dy);});return _this5;
  }_createClass(MoveShapes, [{ key: "undo", value: function undo()

    {var _this6 = this;
      this.shapes.forEach(function (s, i) {return s.copy(_this6.beforeState[i]);});
    } }, { key: "redo", value: function redo()

    {var _this7 = this;
      this.shapes.forEach(function (s, i) {return s.copy(_this7.afterState[i]);});
    }

    // After undo/redo, moved shapes should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return { shapes: this.shapes };
    } }]);return MoveShapes;}(Action);var


RemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);var _super4 = _createSuper(RemoveShape);
  function RemoveShape(layer, shape) {var _this8;_classCallCheck(this, RemoveShape);
    _this8 = _super4.call(this, layer);
    _this8.shape = shape;return _this8;
  }_createClass(RemoveShape, [{ key: "undo", value: function undo()

    {
      this.layer.addShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.removeShape(this.shape);
    }

    // After undo, recovered shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? { shape: this.shape } : null;
    } }]);return RemoveShape;}(Action);var


RemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);var _super5 = _createSuper(RemoveShapes);
  function RemoveShapes(layer, shapes) {var _this9;_classCallCheck(this, RemoveShapes);
    _this9 = _super5.call(this, layer);
    _this9.shapes = shapes.slice();return _this9;
  }_createClass(RemoveShapes, [{ key: "undo", value: function undo()

    {var _this10 = this;
      this.shapes.forEach(function (s) {return _this10.layer.addShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this11 = this;
      this.shapes.forEach(function (s) {return _this11.layer.removeShape(s);});
    }

    // After undo, recovered shapes should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? { shapes: this.shapes } : null;
    } }]);return RemoveShapes;}(Action);var


AddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);var _super6 = _createSuper(AddVertex);
  function AddVertex(layer, poly, polyIndex, p) {var _this12;_classCallCheck(this, AddVertex);
    _this12 = _super6.call(this, layer);
    _this12.poly = poly;
    _this12.polyIndex = polyIndex;
    _this12.point = p.clone();return _this12;
  }_createClass(AddVertex, [{ key: "undo", value: function undo()

    {
      this.poly.removePoint(this.polyIndex.vertex, this.polyIndex.loop);
    } }, { key: "redo", value: function redo()

    {
      this.poly.insertPoint(this.polyIndex.vertex, this.point, this.polyIndex.loop);
    }

    // After redo, select the new vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: afterUndo ? null : this.polyIndex };

    } }]);return AddVertex;}(Action);


// Only for polygons and polylines
var MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);var _super7 = _createSuper(MoveVertex);
  function MoveVertex(layer, poly, polyIndex, newPos) {var _this13;_classCallCheck(this, MoveVertex);
    _this13 = _super7.call(this, layer);
    _this13.poly = poly;
    _this13.polyIndex = polyIndex;
    _this13.posBefore = poly.getPoint(polyIndex.vertex, polyIndex.loop);
    _this13.posAfter = newPos.clone();return _this13;
  }_createClass(MoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.polyIndex.vertex, this.posBefore.x, this.posBefore.y, this.polyIndex.loop);
    } }, { key: "redo", value: function redo()
    {
      this.poly.updatePoint(this.polyIndex.vertex, this.posAfter.x, this.posAfter.y, this.polyIndex.loop);
    }

    // After undo/redo, select moved vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: this.polyIndex };

    } }]);return MoveVertex;}(Action);


// Returns an object that allows for recovering all arc params assoicated with a vertex
var copyArcParams = function copyArcParams(poly, index, loop) {
  if (!poly.isPath() || !poly.edgeIndexValid(index, loop)) {
    return null;
  }

  var type = poly.getEdgeType(index, loop);
  switch (type) {
    // Note that the getter already returns a copy
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:return poly.getEllipseArcParams(index, loop);
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:return {
        cp1: poly.getControlPoint(index, 1, loop),
        cp2: poly.getControlPoint(index, 2, loop) };

    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:return null;
    default:console.warn('unexpected edge type');}

};

// Recover an arc based on the result returned by copyArcParam
var restoreArc = function restoreArc(poly, index, loop, arcParams) {
  if (!arcParams) {
    // nothing to restore
    return;
  }

  if (arcParams instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]) {
    // recover ellipse arc
    poly.setEllipseArc(index, arcParams);
  } else if (arcParams.cp1) {
    // recover bezier arc
    var cp1 = arcParams.cp1;
    var cp2 = arcParams.cp2;
    poly.setBezierArc(index, cp1.x, cp1.y, cp2.x, cp2.y);
  }
};var

RemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);var _super8 = _createSuper(RemoveVertex);
  function RemoveVertex(layer, poly, polyIndex) {var _this14;_classCallCheck(this, RemoveVertex);
    _this14 = _super8.call(this, layer);
    _this14.poly = poly;
    _this14.vertex = polyIndex.vertex;
    _this14.loop = polyIndex.loop;
    _this14.point = poly.getPoint(_this14.vertex, _this14.loop);

    // For consistency and simplicity, we remove arcs if start or end vertex is removed.
    _this14.arcBefore = copyArcParams(poly, poly.edgeBeforeVertex(_this14.vertex, _this14.loop), _this14.loop);
    _this14.arcAfter = copyArcParams(poly, poly.edgeAfterVertex(_this14.vertex, _this14.loop), _this14.loop);return _this14;
  }_createClass(RemoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.insertPoint(this.vertex, this.point, this.loop);

      // recover arc params
      restoreArc(this.poly, this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop, this.arcBefore);
      restoreArc(this.poly, this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop, this.arcAfter);
    } }, { key: "redo", value: function redo()

    {
      // remove arcs at edges starting/ending at the vertex
      if (this.poly.isPath()) {
        this.poly.removeArc(this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop);
        this.poly.removeArc(this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop);
      }

      this.poly.removePoint(this.vertex, this.loop);
    }

    // After undo, select recovered vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: afterUndo ? this.polyIndex : null };

    } }]);return RemoveVertex;}(Action);



// Moves an edge to a new position specified by new positions for start and end vertex.
// Optionally, start and end vertex may be duplicated before moving the edge. In this case, the neighbar edges keep unchanged and
// we introduce new intermediate edges to connect the old start/end position with the new one.
var MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);var _super9 = _createSuper(MoveEdge);

  // @param {EditLayer} layer
  // @param {Polybase}  poly      - must be at start before the change
  // @param {PolyIndex} polyIndex - edge to be modified    
  // @param {Vector3}   newPosA, newPosB
  // @param {bool}      duplicateStartVertex, duplicateEndVertex - Optional, start and end vertex of the edge may be duplicated.
  function MoveEdge(layer, poly, polyIndex, newPosA, newPosB, duplicateStartVertex, duplicateEndVertex) {var _this15;_classCallCheck(this, MoveEdge);
    _this15 = _super9.call(this, layer);
    _this15.poly = poly;

    // store edge index
    _this15.edgeIndex = polyIndex.vertex;
    _this15.loopIndex = polyIndex.loop;

    // store duplicate flags
    _this15.duplicateStartVertex = duplicateStartVertex;
    _this15.duplicateEndVertex = duplicateEndVertex;

    var ia = _this15.edgeIndex;
    var ib = poly.nextIndex(ia, _this15.loopIndex);

    // get edge 
    var a = poly.getPoint(ia, _this15.loopIndex);
    var b = poly.getPoint(ib, _this15.loopIndex);

    _this15.edgeBefore = {
      a: a,
      b: b };

    _this15.edgeAfter = {
      a: newPosA.clone(),
      b: newPosB.clone() };return _this15;

  }_createClass(MoveEdge, [{ key: "undo", value: function undo()

    {
      // get current edgeIndex (after duplicating vertices)
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia, this.loopIndex);

      // Restore original edge positions
      this.poly.updatePoint(ia, this.edgeBefore.a.x, this.edgeBefore.a.y, this.loopIndex);
      this.poly.updatePoint(ib, this.edgeBefore.b.x, this.edgeBefore.b.y, this.loopIndex);

      // Remove extra vertices
      MoveEdge.revertDuplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
    } }, { key: "redo", value: function redo()

    {
      // Duplicate start/end vertex if wanted
      MoveEdge.duplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get edgeIndex after duplicating vertices
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia, this.loopIndex);

      // apply new positions
      this.poly.updatePoint(ia, this.edgeAfter.a.x, this.edgeAfter.a.y, this.loopIndex);
      this.poly.updatePoint(ib, this.edgeAfter.b.x, this.edgeAfter.b.y, this.loopIndex);
    }

    // Insert a duplicate of vertex i to position i+1. Note that vertex i only copies
    // the position. If vertex i contained arc params, these will be at vertex i+1.
  }, { key: "getSelectionHint",














































































    // After undo/redo, select the moved edge. Note that its index may change due to vertex duplication.
    value: function getSelectionHint(afterUndo) {
      var edgeIndex = afterUndo ? this.edgeIndex : MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
      return {
        shape: this.poly,
        edge: new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: edgeIndex, loop: this.loopIndex }) };

    } }], [{ key: "duplicateVertex", value: function duplicateVertex(poly, index) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var p = poly.getPoint(index, loopIndex);poly.insertPoint(index, { x: p.x, y: p.y }, loopIndex);} // Duplicates start and/or end vertex of a given edge in a polyline/polygon.
  }, { key: "duplicateVertices", value: function duplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var startVertex = edgeIndex;if (duplicateStartVertex) {MoveEdge.duplicateVertex(poly, startVertex, loopIndex); // After duplicating, the actual edge start vertex has shifted by 1.
        startVertex++;}if (duplicateEndVertex) {var vNext = poly.nextIndex(startVertex, loopIndex);MoveEdge.duplicateVertex(poly, vNext, loopIndex);}} }, { key: "revertDuplicateVertices", // Reverts the extra vertices inserted by duplicateVertices. Note that edgeIndex refers
    // to the polygon before duplicating the vertices, i.e., should be identical with 
    // the one used in the duplicateVertices(..) to be reverted.
    value: function revertDuplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {// get edge index after considering vertex duplication
      var curEdgeIndex = MoveEdge.getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex); // If the end vertex was duplicated, revert that now
      if (duplicateStartVertex) {// Note that it is important to remove the vertex BEFORE edge start instead of the edge start itself.
        // Although both have identical positions, the edge start vertex may contain additional arc params.
        var iPrev = curEdgeIndex - 1;poly.removePoint(iPrev, loopIndex); // This shifts the edgeIndex back by 1
        curEdgeIndex--;}if (duplicateEndVertex) {// Always remove the first of the two duplicate vertices. The first one is the copy that just contains
        // the position, while the second (=original) one may contain additional arc params.
        var iNext = poly.nextIndex(curEdgeIndex, loopIndex);poly.removePoint(iNext, loopIndex);}} }, { key: "getNewEdgeIndex", // If we duplicate start/end vertex of an edge, the index of that edge may change.
    // This function returns the new index of the edge after duplicating start/end vertex.
    //
    // Note: poly is assumed to contain the duplicated vertices.
    value: function getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var newIndex = edgeIndex; // Duplicating the start vertex always shift the edgeIndex by 1
      if (duplicateStartVertex) {newIndex++;} // get vertexCount of the polygon before insertion of duplicated vertices.
      var vertexCountBefore = poly.getVertexCount(loopIndex) - (duplicateStartVertex ? 1 : 0) - (duplicateEndVertex ? 1 : 0); // Check if edge was the 'closing edge' of the original polygon, i.e., the edge that 
      // connects the last vertex with vertex 0
      var isClosingEdge = edgeIndex === vertexCountBefore - 1; // Duplicating the end vertex may also shift the edgeIndex. This happens if the edge start
      // vertex is the last one in a polygon.
      if (duplicateEndVertex && isClosingEdge) {newIndex++;}return newIndex;} }]);return MoveEdge;}(Action); // Change arc type of a Path edge. It can also be used to change arc params without changing the actual type.
var ChangeEdgeType = /*#__PURE__*/function (_Action10) {_inherits(ChangeEdgeType, _Action10);var _super10 = _createSuper(ChangeEdgeType); // @param {EditLayer} layer
  // @param {Path}      path  - must be in "before" state of the action
  // @param {PolyIndex} polyIndex
  // @param {EdgeType}  edgeType
  // @param {Vector2}   [cp1] - Control points. Only needed when changing to Bezier
  // @param {Vector2}   [cp2]
  // @param {EllipseArcParams} [arcParams] - only needed when changing to EllipseArc
  function ChangeEdgeType(layer, path, polyIndex, edgeType, cp1, cp2, arcParams) {var _this16;_classCallCheck(this, ChangeEdgeType);_this16 = _super10.call(this, layer);_this16.path = path;_this16.edgeIndex = polyIndex.vertex;_this16.loopIndex = polyIndex.loop; // Store previous edge props
    var isBezier = path.isBezierArc(_this16.edgeIndex, _this16.loopIndex);_this16.oldEdgeType = path.getEdgeType(_this16.edgeIndex, _this16.loopIndex);_this16.oldCp1 = isBezier && path.getControlPoint(_this16.edgeIndex, 1, _this16.loopIndex);_this16.oldCp2 = isBezier && path.getControlPoint(_this16.edgeIndex, 2, _this16.loopIndex);_this16.oldEllipseArcParams = path.getEllipseArcParams(_this16.edgeIndex, _this16.loopIndex); // Store new control points (if any)
    _this16.newEdgeType = edgeType;_this16.newCp1 = cp1;_this16.newCp2 = cp2;_this16.newEllipseArcParams = arcParams;return _this16;}_createClass(ChangeEdgeType, [{ key: "redo", value: function redo()

    {
      switch (this.newEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.newEllipseArcParams, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.newCp1.x, this.newCp1.y, this.newCp2.x, this.newCp2.y, this.loopIndex);break;}

    } }, { key: "undo", value: function undo()

    {
      switch (this.oldEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.oldCp1.x, this.oldCp1.y, this.oldCp2.x, this.oldCp2.y, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.oldEllipseArcParams, this.loopIndex);break;}

    }

    // After undo/redo, select changed edge
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.path,
        edge: new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: this.edgeIndex, loop: this.loopIndex }) };

    } }]);return ChangeEdgeType;}(Action);var


ApplyCutOut = /*#__PURE__*/function (_Action11) {_inherits(ApplyCutOut, _Action11);var _super11 = _createSuper(ApplyCutOut);

  function ApplyCutOut(layer, cutPath) {var _this17;_classCallCheck(this, ApplyCutOut);
    _this17 = _super11.call(this, layer);

    // collect all other polygons and closed paths in the layer that overlap the cutPath bbox
    var cutBox = cutPath.getBBox();
    _this17.paths = layer.shapes.filter(function (s) {

      if (s === cutPath) {
        return false;
      }

      // cutout is only be applied on Polygons and closed Paths
      var isClosed = s instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && s.isClosed;
      if (!isClosed) {
        return false;
      }

      var box = s.getBBox();
      return cutBox.isIntersectionBox(box);
    });

    // subtract cutPath from all overlapping shapes
    _this17.clippedPaths = _this17.paths.map(function (p) {
      return _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].apply(p, cutPath, _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].Operator.Difference);
    });

    // create backups of original paths before cutout
    _this17.originalShapes = _this17.paths.map(function (p) {return p.clone();});

    _this17.cutPath = cutPath;return _this17;
  }_createClass(ApplyCutOut, [{ key: "redo", value: function redo()

    {var _this18 = this;
      // replace geometry of all shapes by clipped versions
      this.paths.forEach(function (p, i) {return p.copyGeometry(_this18.clippedPaths[i]);});
      this.layer.update();
    } }, { key: "undo", value: function undo()

    {var _this19 = this;
      // replace all shapes by original versions
      this.paths.forEach(function (p, i) {return p.copyGeometry(_this19.originalShapes[i]);});
    }

    // After undo/redo, select shape that was used for cutout
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.cutPath };

    } }]);return ApplyCutOut;}(Action);var


RemoveLoops = /*#__PURE__*/function (_Action12) {_inherits(RemoveLoops, _Action12);var _super12 = _createSuper(RemoveLoops);

  function RemoveLoops(layer, poly, loops) {var _this20;_classCallCheck(this, RemoveLoops);
    _this20 = _super12.call(this, layer);

    _this20.poly = poly;
    _this20.loops = loops;

    // create a backup of the shape before change
    _this20.before = _this20.poly.clone();return _this20;
  }_createClass(RemoveLoops, [{ key: "redo", value: function redo()

    {
      this.poly.removeLoops(this.loops);
    } }, { key: "undo", value: function undo()

    {
      this.poly.copy(this.before);
    }

    // After undo/redo, select modified shape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly };

    } }]);return RemoveLoops;}(Action);var


MoveLoop = /*#__PURE__*/function (_Action13) {_inherits(MoveLoop, _Action13);var _super13 = _createSuper(MoveLoop);

  function MoveLoop(layer, poly, loopIndex, dx, dy) {var _this21;_classCallCheck(this, MoveLoop);
    _this21 = _super13.call(this, layer);

    _this21.poly = poly;
    _this21.loopIndex = loopIndex;
    _this21.before = _this21.poly.clone();

    _this21.dx = dx;
    _this21.dy = dy;return _this21;
  }_createClass(MoveLoop, [{ key: "redo", value: function redo()

    {
      this.poly.moveLoop(this.dx, this.dy, this.loopIndex);
    } }, { key: "undo", value: function undo()

    {
      this.poly.copy(this.before);
    }

    // After undo/redo, select modified shape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly };

    } }]);return MoveLoop;}(Action);


// Merges all shapes into the first one
var UnifyShapes = /*#__PURE__*/function (_Action14) {_inherits(UnifyShapes, _Action14);var _super14 = _createSuper(UnifyShapes);

  // @param {EditLayer}  layer 
  // @param {PolyBase[]} shapes     - shapes to merge
  // @param {number}     shapeIndex - index within shapes array. All other shapes will be merged into this one.
  function UnifyShapes(layer, shapes, shapeIndex) {var _this22;_classCallCheck(this, UnifyShapes);
    _this22 = _super14.call(this, layer);

    _this22.merged = _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].apply(shapes[0], shapes[1], _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].Operator.Union, shapes.slice(2));
    _this22.before = shapes[shapeIndex].clone();

    _this22.mainShape = shapes[shapeIndex];
    _this22.otherShapes = shapes.filter(function (s) {return s !== _this22.mainShape;});return _this22;
  }_createClass(UnifyShapes, [{ key: "redo", value: function redo()

    {

      // Merge other shapes into main shape
      this.mainShape.copyGeometry(this.merged);

      // Remove all other shapes
      this.layer.removeShapes(this.otherShapes);
    } }, { key: "undo", value: function undo()

    {
      // Recover original main shape
      this.mainShape.copyGeometry(this.before);

      // Add other shapes back to layer
      this.layer.addShapes(this.otherShapes);
    }

    // After undo/redo, select mainShape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.mainShape };

    } }]);return UnifyShapes;}(Action);


// Changes Bezier arc tangent at a vertex v. This may affect up to two edge adjacent to v.
var ChangeBezierTangent = /*#__PURE__*/function () {

  // @param {EditLayer} layer
  // @param {Path}      path
  // @param {number}    vertex     - index of the vertex to be changed
  // @param {number}    loopIndex
  // @param {Vector2}   pStart     - tangent start. This is cp2 of the previous bezier segment (if any)
  // @param {Vector2}   pEnd       - tangent end    
  function ChangeBezierTangent(layer, path, index, loopIndex, pStart, pEnd) {_classCallCheck(this, ChangeBezierTangent);
    this.layer = layer;
    this.path = path;
    this.index = index;
    this.loopIndex = loopIndex;
    this.pStart = pStart;
    this.pEnd = pEnd;

    // Backup of original shape
    this.before = path.clone();
  }

  // Set the two control points that define the bezier tangent. Usually, pEnd is just pStart mirrored at the vertex
  _createClass(ChangeBezierTangent, [{ key: "setTangent", value: function setTangent(pStart, pEnd) {
      this.pStart = pStart;
      this.pEnd = pEnd;
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "redo", value: function redo() {

      // Set start point: This is cp2 of previous arc segment (if any)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);
      var prevExists = prevEdgeIndex !== -1;
      if (prevExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex)) {
        this.path.updateControlPoint(prevEdgeIndex, 2, this.pStart.x, this.pStart.y, this.loopIndex);
      }

      // Set end point: This is cp1 of current segment
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);
      var nextExists = nextEdgeIndex !== -1;
      if (nextExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex)) {
        this.path.updateControlPoint(this.index, 1, this.pEnd.x, this.pEnd.y, this.loopIndex);
      }
    } }, { key: "undo", value: function undo()

    {
      this.path.copyGeometry(this.before);
    }

    // ChangeBezierTangent may happen if a vertex or an edge is selected. So, the hint must be set from
    // outside when the information is available.
    //   @param {PolyIndex} vertex
    //   @param {PolyIndex} edge
  }, { key: "setSelectionItem", value: function setSelectionItem(vertex, edge) {
      this.selectionHint = {
        shape: this.path,
        vertex: vertex,
        edge: edge };

    }

    // After undo/redo, select the edge that was modified
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return this.selectionHint;
    } }]);return ChangeBezierTangent;}();


var Actions = {
  Action: Action,
  AddShape: AddShape,
  AddShapes: AddShapes,
  MoveShapes: MoveShapes,
  RemoveShape: RemoveShape,
  RemoveShapes: RemoveShapes,
  AddVertex: AddVertex,
  MoveVertex: MoveVertex,
  RemoveVertex: RemoveVertex,
  MoveEdge: MoveEdge,
  ChangeEdgeType: ChangeEdgeType,
  ApplyCutOut: ApplyCutOut,
  RemoveLoops: RemoveLoops,
  UnifyShapes: UnifyShapes,
  MoveLoop: MoveLoop,
  ChangeBezierTangent: ChangeBezierTangent };

/***/ }),

/***/ "./extensions/Edit2D/AngleGizmo.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/AngleGizmo.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleGizmo; });
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var Colors = {
  Black: 'rgb(0,0,0)' };


// An angle gizmo indicates a rotation angle using two arrows (start/end direction) and a connecting arc.
// The arc is drawn along the shortest connection, either cw or ccw.
var AngleGizmo = /*#__PURE__*/function () {

  function AngleGizmo(layer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, AngleGizmo);
    this.layer = layer;
    this.options = options;

    // --- Configuration params ---

    // Corner points encloding the angle
    this.center = new THREE.Vector2(); // center of the arc
    this.pStart = new THREE.Vector2(); // center->pStart indicates direction before rotation
    this.pEnd = new THREE.Vector2(); // center->pEnd indicates direction after rotation

    // sizes in pixels
    this.arrowLength = 150;
    this.arrowHeadLength = 18;
    this.arcRadius = 100;

    // Indicate which points are properly set. If only center and one point are valid, we show just an arrow.
    this.centerValid = false;
    this.pStartValid = false;
    this.pEndValid = false;

    // Optional: Show dotted line that connects the arrow with the points that define the direction.
    this.showExtendLines = true;

    // Specifies how far we shift the labelPosition away from the center. An offset of 0 would mean to center the label
    // on the center point of the angle arc line. 
    this.labelPosOffset = 30;

    // Angle text label
    this.enableLabel = true;

    // --- Maintained by the gizmo ---

    // Arrow shapes. Auto-updated based on settings
    this.arrowStart = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    this.arrowEnd = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

    // Sharpness of arrow peaks
    this.arrowStart.headAngle = 45;
    this.arrowEnd.headAngle = 45;


    // Arc line connecting the two arrows
    this.arcLine = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"]().allocPoints(2);
    this.arcArrow = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    this.arcFill = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"]().allocPoints(3);
    this.arcFill.isClosed = true;

    // Used and auto-updated in upadte() 
    this.arcParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EllipseArcParams"]();

    // Update shapes on camera updates
    this.onCameraChange = this.onCameraChange.bind(this);
    this.layer.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // arc style
    this.arcFillOpacity = 0.2;
    this.arcFill.style.lineAlpha = 0;
    this.arcFill.style.fillAlpha = this.arcFillOpacity;
    this.arcLine.style.lineWidth = 2.0;
    this.arcLine.style.lineColor = this.options.arcColor || Colors.Black;

    this.arcArrow.line.style.lineColor = this.options.arcColor || Colors.Black;
    this.arcArrow.line.style.lineWidth = 2.0;
    this.arcArrow.head.style.lineAlpha = 0;
    this.arcArrow.head.style.fillColor = this.options.arcColor || Colors.Black;
    this.arcArrow.head.style.fillAlpha = 1;
    this.arcArrowMaxHeadLength = 0.3; // If the arc arrow is very short (small angles), we restrict the headSize to a percentage of the arrow length

    // start arrow line style
    this.arrowStart.line.style.lineColor = this.options.startColor || Colors.Black;
    this.arrowStart.line.style.lineWidth = 1.5;

    // end arrow line style 
    this.arrowEnd.line.style.lineColor = this.options.endColor || Colors.Black;
    this.arrowEnd.line.style.lineWidth = 1.5;

    // start arrow head style
    this.arrowStart.head.style.lineAlpha = 0;
    this.arrowStart.head.style.fillColor = this.options.startColor || Colors.Black;
    this.arrowStart.head.style.fillAlpha = 1;

    // end arrow head style
    this.arrowEnd.head.style.lineAlpha = 0;
    this.arrowEnd.head.style.fillColor = this.options.endColor || Colors.Black;
    this.arrowEnd.head.style.fillAlpha = 1;

    this.label = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["TextLabel"](this.layer, '', this.options.labelClassName);

    // reused values for label position computation 
    this.labelPos = new THREE.Vector2(); // in layer-coords
    this.arcCurve = new Autodesk.Extensions.CompGeom.EllipseArc();
    this.visible = false;

    // For fadeIn/Out effects
    var setOpacity = function setOpacity(opacity) {
      _this.arrowStart.line.style.lineAlpha = opacity;
      _this.arrowStart.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;
      _this.arrowEnd.line.style.lineAlpha = opacity;
      _this.arrowEnd.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;
      _this.arcLine.style.lineAlpha = opacity;
      _this.arcArrow.line.style.lineAlpha = opacity;
      _this.arcArrow.head.style.fillAlpha = opacity;
      _this.arcFill.style.fillAlpha = opacity * _this.arcFillOpacity;
      _this.opacity = opacity;
      _this.layer.update();
    };

    this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);

    // reflects current fadeIn/fadeOut state
    this.opacity = 1.0;
  }_createClass(AngleGizmo, [{ key: "setCenter", value: function setCenter(

    center) {
      if (center) {
        this.center.copy(center);
        this.centerValid = true;
      } else {
        this.centerValid = false;
      }
    } }, { key: "setStart", value: function setStart(

    pStart) {
      if (pStart) {
        this.pStart.copy(pStart);
        this.pStartValid = isFinite(pStart.x) && isFinite(pStart.y);

        // Warn on NaN/Inf values
        if (!this.pStartValid) {
          console.warn("AngleGizmo: Invalid start point");
        }

      } else {
        this.pStartValid = false;
      }
    } }, { key: "setEnd", value: function setEnd(

    pEnd) {
      if (pEnd) {
        this.pEnd.copy(pEnd);
        this.pEndValid = isFinite(pEnd.x) && isFinite(pEnd.y);

        // Warn on NaN/Inf values
        if (!this.pEndValid) {
          console.warn("AngleGizmo: Invalid end point");
        }
      } else {
        this.pEndValid = false;
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.layer.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (this.visible == visible) {
        return;
      }

      this.visible = visible;
      if (visible) {
        this.layer.addShape(this.arrowStart);
        this.layer.addShape(this.arrowEnd);
        this.layer.addShape(this.arcLine);
        this.layer.addShape(this.arcArrow);
        this.layer.addShape(this.arcFill);
      } else {
        this.layer.removeShape(this.arrowStart);
        this.layer.removeShape(this.arrowEnd);
        this.layer.removeShape(this.arcLine);
        this.layer.removeShape(this.arcArrow);
        this.layer.removeShape(this.arcFill);
      }
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      this.opacityParam.setValue(opacity);
    } }, { key: "skipFade", value: function skipFade()

    {
      this.opacityParam.skipAnim();
    }

    // Fade in/out. This also sets the visibility, i.e. shapes are hidden when opacity reaches zero.
  }, { key: "fadeTo", value: function fadeTo(value) {
      this.opacityParam.fadeTo(value);
    }

    // Update arc label position based on center point of the arc. Note that this.arcLine must be up to 
  }, { key: "updateLabel", value: function updateLabel(pixelsPerUnit, arcRadius) {

      var arc = this.arcLine.exportEllipseArc(0, 0, this.arcCurve);
      var labelPos;

      if (this.options.centerLabel) {
        labelPos = this.center;
      } else {
        // get point at center of the angle arc
        labelPos = arc.getPoint(0.5, this.labelPos);

        // Shift label position more "outside", i.e. away from the center
        var labelPosOffset = this.labelPosOffset / pixelsPerUnit;
        labelPos.sub(this.center);
        labelPos.normalize();
        labelPos.multiplyScalar(arcRadius + labelPosOffset);
        labelPos.add(this.center);
      }

      this.label.setPosition(labelPos.x, labelPos.y);

      // update label text
      var angle = THREE.Math.radToDeg(arc.getAngleDelta());

      if (!isNaN(angle)) {
        var text = angle.toFixed(1) + "";
        this.label.setText(text);
      }
    } }, { key: "update", value: function update()

    {

      // Note: When using the gizmo on a plane in 3D, pixelsPerUnit may vary per point.
      // Todo: Add general support for this case to Edit2D layers.
      var pixelsPerUnit = 1;

      // In case ignoreCameraDistance is set, the size of the arc won't change depending on the camera distance.
      // In fact, the gizmo will behave more like an overlay.
      if (!this.options.ignoreCameraDistance) {
        var pWorld = new THREE.Vector3(this.center.x, this.center.y, 0).applyMatrix4(this.layer.layerToWorld);
        pixelsPerUnit = this.layer.viewer.impl.camera.pixelsPerUnitAtPoint(pWorld);
      }

      // convert all sizes to layer-space
      var arrowHeadLength = this.arrowHeadLength / pixelsPerUnit;
      var arcRadius = this.arcRadius / pixelsPerUnit;

      // Check if all directions are valid
      var showGizmo = this.centerValid && this.pStartValid && this.pEndValid;

      // Update gizmo visibility
      this.arrowStart.setVisible(showGizmo);
      this.arrowEnd.setVisible(showGizmo);
      this.arcLine.setVisible(showGizmo);
      this.arcArrow.setVisible(showGizmo);
      this.arcFill.setVisible(showGizmo);

      // Update label visibility
      var showLabel = showGizmo && this.enableLabel;
      this.label.setOpacity(showLabel ? 1.0 : 0.0, true); // label fades smoothly

      // If everything is hidden now anyway, we are done here
      if (!showGizmo) {
        // Note that we still have to update in case some shapes just changed from visible to hidden.
        this.layer.update();
        return;
      }

      // arrows start at the angle center
      this.arrowStart.setFrom(this.center);
      this.arrowEnd.setFrom(this.center);

      // arrows point toward pStart/pEnd
      this.arrowStart.setTo(this.pStart);
      this.arrowEnd.setTo(this.pEnd);

      // scale arrow-head sizes for constant screen-size
      if (!this.options.hideArrowHead) {
        this.arrowStart.setHeadLength(arrowHeadLength);
        this.arrowEnd.setHeadLength(arrowHeadLength);
      }

      // Compute angle
      var startDir = this.pStart.clone().sub(this.center).normalize();
      var endDir = this.pEnd.clone().sub(this.center).normalize();
      var angle = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(startDir, endDir);

      // Prevent arc from being longer than the arrows
      arcRadius = Math.min(arcRadius, this.pStart.distanceTo(this.center), this.pEnd.distanceTo(this.center));

      // Configure ellpse arc
      this.arcParams.rx = arcRadius;
      this.arcParams.ry = arcRadius;
      this.arcParams.sweepFlag = angle > Math.PI;
      this.arcParams.largeArcFlag = false; // always display the shorter connection

      // Compute arc start/end
      var arcStart = startDir.clone().multiplyScalar(arcRadius).add(this.center);
      var arcEnd = endDir.clone().multiplyScalar(arcRadius).add(this.center);

      // Configure arc line
      this.arcLine.updatePoint(0, arcStart.x, arcStart.y);
      this.arcLine.updatePoint(1, arcEnd.x, arcEnd.y);
      this.arcLine.setEllipseArc(0, this.arcParams);

      // Configure arc arrow
      var poly = this.arcLine.toPoly();
      var from = poly.getPoint(poly.getVertexCount() - 2);
      this.arcArrow.setFrom(from);
      this.arcArrow.setTo(this.pEnd);

      // Prevent the arrow from being larger than the arc itself
      var arcArrowLenght = Math.min(arrowHeadLength, this.arcArrowMaxHeadLength * this.pEnd.distanceTo(this.pStart));
      this.arcArrow.setHeadLength(arcArrowLenght);

      // Configure arc fill
      this.arcFill.updatePoint(0, this.center.x, this.center.y);
      this.arcFill.updatePoint(1, arcStart.x, arcStart.y);
      this.arcFill.updatePoint(2, arcEnd.x, arcEnd.y);
      this.arcFill.setEllipseArc(1, this.arcParams);

      this.updateLabel(pixelsPerUnit, arcRadius);

      this.layer.update();
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.update();
    }

    // If true, the angle label is frozen at its current state
  }, { key: "setLabelEnabled", value: function setLabelEnabled(enabled) {
      this.enableLabel = enabled;
    } }]);return AngleGizmo;}();

/***/ }),

/***/ "./extensions/Edit2D/AngleGizmo3d.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleGizmo3d.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleGizmo3d; });
/* harmony import */ var _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleGizmo.js */ "./extensions/Edit2D/AngleGizmo.js");
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var nextId = 1;

// Extends the AngleGizmo class by the ability to be used within a 3D scene.
//
// For this, AngleGizmo3d maintains an own layer that is placed within the current 3d view.
// The layer is placed in a plane that is chosen based on selected location center and rotation axis.
var AngleGizmo3d = /*#__PURE__*/function (_AngleGizmo) {_inherits(AngleGizmo3d, _AngleGizmo);var _super = _createSuper(AngleGizmo3d);

  // @param {Viewer3d} viewer
  // @param {string}   [overlayName] - Must be the name of an existing viewer overlay. If not set, the gizmo creates its own
  function AngleGizmo3d(viewer, options) {var _this;var overlayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;_classCallCheck(this, AngleGizmo3d);
    _this = _super.call(this, new _EditLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](viewer), options); // init own layer

    _this.viewer = viewer;

    // Rotation center in world-coords. Serves as anchor point to place the EditLayer within 3d.
    _this.center3d = new THREE.Vector3();
    _this.pStart3d = new THREE.Vector3();
    _this.pEnd3d = new THREE.Vector3();

    _this.id = nextId++;

    _this.overlayName = overlayName;
    _this.overlayOwned = false;

    // Create an own overlay if none is provided
    if (!overlayName) {
      // Create own overlay.
      _this.overlayName = 'Autodesk.Edit2d.AngleGizmo3d.' + _this.id;
      _this.viewer.impl.createOverlayScene(_this.overlayName);

      // Remember that we have to clear it later
      _this.overlayOwned = true;
    }

    // Display layer in the given overlay
    _this.viewer.impl.addOverlay(_this.overlayName, _this.layer.scene);

    // Reused for computing the layer placement
    _this.layerMatrix = new THREE.Matrix4();return _this;
  }_createClass(AngleGizmo3d, [{ key: "dtor", value: function dtor()

    {
      // Remove layer from overlay
      this.viewer.impl.removeOverlay(this.overlayName, this.layer.scene);

      // Remove overlay if own it
      if (this.overlayOwned) {
        this.viewer.impl.removeOverlayScene(this.overlayName);
      }
    }

    // Return layer coords from given 3d world position
  }, { key: "toLayer", value: function toLayer(p3d) {
      return p3d && p3d.clone().applyMatrix4(this.layer.worldToLayer);
    }

    // Set EditLayer transform so that the layer is on the same
    // plane as center.
  }, { key: "updateLayerTransform", value: function updateLayerTransform() {
      // Todo: Generalize to different axes
      this.layerMatrix.makeTranslation(0, 0, this.center3d.z);
      this.layer.setMatrix(this.layerMatrix);
    } }, { key: "setCenter3d", value: function setCenter3d(

    center3d) {

      // If not set, just clear 2d center as well. This will hide the gizmo until a proper center is set. 
      if (!center3d) {
        this.setCenter(null);
        return;
      }

      // move layer to the plane containing center3d
      this.center3d.copy(center3d);
      this.updateLayerTransform();

      // Make sure that any previously valid 2d start/end positions keep correct.
      // Note that a new center was just chosen anyway, 
      this.pStartValid && this.setStart(this.toLayer(this.pStart3d));
      this.pEndValid && this.setEnd(this.toLayer(this.pEnd3d));

      // set center in layer-coords
      this.setCenter(this.toLayer(this.center3d));
    } }, { key: "setStart3d", value: function setStart3d(

    start3d) {
      if (start3d) {
        this.pStart3d.copy(start3d);
      }
      this.setStart(this.toLayer(start3d));
    } }, { key: "setEnd3d", value: function setEnd3d(

    end3d) {
      if (end3d) {
        this.pEnd3d.copy(end3d);
      }
      this.setEnd(this.toLayer(end3d));
    } }]);return AngleGizmo3d;}(_AngleGizmo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/AngleSnapper.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleSnapper.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleSnapper; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. 
//
// If pMov is the vertex being moved, the snapping behavior includes:
//
//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.
//
//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.
//
//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.
//
//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.
//

// A SnapLine is a line that we consider for snapping. 
var SnapLine = /*#__PURE__*/function () {

  function SnapLine(a, b) {_classCallCheck(this, SnapLine);

    // start and end point
    this.a = a.clone();
    this.b = b.clone();

    // normalized edge direction
    this.dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);
  }

  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.
  // @returns {bool} true on success
  _createClass(SnapLine, [{ key: "intersect", value: function intersect(line, outPoint) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(this.a, this.dir, line.a, line.dir, outPoint);
    }

    // project point to SnapLine
  }, { key: "snapToLine", value: function snapToLine(p) {
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(p, this.a, this.dir);
    }

    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.
  }, { key: "isUsable", value: function isUsable(p, snapRadius) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointLineDistance(p, this.a, this.dir) < snapRadius;
    }

    // Checks if a SnapLine is (approx.) identical with another one
  }, { key: "isEqual", value: function isEqual(snapLine, precision) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].collinear(this.a, this.dir, snapLine.a, snapLine.dir, precision);
    } }]);return SnapLine;}();
;

// Snap position based on 1 or 2 SnapLines.
//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place
//  @param {SnapLine} snapLine1   - First line to snap to
//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.
// Preconditions:
//  - SnapLine1: Is close to pos (wrt. to snap tolerance)
//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  
var snapToLines = function snapToLines(pos, snapLine1, snapLine2) {

  // No snaplines => keep original pos
  if (!snapLine1 && !snapLine2) {
    return;
  }

  // If only SnapLine1 exists
  if (!snapLine2) {
    // project pos to snapLine1
    snapLine1.snapToLine(pos);
    return;
  }

  // If only snapLine2 exists
  if (!snapLine1) {
    // project pos to snapLine2
    snapLine2.snapToLine(pos);
    return;
  }

  // Snap pos to line intersection.
  snapLine1.intersect(snapLine2, pos);
};

// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.
// Accepts negative indices up to -this.poly.length.
var getPointMod = function getPointMod(poly, index, loopIndex) {
  var vertexCount = poly.getVertexCount(loopIndex);
  index = (index + vertexCount) % vertexCount;
  return poly.getPoint(index, loopIndex);
};

// Returns an array of SnapLines used to align with each edge of the given polygon.
//  @param {Polygon}   poly
//  @param {vIndex}    vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.
//  @param {loopIndex} loopIndex
var findSnapLines = function findSnapLines(poly, vIndex, loopIndex) {

  // tmp vectors
  var normal = new THREE.Vector2();
  var center = new THREE.Vector2();
  var pEnd = new THREE.Vector2();

  var snapLines = [];

  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.
  // and adds it to snapLines.
  // Generated snapLines are:
  //  - Line spanned by the edge
  //  - Orthogonal lines at start, center, and end point.
  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {

    // add line spanned by the edge
    snapLines.push(new SnapLine(a, b));

    // get edge normal and center point
    normal = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b, normal));
    center = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeCenter(a, b, center);

    // add orthogonal line add edge start
    pEnd.copy(a).add(normal); // pEnd = p1 + normal
    snapLines.push(new SnapLine(a, pEnd));

    // add orthogonal line at edge center
    pEnd.copy(center).add(normal); // pEnd = center + normal
    snapLines.push(new SnapLine(center, pEnd));

    // add orthogonal line at edge end
    pEnd.copy(b).add(normal); // pEnd = p2 + normal
    snapLines.push(new SnapLine(b, pEnd));
  };var _loop = function _loop(

  l) {
    poly.enumEdges(function (a, b, ia, ib) {

      // Exclude edges containing the moved vertex: These edges are not fixed yet and should not
      // be used for alignment.
      if (l === loopIndex && (ia === vIndex || ib === vIndex)) {
        return;
      }

      // skip edge if degenerate
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(a, b)) {
        return;
      }

      addEdgeSnapLines(a, b);
    }, l);};for (var l = 0; l < poly.loopCount; l++) {_loop(l);
  }
  return snapLines;
};

// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.
// A candidate is only suitable if...
//  1. The intersection with snapLine1 is within snapping tolerance
//  2. The angle formed with snapLine1 is as closer to 90 than all other candidates. This makes sure that we rather 
//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.
// 
//  @param {SnapLine} candidate       - SnapLine candidates to be compared    
//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)
//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.
//  @param {Vector2}  pos             - position to be snapped
//  @param {number}   snapRadius      - in layer coords
//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate
var checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {

  // If candidate does not intersect snapLine1, we cannot use it.
  var pIntersect = new THREE.Vector2();
  if (!snapLine1.intersect(candidate, pIntersect)) {
    return bestCandidate;
  }

  // If intersection point is outside snapRadius, discard candidate
  if (pIntersect.distanceTo(pos) > snapRadius) {
    return bestCandidate;
  }

  // If there is no competitor, the candidate made it.
  if (!bestCandidate) {
    return candidate;
  }

  // Check which of the candidates is "less parallel" to snapLine1
  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));
  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));
  return dp1 > dp2 ? candidate : bestCandidate;
};

var xAxis = new THREE.Vector2(1, 0);

var av = Autodesk.Viewing;
// AngleSnapper helps to draw right angles, parallel lines etc.
var AngleSnapper = /*#__PURE__*/function () {

  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);
    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.
    this.poly = null;

    // Index of the vertex in this.poly that is beging moved.
    this.vIndex = -1;
    this.loopIndex = -1;

    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle
    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];

    // We consider an angle "close to" another one if they differ by this value or less.
    this.snapAngleTolerance = 2; // in degrees

    // Allow snapping to lines within x pixels.
    this.snapRadius = 10;

    this.gizmoLayer = gizmoLayer;
    this.setGlobalManager(gizmoLayer.globalManager);

    // reused tmp points
    this.movedPoint = new THREE.Vector2(); // the vertex being moved
    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint
    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint

    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint
    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis

    // Array of snapLines to align a vertex position with other edges
    this.edgeSnapLines = [];

    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.
    this.snapLine1 = null;
    this.snapLine2 = null;

    // Optional: External line constraint. This is used if we already snapped to a line geometry and
    //           want to combine the snap with angle snapping.
    this.snapLineExt = null;

    // Gizmos to display the lines considered for snapping
    this.snapLineStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineColor: 'rgb(255, 0, 0)',
      lineWidth: 1.0,
      lineStyle: 10 });

    this.snapLineGizmos = [];
    this.snapLineGizmosUsed = 0;
  }_createClass(AngleSnapper, [{ key: "onSetGlobalManager", value: function onSetGlobalManager(

    globalManager) {
      this.globalManager = globalManager;
      this.snapLineGizmos.forEach(function (g) {return g.setGloblaManager(globalManager);});
    } }, { key: "acquireSnapLineGizmo", value: function acquireSnapLineGizmo()

    {
      var gizmo = this.snapLineGizmos[this.snapLineGizmosUsed];
      if (!gizmo) {
        // Create new line gizmo
        gizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
        gizmo.setGlobalManager(this.globalManager);
        this.snapLineGizmos[this.snapLineGizmosUsed] = gizmo;
      }
      this.snapLineGizmosUsed++;
      return gizmo;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {var _this = this;
      var removeGizmo = function removeGizmo(g) {return _this.gizmoLayer.removeShape(g);};
      this.snapLineGizmos.forEach(removeGizmo);
      this.snapLineGizmosUsed = 0;
    }

    // Configures snapping to align to edges of the given polygon/polyline
    //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.
    //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.
    //  @param {number}           loopIndex
  }, { key: "startSnapping", value: function startSnapping(poly, vIndex, loopIndex) {
      this.poly = poly;
      this.vIndex = vIndex;
      this.loopIndex = loopIndex;

      // precompute snapLines for alignment. These don't change while moving a vertex.
      this.edgeSnapLines = findSnapLines(poly, vIndex, this.loopIndex);
    } }, { key: "stopSnapping", value: function stopSnapping()

    {

      this.poly = null;
      this.vIndex = -1;
      this.loopIndex = -1;

      // Discard any outdated results and hide gizmos
      this.snapLine1 = null;
      this.snapLine2 = null;
      this.clearSnappingGizmos();
    }

    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when
    // snapping while snapping is bypassed.
  }, { key: "clearSnappingResult", value: function clearSnappingResult() {
      this.snapLine1 = null;
      this.snapLine2 = null;
    } }, { key: "getPrevSnapLine",





    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the previous edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
    value: function getPrevSnapLine(pMov) {

      // Get vertices one and two indices before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);
      var pPrev2 = getPointMod(this.poly, this.vIndex - 2, this.loopIndex);

      // Check angle between (pPrev, pMov) and its predecessor edge (pPrev2, pPrev)
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pPrev2, pPrev);
      return this.computeAngleSnapLine(pMov, pPrev, alignAxis);
    }

    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the next edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
  }, { key: "getNextSnapLine", value: function getNextSnapLine(pMov) {

      // When moving one of the last two vertices of a polyline, there is actually no "next edge", because start and end
      // vertex are not connected. Therefore, we skip snapping to "next edge" for this case.
      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.getVertexCount(this.loopIndex) - 2;
      if (ignoreNextEdge) {
        return null;
      }

      var pNext = getPointMod(this.poly, this.vIndex + 1, this.loopIndex);
      var pNext2 = getPointMod(this.poly, this.vIndex + 2, this.loopIndex);

      // Snap to angle wrt. to next edge: (only for polygons)
      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pNext, pNext2);
      return this.computeAngleSnapLine(pMov, pNext, alignAxis);
    }

    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved
    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.
    //  @param {Vector2} pMov - Position to be snapped
    //  @param {Object}  [lineConstraint] - Optional: External line-constraint {a,b}. If specified, we only allow snapping to
    //                                                intersections with angle snapLines and the line (lineConstraint.a, lineConstraint.b).
  }, { key: "snapToAngle", value: function snapToAngle(pMov, lineConstraint) {var _this2 = this;

      // Reset the two lines that we consider for snapping.
      this.snapLine1 = null;
      this.snapLine2 = null;

      // Create snapLine from external line constraint (if specified)
      this.snapLineExt = lineConstraint && new SnapLine(lineConstraint.a, lineConstraint.b);

      if (!this.active || this.poly.vertexCount <= 1) {
        return;
      }

      // Get point before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);

      // get snapRadius in layer-coords. This is the maximum distance that we allow
      // between mouse pos and the final snap position that we obtain by projecting
      // to a SnapLine or by intersecting two SnapLines.
      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();

      // If we just have a single edge, we can only snap to angles relative to x-axis
      var isFirstEdge = this.poly.vertexCount == 2;
      if (isFirstEdge) {
        // Get closest angle-snap line relative to mainAxis (or null if no snapAngle is close enough)
        var snapAxis = this.computeAngleSnapLine(pMov, pPrev, xAxis);

        if (snapAxis && this.snapLineExt) {
          // If an external line constraint is set, snapAxis can only be considered as a secondary snap.
          // This means, we can only consider if it intersects with the costraint line and the intersection is close to pMov
          this.snapLine1 = checkSecondSnapCandidate(snapAxis, null, this.snapLineExt, pMov, snapRadiusLC);
        } else {
          // No other constraints. Just use the snapAxis (or no axis at all if snapAxis is null)
          this.snapLine1 = snapAxis;
        }

        snapToLines(pMov, this.snapLine1, this.snapLineExt);
        return;
      }

      var prevSnapLine = this.getPrevSnapLine(pMov);
      var nextSnapLine = this.getNextSnapLine(pMov);

      // Filter to lines that are close enough to pMov
      var snapLineUsable = function snapLineUsable(snapLine) {

        if (!snapLine) {
          return false;
        }

        if (_this2.snapLineExt) {
          // Consider line-constraint: Only accept snapLine if...
          //  1. ...it intersects constraint line
          //  2. ...intersection point is within snapRadius.
          return Boolean(checkSecondSnapCandidate(snapLine, null, _this2.snapLineExt, pMov, snapRadiusLC));
        }

        // No constraint: Accept any snapLines within snapRadius
        return snapLine.isUsable(pMov, snapRadiusLC);
      };

      var candidates = this.edgeSnapLines.filter(snapLineUsable);

      // Reject prevSnapLine/nextSnapLine if they are not usable
      prevSnapLine = snapLineUsable(prevSnapLine) && prevSnapLine;
      nextSnapLine = snapLineUsable(nextSnapLine) && nextSnapLine;

      // choose first snapLine
      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];

      // Stop here if there is no snapping candidate at all
      if (!this.snapLine1) {
        return;
      }

      // If we have an external line constraint, we can only choose a single snapLine, because we already
      // have to intersect it with the external constraint line.
      if (this.snapLineExt) {
        return snapToLines(pMov, this.snapLine1, this.snapLineExt);
      }

      // If prev and next edge allow angle snapping, check if we can snap to both
      if (prevSnapLine && nextSnapLine) {
        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);
      }

      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,
      // check if we can snap to another edge to be aligned with other edges.
      if (!this.snapLine2) {
        for (var i = 0; i < candidates.length; i++) {
          var c = candidates[i];
          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);
        }
      }

      // We selected one or two SnapLines. Now, use them to decide snapped position
      return snapToLines(pMov, this.snapLine1, this.snapLine2);
    } }, { key: "isSnapped", value: function isSnapped()

    {
      return Boolean(this.snapLine1 || this.snapLine2);
    } }, { key: "updateSnapLineGizmos", value: function updateSnapLineGizmos(

    snappedPos) {var _this3 = this;

      // First, clear any outdated gizmos
      this.clearSnappingGizmos();

      if (!this.poly) {
        return;
      }

      // Collect all snapLines that we want to display
      //
      // Note that we don't just want to indicate SnapLines that actively affected the position,
      // but also the "accidentally" matched ones. E.g., if we snapped to a geometry intersection,
      // the actual snapping was not affected by angle snapping, but the resulting position may still
      // match with angle snapLines as well.
      var snapLinesToShow = [];

      // We consider the snapped position p to be "on a snapLine L" if the distance d(p,L) is within the tolerance below.
      var tolerance = 0.0001;
      var shouldBeShown = function shouldBeShown(sl) {return sl && sl.isUsable(snappedPos, tolerance);}; // Decides whether a SnapLine should be displayed

      // If we only have a single edge, angle snapping is only possible wrt. to main axes
      var isFirstEdge = this.poly.vertexCount == 2;

      // Collect SnapLines to display
      if (isFirstEdge) {
        // Just a single edge: Only snap if this first edge forms a snapping angle with x- or y-axis.
        var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);
        var snapAxis = this.computeAngleSnapLine(snappedPos, pPrev, xAxis);

        // Display snapAxis if the p is on this line
        if (snapAxis && shouldBeShown(snapAxis)) {
          snapLinesToShow.push(snapAxis);
        }
      } else {
        // Consider all edge snaplines that contain pSnappedPos
        snapLinesToShow = this.edgeSnapLines.filter(shouldBeShown);

        // Consider angles to previous and next edge
        var prevSnapLine = this.getPrevSnapLine(snappedPos);
        var nextSnapLine = this.getNextSnapLine(snappedPos);
        shouldBeShown(prevSnapLine) && snapLinesToShow.push(prevSnapLine);
        shouldBeShown(nextSnapLine) && snapLinesToShow.push(nextSnapLine);
      }

      // Eliminate duplicates: If a SnapLine is collinear with another one, displaying it would just cause artifacts.
      // Note: This is a brute-force n^2 loop. The number of SnapLines to display is usually small, so that this shouldn't be a problem.
      var isRelevant = function isRelevant(sl, index) {
        // Check if sl is a duplicate of any previous SnapLine
        var isDuplicate = false;
        for (var i = 0; i < index; i++) {
          var sl2 = snapLinesToShow[i];
          if (sl.isEqual(sl2, tolerance)) {
            isDuplicate = true;
            break;
          }
        }
        return !isDuplicate;
      };
      snapLinesToShow = snapLinesToShow.filter(isRelevant);

      // Choose SnapLineLength large enough to fill whole canvas
      var canvas = this.gizmoLayer.viewer.canvas;
      var diag = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
      var snapLineLength = this.gizmoLayer.getUnitsPerPixel() * diag;

      // A SnapLine indicator is constructed as follows:
      //  - It starts at the snapLine start point, which "explains where the SnapLine comes from". 
      //    This may be start/center/end of another edge.
      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)
      //  - It is enlarged to overshoot pMov 
      var showSnapLine = function showSnapLine(line, gizmo) {
        if (!line) {
          return;
        }

        var a = line.a;

        // Let line start at a, point towards dir, and be long enough to leave screen
        gizmo.makeLine(
        a.x - snapLineLength * line.dir.x,
        a.y - snapLineLength * line.dir.y,
        a.x + snapLineLength * line.dir.x,
        a.y + snapLineLength * line.dir.y);

        _this3.gizmoLayer.addShape(gizmo);
      };

      // Add lineGizmo for each SnapLine to be displayed
      for (var i = 0; i < snapLinesToShow.length; i++) {
        var snapLine = snapLinesToShow[i];
        var gizmo = this.acquireSnapLineGizmo();
        showSnapLine(snapLine, gizmo);
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.clearSnapping();
    }

    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.
    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.
    //  @param {Vector2} p              - vertex being moved
    //  @param {Vector2} pPrev          - vertex connected to p
    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.
  }, { key: "computeAngleSnapLine", value: function computeAngleSnapLine(p, pPrev, alignAxis) {

      // Don't try angle snapping with degenerated edges
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(pPrev, p)) {
        return null;
      }

      // get direction of new edge (ending at pMov)
      var edgeDir = p.clone().sub(pPrev);

      // Compute angle between new edge and alignment direction
      var angle = THREE.Math.radToDeg(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(edgeDir, alignAxis));

      // Check if angle matches with any index in snapAngles array
      var snapIndex = -1;
      for (var i = 0; i < this.snapAngles.length; i++) {
        var _snapAngle = this.snapAngles[i];

        var dif = Math.abs(_snapAngle - angle);
        if (dif < this.snapAngleTolerance) {
          snapIndex = i;
          break;
        }
      }

      // Stop here if no snapAngle is found
      if (snapIndex == -1) {
        return null;
      }

      // Rotate alignment axis by selected snapAngle
      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);
      var snapDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].rotateAround(alignAxis.clone(), snapAngle);

      // scale snapLine direction to the same length as (pPrev, p)
      var dist = pPrev.distanceTo(p);
      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);

      // Return snapline from pPrev pointing towards snapped direction
      return new SnapLine(pPrev, snapLineEnd);
    } }, { key: "active", get: function get() {return this.poly;} }]);return AngleSnapper;}();


av.GlobalManagerMixin.call(AngleSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/Arrow.js":
/*!************************************!*\
  !*** ./extensions/Edit2D/Arrow.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


// Vector-shape for displaying simple arrows.
var Arrow = /*#__PURE__*/function (_Shape) {_inherits(Arrow, _Shape);var _super = _createSuper(Arrow);

  function Arrow() {var _this;_classCallCheck(this, Arrow);
    _this = _super.call(this);

    // in layer coords
    _this.from = new THREE.Vector2();
    _this.to = new THREE.Vector2();

    // extends of the arrow head in layer coords
    _this.headLength = 2; // along arrow direction
    _this.headAngle = 60; // in degrees. Angle at the tip of the arrow head.

    _this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]();
    _this.head = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]();

    // If true, head is a filled triangle, otherwise just two lines joining at the tip.
    _this.headFilled = true;
    _this.head.style.lineAlpha = 0.0;

    // Add points for triangular head. We only update point positions afterwards.
    _this.head.addPoint(0, 0);
    _this.head.addPoint(0, 0);
    _this.head.addPoint(0, 0);

    // normalized arrow directiom. Auto-updated based on from/to
    _this.dir = new THREE.Vector2();

    // tmp vectors
    _this.tmpVec1 = new THREE.Vector2();
    _this.tmpVec2 = new THREE.Vector2();
    _this.tmpVec3 = new THREE.Vector2();return _this;
  }_createClass(Arrow, [{ key: "modified", value: function modified()

    {
      _get(_getPrototypeOf(Arrow.prototype), "modified", this).call(this);
      this.needsUpdate = true;
    } }, { key: "draw", value: function draw(

    ctx) {
      this.update();

      // Todo: Concept to clarify style override for shapes with child shapes with different styles.
      this.line.draw(ctx, this.line.style);
      this.head.draw(ctx, this.head.style);
    } }, { key: "move", value: function move(

    dx, dy) {
      this.from.x += dx;
      this.from.y += dy;
      this.to.x += dx;
      this.to.y += dy;
      this.modified();
      return this;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      this.update();
      return this.line.hitTest(x, y) || this.head.hitTest(x, y);
    } }, { key: "clone", value: function clone()

    {
      return new Arrow().copy(this);
    } }, { key: "setFrom", value: function setFrom(

    x, y, z) {
      if (_typeof(x) === 'object') {
        this.from.copy(x);
      } else {
        this.from.set(x, y, z);
      }
      this.modified();
    } }, { key: "setTo", value: function setTo(

    x, y, z) {
      if (_typeof(x) === 'object') {
        this.to.copy(x);
      } else {
        this.to.set(x, y, z);
      }
    }

    // Length of the arrow head. Should always be smaller than the full length of the arrow.
  }, { key: "setHeadLength", value: function setHeadLength(len) {
      this.headLength = len;
      this.modified();
    }

    // Angle at the tip of the arrow head. In degrees.
  }, { key: "setHeadAngle", value: function setHeadAngle(angle) {
      this.headAngle = angle;
      this.modified();
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Arrow.prototype), "copy", this).call(this, from);
      this.from = from.from.clone();
      this.to = from.to.clone();
      this.headLength = from.headLength;
      this.headAngle = from.headAngle;
      this.headFilled = from.headFilled;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.line.computeBBox();
      this.head.computeBBox();

      this.bbox.makeEmpty();
      this.bbox.union(this.line.bbox);
      this.bbox.union(this.head.bbox);
    } }, { key: "getLength", value: function getLength()






    {
      return this.to.distanceTo(this.from);
    }

    // Change arrow lenght by changing one of the points. 
    //  @param {number} l - new length
    //  @param {bool}   [changeFrom] - By default (false), we change the toPoint and keep fromPoint constant.
    //                                 If true, we keep toPoint and change fromPoint instead.
  }, { key: "setLength", value: function setLength(l, changeFrom) {

      // Scale direction by new length
      var dir = this.direction;
      var dx = dir.x * l;
      var dy = dir.y * l;

      // Reset fromPoint or toPoint
      if (changeFrom) {
        this.setFrom(this.to.x - dx, this.to.y - dy);
      } else {
        this.setTo(this.from.x + dx, this.from.y + dy);
      }
    } }, { key: "update", value: function update()

    {

      if (!this.needsUpdate) {
        return;
      }

      var dir = this.direction;

      // compute line endpoint. If the head is filled, the line ends at the
      // center of the head hypothenuse, otherwise at the to-point.
      var ex = this.to.x - (this.headFilled ? dir.x * this.headLength : 0);
      var ey = this.to.y - (this.headFilled ? dir.y * this.headLength : 0);

      // draw arrow tail
      this.line.makeLine(this.from.x, this.from.y, ex, ey);

      // compute vector perpendicular to arrow directrion
      var leftNormal = this.tmpVec2.copy(dir);
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(leftNormal);

      // compute distance between arrow line and left vertex of arrow head
      var halfAngle = 0.5 * THREE.Math.degToRad(this.headAngle);
      var dist = Math.tan(halfAngle) * this.headLength;

      // compute left head vertex
      var leftX = this.to.x - dir.x * this.headLength + leftNormal.x * dist;
      var leftY = this.to.y - dir.y * this.headLength + leftNormal.y * dist;

      // compute right head vertex
      var rightX = this.to.x - dir.x * this.headLength - leftNormal.x * dist;
      var rightY = this.to.y - dir.y * this.headLength - leftNormal.y * dist;

      // update the 3 head vertices
      this.head.updatePoint(0, leftX, leftY); // left vertex
      this.head.updatePoint(1, this.to.x, this.to.y); // tip of the arrow
      this.head.updatePoint(2, rightX, rightY); // right vertex

      this.needsUpdate = false;
    } }, { key: "direction", get: function get() {// Normalized arrow direction
      return this.dir.copy(this.to).sub(this.from).normalize();} }]);return Arrow;}(_EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Shape"]);

/***/ }),

/***/ "./extensions/Edit2D/BooleanOps.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/BooleanOps.js ***!
  \*****************************************/
/*! exports provided: BooleanOps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanOps", function() { return BooleanOps; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoopContainment.js */ "./extensions/Edit2D/LoopContainment.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}





var Operator = {
  Intersect: 1, // only keep regions where path1 and path2 are overlapping
  Union: 2, // unify both shapes
  Difference: 3, // path1 after removing all regions that are overlapped by path2
  Xor: 4 // only keep regions that are either covered by path1 or path2, but not both
};

// Returns all faces that are "inside the given wireBody", whereby:
//  - All wires in wireBody must be closed loops without branching
//  - A face is considered as "inside" if it is enclosed by an odd number of wires ("Even-Odd-Rule")
//
// @param {SketchRegionSolver} solver   - initialized with all edges of subject and cutLoop
// @param {SolidDef.WireBody}  wireBody - must contain closed loops.
// Returns the subset of region faces that is inside the given wireBody. 
var getFacesInside = function getFacesInside(solver, wireBody) {

  // Mark all faces as rank 0, indicating that we did not find an enclosing loop yet
  // Note: It's not perfectly clean to add extra attributes, but...
  //  a) Since faces don't have unique ids, we don't have proper way to index them without modifying
  //  b) All faces here are only temporary.
  var regionFaces = solver.getFaces();
  regionFaces.forEach(function (f) {return f.rank = 0;});

  // for each wire
  var wires = wireBody.getWires();
  wires.forEach(function (w) {

    // get faces inside this loop
    var loopEdges = w.getEdges();
    var facesInside = Object(_LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__["getFacesInsideLoop"])(solver, loopEdges);

    // increase rank for all faces inside this loop
    facesInside.forEach(function (f) {return f.rank++;});
  });

  // Return all faces whose rank is not a multiple of 2
  var hasOddRank = function hasOddRank(f) {return Boolean(f.rank & 1);};
  return regionFaces.filter(hasOddRank);
};

// Apply boolean operation on two SolidDef paths (must be closed).
//
// @param {SolidDef.Path2D}   path1           - the path to be clipped.
// @param {SolidDef.Path2D}   path2           - to be cut away. Must be a single loop.
// @param {Operator}          operator
// @param {SolidDef.Path2D[]} [extraOperands] - Unify supports more than 2 operands.
// @returns {SolidDef.Face[]} 
var applyOperation = function applyOperation(path1, path2, operator, extraOperands) {

  // get paths as wires
  var wireBody1 = path1.getWireBody();
  var wireBody2 = path2.getWireBody();

  // get both paths as edge arrays
  var edges1 = wireBody1.getEdges();
  var edges2 = wireBody2.getEdges();

  // get unified array with edges of both parts 
  var allEdges = edges1.concat(edges2);

  // add edges of additional operands
  extraOperands && extraOperands.forEach(function (p) {
    var wb = p.getWireBody();
    var edges = wb.getEdges();
    allEdges.push.apply(allEdges, _toConsumableArray(edges));
  });

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["SketchRegionSolver"]();
  solver.compute(allEdges);
  var allFaces = solver.getFaces();

  // check which of the faces are within path and cutPath        
  var facesInPath1 = getFacesInside(solver, wireBody1);
  var facesInPath2 = getFacesInside(solver, wireBody2);

  // check which faces are in any of the extra operands
  var facesInExtraPaths = extraOperands && extraOperands.map(function (p) {
    var wb = p.getWireBody();
    return getFacesInside(solver, wb);
  });

  // Filter faces based on operation type.
  // Note: We have a O(numEdges^2) runtime here, which might be an issue for number of faces. 
  //       If needed, this could be optimized by tagging the edges with unique IDs in advance and indexing
  //       the faces by id.
  var filter = function filter(f) {
    var inPath1 = facesInPath1.includes(f);
    var inPath2 = facesInPath2.includes(f);

    // Check if face is contained in any of the extra paths
    var inExtraPath = facesInExtraPaths && facesInExtraPaths.some(function (faceSet) {return faceSet.includes(f);});

    switch (operator) {
      case Operator.Union:return inPath1 || inPath2 || inExtraPath;
      case Operator.Intersect:return inPath1 && inPath2;
      case Operator.Difference:return inPath1 && !inPath2;
      case Operator.Xor:return inPath1 !== inPath2;}

  };
  var selectedFaces = allFaces.filter(filter);

  // Finally, merge these faces to obtain result
  return Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["mergeConnectedFaces"])(selectedFaces);
};

//  @param {PolyBase[]} [extraOperands] - For unify, we allow moore than 2 operands.
var apply = function apply(path1, path2, operator, extraOperands) {
  // Convert to SolidDef
  var path1Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path1);
  var path2Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path2);

  var extraOperandsSD = extraOperands && extraOperands.map(function (p) {return _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(p);});

  // Run operation
  var faces = applyOperation(path1Sd, path2Sd, operator, extraOperandsSD);

  // Convert SolidDef faces back to Edit2D paths
  var result = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].facesToShape(faces);

  // Let result inherit style of path1
  result.style.copy(path1.style);

  return result;
};

var BooleanOps = {
  Operator: Operator,
  apply: apply };

/***/ }),

/***/ "./extensions/Edit2D/CanvasGizmo.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/CanvasGizmo.js ***!
  \******************************************/
/*! exports provided: AlignX, AlignY, CanvasGizmoBase, CanvasGizmo, TextLabel, ShapeLabel, LengthLabel, AreaLabel, EdgeGizmo, EdgeMoveGizmo, EdgeLabel, VertexGizmo, LabelFilter, DefaultLabelFilter, LabelStyleRule, FadeOutStyleRule, ShapeLabelRule, ShapeToolTip, GizmoManager, ArcEdgeGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignX", function() { return AlignX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignY", function() { return AlignY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmoBase", function() { return CanvasGizmoBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmo", function() { return CanvasGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLabel", function() { return TextLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabel", function() { return ShapeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LengthLabel", function() { return LengthLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLabel", function() { return AreaLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeGizmo", function() { return EdgeGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeMoveGizmo", function() { return EdgeMoveGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeLabel", function() { return EdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexGizmo", function() { return VertexGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelFilter", function() { return LabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLabelFilter", function() { return DefaultLabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelStyleRule", function() { return LabelStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FadeOutStyleRule", function() { return FadeOutStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabelRule", function() { return ShapeLabelRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeToolTip", function() { return ShapeToolTip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GizmoManager", function() { return GizmoManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcEdgeGizmo", function() { return ArcEdgeGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var AlignX = {
  Left: 1,
  Center: 2,
  Right: 3 };


var AlignY = {
  Top: 1,
  Center: 2,
  Bottom: 3 };


var av = Autodesk.Viewing;

// Base class for any gizmo that needs to be synchronized with the shapes of an EditLayer.
var CanvasGizmoBase = /*#__PURE__*/function () {
  function CanvasGizmoBase() {_classCallCheck(this, CanvasGizmoBase);}

  // Called whenever the layer or camera changes.
  _createClass(CanvasGizmoBase, [{ key: "update", value: function update() {} }]);return CanvasGizmoBase;}();


av.GlobalManagerMixin.call(CanvasGizmoBase.prototype);

// A CanvasGizmo is an html div anchored at a position in layer-coords
var CanvasGizmo = /*#__PURE__*/function (_CanvasGizmoBase) {_inherits(CanvasGizmo, _CanvasGizmoBase);var _super = _createSuper(CanvasGizmo);
  function CanvasGizmo(layer) {var _this;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, CanvasGizmo);
    _this = _super.call(this);

    _this.layer = layer;
    _this.setGlobalManager(layer.globalManager);

    // position in layer-coords. The transform origin of the div will appear at this position.
    _this.layerPos = new THREE.Vector2();

    // position in canvas-coords (updated based on this.layerPos and camera)
    _this.canvasPos = new THREE.Vector2();

    // html content to be shown
    var _document = _this.getDocument();
    _this.container = _document.createElement('div');

    // Make sure that label is displayed on top of the canvas and not "pushed away" by it.
    _this.container.style.position = 'absolute';

    // Rotate around gizmo center
    _this.container.style.transformOrigin = '50% 50%';
    _this.container.style.top = '0px';
    _this.container.style.left = "0px";

    if (className) {
      _this.container.classList.add(className);
    }

    // Show immediately if wanted
    _this.visible = false;

    _this.alignX = AlignX.Center;
    _this.alignY = AlignY.Center;

    // Clockwise rotation angle in degrees. Rotates around center.
    _this.angle = 0;

    if (visible) {
      _this.setVisible(true, false);
    }

    // For fadeIn/Out effects
    var setOpacity = function setOpacity(t) {
      _this.container.style.opacity = t;
    };
    _this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);

    // By default, just delegate to viewer context menu. Edit2DContextMenu will take care
    // that it is properly configured.
    _this.container.addEventListener('contextmenu', function (e) {

      // Workaround for Mac: By default, LMV's context menu is responds to right mouse-button.
      // On Mac, Ctrl + Left also triggers context menu events. These must be ignored here, because:
      //    a) Consistency: LMV ignores them as well.
      //    b) Conflicts:   When inserting a vertex, we don't want the ContextMenu to show up.
      var isLeftButton = e.buttons == 1;
      if (!isLeftButton) {
        _this.layer.viewer.triggerContextMenu(e);
      }
    });return _this;
  }_createClass(CanvasGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
    } }, { key: "setVisible", value: function setVisible(

    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (visible == this.visible) {
        return;
      }

      if (visible) {
        this.addToCanvas(autoUpdate);
      } else {
        this.removeFromCanvas();
      }

      this.visible = visible;
    } }, { key: "addToCanvas", value: function addToCanvas()

    {var autoUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:
      //       ToolController listens to events on canvasWrap. Therefore, if we would add
      //       it to viewer.container, all mouse events captured would never reach the ToolController
      //       no matter whether the gizmo handles them or not.
      this.layer.viewer.canvasWrap.appendChild(this.container);
      this.layer.addCanvasGizmo(this);

      // Make sure that position is correct
      if (autoUpdate) {
        this.update();
      }
    } }, { key: "removeFromCanvas", value: function removeFromCanvas()

    {
      this.layer.viewer.canvasWrap.removeChild(this.container);
      this.layer.removeCanvasGizmo(this);
    } }, { key: "setAlignX", value: function setAlignX(

    alignX) {
      this.alignX = alignX;
      this.update();
    } }, { key: "setAlignY", value: function setAlignY(

    alignY) {
      this.alignY = alignY;
      this.update();
    }

    // @param {number} angle - Clockwise angle in degrees
    //
    // Note: Do not use 'position:absolute' in child html elements.
    //       Otherwise, the content box will be empty and it will not rotate around anymore.
  }, { key: "setRotation", value: function setRotation(angle) {
      this.angle = angle;
      this.update();
    } }, { key: "update", value: function update()

    {
      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));

      var p = this.canvasPos;
      var style = this.container.style;

      // set left/top to gizmo position
      var left = toPixels(p.x);
      var top = toPixels(p.y);

      // Choose translation offset in % based on X-alignment
      var tx;
      switch (this.alignX) {
        case AlignX.Left:tx = '0%';break;
        case AlignX.Center:tx = '-50%';break;
        case AlignX.Right:tx = '-100%';break;}


      var ty;
      switch (this.alignY) {
        case AlignY.Top:ty = '0%';break;
        case AlignY.Center:ty = '-50%';break;
        case AlignY.Bottom:ty = '-100%';break;}


      // Update transform based on rotation angle and alignment
      style.transform = "translate(".concat(left, ", ").concat(top, ") translate(").concat(tx, ", ").concat(ty, ") rotate(").concat(this.angle, "deg)");
    }

    // Set position in layer coords
  }, { key: "setPosition", value: function setPosition(x, y) {
      this.layerPos.set(x, y);
      this.update();
    } }, { key: "setClassEnabled", value: function setClassEnabled(

    className, enabled) {
      if (enabled) {
        this.container.classList.add(className);
      } else {
        this.container.classList.remove(className);
      }
    }

    // Selection state is managed using a css-class 'selected'.
    // Note that this only has an effect if the css style used for the gizmo supports it.
  }, { key: "setSelected", value: function setSelected(selected) {
      this.setClassEnabled('selected', selected);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.container.classList.contains('selected');
    }

    // Optional: Hover-effect for gizmos that can be clicked or dragged.
  }, { key: "setHoverEnabled", value: function setHoverEnabled(enabled) {
      this.setClassEnabled('enable-hover', enabled);
    }

    // Optional: Assign a name to gizmo and div element to facilitate debugging and testing.
  }, { key: "setName", value: function setName(name) {
      this.name = name;
      this.container.id = name ? name : '';
    }

    // Change css opacity. If wanted, the change can be smoothly faded.
  }, { key: "setOpacity", value: function setOpacity(value, animate) {
      if (animate) {
        this.opacityParam.fadeTo(value);
      } else {
        this.opacityParam.setValue(value);
      }
    } }]);return CanvasGizmo;}(CanvasGizmoBase);


// Configure CanvasGizmo as a text label.
var initTextLabel = function initTextLabel(gizmo) {

  // Use measure-tool styles by default
  gizmo.container.classList.add('edit2d-label');
  gizmo.container.classList.add('visible');

  // Create textDiv child div
  var _document = gizmo.getDocument();
  gizmo.textDiv = _document.createElement('div');
  gizmo.textDiv.classList.add('edit2d-label-text');
  gizmo.container.appendChild(gizmo.textDiv);

  // Add setText convenience function
  gizmo.setText = function (str) {
    this.textDiv.textContent = str;
  }.bind(gizmo);
};

// Simple TextLabel bound to a fixed position in layer coords
var TextLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(TextLabel, _CanvasGizmo);var _super2 = _createSuper(TextLabel);

  function TextLabel(layer, text, className) {var _this2;_classCallCheck(this, TextLabel);
    _this2 = _super2.call(this, layer, true, className);
    initTextLabel(_assertThisInitialized(_this2));return _this2;
  }return TextLabel;}(CanvasGizmo);

;

// A ShapeLabel is a text label whose anchor position is synchronized with the bbox center of a shape in a layer.
var ShapeLabel = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(ShapeLabel, _CanvasGizmo2);var _super3 = _createSuper(ShapeLabel);

  function ShapeLabel(shape, layer) {var _this3;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, ShapeLabel);
    _this3 = _super3.call(this, layer, visible, className);

    initTextLabel(_assertThisInitialized(_this3));

    _this3.shape = shape;

    // Can be set to hidden to temporarily hide the label
    _this3.valueValid = true;

    // Optional: Shift label by a couple of pixels.
    _this3.pixelOffset = new THREE.Vector2();

    _this3.update();return _this3;
  }_createClass(ShapeLabel, [{ key: "update", value: function update()

    {
      if (this.shape && this.valueValid) {
        // Set it to visible (in case polygon was null before)
        this.container.style.visibility = 'visible';

        if (this.shape.isPolyline()) {
          var edgeCount = this.shape.getEdgeCount(0);
          // For a start, simply position the label on the segment roughly in the middle of the polyline
          var edgeToLabel = Math.floor(edgeCount / 2);
          if (this.shape.edgeIndexValid(edgeToLabel)) {
            // Set layer position to center point of the segment.
            this.shape.getPointOnEdge(edgeToLabel, 0.5, 0, this.layerPos);
          }
        } else
        {
          // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the
          // polygon, so we may consider something smarter later.
          this.shape.computeBBox();
          this.shape.bbox.center(this.layerPos);
        }

        // Optional: Shift by a few pixels
        if (this.pixelOffset) {
          var toUnits = this.layer.getUnitsPerPixel();
          var shiftX = this.pixelOffset.x * toUnits;
          var shiftY = this.pixelOffset.y * toUnits;
          this.layerPos.x += shiftX;
          this.layerPos.y += shiftY;
        }

        _get(_getPrototypeOf(ShapeLabel.prototype), "update", this).call(this);
      } else {
        this.container.style.visibility = 'hidden';
      }
    } }, { key: "setShape", value: function setShape(

    shape) {
      this.shape = shape;
      this.update();
    } }]);return ShapeLabel;}(CanvasGizmo);


// Only works for shapes with getLength() function
var LengthLabel = /*#__PURE__*/function (_ShapeLabel) {_inherits(LengthLabel, _ShapeLabel);var _super4 = _createSuper(LengthLabel);

  // @param {Polyline}    polyline
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function LengthLabel(polyline, layer, unitHandler) {var _this4;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, LengthLabel);
    _this4 = _super4.call(this, polyline, layer, visible);
    _this4.unitHandler = unitHandler;return _this4;
  }_createClass(LengthLabel, [{ key: "update", value: function update()

    {
      // Get shape length (if shape supports it)
      var hasLength = this.shape && this.shape.getLength;
      var length = hasLength && this.shape.getLength(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined length.
      // We also hide it if length is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(length);

      if (this.valueValid) {
        var text = this.unitHandler.lengthToString(length);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(LengthLabel.prototype), "update", this).call(this);
    } }]);return LengthLabel;}(ShapeLabel);


// Only works for shapes with getArea() function
var AreaLabel = /*#__PURE__*/function (_ShapeLabel2) {_inherits(AreaLabel, _ShapeLabel2);var _super5 = _createSuper(AreaLabel);

  // @param {Polygon}     polygon
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function AreaLabel(polygon, layer, unitHandler) {var _this5;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);
    _this5 = _super5.call(this, polygon, layer, visible);
    _this5.unitHandler = unitHandler;
    _this5.update(); // update with proper unitHandler
    return _this5;}_createClass(AreaLabel, [{ key: "update", value: function update()

    {
      // Don't display until a unitHandler is set
      if (!this.unitHandler) {
        return;
      }

      // Handle PolyBase with self-intersections: Display an error indicator in this case.
      if (this.shape && this.shape.isSelfIntersecting && this.shape.isSelfIntersecting()) {

        // Show an error indicator instead
        this.setText(av.i18n.t('Invalid shape'));

        // Mark area label as error
        this.container.classList.add('error-indicator');

        // Mark sure error indicator is displayed
        this.valueValid = true;
        _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);

        return;
      } else {
        // Make sure that error indicator is toggled off
        this.container.classList.remove('error-indicator');
      }

      // Get shape area (if shape supports it)
      var hasArea = this.shape && this.shape.getArea;
      var area = hasArea && this.shape.getArea(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined area.
      // We also hide it if area is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(area);

      if (this.valueValid) {
        var text = this.unitHandler.areaToString(area);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);
    } }]);return AreaLabel;}(ShapeLabel);


// A html element for which position and rotation is aligned with an edge
var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(EdgeGizmo, _CanvasGizmo3);var _super6 = _createSuper(EdgeGizmo);

  // @param {EditLayer} layer
  // @param {bool} visible
  function EdgeGizmo(layer) {var _this6;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, EdgeGizmo);
    _this6 = _super6.call(this, layer, visible, className);

    _this6.posA = new THREE.Vector2();
    _this6.posB = new THREE.Vector2();

    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is
    // attached to an edge, this flag is set automatically.
    _this6.posValid = false;

    // Temp vectors used in update
    _this6.edgeDir = new THREE.Vector2();

    // Optional: Positions can be synchronized with an edge of a polygon or polyline
    _this6.poly = null;
    _this6.loopIndex = 0;
    _this6.edgeIndex = 0;

    // Use measure-length css style by default
    _this6.container.classList.add('edge-gizmo');

    // Optional: By default, an EdgeGizmo is always placed on a segment, i.e., the gizmo will follow a curve for arc segments.
    //           If this flag is true, the gizmo is always placed on the direct line connection.
    _this6.ignoreArcs = false;

    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:
    // We hide the gizmo if it exceeds x * edgeLength on screen.
    _this6.maxRelativeLength = undefined; // in [0,1]
    return _this6;}

  // If a poly is set, the gizmo is automatically synchronized with the edge.
  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.
  //
  //  @param {PolyBase} poly      - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.
  //  @param {number} edgeIndex   - edgeIndex in poly. If not valid, gizmo is hidden.
  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default
  _createClass(EdgeGizmo, [{ key: "attachToEdge", value: function attachToEdge(poly, edgeIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.poly = poly;
      this.edgeIndex = edgeIndex;
      this.loopIndex = loopIndex;
      this.update();
    } }, { key: "detachFromEdge", value: function detachFromEdge()

    {
      this.poly = null;
      this.edgeIndex = -1;
      this.loopIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "edgeValid", value: function edgeValid()

    {
      return this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex);
    } }, { key: "update", value: function update()

    {

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore
      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex)) {
        this.poly.getEdge(this.edgeIndex, this.posA, this.posB, this.loopIndex);
        this.posValid = true;
      } else {
        // This may happen if host polygon was modified and the edge does not exist anymore.
        this.posValid = false;
      }

      // If edge is invalid or too small on screen, just hide the gizmo
      var show = this._shouldBeShown();
      this.container.style.visibility = show ? 'visible' : 'hidden';
      if (!show) {
        return;
      }

      // Center gizmo at edge center
      if (this.ignoreArcs) {
        // Place on the line segment
        _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"].prototype.getPointOnEdge.call(this.poly, this.edgeIndex, 0.5, this.loopIndex, this.layerPos);
      } else {
        // Place on line segment or arc - depending on actual edge type
        this.poly.getPointOnEdge(this.edgeIndex, 0.5, this.loopIndex, this.layerPos);
      }

      // Set rotation angle
      this._updateRotation();

      _get(_getPrototypeOf(EdgeGizmo.prototype), "update", this).call(this);
    }

    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.
  }, { key: "_shouldBeShown", value: function _shouldBeShown() {

      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()
      if (!this.posValid) {
        return false;
      }

      // Show/Hide gizmo depending on zoom:
      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.
      if (this.maxRelativeLength) {
        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);
        var edgeLengthScreen = aScreen.distanceTo(bScreen);
        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;
        var _window = this.getWindow();
        var width = parseFloat(_window.getComputedStyle(this.container).width);
        return width < maxAllowedPixels;
      }
      return true;
    }

    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge
  }, { key: "_updateRotation", value: function _updateRotation() {

      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b
      // It's important to compute the angle in canvas space here. If we would compute it in layer space,
      // the angle orientation of the result may be inverted if the layerToCanvas() transform inverts orientation (e.g. by flipped y-axis)
      var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
      var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);

      var dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(aScreen, bScreen, this.edgeDir);
      var angle = Math.atan2(dir.y, dir.x);

      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.
      if (dir.x < 0) {
        angle += Math.PI;
      }

      // Convert angle to clockwise degrees and apply it to style
      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.
      this.angle = THREE.Math.radToDeg(angle);
    } }]);return EdgeGizmo;}(CanvasGizmo);


var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);var _super7 = _createSuper(EdgeMoveGizmo);

  function EdgeMoveGizmo(layer, name) {var _this7;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, EdgeMoveGizmo);
    _this7 = _super7.call(this, layer, visible, className);

    _this7.setName(name);
    _this7.container.classList.add('edge-move-gizmo');

    // We place EdgeMoveGizmos always directly on the straight lines. In this way, edge moving
    // will work in the same way - no matter whether a segment is an arc or not.
    _this7.ignoreArcs = true;

    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength
    _this7.maxRelativeLength = 0.3; // in [0,1]
    return _this7;}return EdgeMoveGizmo;}(EdgeGizmo);


// An EdgeGizmo to display text
var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);var _super8 = _createSuper(EdgeLabel);

  function EdgeLabel(layer) {var _this8;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);
    _this8 = _super8.call(this, layer, visible);
    initTextLabel(_assertThisInitialized(_this8));

    // Hide label if it would exceed the edge length
    _this8.maxRelativeLength = 1.0;return _this8;
  }return EdgeLabel;}(EdgeGizmo);


var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo4) {_inherits(VertexGizmo, _CanvasGizmo4);var _super9 = _createSuper(VertexGizmo);

  // @param {number}  x,y       - Position in layer coords
  // @param {string}  id        - id string used to tag shapes that represent this gizmo
  function VertexGizmo(layer, x, y, name, className) {var _this9;_classCallCheck(this, VertexGizmo);
    _this9 = _super9.call(this, layer, true, className);
    _this9.setPosition(x, y);
    _this9.setName(name);

    _this9.pos = new THREE.Vector2();

    // Optional: Positions can be synchronized with a vertex of a polygon or polyline
    _this9.poly = null;
    _this9.loopIndex = -1;
    _this9.vertexIndex = -1;

    _this9.container.classList.add('vertex-gizmo');return _this9;
  }

  // If a poly is set, the gizmo is automatically synchronized with the vertex.
  // As long as the poly is visible in the same layer, the vertex gizmo is automatically kept in sync with the vertex.
  //
  //  @param {PolyBase} poly      - polygon or polyline containing the vertex that we want to attach to. If null, positions can be set manually.
  //  @param {number} vertexIndex   - vertexIndex in poly. If not valid, gizmo is hidden.
  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default
  _createClass(VertexGizmo, [{ key: "attachToVertex", value: function attachToVertex(poly, vertexIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.poly = poly;
      this.vertexIndex = vertexIndex;
      this.loopIndex = loopIndex;
      this.update();
    } }, { key: "detachFromVertex", value: function detachFromVertex()

    {
      this.poly = null;
      this.vertexIndex = -1;
      this.loopIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "update", value: function update()

    {
      // Gizmo is not attached to a polygon. Just update according to the initial position.
      if (!this.poly) {
        _get(_getPrototypeOf(VertexGizmo.prototype), "update", this).call(this);
        return;
      }

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if vertex does not exist anymore
      if (this.poly.indexValid(this.vertexIndex, this.loopIndex)) {
        this.poly.getPoint(this.vertexIndex, this.loopIndex, this.pos);
        this.posValid = true;
      } else {
        // This may happen if host polygon was modified and the vertex does not exist anymore.
        this.posValid = false;
      }

      // If edge is invalid, just hide the gizmo
      var show = this.posValid;

      this.container.style.visibility = show ? 'visible' : 'hidden';

      if (!show) {
        return;
      }

      this.layerPos.set(this.pos.x, this.pos.y);

      _get(_getPrototypeOf(VertexGizmo.prototype), "update", this).call(this);
    } }]);return VertexGizmo;}(CanvasGizmo);


// A Label filter decides for which shapes we display a label
var LabelFilter = /*#__PURE__*/function () {

  function LabelFilter() {_classCallCheck(this, LabelFilter);}

  // If false, we don't need to acquire a label at all.
  _createClass(LabelFilter, [{ key: "accepts", value: function accepts(shape, text) {
      return true;
    } }]);return LabelFilter;}();
;

// Get shape width in screen-pixels
var getShapeWidth = function getShapeWidth(shape, layer) {
  // get shape size in screen-pixels
  shape.updateBBox();
  var bbox = shape.bbox;
  var shapeWidth = bbox.max.x - bbox.min.x;
  return shapeWidth * layer.getPixelsPerUnit() * shapeWidth;
};

// By default, we hide labels if text is empty or if the shape size on screen falls beyond a pixel threshold
var DefaultLabelFilter = /*#__PURE__*/function (_LabelFilter) {_inherits(DefaultLabelFilter, _LabelFilter);var _super10 = _createSuper(DefaultLabelFilter);

  // @param {number} minWidth - minimum pixel width a shape must have to receive a label
  function DefaultLabelFilter() {var _this10;var minWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;_classCallCheck(this, DefaultLabelFilter);
    _this10 = _super10.call(this);
    _this10.minWidth = minWidth;return _this10;
  }

  // Accept shape if text is not empty and its screen-width is big enough.
  _createClass(DefaultLabelFilter, [{ key: "accepts", value: function accepts(shape, text, layer) {
      var width = getShapeWidth(shape, layer);
      return Boolean(text) && width >= this.minWidth;
    } }]);return DefaultLabelFilter;}(LabelFilter);


// A LabelStyle rule allows to apply css style modifications on a label, e.g., depending on screen size
var LabelStyleRule = /*#__PURE__*/function () {

  function LabelStyleRule() {_classCallCheck(this, LabelStyleRule);}

  // Note: Labels may be reused for different shapes. So, make sure that the style parameters are
  //       not just modified for some subset of shapes, but reset for others.
  _createClass(LabelStyleRule, [{ key: "apply", value: function apply(label, shape, layer) {} }]);return LabelStyleRule;}();
;

// Fades out based on label size
var FadeOutStyleRule = /*#__PURE__*/function (_LabelStyleRule) {_inherits(FadeOutStyleRule, _LabelStyleRule);var _super11 = _createSuper(FadeOutStyleRule);

  // @param {number} rangeStart - shape width in screen-pixels at which the label starts to fade-in
  // @param {number} rangeEnd   - shape width in screen-pixels at which the label is fully opaque.
  function FadeOutStyleRule() {var _this11;var rangeStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;var rangeEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;_classCallCheck(this, FadeOutStyleRule);
    _this11 = _super11.call(this);
    _this11.rangeStart = rangeStart;
    _this11.rangeEnd = rangeEnd;return _this11;
  }_createClass(FadeOutStyleRule, [{ key: "apply", value: function apply(

    label, shape, layer) {

      // compute opacity from shape screen-width
      var width = getShapeWidth(shape, layer);
      var t = (width - this.rangeStart) / (this.rangeEnd - this.rangeStart);
      var opacity = THREE.Math.clamp(t, 0, 1);

      label.container.style.opacity = opacity;
    } }]);return FadeOutStyleRule;}(LabelStyleRule);
;

// A ShapeLabelRule maintains a set of labels that is automatically synced with the shapes in a layer.
// It implements the CanvasGizmoBase to update the set of maintained labels.
var ShapeLabelRule = /*#__PURE__*/function () {

  // @param {EditLayer}               layer            - Labels are shown (and synchronized) with the content of this layer.
  // @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  // @param {LabelFilter}             [filter]         - Defines which labels to show. See DefaultLabelFilter for default behavior.
  // @param {LabelStyleRule}          [styleRule]      - Defines how label style is modified dynamically. (By default, we fade-out based on label size)
  function ShapeLabelRule(layer, shapeToLabelText) {var labelFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DefaultLabelFilter();var styleRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FadeOutStyleRule();_classCallCheck(this, ShapeLabelRule);
    this.layer = layer;
    this.shapeToLabelText = shapeToLabelText;

    // All labels that we created.
    this.labels = {}; // {shapeId: ShapeLabel}

    this.layer.addCanvasGizmo(this);
    this.visible = true;
    this.layer.update();

    this.filter = labelFilter;
    this.styleRule = styleRule;
  }

  // Replace the rule to define label texts.
  //   @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  _createClass(ShapeLabelRule, [{ key: "setTextRule", value: function setTextRule(shapeToLabelText) {
      this.shapeToLabelText = shapeToLabelText;
      this.update();
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible === this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add 'this' first and all maintained labels behind. In this way, this gizmo is updated first to
        //       configure all labels - followed by the update calls for all active labels in use.
        this.layer.addCanvasGizmo(this);
        this.update();
      } else {
        this.clearLabels();
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "dtor", value: function dtor()

    {
      // Make sure that we don't leave any of our labels in the layer
      this.setVisible(false);
    } }, { key: "removeLabelFromShape", value: function removeLabelFromShape(

    shape) {
      if (this.labels[shape.id]) {
        this.clearLabel(this.labels[shape.id]);
        delete this.labels[shape.id];
      }
    } }, { key: "clearLabel", value: function clearLabel(

    label) {
      label.setShape(null);
      label.setVisible(false);
    }

    // Hide + release all current labels, so that we can re-acquire them based on latest Layer state.
  }, { key: "clearLabels", value: function clearLabels() {var _this12 = this;
      Object.values(this.labels).forEach(function (label) {
        _this12.clearLabel(label);
      });

      this.labels = {};
    }

    // Create new label or get it from cache
  }, { key: "acquireLabel", value: function acquireLabel(shape) {
      var label = this.labels[shape.id];

      if (label) {
        return label;
      }

      label = new ShapeLabel(null, this.layer);
      label.setShape(shape);

      this.labels[shape.id] = label;

      return label;
    } }, { key: "update", value: function update()

    {var _this13 = this;
      var shapes = this.layer.shapes;
      for (var i = 0; i < shapes.length; i++) {

        var shape = shapes[i];

        // Get label text
        var text = this.shapeToLabelText(shape);

        // Check if we want to display a label for this shape
        if (this.filter && !this.filter.accepts(shape, text, this.layer)) {
          this.removeLabelFromShape(shape);
          continue;
        }

        // Configure label
        var label = this.acquireLabel(shape);
        label.setText(text);
        label.setVisible(true);

        // Apply optional custom style rule
        this.styleRule && this.styleRule.apply(label, shape, this.layer);
      }

      // Clear labels that their shapes were removed.
      // Needed when autoUpdate is disabled.
      Object.values(this.labels).forEach(function (label) {
        // Shape no longer exists
        if (shapes.indexOf(label.shape) === -1) {
          _this13.removeLabelFromShape(label.shape);
        }
      });
    } }]);return ShapeLabelRule;}();


// A ShapeToolTip is a label that shows up when hovering a shape.
// By default, it appears a few pixels above the top-right corner of a shape's bbox.
var ShapeToolTip = /*#__PURE__*/function (_CanvasGizmoBase2) {_inherits(ShapeToolTip, _CanvasGizmoBase2);var _super12 = _createSuper(ShapeToolTip);

  // @param {EditLayer}               layer - Tooltip will appear for all shapes in the given layer.
  // @param {function(shape)=>string} getText - Function to define the text for a given shape
  function ShapeToolTip(layer) {var _this14;var getText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;_classCallCheck(this, ShapeToolTip);
    _this14 = _super12.call(this);

    _this14.layer = layer;
    _this14.textCb = getText;
    _this14.viewer = _this14.layer.viewer;

    // track latest mouse position in layer coords (init on first mouse move)
    _this14.mousePos = null;

    // distance between tooltip and shape bbox
    _this14.distanceToBox = 5; // in pixels

    // Create tooltip div
    _this14.container = _this14.getDocument().createElement('div');
    _this14.container.classList.add('adsk-control-tooltip');

    // Add div to viewer canvas container and layer
    _this14.viewer.canvasWrap.appendChild(_this14.container);

    // Update if layer changed
    _this14.layer.addCanvasGizmo(_assertThisInitialized(_this14));

    // Update if mouse moved
    _this14.onMouseMoved = _this14.onMouseMoved.bind(_assertThisInitialized(_this14));
    _this14.viewer.canvasWrap.addEventListener('mousemove', _this14.onMouseMoved);

    _this14.layer.updateCanvasGizmos();return _this14;
  }_createClass(ShapeToolTip, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeCanvasGizmo();
      this.viewer.canvasWrap.removeEventListener('mousemove', this.onMouseMoved);
      this.viewer.canvasWrap.removeChild(this.container);
    }

    // Set callback that defines which text to display for each shape. Returning '' or null will hide the tooltip.
    // @param {function(shape)=>string} getText - Function to define the text for a given shape
  }, { key: "setTextCallback", value: function setTextCallback(getText) {
      this.textCb = getText;
      this.update();
    } }, { key: "onMouseMoved", value: function onMouseMoved(

    event) {

      // Add canvas coords to event
      this.viewer.toolController.__clientToCanvasCoords(event);

      // Track mouse position
      this.mousePos = this.layer.canvasToLayer(event.canvasX, event.canvasY);

      this.update();
    } }, { key: "update", value: function update()

    {

      // If a textCb is set, check shape under mouse
      var shape = this.mousePos && this.textCb && this.layer.hitTest(this.mousePos.x, this.mousePos.y);

      // Choose label text
      var text = shape && this.textCb(shape);

      // Apply text
      this.container.textContent = text || '';

      // Stop here if nothing to display
      if (!text) {
        this.container.style.visibility = 'hidden';
        return;
      }

      // Show label
      this.container.style.visibility = 'visible';

      // Get top-right corner of bbox
      shape.updateBBox(); // Make sure bbox is up-to-date
      var corner = shape.bbox.max;

      // Get anchor in canvas coords
      var anchor = this.layer.layerToCanvas(corner.x, corner.y);

      // Add some pixels y-offset
      anchor.y -= this.distanceToBox;

      // get canvas size
      var width = this.viewer.canvas.width;
      var height = this.viewer.canvas.height;

      // Update tooltip position
      this.container.style.right = width - anchor.x + 'px';
      this.container.style.bottom = height - anchor.y + 'px';

      this.container.style.left = 'auto';
      this.container.style.top = 'auto';
    } }]);return ShapeToolTip;}(CanvasGizmoBase);


// Purpose:
// There is no efficient and simple way to ask a div whether it is under mouse or not.
// The most reliable way is document.elementFromPoint(), but it is rather expensive.
// Therefore, we don't want to do it for each and every gizmo. Instead, GizmoManager tracks
// which object is under mouse and is generally used to check which gizmo is at mouse position.
var GizmoManager = /*#__PURE__*/function () {

  function GizmoManager() {_classCallCheck(this, GizmoManager);
    // div element at mouse position
    this.elemUnderMouse = null;
  }

  // Must be triggered on mouse events.
  // @param {MouseEvent}
  _createClass(GizmoManager, [{ key: "update", value: function update(e) {
      this.elemUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
    }

    // @param {CanvasGizmo}
  }, { key: "isUnderMouse", value: function isUnderMouse(gizmo) {
      return gizmo.container && gizmo.container === this.elemUnderMouse;
    }

    // Returns the index of the gizmo that matches with the element under mouse.
    // Result is -1 if none of the gizmos matches.
    //  @param {CanvasGizmo[]} gizmo
  }, { key: "getGizmoIndex", value: function getGizmoIndex(gizmos) {var _this15 = this;
      return gizmos.findIndex(function (g) {return _this15.isUnderMouse(g);});
    } }]);return GizmoManager;}();


// Display dashed lines to connect start/end of arc segments. Used by PolygonEditTool.
// It updates itself automatically whenever the shape changed.
var ArcEdgeGizmo = /*#__PURE__*/function () {
  function ArcEdgeGizmo(layer, gizmoLayer) {_classCallCheck(this, ArcEdgeGizmo);

    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // One Line shape per arc segment in the host shape
    this.shapes = [];

    this.visibility = false;
    this.setVisible(true);

    // Optional: Display one edge in another color
    this.highlightColor = undefined;
    this.highlightIndex = -1; // must be a valid edge index in this.poly
    this.highlightLoopIndex = -1; // must be a valid loop index in this.poly
  }_createClass(ArcEdgeGizmo, [{ key: "dtor", value: function dtor()

    {
      // Just make sure it is invisible, so that shapes are cleared and
      // gizmo is removed from GizmoLayer.
      this.setVisible(false);
    }

    // Set the shape for which we display lines
  }, { key: "setPoly", value: function setPoly(poly) {
      if (poly !== this.poly) {
        this.poly = poly;
        this.clearEdgeHighlighting();
        this.update();
      }
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      // Do nothing if there's no change
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;

      // add/remove from layer
      if (visible) {
        this.layer.addCanvasGizmo(this);
      } else {
        this.layer.removeCanvasGizmo(this);
      }
      this.update();
    } }, { key: "clearShapes", value: function clearShapes()

    {var _this16 = this;
      this.shapes.forEach(function (s) {return _this16.gizmoLayer.removeShape(s);});
      this.shapes = [];
    } }, { key: "edgeShapeName", value: function edgeShapeName(

    index, loopIndex) {
      return 'ArcEdgeGizmo_' + loopIndex + '_' + index;
    }

    // Create a line shape that connects start/end vertex of segment i in poly.
  }, { key: "_addEdge", value: function _addEdge(index, loopIndex) {

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(index, a, b, loopIndex);

      // Create a line from it
      var line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]([a, b]);
      line.name = this.edgeShapeName(index, loopIndex);

      // Configure line style
      line.style.lineStyle = 11; // short dashes
      line.style.lineWidth = this.poly.style.lineWidth / 2.0;
      line.style.lineAlpha = this.poly.style.lineAlha / 2.0;

      // Apply optional edge highlighting color
      if (index == this.highlightIndex && this.highlightColor) {
        line.style.lineColor = this.highlightColor;
      }

      this.gizmoLayer.addShape(line);
      this.shapes.push(line);
    } }, { key: "clearEdgeHighlighting", value: function clearEdgeHighlighting()

    {

      if (this.highlightIndex === -1) {
        return;
      }

      this.highlightColor = null;
      this.highlightIndex = -1;
      this.highlight;
      this.update();
    }

    // Assign different
  }, { key: "setEdgeHighlighted", value: function setEdgeHighlighted(index, loopIndex, color) {

      // Only do work if needed
      if (index === this.highlightIndex && color === this.highlightColor) {
        return;
      }

      this.highlightColor = color;
      this.highlightIndex = index;
      this.highlightLoopIndex = loopIndex;
      this.update();
    }

    // Updates the edges for the given Path shape
  }, { key: "update", value: function update() {

      this.clearShapes();

      // Stop if there are no arcs
      if (!this.visible || !this.poly || !this.poly.isPath()) {
        return;
      }

      // For each loop...
      for (var l = 0; l < this.poly.loopCount; l++) {

        // For each edge...
        var edgeCount = this.poly.getEdgeCount(l);
        for (var i = 0; i < edgeCount; i++) {

          // Add line if it is an arc
          var isArc = this.poly.isArc(i, l);
          if (isArc) {
            this._addEdge(i, l);
          }
        }
      }
    } }]);return ArcEdgeGizmo;}();

/***/ }),

/***/ "./extensions/Edit2D/Clipboard.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Clipboard.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Clipboard; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Clipboard = /*#__PURE__*/function () {
  function Clipboard() {_classCallCheck(this, Clipboard);
    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.shapes = [];
  }

  /**
     * Clear the contents of the clipboard
     */_createClass(Clipboard, [{ key: "clear", value: function clear()
    {
      this.shapes = [];
      this._dispatchContentChangedEvent(this.shapes);
    }

    /**
       * Check if the clipboard contains shapes
       *
       * @returns {boolean} True if there are shapes on the clipboard, false otherwise
       */ }, { key: "hasShapes", value: function hasShapes()
    {
      return this.shapes.length !== 0;
    }

    /**
       * Post shapes to the clipboard.
       *
       * The shapes will be cloned and then posted to the clipboard.
       *
       * @param {Shape[]} shapes The shapes to post to the clipboard
       */ }, { key: "postShapes", value: function postShapes(
    shapes) {
      this.shapes = shapes.map(function (s) {return s.clone();});
      this._dispatchContentChangedEvent(shapes);
    }

    /**
       * Clone the shapes on to the clipboard.
       *
       * @returns {Shape[]} Clones of shapes on the clipboard. May be empty if no shapes are on the clipboard.
       */ }, { key: "cloneShapes", value: function cloneShapes()
    {
      return this.shapes.map(function (s) {return s.clone();});
    } }, { key: "_dispatchContentChangedEvent", value: function _dispatchContentChangedEvent(

    shapes) {
      this.dispatchEvent({
        type: Clipboard.CONTENT_CHANGED,
        shapes: shapes });

    } }]);return Clipboard;}();


Clipboard.CONTENT_CHANGED = "CONTENT_CHANGED";

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.css":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Edit2D.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Edit2D.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DExtension; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Clipboard.js */ "./extensions/Edit2D/Clipboard.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Trackings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Trackings.js */ "./extensions/Edit2D/Trackings.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Edit2DSnapper.js */ "./extensions/Edit2D/Edit2DSnapper.js");
/* harmony import */ var _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Edit2DContextMenu.js */ "./extensions/Edit2D/Edit2DContextMenu.js");
/* harmony import */ var _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./UnitHandler.js */ "./extensions/Edit2D/UnitHandler.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
/* harmony import */ var _ScreenOverlay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ScreenOverlay.js */ "./extensions/Edit2D/ScreenOverlay.js");
/* harmony import */ var _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AngleGizmo.js */ "./extensions/Edit2D/AngleGizmo.js");
/* harmony import */ var _AngleGizmo3d_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./AngleGizmo3d.js */ "./extensions/Edit2D/AngleGizmo3d.js");
/* harmony import */ var _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tools/MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tools/PolygonTool.js */ "./extensions/Edit2D/tools/PolygonTool.js");
/* harmony import */ var _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./tools/PolygonEditTool.js */ "./extensions/Edit2D/tools/PolygonEditTool.js");
/* harmony import */ var _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./tools/InsertSymbolTool.js */ "./extensions/Edit2D/tools/InsertSymbolTool.js");
/* harmony import */ var _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./tools/RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./tools/UndoTool.js */ "./extensions/Edit2D/tools/UndoTool.js");
/* harmony import */ var _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./tools/CopyTool.js */ "./extensions/Edit2D/tools/CopyTool.js");
/* harmony import */ var _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./tools/LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
/* harmony import */ var _tools_VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./tools/VertexMoveTool.js */ "./extensions/Edit2D/tools/VertexMoveTool.js");
/* harmony import */ var _tools_EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./tools/EdgeMoveTool.js */ "./extensions/Edit2D/tools/EdgeMoveTool.js");
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
/* harmony import */ var _locales__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./locales */ "./extensions/Edit2D/locales.js");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./Edit2D.css */ "./extensions/Edit2D/Edit2D.css");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(_Edit2D_css__WEBPACK_IMPORTED_MODULE_33__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}



































 // IMPORTANT!!

var myExtensionName = 'Autodesk.Edit2D';
var namespace = AutodeskNamespace('Autodesk.Edit2D');
var av = Autodesk.Viewing;

var OverlayName = 'Edit2D';var

ToolSet =
function ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);
  this.name = name;
  this.autoReactivate = autoReactivate;
  this.context = null;
  this.tools = {};
};


/** 
    * Edit2D extension provides API for implementing 2D vector editing. 
    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only
    * to provide a basis for other extensions and client applications.
    * 
    * The extension id is: `Autodesk.Edit2D`
    * 
    * @example
    *   viewer.loadExtension('Autodesk.Edit2D')
    *
    * @memberof Autodesk.Viewing.Extensions
    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
    * @alias Autodesk.Viewing.Extensions.Edit2DExtension
    * @class
    */var
Edit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);var _super = _createSuper(Edit2DExtension);
  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);
    _this = _super.call(this, viewer, options);

    _this.extendLocalization(_locales__WEBPACK_IMPORTED_MODULE_32__["locales"]);

    _this.undoStack = new _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__["default"]();

    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)
    _this._registeredTools = new Map();
    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_this));
    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_this));
    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(Edit2DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:



                // The overlay "Edit2D" contains subscenes for each edit layer.
                this.viewer.impl.createOverlayScene(OverlayName);

                // We require Snapping and Autodesk.CompGeom (already a dependency of Autodesk.Snapping)
                _context.next = 3;return this.viewer.loadExtension('Autodesk.Snapping');case 3:

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools
                this.undoTool = new _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__["default"](this.undoStack);
                this.viewer.toolController.registerTool(this.undoTool);
                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {var _iterator = _createForOfIteratorHelper(
      this._registeredTools.keys()),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var toolSetName = _step.value;
          this.unregisterTools(toolSetName);
        }} catch (err) {_iterator.e(err);} finally {_iterator.f();}

      this.viewer.toolController.deregisterTool(this.undoTool);
      this.undoTool = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

      return true;
    } }, { key: "_onModelAdded", value: function _onModelAdded()

    {var _this2 = this;
      if (this.viewer.getVisibleModels().length !== 1) {
        // Do the reactivation only when the first model got loaded.
        return;
      }var _iterator2 = _createForOfIteratorHelper(

      this._registeredTools.values()),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var toolSet = _step2.value;
          if (toolSet.autoReactivate) {var _toolSet$toolsToReact;
            (_toolSet$toolsToReact = toolSet.toolsToReactivate) === null || _toolSet$toolsToReact === void 0 ? void 0 : _toolSet$toolsToReact.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});
          }
        }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}
    } }, { key: "_onModelRemoved", value: function _onModelRemoved()

    {
      if (this.viewer.getVisibleModels().length !== 0) {
        // Only deactivate tools when no model is active anymore.
        return;
      }

      var controller = this.viewer.toolController;var _iterator3 = _createForOfIteratorHelper(
      this._registeredTools.values()),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {var toolSet = _step3.value;
          if (toolSet.autoReactivate) {
            // The next statement gets all possible names of all tools of a toolSet,
            // flatten the resulting array
            // and returns a list tool names that are active.
            toolSet.toolsToReactivate = Object.values(toolSet.tools).
            map(function (t) {return t.getNames();}).
            reduce(function (res, names) {return res.concat(names);}, []) // flatten
            .filter(function (name) {return controller.isToolActivated(name);});

            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});
          }
        }} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}
    }

    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.
  }, { key: "_onSelectionChanged", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iterator4 = _createForOfIteratorHelper(
      this._registeredTools.values()),_step4;try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {var toolSet = _step4.value;
          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {
            toolSet.context.selection.clear();
          }
        }} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}
    } }, { key: "registerDefaultTools", value: function registerDefaultTools()

    {
      this.defaultContext = this.registerTools('default');
    }

    // Get default tools. registerDefaultTools() must be called first, otherwise it returns null.
  }, { key: "getToolSet",




    // returns a given toolset, or null if none with the given name have been registered.
    value: function getToolSet(toolSetName) {
      return this._registeredTools.get(toolSetName);
    } }, { key: "registerTools", value: function registerTools(

    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toolSet = this._registeredTools.get(toolSetName);
      if (toolSet) {
        console.warn("Edit 2D tools are already registered for tool set '".concat(toolSetName, "'"));
        return toolSet.context;
      }

      toolSet = new ToolSet(toolSetName, autoReactivate);
      this._registeredTools.set(toolSetName, toolSet);

      // create context
      var context = toolSet.context = new Edit2DContext(this, toolSetName, options);
      context.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // create tools
      toolSet.tools.polygonTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"].Mode.Polygon);
      toolSet.tools.polylineTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"].Mode.Polyline);
      toolSet.tools.moveTool = new _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__["default"](context);
      toolSet.tools.polygonEditTool = new _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__["default"](context);
      toolSet.tools.insertSymbolTool = new _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__["default"](context);
      toolSet.tools.copyTool = new _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__["default"](context);

      // Enable all new shapes to be Paths, so that you can turn line segments into arc segments
      var enableArcs = Boolean(this.options.enableArcs);
      toolSet.tools.polygonTool.setArcsEnabled(enableArcs);
      toolSet.tools.polylineTool.setArcsEnabled(enableArcs);

      // Allow converting segments to ellipse arcs if wanted
      if (this.options.enableEllipseArcs) {
        toolSet.tools.polygonEditTool.enableEllipseArcs = true;
      }

      // register them
      var controller = this.viewer.toolController;
      controller.registerTool(toolSet.tools.polygonTool);
      controller.registerTool(toolSet.tools.polylineTool);
      controller.registerTool(toolSet.tools.moveTool);
      controller.registerTool(toolSet.tools.polygonEditTool);
      controller.registerTool(toolSet.tools.insertSymbolTool);
      controller.registerTool(toolSet.tools.copyTool);

      // activate CopyTool immediately, because they run parallel to other tools
      controller.activateTool(toolSet.tools.copyTool.getName());

      // create and register context menu
      toolSet.contextMenu = new _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.viewer, toolSet);
      toolSet.contextMenu.register();

      return context;
    } }, { key: "unregisterDefaultTools", value: function unregisterDefaultTools()

    {
      this.unregisterTools('default');
      this.defaultContext = null;
    } }, { key: "unregisterTools", value: function unregisterTools(

    toolSetName) {
      var toolSet = this._registeredTools.get(toolSetName);
      if (!toolSet) {
        return;
      }

      var controller = this.viewer.toolController;
      controller.deregisterTool(toolSet.tools.polygonTool);
      controller.deregisterTool(toolSet.tools.polylineTool);
      controller.deregisterTool(toolSet.tools.moveTool);
      controller.deregisterTool(toolSet.tools.polygonEditTool);
      controller.deregisterTool(toolSet.tools.insertSymbolTool);
      controller.deregisterTool(toolSet.tools.copyTool);

      toolSet.context.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // Unregister and delete context menu
      toolSet.contextMenu.unregister();
      toolSet.contextMenu = null;

      this._registeredTools.delete(toolSetName);
    } }, { key: "createLayer", value: function createLayer(

    options) {

      var model = this.viewer.model;
      if (!model) {
        console.error("A 2D model is needed to adjust viewport");
      }

      // create new overlay scene to show
      var layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, options);

      if (!options.useSceneAfter) {
        // add layer scene to our overlay scene
        this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);
      }

      return layer;
    } }, { key: "defaultTools", get: function get() {var toolSet = this._registeredTools.get('default');return toolSet && toolSet.tools;} }]);return Edit2DExtension;}(av.Extension);


// Common set of objects usually needed by tools
var Edit2DContext = /*#__PURE__*/function () {

  // @param {Edit2D} ext - Edit2d extension
  function Edit2DContext(ext, toolSetName) {var _this3 = this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, Edit2DContext);
    this.toolSetName = toolSetName;
    this.ext = ext;
    this.viewer = ext.viewer;
    this.layer = ext.createLayer(options);
    this.gizmoLayer = ext.createLayer(options);
    this.undoStack = ext.undoStack;
    this.clipboard = new _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.selection = new _Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.layer, this.undoStack);
    this.snapper = new _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.viewer, this.layer, this.gizmoLayer);
    this.unitHandler = new _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["DefaultUnitHandler"](this.viewer);

    // track mouse in Edit2D
    this.mouseTracker = ext.options.mouseTracker;

    // Update all visible labels if display units are changed
    var onUnitChange = function onUnitChange() {
      _this3.layer.updateCanvasGizmos();
      _this3.gizmoLayer.updateCanvasGizmos();
    };
    this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, onUnitChange);
  }_createClass(Edit2DContext, [{ key: "setAllGizmosEnabled", value: function setAllGizmosEnabled(

    enabled) {
      var toolSet = this.ext.getToolSet(this.toolSetName);
      toolSet.tools.polygonEditTool.setAllGizmosEnabled(enabled);
    }

    // Set matrix that is applied to all displayed geometry
  }, { key: "setMatrix", value: function setMatrix(matrix) {
      this.layer.setMatrix(matrix);
      this.gizmoLayer.setMatrix(matrix);
      this.layer.update();
      this.gizmoLayer.update();
    }

    // Clears current layer in a way that undo-stack keeps consistent.
    // 
    //  @param {boolean} enableUndo - If false, the undoStack is cleared.
  }, { key: "clearLayer", value: function clearLayer() {var enableUndo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (enableUndo) {
        var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].RemoveShapes(this.layer, this.layer.shapes);
        this.undoStack.run(action);
      } else {
        this.layer.clear();
        this.undoStack.clear();
      }
    } }, { key: "addShape", value: function addShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].AddShape(this.layer, shape);
      this.undoStack.run(action);
    } }, { key: "removeShape", value: function removeShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].RemoveShape(this.layer, shape);
      this.undoStack.run(action);
    } }]);return Edit2DContext;}();


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);

namespace.Shape = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Shape"];
namespace.Polygon = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polygon"];
namespace.Polyline = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polyline"];
namespace.PolyBase = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"];
namespace.Path = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"];
namespace.PolygonPath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolygonPath"];
namespace.PolylinePath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolylinePath"];
namespace.Circle = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Circle"];
namespace.Style = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Style"];
namespace.EllipseArcParams = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EllipseArcParams"];
namespace.PolygonTool = _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"];
namespace.Selection = _Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"];
namespace.MoveTool = _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__["default"];
namespace.PolygonEditTool = _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__["default"];
namespace.VertexMoveTool = _tools_VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_27__["default"];
namespace.EdgeMoveTool = _tools_EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_28__["default"];
namespace.InsertSymbolTool = _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__["default"];
namespace.Math2D = _Math2D_js__WEBPACK_IMPORTED_MODULE_5__["Math2D"];
namespace.VertexGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["VertexGizmo"];
namespace.RectangleTool = _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_23__["default"];
namespace.LineTool = _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_26__["default"];
namespace.CopyTool = _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__["default"];
namespace.Actions = _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"];
namespace.UndoStack = _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__["default"];
namespace.Clipboard = _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.UndoTool = _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__["default"];
namespace.Edit2DContext = Edit2DContext;
namespace.CanvasGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["CanvasGizmo"];
namespace.CanvasGizmoBase = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["CanvasGizmoBase"];
namespace.ShapeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeLabel"];
namespace.AlignX = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AlignX"];
namespace.AlignY = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AlignY"];
namespace.AreaLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AreaLabel"];
namespace.EdgeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["EdgeLabel"];
namespace.UnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["UnitHandler"];
namespace.SimpleUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["SimpleUnitHandler"];
namespace.DefaultUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["DefaultUnitHandler"];
namespace.ShapeLabelRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeLabelRule"];
namespace.ShapeWrapper = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["ShapeWrapper"];
namespace.SegmentTree = _SegmentTree_js__WEBPACK_IMPORTED_MODULE_15__["default"];
namespace.TangentGizmo = _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_14__["default"];
namespace.MeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__["MeasureTransform"];
namespace.DefaultMeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__["DefaultMeasureTransform"];
namespace.ShapeToolTip = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeToolTip"];
namespace.Svg = _Svg_js__WEBPACK_IMPORTED_MODULE_6__["Svg"];
namespace.SolidDefConvert = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_30__["SolidDefConvert"];
namespace.BooleanOps = _BooleanOps_js__WEBPACK_IMPORTED_MODULE_31__["BooleanOps"];
namespace.LoopType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["LoopType"];
namespace.EdgeType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EdgeType"];
namespace.FadeOutStyleRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["FadeOutStyleRule"];
namespace.EditLayer = _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"];
namespace.ScreenOverlay = _ScreenOverlay_js__WEBPACK_IMPORTED_MODULE_16__["default"];
namespace.Arrow = _Arrow_js__WEBPACK_IMPORTED_MODULE_3__["default"];
namespace.AngleGizmo = _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_17__["default"];
namespace.AngleGizmo3d = _AngleGizmo3d_js__WEBPACK_IMPORTED_MODULE_18__["default"];
namespace.TextLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["TextLabel"];
namespace.Trackings = _Trackings_js__WEBPACK_IMPORTED_MODULE_8__["Trackings"];

/***/ }),

/***/ "./extensions/Edit2D/Edit2DContextMenu.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/Edit2DContextMenu.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DContextMenu; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;var

Edit2DContextMenu = /*#__PURE__*/function () {

  // @param {ToolSet} toolSet (see Edit2D.js)
  function Edit2DContextMenu(viewer, toolSet) {_classCallCheck(this, Edit2DContextMenu);

    this.viewer = viewer;
    this.toolSet = toolSet;

    // Define ContextMenu callback
    this.callbackId = "Edit2D_".concat(toolSet.name);
    this.callback = this.onContextMenu.bind(this);
  }_createClass(Edit2DContextMenu, [{ key: "register", value: function register()

    {
      this.viewer.registerContextMenuCallback(this.callbackId, this.callback);
    } }, { key: "unregister", value: function unregister()

    {
      this.viewer.unregisterContextMenuCallback(this.callbackId);
    }

    //  @param {CanvasGizmo[][]} Array of CanvasGizmo arrays per loop
    // Returns {PolyIndex} - Returns the PolyIndex of the vertex gizmo under mouse
  }, { key: "findGizmoUnderMouse", value: function findGizmoUnderMouse(gizmos, clientX, clientY) {
      // Check element under mouse
      var elem = document.elementFromPoint(clientX, clientY);

      // Check if it matches with any vertex gizmo
      for (var l = 0; l < gizmos.length; l++) {
        var index = gizmos[l].findIndex(function (g) {return g.container === elem;});
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    }

    // Note that editTool.getVertexIndex() does not work if a context menu is already open.
    // Reason is that the evens are all consumed by an invisible full-screen-div, so that a
    // gizmos cannot detect anymore if the mouse is on it.
  }, { key: "vertexGizmoUnderMouse", value: function vertexGizmoUnderMouse(clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.vertexMoveTool.vertexGizmos;
      return this.findGizmoUnderMouse(gizmos, clientX, clientY);
    } }, { key: "edgeGizmoUnderMouse", value: function edgeGizmoUnderMouse(

    clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.edgeMoveTool.edgeGizmos;
      var polyIndex = this.findGizmoUnderMouse([gizmos], clientX, clientY);
      return polyIndex ? polyIndex.vertex : -1;
    }

    // Define callback to modify the viewer context menu
    //  @param {Object[]} menuItems - items to be modified
    //  @param {Object}   status    - ObjectContextMenu.js
  }, { key: "onContextMenu", value: function onContextMenu(menu, status) {var _this = this;

      var editTool = this.toolSet.tools.polygonEditTool;
      var layer = this.toolSet.context.layer;
      var event = status.event;
      var selection = this.toolSet.context.selection;
      var undoStack = this.toolSet.context.undoStack;

      // get mouse pos in layer coords
      var mousePos = layer.canvasToLayer(status.canvasX, status.canvasY);

      // Check if mouse is close to an edge of the current edit polygon
      var edgePolyIndex = editTool.findEdgeUnderMouse(mousePos);

      // Check shape under mouse. If we are close to a current edge of the editPoly, 
      // consider it as under mouse as well.
      var shapeUnderMouse = edgePolyIndex ? editTool.poly : layer.hitTest(mousePos.x, mousePos.y);

      // When right-clicking outside current selection, we select the shape under mouse or clear selection of there is none.
      // This avoids ambiguities about which shape we are modifying (selected vs. under mouse)
      var selectedShapes = selection.getSelectedShapes();
      var mouseOnSelection = selectedShapes.includes(shapeUnderMouse);
      if (!mouseOnSelection && editTool.active) {
        selection.selectOnly(shapeUnderMouse);
      }

      // Multi-select operations are allowed when right-clicking on one of the selected shapes
      var multiSelect = mouseOnSelection && selectedShapes.length > 1;
      if (multiSelect) {

        // Remove shapes
        menu.push({
          title: 'Remove Shapes',
          target: function target() {
            undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShapes(layer, selectedShapes));
          } });


        // Unify shapes
        if (editTool.enableUnify) {

          // To allow unify, all shapes must be closed and PolyBase instances
          var canBeUnified = !selectedShapes.find(function (s) {return !s instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] || !s.isClosed;});
          if (canBeUnified) {
            menu.push({
              title: 'Unify Shapes',
              target: function target() {
                // get index of the shape under mouse within selected shapes
                var shapeIndex = selectedShapes.indexOf(shapeUnderMouse);
                undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].UnifyShapes(layer, selectedShapes, shapeIndex));
              } });

          }
        }
      }

      // Check if a shape is selected for editing
      var shapeSelected = Boolean(editTool.poly);
      if (!shapeSelected) {
        // If not, keep original viewer context menu
        return;
      }

      // Check if we hit a vertex gizmo. Note that a VertexGizmo exceeds the actual shape.
      var vertex = this.vertexGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnVertexGizmo = Boolean(vertex);

      // Check if we hit an edge gizmo.
      var edgeGizmoIndex = this.edgeGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnEdgeGizmo = edgeGizmoIndex !== -1;

      // Check if "insert vertex" is possible at the current position        
      var edgeIndex = edgePolyIndex && edgePolyIndex.vertex;
      var newVertexPos = edgePolyIndex && editTool.getNewVertexPosition(mousePos, edgePolyIndex);
      var mouseCloseToEdge = Boolean(newVertexPos);

      // If the mouse is neither on a shape nor on a vertex gizmo, exist here.
      // Note that the gizmos exceed the actual shape by a few pixels, so we may hit one without hitting the shape.        
      if (!shapeUnderMouse && !mouseOnVertexGizmo && !mouseCloseToEdge) {
        // When clicking somewhere else, leave default context menu
        return;
      }

      // If a polygon is selected for editing, we hijack the menu completely and remove the 
      // viewer default stuff (Show all layers etc.) - assuming that the user is focusing on 2D editing.
      menu.length = 0;

      if (editTool.enableCutout) {
        // add cutout menu item
        var selected = editTool.poly;
        var isClosed = selected instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && selected.isClosed;
        if (isClosed) {
          menu.push({
            title: 'Apply as Cutout',
            target: function target() {
              var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ApplyCutOut(layer, selected);
              _this.toolSet.context.undoStack.run(action);
            } });

        }
      }

      // If so, add RemoveVertex item
      if (mouseOnVertexGizmo) {
        menu.push({
          title: 'Remove Vertex',
          target: function target() {
            editTool.removePoint(vertex);
          } });

      } else if (edgePolyIndex && newVertexPos) {
        // Add "Insert Vertex" menu item
        menu.push({
          title: 'Insert Vertex',
          target: function target() {
            // insert new vertex after edge starting point
            var newVertex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: edgePolyIndex.vertex + 1, loop: edgePolyIndex.loop });
            editTool.insertPoint(newVertex, newVertexPos);
          } });

      }

      // Consider mouse as "onEdge" if it is hovering the edge gizmo or close to the edge itself.
      var onEdge = mouseOnEdgeGizmo || mouseCloseToEdge;

      // Check if Create/Remove arc is possible
      var enableArc = editTool.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];

      // If mouse is close to an edge or on an edge gizmo, add edge operations
      if (!mouseOnVertexGizmo && onEdge && enableArc) {

        var currentType = editTool.poly.getEdgeType(edgeIndex, edgePolyIndex.loop);

        // Add "Change-To" operations for all edge types except the current...

        // Change-to-Line
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
          menu.push({
            title: 'Change to Line Segment',
            target: function target() {
              editTool.changeEdgeToLine(edgePolyIndex);
            } });

        }

        // Change-to-Bezier
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier) {
          menu.push({
            title: 'Change to Arc Segment',
            target: function target() {
              editTool.changeEdgeToBezier(edgePolyIndex);
            } });

        }

        // Change-to-Ellipse
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse && editTool.enableEllipseArcs) {
          menu.push({
            title: 'Change to Ellipse Segment',
            target: function target() {
              editTool.changeEdgeToEllipse(edgePolyIndex);
            } });

        }
      }

      // Check if there are loops any loops left if we remove this one
      if (edgePolyIndex && editTool.poly.isClosed) {

        // If the loop under mouse is the (only) outer loop, don't show "removeLoop", because it makes more sense to just remove the shape instead.
        var mainLoops = editTool.poly.getMainLoops();
        var isOnlyMainLoop = mainLoops.length === 1 && mainLoops[0] === edgePolyIndex.loop;

        // Check loop type
        var type = editTool.poly.getLoopType(edgePolyIndex.loop);
        var itemName;
        switch (type) {
          case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["LoopType"].Outer:itemName = 'Remove Shape Part';break;
          case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["LoopType"].Inner:itemName = 'Remove Hole';break;
          default:itemName = 'Remove Loop';}
        ;

        if (!isOnlyMainLoop) {
          menu.push({
            title: itemName,
            target: function target() {
              editTool.removeLoop(edgePolyIndex.loop);
            } });

        }
      }

      if (shapeUnderMouse) {
        menu.push({
          title: 'Remove Shape',
          target: function target() {
            undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShape(layer, shapeUnderMouse));
          } });

      }
    } }]);return Edit2DContextMenu;}();

/***/ }),

/***/ "./extensions/Edit2D/Edit2DSnapper.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/Edit2DSnapper.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DSnapper; });
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var SnapType = Autodesk.Viewing.MeasureCommon.SnapType;

// Edit2DSnapper combines 3 different types of snapping:
//  1. Snapping to sheet geometry
//  2. Snapping to other geometry in the same layer
//  3. Snapping to angles and alignments

var av = Autodesk.Viewing;var

Edit2DSnapper = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {Layer} layer
  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)
  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);
    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // Snapper for sheet geometry and layer geometry.
    // Note: SnapResults are always stored in LMV world-coords (!=layer coords). Otherwise, SnapperIndicator would not display correctly.
    this.sheetSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);
    this.layerSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);

    // Used for snapping to angles and alignments
    this.angleSnapper = new _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__["default"](gizmoLayer);

    // tmp box reused for snapping
    this.snapBox = new THREE.Box2();

    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.
    this.sheetSnapper.activate();
    this.layerSnapper.activate();

    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)
    this.onCameraChangeCb = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);

    // If there is a model already, compute SegmentTree right now
    this.initSegmentTrees();

    // Reused tmp vector
    this.tmpVec = new THREE.Vector3();
    // Raycaster for snapping
    this.raycaster = new THREE.Raycaster();
    this.ray = new THREE.Ray();

    // If we snapped to a line segment, this member contains
    // this line segment in layer coords. See _getGeomSnapLine().
    this.geomSnapLine = {
      a: new THREE.Vector3(),
      b: new THREE.Vector3() };

  }_createClass(Edit2DSnapper, [{ key: "dtor", value: function dtor()

    {
      this.sheetSnapper.deactivate();
      this.layerSnapper.deactivate();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updateSnapperIndicators();
    }

    // Make sure that all visible models have a SegmentTree
  }, { key: "initSegmentTrees", value: function initSegmentTrees() {
      var models = this.viewer.getVisibleModels();
      models.forEach(function (model) {
        // Note: We have to wait until the model finished loading. Otherwise, we may end up with a segmentTree that only
        //       contains a subset of the segments.
        //       In addition, make sure to skip the segment building in case it's a leaflet (e.g. a raster PDF).
        var isLeaflet = model.isLeaflet();
        if (model.is2d() && !isLeaflet && !model.segmentTree && model.isLoadDone()) {
          model.segmentTree = new _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
          model.segmentTree.buildFromModel(model);
        }
      });
    } }, { key: "updateSnapperIndicators", value: function updateSnapperIndicators()

    {
      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper
      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear 
      // the sheet-snapping indicator again.
      if (this.sheetSnapper.isSnapped()) {
        this.sheetSnapper.indicator.render();
      } else {
        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.
        this.layerSnapper.indicator.render();
      }
    }

    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.
    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.
  }, { key: "getSnapPosition", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);

      // keep snapping gizmos up to date
      this.angleSnapper.updateSnapLineGizmos(p);

      this.updateSnapperIndicators();

      return p;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.angleSnapper.clearSnappingGizmos();
      this.sheetSnapper.clearSnapped();
      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();
      this.layerSnapper.clearSnapped();
      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();
    }

    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.
    // Otherwise, it has no effect.
  }, { key: "startAngleSnapping", value: function startAngleSnapping(poly, draggedVertex, loopIndex) {
      this.angleSnapper.startSnapping(poly, draggedVertex, loopIndex);
    }

    // Stop snapping to angles. (No effect if angleSnapping is already off).
  }, { key: "stopAngleSnapping", value: function stopAngleSnapping() {
      this.angleSnapper.stopSnapping();
    }

    // Like getSnapPosition, but excluding Snapping gizmo updates.
  }, { key: "_getSnapPosition", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {

      // Discard any outdated snapping results
      this.angleSnapper.clearSnappingResult();
      this.sheetSnapper.clearSnapped();
      this.layerSnapper.clearSnapped();

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Check if geom-snapping is possible (pGeom is in layer-coords)
      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);

      // Check if we snapped to line geometry. If so, we can still allow angle-snapping - as long as we constrain it to the geometry snapLine.
      var geomSnapLine = this._getGeomSnapLine();

      if (pGeom && !geomSnapLine) {
        // We snapped to geometry and the snapType does not allow us to combine it with angle snapping
        // => Just return result of geometry snapping
        return pGeom;
      }

      // Apply angle-snapping. If we snapped to line geometry already, constrain angleSnapping to this line.
      this.angleSnapper.snapToAngle(p, geomSnapLine);

      // If there is no angle-snap, just apply the geometry snap
      if (geomSnapLine && !this.angleSnapper.isSnapped()) {
        return pGeom;
      }

      // By default, SnapperIndicator only considers the geometry snapping result. If we corrected the snap point and used the intersection with an
      // angle snapLine, we have to update the SnapResult so that the snapPoint is correctly reflected by the SnapperIndicator.
      if (geomSnapLine && this.angleSnapper.isSnapped()) {
        var result = this._getGeomSnapResult();

        // p is in 2D layer coords, but LMV Snapper snapResults are always stored in LMV world coords
        var pWorld = new THREE.Vector3(p.x, p.y, 0.0).applyMatrix4(this.layer.layerToWorld);

        result.geomType = SnapType.SNAP_INTERSECTION;
        result.snapPoint = pWorld;
        result.geomVertex = result.snapPoint; // Otherwise, snapResult.isEmpty() returns true
      }

      return p;
    }

    // Gets snap position from mouse event. 
    //  @returns {Vector2|null} Snapped position or null if not snapped.
  }, { key: "_getGeomSnapPosition", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Compute snap position for model geom and edit layer. 
      // Both may be undefined if there was nothing to snap to.
      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);
      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);

      // If nothing is snapped, don't snap
      if (!pSheet && !pLayer) {
        return null;
      }

      // If only one snap point was found, use it
      if (!pLayer) {
        return pSheet;
      } else if (!pSheet) {
        return pLayer;
      }

      // Get distances of snapPoints to accurate position
      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);
      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);

      // Choose the closer snap. If equal, prefer edit layer snap.
      // We discard unused snap results here, so that snapper indicator keeps correct
      if (distSheet < distLayer) {
        // Use sheet snap and discard the other snap result
        this.layerSnapper.clearSnapped();
        return pSheet;
      } else {
        // Use layer snap and discard the other snap result
        this.sheetSnapper.clearSnapped();
        return pLayer;
      }
    }

    // Returns the SnapResult of sheetSnapper or layerSnapper if any of them is currently snapped. Returns null otherwise.
    // Note that LMV snapResults contain values in lmv world coords.
  }, { key: "_getGeomSnapResult", value: function _getGeomSnapResult() {

      // Check which of the snappers has snapped
      var sheetSnap = this.sheetSnapper.isSnapped();
      var layerSnap = this.layerSnapper.isSnapped();
      if (!sheetSnap && !layerSnap) {
        return null;
      }

      // Get latest SnapResult
      var geomSnapper = sheetSnap ? this.sheetSnapper : this.layerSnapper;
      return geomSnapper.getSnapResult();
    }

    // If the last geometry snapping successfully snapped to a line segment, this function returns this line segment.
    // Result is in layer-coords.
    //  @returns {Object} - If we snapped to a line segment, we return r={a, b} where r.a and r.b are line start/end as Vector2.
  }, { key: "_getGeomSnapLine", value: function _getGeomSnapLine() {

      var result = this._getGeomSnapResult();
      if (!result) {
        return null;
      }

      // If we snapped to an edge, return this edge. Note that SnapType may be SNAP_EDGE, but may also be SNAP_VERTEX
      var edgeGeom = result.geomEdge;
      if (edgeGeom) {
        var verts = result.geomEdge.vertices;

        // Copy edge start/end to this.geomSnapLine
        this.geomSnapLine.a.copy(verts[0]);
        this.geomSnapLine.b.copy(verts[1]);

        // SnapResults are in world coords. We want the geomSnapLine in layer coords.
        this.geomSnapLine.a.applyMatrix4(this.layer.worldToLayer);
        this.geomSnapLine.b.applyMatrix4(this.layer.worldToLayer);

        return this.geomSnapLine;
      }

      // Another SnapType => No line constraint.
      return null;
    }

    // Snaps to 2D edit layer geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
    //  @returns {Vector2} - snap position in layer coords.
  }, { key: "_getEditLayerSnapPosition", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {

      // Note that snapper needs a Vector3 to work.
      var point = this.layer.canvasToLayer(canvasX, canvasY, this.tmpVec);

      // compute snap radius in layer coords
      var radius = this.layerSnapper.detectRadiusInPixels * this.layer.getUnitsPerPixel();

      // create bbox centered at the point and expanded by snapRadius in each direction
      this.snapBox.min.set(point.x - radius, point.y - radius);
      this.snapBox.max.set(point.x + radius, point.y + radius);

      // Build dictionary of dbIds of all shapes intersecting the snapBox
      var dbIds = {};
      this.layer.enumShapes(this.snapBox, function (shape) {
        // Collect dbId - unless shape is excluded from snapping
        if (!snappingFilter || snappingFilter(shape)) {
          dbIds[shape.id] = true;
        }
      });

      // Collect all triangulated meshes intersecting the snapBox
      var meshes = [];
      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});

      // Only consider edges/arcs/vertices within snapRadius
      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};

      // Run snapper on the given meshes/dbIds. Note that we run snapping in layer coords.
      this.layerSnapper.clearSnapped();
      this.layerSnapper.snapping2DOverlay(point, meshes, filter, radius);

      // Stop here if nothing was snapped
      if (!this.layerSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position in layer-coords
      var res = this.layerSnapper.getSnapResult();
      var snapPos = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);

      // snapPos points to a vector inside snapResult. SnapResult will finally be converted to 
      // LMV world coords to make SnapperIndicator work. So, we copy it to a 2D vector first.
      snapPos = new THREE.Vector2().copy(snapPos);

      // SnapperIndicator requires world-coords in getSnapResult() to display correctly. 
      // Since we computed snapping in layer-coords, we finally convert it to LMV world coords.
      res.applyMatrix4(this.layer.layerToWorld);

      // Return snap position in layer coords
      return snapPos;
    }

    // Snaps to sheet geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
  }, { key: "_getSheetSnapPosition", value: function _getSheetSnapPosition(canvasX, canvasY) {var _this = this;

      // Make sure that SegmentTree exists for all visible 2D models
      this.initSegmentTrees();

      var viewerImpl = this.viewer.impl;
      // Callback to enum segments of all visible models
      var enumSegments = function enumSegments() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        var models = viewerImpl.get2DModels();
        models.forEach(function (model) {
          // NOTE: SegmentTree may not be available yet if a model is still loading.
          //       In this case, we exclude it from snapping until loading is done.
          if (model.segmentTree) {var _model$segmentTree;
            (_model$segmentTree = model.segmentTree).enumSegments.apply(_model$segmentTree, args);
          }
        });
      };

      var intersect2DModels = function intersect2DModels(canvasX, canvasY) {
        var models = viewerImpl.get2DModels();
        if (!models.length) {
          return;
        }

        var vpVec = viewerImpl.clientToViewport(canvasX, canvasY);
        viewerImpl.viewportToRay(vpVec, _this.ray);
        _this.raycaster.set(_this.ray.origin, _this.ray.direction);

        var results = [];
        models.forEach(function (model) {
          // Since we are not passing a getDbIdAtPointFor2D function, this will be a pure geometry comparison
          // and even entities that are hidden due to cropping will be considered
          results.push(model.rayIntersect2D(_this.raycaster));
        });

        // Get the closest hit
        results.sort(function (a, b) {return a.distance - b.distance;});

        return results[0];
      };


      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var result = intersect2DModels(canvasX, canvasY);
      if (!result) {
        return;
      }
      // We use enumSegments in order to get SNAP_INTERSECTION support, which is not provided by the default VertexBufferReader enumeration.
      this.sheetSnapper.snapping2D(result, { enumSegments: enumSegments });

      // If not snapped, just return current position
      if (!this.sheetSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position
      var res = this.sheetSnapper.getSnapResult();
      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3

      // convert result from LMV world coords to layer coords
      // Note that we have to copy first, because p3D is a reference into the SnapResult. 
      // The SnapResult itself must remain in world coords to keep SnapperIndicator correct.
      p3D = this.tmpVec.copy(p3D).applyMatrix4(this.layer.worldToLayer);

      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()
      return new THREE.Vector2().copy(p3D);
    } }]);return Edit2DSnapper;}();


av.GlobalManagerMixin.call(Edit2DSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/EditLayer.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/EditLayer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditLayer; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var nextLayerId = 1;

// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.
var DefaultLineHitRadius = 10;

var av = Autodesk.Viewing;

// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.
var EditLayer = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer - Viewer instance needed to create materials
  function EditLayer(viewer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EditLayer);

    av.EventDispatcher.prototype.apply(this);

    this.viewer = viewer;
    this.options = options;
    // Contains the triangulated geometry ready for rendering.
    this.group = new THREE.Group();
    if (options.useSceneAfter) {
      this.viewer.sceneAfter.add(this.group);
    } else {
      this.scene = new THREE.Scene();
      this.scene.add(this.group);
    }

    // @param {Shape[]}
    this.shapes = [];

    // @param {CanvasGizmoBase[]}
    this.canvasGizmos = [];

    this.id = nextLayerId++;

    // We don't use font rendering so far
    var fontEngine = null;

    // Always use client coords for drawing
    var toPageUnits = 1.0;

    // LMVCanvasContext doesn't really need a viewport - unless it's used with Pdf.js
    var dummyViewport = { width: 0, height: 0 };
    this.context = new Autodesk.Extensions.CompGeom.LmvCanvasContext(dummyViewport, toPageUnits, this._processMesh.bind(this), fontEngine);

    // When using LMVCanvasContext for PDF, this is not needed because PDF.js takes care that mozCurrentTransform exists.
    // In our case, we must make LMVCanvasContext create it.
    this.context.addContextCurrentTransform();

    this.setGlobalManager(viewer.globalManager);

    // By default, we always update on modification operations. But it can (and should) be temporarily disabled 
    // for batch operations. 
    this.autoUpdate = true;

    this.toPageUnits = toPageUnits;

    this.styleModifiers = [];

    // Update gizmo positions on camera changes
    this.onCameraChange = function () {return _this.updateCanvasGizmos();};
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);

    // Use custom tesselation accuracy for Bezier arcs. We use a bit finer values than PDF does right now.
    this.context.setTessParams({
      numIterations: 100,
      minSegLenFraction: 0.01 });


    // Optional transform between layer geometry and LMV world coords (default: identity)
    this.layerToWorld = new THREE.Matrix4();
    this.worldToLayer = new THREE.Matrix4();

    // Reused tmp values
    this.tmp_pWorld = new THREE.Vector3();
    this.tmp_p0 = new THREE.Vector2();
    this.tmp_p1 = new THREE.Vector2();
    this.tmp_ray = new THREE.Ray();
    this.tmp_box = new THREE.Box2();

    // For editing on planes in 3D
    this.is3d = false;
    this.plane = new THREE.Plane();
    this._updatePlane();

    // By default, viewer cutplanes also apply to EditLayers. Optional, all cutplanes can be excluded from layer geometry.
    this.enableCutplanes = true;

    // Camera used to render overlays.
    this.overlayCamera = undefined;
  }_createClass(EditLayer, [{ key: "dtor", value: function dtor()

    {
      this._clearScene();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);
    }

    // @param {Shape} shape
    // @returns {number} - The id of the shape. Used to access this shape later.
  }, { key: "addShape", value: function addShape(shape) {
      this.shapes.push(shape);

      this.dispatchEvent({ type: EditLayer.SHAPE_ADDED, shape: shape });

      this._onModified();
    }

    // @param {Shape[]} shapes
  }, { key: "addShapes", value: function addShapes(shapes) {var _this2 = this;
      shapes.forEach(function (s) {return _this2.addShape(s);});
    }

    // @param {Shape} shape
    // @returns {bool} true if shape was found.
  }, { key: "hasShape", value: function hasShape(shape) {
      return this.shapes.indexOf(shape) !== -1;
    }

    // Removes the given shape. 
    //  @returns {bool} true if shape was found and removed, otherwise false.
  }, { key: "removeShape", value: function removeShape(shape) {
      var index = this.shapes.indexOf(shape);
      if (index === -1) {
        return false;
      }
      this.shapes.splice(index, 1);

      this.dispatchEvent({ type: EditLayer.SHAPE_REMOVED, shape: shape });

      this._onModified();
      return true;
    }

    // @param {Shape[]} shapes
  }, { key: "removeShapes", value: function removeShapes(shapes) {var _this3 = this;
      shapes.forEach(function (s) {return _this3.removeShape(s);});
    } }, { key: "clear", value: function clear()

    {
      this.shapes.length = 0;

      this.dispatchEvent({ type: EditLayer.LAYER_CLEARED });

      this._onModified();
    }

    // Must be called after modifications to update the scene.
  }, { key: "update", value: function update() {

      // clear scene
      this._clearScene();

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Skip hidden shapes
        if (!shape.visible) {
          continue;
        }

        // apply override style if specified
        var overrideStyle = this._getOverrideStyle(shape);

        shape.draw(this.context, overrideStyle);
      }

      // Make sure that all shapes are processed
      this.context.flushBuffer(0, true);

      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.
      // There's also the option to use sceneAfter (which is helpful if we need more control over the blending method)
      // so in that case invalidating only the overlay is not enough for re-rendering.
      this.viewer.impl.invalidate(this.options.useSceneAfter, false, !this.options.useSceneAfter);

      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed
      this.updateCanvasGizmos();
    } }, { key: "updateCanvasGizmos", value: function updateCanvasGizmos()

    {
      for (var i = 0; i < this.canvasGizmos.length; i++) {
        this.canvasGizmos[i].update();
      }
    }

    // @param {CanvasGizmoBase} gizmo - Must implement gizmo.update() to respond to changes.
  }, { key: "addCanvasGizmo", value: function addCanvasGizmo(gizmo) {
      this.canvasGizmos.push(gizmo);
    }

    // @param {CanvasGizmoBase} gizmo
  }, { key: "removeCanvasGizmo", value: function removeCanvasGizmo(gizmo) {
      var index = this.canvasGizmos.indexOf(gizmo);
      if (index === -1) {
        return false;
      }
      this.canvasGizmos.splice(index, 1);
      return true;
    } }, { key: "getViewport", value: function getViewport()

    {
      return this.viewport;
    }

    // Returns the topmost shape containing the point (x,y)
    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.
  }, { key: "hitTest", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;

      // process shapes backwards to find topmost first
      for (var i = this.shapes.length - 1; i >= 0; i--) {
        var shape = this.shapes[i];

        // Skip hidden shapes
        if (!shape.visible) {
          continue;
        }

        var radiusLC = this.getLineHitRadius(shape, hitRadius);

        // Compute box centered at (x,y) with given hitRadius
        var hitBox = this.tmp_box.makeEmpty();
        hitBox.min.set(x - radiusLC, y - radiusLC);
        hitBox.max.set(x + radiusLC, y + radiusLC);

        // get (latest) shape bbox
        shape.updateBBox();

        // Skip if shape bounds and hitBounds don't intersect
        if (!shape.bbox.isIntersectionBox(hitBox)) {
          continue;
        }

        if (shape.hitTest(x, y, radiusLC)) {
          return shape;
        }
      }
    }

    // Used for line-feature hit tests: 
    // We consider a point p to be "on edge e" if p is within a certain radius around e.
    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.
  }, { key: "getLineHitRadius", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;

      var unitsPerPixel = this.getUnitsPerPixel();

      // Get line-width in layer coords
      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;

      // For thin lines, consider hits as long as they are within minPixels radius
      return Math.max(lineWidth, hitRadius * unitsPerPixel);
    }

    // Optional: Sets a callback to override the style for either all or a subset of shapes.
    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.
  }, { key: "addStyleModifier", value: function addStyleModifier(modifier) {
      this.styleModifiers.push(modifier);
      this._onModified();
    } }, { key: "removeStyleModifier", value: function removeStyleModifier(

    modifier) {
      var index = this.styleModifiers.indexOf(modifier);
      if (index == -1) {
        return false;
      }
      this.styleModifiers.splice(index, 1);
      this._onModified();
      return true;
    }

    // Convert layer coordinates to canvas coords.
    //  @param {Vector2|Vector3} [target]
  }, { key: "layerToCanvas", value: function layerToCanvas(x, y) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // get point in LMV world coords
      var pWorld = this.tmp_pWorld.set(x, y, 0).applyMatrix4(this.layerToWorld);

      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.
      var res = this.viewer.impl.worldToClient(pWorld, this.overlayCamera);
      return target.set(res.x, res.y, 0.0); // Set z to 0 if target is Vector3. Otherwise, the param has no effect
    }

    // Note: This function currently assumes a uniform unitPerPixel ratio. This may change if we add support for projected
    //       planes in 3D, where pixelRatio may vary across the layer and may require different values in x/y direction.
  }, { key: "getPixelsPerUnit", value: function getPixelsPerUnit() {
      var _window = this.getWindow();

      // get screen projections of two points in layer-coords that have unit-distance
      var p0 = this.layerToCanvas(0, 0, this.tmp_p0);
      var p1 = this.layerToCanvas(1, 0, this.tmp_p1);
      return p0.distanceTo(p1) / _window.devicePixelRatio;
    } }, { key: "getUnitsPerPixel", value: function getUnitsPerPixel()

    {
      return 1.0 / this.getPixelsPerUnit();
    }

    // Convert canvas coordinates (from input events) to layer viewport coordinates
    //  @param {Vector2|Vector3} [target]
  }, { key: "canvasToLayer", value: function canvasToLayer(canvasX, canvasY)
    {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      // Compute "ray through pixel" in world-coords.
      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);
      var ray = this.viewer.impl.viewportToRay(vpVec, this.tmp_ray, this.overlayCamera);

      // Intersect ray with plane that we edit on
      var intersect = ray.intersectPlane(this.plane, this.tmp_pWorld);

      if (!intersect) {
        // TODO: For 3D scenarios, we must properly support the case that canvasToLayer fails.
        return target.set(0, 0);
      }

      // Convert from world to layer coords
      intersect.applyMatrix4(this.worldToLayer);

      // Set 3rd-component to 0 for Vector3 targets. For 2D, the z param is ignored
      return target.set(intersect.x, intersect.y, 0);
    }

    // Runs the callback for all shapes in the layer that overlap the given bbox
    //  @param {Box2} bbox
    //  @param {function(Shape)} cb
  }, { key: "enumShapes", value: function enumShapes(bbox, cb) {
      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Make sure that bbox is up-to-date
        shape.updateBBox();

        if (bbox.isIntersectionBox(shape.bbox)) {
          cb(shape);
        }
      }
    }

    // Runs the callback for all triangulated 2D meshes created in the last update() call.
  }, { key: "enumMeshes", value: function enumMeshes(bbox, cb) {
      for (var i = 0; i < this.group.children.length; i++) {
        var mesh = this.group.children[i];
        var meshBox = mesh.geometry.boundingBox;

        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,
        //       we would need to compute a world-box using applyMatrixWorld() here.

        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,
        // it's important to call intersectsBox on the input box and not on the mesh.
        if (bbox.isIntersectionBox(meshBox)) {
          cb(mesh);
        }
      }
    } }, { key: "findShapeById", value: function findShapeById(

    id) {
      return this.shapes.find(function (s) {return s.id == id;});
    } }, { key: "setMatrix", value: function setMatrix(

    layerToWorld) {
      this.layerToWorld.copy(layerToWorld);
      this.worldToLayer.getInverse(layerToWorld);

      // Update projection plane
      this._updatePlane();
    }

    // By default, the viewer cutplanes are applied to EditLayers as well. This can be used, e.g., to crop them.
    //  @param {bool} enabled - If false, cutplanes are ignored for all layer geometry. 
  }, { key: "setCutPlanesEnabled", value: function setCutPlanesEnabled() {var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (enabled != this.enableCutplanes) {
        this.enableCutplanes = enabled;
        this.update();
      }
    }

    // 
    // --- Internal functions ---
    //

    // process meshData produced by LmvCanvasContext
  }, { key: "_processMesh", value: function _processMesh(meshData) {

      // create GeometryBuffer
      var mdata = { mesh: meshData, is2d: true, packId: "0", meshIndex: 0 };
      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      // create 2D material
      // Note that it is essential not to associate the material witha model. Otherwise,
      // the EditShapes will disappear if model layer 0 is switched off.
      var matman = this.viewer.impl.getMaterials();
      var matName = matman.create2DMaterial(null, meshData.material);
      var material = matman.findMaterial(null, matName);

      // Optional: Ignore cutplanes
      if (!this.enableCutplanes) {
        // Do not apply any cutplanes to the geometry
        material.cutplanes = undefined;
        material.doNotCut = true;
      }

      var mesh = new THREE.Mesh(geom, material);

      // Set mesh matrix
      mesh.matrix = this.layerToWorld;
      mesh.matrixAutoUpdate = false; // make sure matrix is not overwritten within updateMatrixWorld() later

      this.group.children.push(mesh);
    } }, { key: "_onModified", value: function _onModified()

    {
      if (this.autoUpdate) {
        this.update();
      }
    }

    // Apply one or more style modifiers
  }, { key: "_getOverrideStyle", value: function _getOverrideStyle(shape) {
      var style = shape.style;
      for (var i = 0; i < this.styleModifiers.length; i++) {
        var mod = this.styleModifiers[i];
        style = mod(shape, style) || style;
      }
      return style;
    }

    // Dispose all shapes generated by this layer.
  }, { key: "_clearScene", value: function _clearScene() {

      // Dispose any GPU resources for previous output geometry
      // Note that we construct the scene as a flat list of meshes (see _processMesh). So, we don't need a generic traversal here.
      var meshes = this.group.children;
      for (var i = 0; i < meshes.length; i++) {
        var mesh = meshes[i];
        mesh.geometry.dispose();

        // TODO: We have to take care to dispose materials here as well. However, just disposing materials here as well would produce a couple of issues:
        //
        //  1. MaterialManager caches materials based on properties. So, we cannot safely assume that the materials are solely used by ourselves.
        //     => MaterialManager currently only allows models to own 2D materials. We have to generalize it to support "ownerIDs" so
        //        that we can ensure that the materials are owned by this layer.
        //  2. Recompiling shaders on each update would be a waste. So we will need some caching.
      }
      this.group.children.length = 0;
    }

    // Only needed for 3D scenes
  }, { key: "_updatePlane", value: function _updatePlane() {
      // The layer geometry itself is in the {z=0} plane
      this.plane.normal.set(0, 0, 1);
      this.plane.constant = 0.0;

      // Transform plane to world-coords
      this.plane.applyMatrix4(this.layerToWorld);
    }

    // Used for projecting / unprojecting overlay elements. 
  }, { key: "setOverlayCamera", value: function setOverlayCamera(camera) {
      this.overlayCamera = camera;
    } }]);return EditLayer;}();


av.GlobalManagerMixin.call(EditLayer.prototype);

EditLayer.SHAPE_ADDED = 'shapeAdded';
EditLayer.SHAPE_REMOVED = 'shapeRemoved';
EditLayer.LAYER_CLEARED = 'layerCleared';

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, LoopType, PolyBase, PolyIndex, Polygon, Polyline, EdgeType, runPath, EllipseArcParams, Path, PolygonPath, PolylinePath, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopType", function() { return LoopType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyIndex", function() { return PolyIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeType", function() { return EdgeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runPath", function() { return runPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcParams", function() { return EllipseArcParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonPath", function() { return PolygonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylinePath", function() { return PolylinePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoopContainment.js */ "./extensions/Edit2D/LoopContainment.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var nextShapeId = 1;

var av = Autodesk.Viewing;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

// Default arc tessellation params that we use for area computations. (see Bezier.js)
// We use smaller min segment length than for drawing, because the DefaultTessParams would cause too inaccurate measurements.
// TODO: Replace by more accurate and faster analytic computation to replace brute-force tesselation completely.
var AreaTessParam = {
  numIterations: 100,
  minSegLenFraction: 0.01 };


var tmpVec3 = new THREE.Vector3();
var tmpVec3_2 = new THREE.Vector3();
var tmpBox2 = new THREE.Box2();
var tmpVec2 = new THREE.Vector2();

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,128)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,128)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
    this.compositeOperation = 'source-over';
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      this.compositeOperation = from.compositeOperation;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Add all points to given bbox.
var addPointsToBBox = function addPointsToBBox(points, dstBox) {
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function (_av$EventDispatcher) {_inherits(Shape, _av$EventDispatcher);var _super = _createSuper(Shape);
  function Shape() {var _this;var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    _this = _super.call(this);

    _this.style = style;

    // assign unique id
    _this.id = nextShapeId++;

    _this.bbox = new THREE.Box2();
    _this.bboxDirty = true;

    // If false, it is skipped by EditLayer traversals
    _this.visible = true;

    // whether users can move this shape by clicking and dragging.
    _this.movable = true;

    // whether users can select this shape. If false, clicks on this shape will not select it, and by consequence it
    // won't be editable either.
    _this.selectable = true;

    // Should be set by creator by something more descriptive.
    _this.name = _this.id.toString();return _this;
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.
  }, { key: "move", value: function move()
    /*dx, dy*/{return this;}

    // Apply a transform to each point. (assuming z=0)
    // @param {Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
      this.fireEvent({ type: Shape.Events.MODIFIED });
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    }

    // Return bbox while making sure that it's up-to-date.
  }, { key: "getBBox", value: function getBBox() {
      this.updateBBox();
      return this.bbox;
    }

    // @param {string}  svg - e.g. '<path d="M 13,4 L 14,4"/>'
  }, { key: "toSVG",



    // Convert to SVG style string, e.g., '<path d="M 13,4 L 14,4"/>'
    // See Svg.toSvg() comment for options.
    //
    // Note: The digits param is deprecated and only exists for legacy reasons. 
    //       Set digits via options.digits instead.
    value: function toSVG(options, digits) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvg(this, options, digits);
    }

    // Converts shape into a DOM element (usually a <path>).
    //  @param {Object} 
    //  @param {bool}   [options.exportStyle=true]
  }, { key: "createSvgShape", value: function createSvgShape(options) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvgElement(this, options);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      this.visible = visible;
    } }], [{ key: "fromSVG", value: function fromSVG(svg) {return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].fromSvg(svg);} }]);return Shape;}(av.EventDispatcher);


Shape.Events = {
  MODIFIED: 'modified' };


av.GlobalManagerMixin.call(Shape.prototype);

var LoopType = {
  Empty: 0, // Loop is empty or does not exist
  Inner: 1,
  Outer: 2,
  Overlapping: 3 // Loop is intersecting itself or other loops
};

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);var _super2 = _createSuper(PolyBase);

  function PolyBase() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this2 = _super2.call(this, style);

    // Array of Array of points, each represented as an object {x, y}
    // By default, we start with a single loop/chain
    _this2._loops = points ? [points] : [];

    // Set by derived classes
    _this2.isClosed = undefined;

    // Computed on-demand: Provides extra information about how loops are nested.
    _this2._loopInfos = null;return _this2;
  }

  // For backward compatibility
  _createClass(PolyBase, [{ key: "allocPoints",








    // acquire a number of additional points in the given loop. Each has initial coords (0,0)
    value: function allocPoints(numPoints) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < numPoints; ++i) {
        this.addPoint(0, 0, loopIndex);
      }
      return this;
    } }, { key: "isPolygon", value: function isPolygon()

    {return this.isClosed;} }, { key: "isPolyline", value: function isPolyline()
    {return !this.isClosed;} }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // get or create loop
      var loop = this._loops[loopIndex] || (this._loops[loopIndex] = []);

      // add point to loop
      var point = { x: x, y: y };
      loop.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // Legacy fallback (deprecated): This can be removed as soon as no code
      // is passing a target vector without a loop index
      if (_typeof(loopIndex) === 'object') {
        target = loopIndex;
        loopIndex = 0;
      }

      return target.copy(this._loops[loopIndex][index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._loops[loopIndex].splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var p = this._loops[loopIndex][index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this._loops[loopIndex].splice(index, 0, p);
    } }, { key: "getVertexCount",











    // Returns 0 if a loop is empty or does not exist.
    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // Array may not exist yet if no vertices were added to the loop yet.
      var loop = this._loops[loopIndex];
      return loop ? loop.length : 0;
    }

    // Reset back to a single empty loop
  }, { key: "clear", value: function clear() {
      this._loops = [];
      this.modified();
    }

    // Enumerate all edges (a,b).
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      // get edge count
      var edgeCount = this.getEdgeCount(loopIndex);

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = this.nextIndex(i, loopIndex);

        // get points
        var a = this.getPoint(ai, loopIndex);
        var b = this.getPoint(bi, loopIndex);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb, loopIndex);
      return edgeIndex;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        points[i].x += dx;
        points[i].y += dy;
      }
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var l = 0; l < this.loopCount; l++) {
        this.moveLoop(dx, dy, l);
      }
      return this;
    }

    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)
    // @param {THREE.Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      for (var l = 0; l < this.loopCount; l++) {
        var points = this._loops[l];

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          // set target to (x,y) * matrix
          var transformPoint = function transformPoint(x, y, target) {
            // convert to vec3, transform, and write back to target
            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);
            target.x = vec3.x;
            target.y = vec3.y;
            return target;
          };

          transformPoint(p.x, p.y, p);

          // transform Bezier control points
          if (this.isBezierArc(i, l)) {
            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);
            p.cp1x = cp.x;
            p.cp1y = cp.y;

            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);
            p.cp2x = cp.x;
            p.cp2y = cp.y;
          }

          // Transform ellipse arcs
          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)
          if (this.isEllipseArc(i, l)) {
            p.ellipseArcParams.applyMatrix4(matrix);
          }
        }
      }
      this.modified();
      return this;
    }

    // Copy a single loop from src poly and adds it to this one
    //  @param {PolyBase} srcPoly
    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src
    //  @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // copy loop points
      var srcLoop = srcPoly._loops[srcLoopIndex];
      var newLoop = cloneVectorArray(srcLoop);

      // insert new loop
      var newIndex;
      if (dstLoopIndex === -1) {
        // find a free loop index to store the new loop
        newIndex = this.nextFreeLoop();
        this._loops[newIndex] = newLoop;
      } else {
        // insert new loop at given index
        newIndex = dstLoopIndex;
        this._loops.splice(newIndex, 0, newLoop);
      }
      this.modified();

      return newIndex;
    }

    // Removes any empty loops, so that any loop i for 0<i<this.loopCount contains points.
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length > 0;});
      this.modified();
    } }, { key: "copyGeometry", value: function copyGeometry(

    srcPoly) {
      this.isClosed = srcPoly.isClosed;

      // copy loops
      this._loops = [];
      for (var i = 0; i < srcPoly.loopCount; i++) {
        this.addLoop(srcPoly, i);
      }
      return this;
    } }, { key: "copy", value: function copy(

    srcPoly) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, srcPoly);
      return this.copyGeometry(srcPoly);
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.makeEmpty();
      for (var i = 0; i < this.loopCount; i++) {
        var loop = this._loops[i];
        if (loop) {
          addPointsToBBox(loop, this.bbox);
        }
      }
      return this.bbox;
    } }, { key: "indexValid", value: function indexValid(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return index >= 0 && index < this.getVertexCount(loopIndex);
    }

    // Returns -1 if there is no next Index    
  }, { key: "nextIndex", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle last vertex
      var isLast = index === this.getVertexCount(loopIndex) - 1;
      if (isLast) {
        // If closed, restart. Otherwise, there is no next index.
        return this.isClosed ? 0 : -1;
      }

      return index + 1;
    }

    // Returns -1 if there is no previous vertex index
  }, { key: "prevIndex", value: function prevIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle first vertex
      if (index === 0) {
        // if closed, continue at end. Otherwise, there is no previous index.
        var vertexCount = this.getVertexCount(loopIndex);
        return this.isClosed ? vertexCount - 1 : -1;
      }

      return index - 1;
    }

    // Returns index of the edge ending at the given vertex or -1 if it does not exist.
  }, { key: "edgeBeforeVertex", value: function edgeBeforeVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.prevIndex(index, loopIndex);
    }

    // Returns index of the edge starting at the given vertex.
    // Returns -1 if index is the end vertex of a polyline.
  }, { key: "edgeAfterVertex", value: function edgeAfterVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(index, loopIndex) ? index : -1;
    }

    // Returns -1 if there is no previous edge.
  }, { key: "nextEdgeIndex", value: function nextEdgeIndex(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeIndex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for last polyline edge
      if (!this.isClosed && edgeIndex === this.getEdgeCount(loopIndex) - 1) {
        return -1;
      }

      return this.nextIndex(edgeIndex, loopIndex);
    } }, { key: "prevEdgeIndex", value: function prevEdgeIndex(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeindex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for first polyline edge
      if (!this.isClosed && edgeIndex === 0) {
        return -1;
      }

      return this.prevIndex(edgeIndex, loopIndex);
    } }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var edgeCount = this.getEdgeCount(loopIndex);
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    } }, { key: "prevEdgeExists", value: function prevEdgeExists(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (edgeIndex > 0 || this.isClosed);
    } }, { key: "nextEdgeExists", value: function nextEdgeExists(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      var isLastEdge = edgeIndex === vertexCount - 2;
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (!isLastEdge || this.isClosed);
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      this.getPoint(ia, loopIndex, outA);
      this.getPoint(ib, loopIndex, outB);
    } }, { key: "getEdgeDirection", value: function getEdgeDirection(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(loop[ia], loop[ib], target);
    } }, { key: "getEdgeLength", value: function getEdgeLength(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      var a = loop[ia];
      var b = loop[ib];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.isClosed ? vertexCount : vertexCount - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    //
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(loopIndex); i++) {
        this.getEdge(i, a, b, loopIndex);

        // apply optional measure transform
        if (measureTransform) {
          measureTransform.apply(a);
          measureTransform.apply(b);
        }

        sum += a.distanceTo(b);
      }
      return sum;
    }

    // Set vertices from THREE.Box2
  }, { key: "fromBox2", value: function fromBox2(box) {
      this.addPoint(box.min.x, box.min.y);
      this.addPoint(box.max.x, box.min.y);
      this.addPoint(box.max.x, box.max.y);
      this.addPoint(box.min.x, box.max.y);
      return this;
    }

    // Returns a point along an edge. Note that the edge may be an arc for Paths.
    //  @param {number} edgeIndex   - A valid edgeIndex
    //  @param {number} t           - in [0,1]. t=0: startPoint, t=1: endPoint
    //  @param {number} [loopIndex]
    //  @param {Vector2} [target]  
  }, { key: "getPointOnEdge", value: function getPointOnEdge(edgeIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var loop = this._loops[loopIndex];
      var p0 = loop[edgeIndex];
      var p1 = loop[this.nextIndex(edgeIndex, loopIndex)];
      return target.lerpVectors(p0, p1, t);
    }

    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, 
    // we assume an additional edge from end to start.
    // @returns {bool}
  }, { key: "isCCW", value: function isCCW() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return Autodesk.Extensions.CompGeom.polygonArea(this._loops[loopIndex]) > 0;
    }

    // Return 2D edge normal
  }, { key: "getLeftEdgeNormal", value: function getLeftEdgeNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();

      var points = this._loops[loopIndex];

      // get start/end point of the edge
      var vi1 = edgeIndex;
      var vi2 = (edgeIndex + 1) % points.length;
      var v1 = points[vi1];
      var v2 = points[vi2];

      // get edge direction
      target.subVectors(v2, v1).normalize();

      // rotate by 90 degrees
      var tmp = target.x;
      target.x = -target.y;
      target.y = tmp;

      return target;
    }

    // Get edge normal facing outside wrt. to the loop containing the edge. If the contour is not closed, we
    // assume an additional connection between endpoint and startpoint to defined "outside".
  }, { key: "getOuterNormal", value: function getOuterNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var normal = this.getLeftEdgeNormal(edgeIndex, loopIndex, target);
      return this.isCCW(loopIndex) ? normal.multiplyScalar(-1) : normal;
    }

    // Returns the first loopIndex >=0 that doesn't contain any points yet.
    //  @param {number}
  }, { key: "nextFreeLoop", value: function nextFreeLoop() {
      var isFree = function isFree(l) {return !l || !l.length;};
      var index = this._loops.findIndex(isFree);
      return index >= 0 ? index : this.loopCount;
    }

    // Seaches all loops to find a vertex for which cb(vertexIndex, loopIndex) returns true.    
    //  @{function(vertexIndex, loopIndex)=>bool} searchFilter   
    //  @returns {Object|null}                    A {vertexIndex, loopIndex} pair on success. Otherwise null.
  }, { key: "findVertex", value: function findVertex(searchFilter) {
      for (var l = 0; l < this.loopCount; l++) {
        var len = this.getVertexCount(l);
        for (var i = 0; i < len; i++) {
          if (searchFilter(i, l)) {
            return {
              vertexIndex: i,
              loopIndex: l };

          }
        }
      }
      return null;
    }

    // Returns true if poly does not contain any (non-empty loops)
  }, { key: "empty", value: function empty() {
      return !this._loops.some(function (loop) {return loop && loop.length > 0;});
    } }, { key: "modified", value: function modified()

    {
      _get(_getPrototypeOf(PolyBase.prototype), "modified", this).call(this);

      // Loop containment may have changed
      this._loopInfos = null;
    }

    // Returns true if the shape has overlapping loops
  }, { key: "isSelfIntersecting", value: function isSelfIntersecting() {

      // Todo: Currently, we only detect overlaps between different loops. We also
      //       have to track self-intersections within a single loop.


      // Check if we have multiple overlapping loops
      var loopInfos = this._getLoopInfos();
      return loopInfos && loopInfos.some(function (l) {return l.error;});
    } }, { key: "_getLoopInfos", value: function _getLoopInfos()

    {
      // Loop infos are only needed for closed paths with 2 or more loops
      if (!this.isClosed || this.loopCount < 1) {
        return undefined;
      }

      // Reuse if already available
      if (!this._loopInfos) {
        this._loopInfos = Object(_LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__["computeLoopContainment"])(this);
      }
      return this._loopInfos;
    }

    // Only works for closed loops.
  }, { key: "getLoopType", value: function getLoopType(loopIndex) {

      if (!this.isClosed) {
        return undefined;
      }

      if (!this.getVertexCount(loopIndex)) {
        return LoopType.Empty;
      }

      // LoopInfo should always exist for closed non-empty loops
      var infos = this._getLoopInfos();
      var info = infos[loopIndex];

      if (info.error) {
        return LoopType.Overlapping;
      }

      // Even-odd-rule: Loops with even rank are outer ones.
      return info.rank & 1 ? LoopType.Inner : LoopType.Outer;
    }

    // Get all loops (directly or indirectly) enclosed by the given one
  }, { key: "getChildLoops", value: function getChildLoops(loopIndex) {
      var infos = this._getLoopInfos();
      var info = infos && infos[loopIndex];
      return info ? info.containedLoops.slice() : [];
    }

    // Eliminiate all empty loops, so that loopCount matches the number of non-empty loops
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length >= 0;});
    }

    // Returns all loops that are not enclosed by any other one. Only for closed shapes.
  }, { key: "getMainLoops", value: function getMainLoops() {
      var infos = this._getLoopInfos();
      if (!infos) {
        return [];
      }

      // Collect all rank-0 loops
      var loops = [];
      for (var i = 0; i < infos.length; i++) {
        var info = infos[i];

        // Skip empty or invalid loops
        var type = this.getLoopType(i);
        if (type !== LoopType.Outer) {
          continue;
        }

        if (info.rank === 0) {
          loops.push(i);
        }
      }
      return loops;
    }

    // Remove loop. Remaining loop indices are shifted back by one 
  }, { key: "removeLoop", value: function removeLoop(loopIndex) {
      this._loops.splice(loopIndex, 1);
      this.modified();
      return this;
    }

    // Remove multiple loop indices
    // @param {number[]} 
  }, { key: "removeLoops", value: function removeLoops(loops) {
      this._loops = this._loops.filter(function (l, i) {return !loops.includes(i);});
    }

    // Returns true if a point contains valid (i.e. finite) numbers.
  }, { key: "isPointFinite", value: function isPointFinite(vertex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!this.indexValid(vertex, loopIndex)) {
        return false;
      }

      var points = this._loops[loopIndex];
      var p = points[vertex];
      return isFinite(p.x) && isFinite(p.y);
    } }, { key: "isLoopFinite", value: function isLoopFinite(

    loopIndex) {
      var points = this._loops[loopIndex];
      var count = points ? points.length : 0;
      for (var i = 0; i < count; i++) {
        if (!this.isPointFinite(i, loopIndex)) {
          return false;
        }
      }
      return true;
    } }, { key: "points", get: function get() {// Create empty loop 0 if needed
      return this._loops[0] || (this._loops[0] = []);} }, { key: "loopCount", get: function get() {return this._loops.length;} }, { key: "length", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility
  }, { key: "vertexCount", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);
// Helper class to address a single vertex within a loop of a PolyBase.
// Can also be used to address edges (by indexing its start vertex).
var PolyIndex = /*#__PURE__*/function () {
  function PolyIndex(_ref) {var _ref$vertex = _ref.vertex,vertex = _ref$vertex === void 0 ? 0 : _ref$vertex,_ref$loop = _ref.loop,loop = _ref$loop === void 0 ? 0 : _ref$loop;_classCallCheck(this, PolyIndex);
    this.vertex = vertex;
    this.loop = loop;
  }_createClass(PolyIndex, [{ key: "equals", value: function equals(
    v) {
      return v && this.vertex === v.vertex && this.loop === v.loop;
    } }]);return PolyIndex;}();


var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);var _super3 = _createSuper(Polygon);

  function Polygon() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);
    _this3 = _super3.call(this, points, style);
    _this3.isClosed = true;return _this3;
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it
    // is enclosed by an odd number of loops.
  }, { key: "hitTest", value: function hitTest(x, y) {
      if (!this.vertexCount) {
        return false;
      }

      // Compute number of loops that enclose (x,y)
      var rank = 0;
      for (var l = 0; l < this.loopCount; l++) {
        var loop = this._loops[l];
        if (!loop) {
          continue;
        }

        // set current loop as points
        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);

        // create dummy contour
        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
        var contour = [];
        for (var i = 0; i < loop.length; i++) {
          contour.push(i);
        }

        if (cp.pointInContour(x, y, contour)) {
          rank++;
        }
      }

      // Apply even-odd-rule
      return Boolean(rank & 1);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (!this.isClosed) {
        return undefined;
      }

      // If there are multiple loops, we need loopInfos to distinguish inner and outer loops
      var loopInfos = this._getLoopInfos();

      var sumArea = 0;
      for (var loopIndex = 0; loopIndex < this.loopCount; loopIndex++) {

        // Skip degenerate loops
        if (this.points.length < 3) {
          continue;
        }

        // determine loop rank (number of other loops containing it)
        // Note that loopInfos are null for single loops where we don't need them.
        var loopInfo = loopInfos ? loopInfos[loopIndex] : null;
        var rank = loopInfo ? loopInfo.rank : 0;

        // Even-odd rule: Loops with odd rank are holes and contribute negatively
        var sign = rank & 1 ? -1 : 1;

        var loopArea = 0.0;
        this.enumEdges(function (a, b) {
          // apply optional transform
          measureTransform && measureTransform.apply(a);
          measureTransform && measureTransform.apply(b);

          // sum up signed areas
          loopArea += a.x * b.y - b.x * a.y;
        }, loopIndex);
        sumArea += sign * Math.abs(0.5 * loopArea);
      }
      return sumArea;
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);var _super4 = _createSuper(Polyline);

  function Polyline() {var _this4;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);
    _this4 = _super4.call(this, points, style);
    _this4.isClosed = false;return _this4;
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.vertexCount !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var EdgeType = {
  Line: 0, // Simple line segment
  Bezier: 1, // Cubic Bezier Arc
  Ellipse: 2 // Ellipse Arc
};


// Tmp objct for Ellipse Arcs. We need delayed initialization, 
// because Autodesk.Extensions.CompGeom might not be available yet at compile time.
var _tmpArc = null;
var getTmpArc = function getTmpArc() {
  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();
  return _tmpArc;
};

var tmpVec = new THREE.Vector2();

// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
//  @param {number}                         loopIndex - must be a valid loop index in path
var runLoop = function runLoop(ctx, path, loopIndex) {

  var points = path._loops[loopIndex];
  if (!points || !points.length) {
    return;
  }

  // Trying to fill paths with NaN or infinite numbers may cause hangs in clipper. So, we prevent those here.
  if (!path.isLoopFinite(loopIndex)) {
    console.warn("Skipped loop, because it contains Inf or NaN values. Shape ID: ".concat(path.id, ". LoopIndex: ").concat(loopIndex));
    return;
  }

  ctx.moveTo(points[0].x, points[0].y);

  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {
    switch (pStart.arcType) {
      case EdgeType.Line:break;

      case EdgeType.Bezier:{
          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);
          return;
        }

      case EdgeType.Ellipse:{
          var params = pStart.ellipseArcParams;
          var arc = path.exportEllipseArc(edgeIndex, loopIndex, getTmpArc());

          // ignore arcs with NaN values
          if (!arc.isValid()) {
            break;
          }

          if (ctx.ellipseArcTo) {
            // Support SolidDef Path2D
            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);
          } else {
            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.
            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);
          }

          return;
        }}

    ctx.lineTo(pEnd.x, pEnd.y);
  };

  for (var i = 1; i < points.length; i += 1) {
    // The segment start point defines the type (line or arc)
    var prev = points[i - 1];
    var p = points[i];

    processSegment(prev, p, i - 1);
  }

  if (path.isClosed) {
    // add closing segment
    var pLast = points[points.length - 1];
    var pFirst = points[0];
    processSegment(pLast, pFirst, points.length - 1);

    ctx.closePath();
  }
};

// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
var runPath = function runPath(ctx, path) {
  for (var i = 0; i < path.loopCount; i++) {
    runLoop(ctx, path, i);
  }
};

// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon
//  @param {LmvCanvasContext}      ctx
//  @param {Polyline|Polygon|Path} path
//  @param {Style}                 [overrideStyle]
var drawPath = function drawPath(ctx, path, overrideStyle) {

  if (!path.vertexCount) {
    return;
  }

  var style = overrideStyle || path.style;
  var c = ctx.canvasContext;
  ctx.dbId = path.id;
  ctx.lineStyle = style.lineStyle;
  ctx.isScreenSpace = style.isScreenSpace;

  var currentGlobalCompositeOp = c.globalCompositeOperation;
  if (style.compositeOperation) {
    c.globalCompositeOperation = style.compositeOperation;
    // Make sure any previous shapes with a different blending are flushed first
    ctx.flushBuffer(0, true);
  }

  ctx.beginPath();

  // Run moveTo/lineTo/... commands on context
  runPath(ctx, path);

  // Draw fill for closed paths
  if (path.isClosed) {
    c.fillStyle = style.fillColor;
    // Creates a gradient fill style.
    if (style.fillColor.hasOwnProperty('colorStops')) {
      var gradientData = ctx.createGradientData(style.fillColor);
      var fillStyle = gradientData.getFillStyle(c);
      c.fillStyle = fillStyle;
    }
    c.globalAlpha = style.fillAlpha;

    ctx.fill();
  }

  // draw lines
  c.strokeStyle = style.lineColor;
  c.globalAlpha = style.lineAlpha;
  c.lineWidth = style.lineWidth;

  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
  // For human eyes the line width is then the same width.
  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

  ctx.stroke();

  // restore default values
  ctx.dbId = -1;
  ctx.lineStyle = 0;
  ctx.isScreenSpace = false;
  c.globalCompositeOperation = currentGlobalCompositeOp;
};

// Extra params for cubic Bezier arc edges.
var BezierArcParams = /*#__PURE__*/function () {
  function BezierArcParams() {_classCallCheck(this, BezierArcParams);
    // control point 1 that defines start tangent
    this.cp1x = 0;
    this.cp1y = 0;

    // control point 2 that defines end tangent
    this.cp2x = 0;
    this.cp2y = 0;
  }_createClass(BezierArcParams, [{ key: "copy", value: function copy(

    src) {
      this.cp1x = src.cp1x;
      this.cp1y = src.cp1y;
      this.cp2x = src.cp2x;
      this.cp2y = src.cp2y;
      return this;
    } }, { key: "clone", value: function clone()

    {
      return new BezierArcParams().copy(this);
    } }]);return BezierArcParams;}();


// SVG compatible ellipse arc params
// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
var EllipseArcParams = /*#__PURE__*/function () {

  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);
    // {number} Radius along x-axis
    this.rx = 0;

    // {number} Radius along y-axis
    this.ry = 0;

    // {number} ccw rotation of x/y-axes in degrees
    this.rotation = 0;

    // {bool} whether to use shorter or longer path around ellipse.
    this.largeArcFlag = false;

    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.
    this.sweepFlag = false;
  }_createClass(EllipseArcParams, [{ key: "copy", value: function copy(

    src) {
      this.rx = src.rx;
      this.ry = src.ry;
      this.rotation = src.rotation;
      this.largeArcFlag = src.largeArcFlag;
      this.sweepFlag = src.sweepFlag;
      return this;
    } }, { key: "clone", value: function clone()
    {
      return new EllipseArcParams().copy(this);
    }

    // @param {number} angle - counterclockwise in degrees
  }, { key: "rotate", value: function rotate(angle) {

      this.rotation += angle;

      // Normalize angle to keep within [0,360]
      this.rotation -= Math.trunc(this.rotation / 360) * 360;
    } }, { key: "scale", value: function scale(

    factor) {
      this.rx *= factor;
      this.ry *= factor;
    }

    // updates arc params according to a given transform.
    // Note: Transforming ellipse arcs is currently only supported for 
    //       simple transforms like translation, rotation, and uniform scaling.
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      // apply transform to x-axis direction
      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);
      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);
      var axis = tmpVec3.sub(tmpVec3_2);

      // obtain rotation angle and scale (assuming uniform scaling)
      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));
      var scale = axis.length();

      // update ellipse params
      this.rotate(rotAngle);
      this.scale(scale);

      // If a transform changes the orientation, we have to invert sweepFlag and rotation param
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].changesOrientation(matrix)) {
        this.sweepFlag = !this.sweepFlag;
        this.rotation = 360.0 - this.rotation;
      }
    } }]);return EllipseArcParams;}();


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);var _super5 = _createSuper(Path);

  function Path(points) {var _this5;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);
    _this5 = _super5.call(this, points, style);

    // If true, the path is automatically closed and can be filled.
    _this5.isClosed = isClosed;return _this5;
  }

  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   
  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.
  // @param {number} loopIndex   - must be valid. 
  // @param {Vector2} newA, newB - edge vertices after modification
  _createClass(Path, [{ key: "_updateEllipseArcParams", value: function _updateEllipseArcParams(edgeIndex, loopIndex, newA, newB) {

      var params = this._loops[loopIndex][edgeIndex].ellipseArcParams;

      // compute angle by which the edge was rotated
      var oldDir = this.getEdgeDirection(edgeIndex, loopIndex);
      var newDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(newA, newB);
      var dAngle = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].angleBetweenDirections(newDir, oldDir);

      params.rotate(THREE.Math.radToDeg(dAngle));

      // get scale factor applied to the edge
      var oldLength = this.getEdgeLength(edgeIndex, loopIndex);
      var newLength = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].distance2D(newA, newB); // also works for simple {x,y} pairs
      var scale = newLength / oldLength;

      // scale ellipse radii (if scaling is valid)
      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work
      if (scaleValid) {
        params.scale(scale);
      }
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var points = this._loops[loopIndex];
      var p = points[index];

      var pNew = tmpVec.set(x, y);

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index, loopIndex)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Update ellipse arc starting at p
      if (this.isEllipseArc(index, loopIndex)) {
        // next point must exist if index is a valid ellipse-arc edge.
        var nextIndex = this.nextIndex(index, loopIndex);
        var pNext = points[nextIndex];
        this._updateEllipseArcParams(index, loopIndex, pNew, pNext);
      }

      // Update arc params of segment ending at p
      // Note: For polylines, this edge does not exist for index==0
      var prevEdge = this.edgeBeforeVertex(index, loopIndex);
      if (this.edgeIndexValid(prevEdge, loopIndex)) {

        // get previous vertex
        var pPrev = points[prevEdge];

        // Update bezier control point
        if (this.isBezierArc(prevEdge, loopIndex)) {
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }

        // Update ellipse arc
        if (this.isEllipseArc(prevEdge, loopIndex)) {
          this._updateEllipseArcParams(prevEdge, loopIndex, pPrev, pNew);
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "getEdgeType", value: function getEdgeType(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = this._loops[loopIndex][segmentIndex].arcType;
      return type ? type : EdgeType.Line;
    }

    // Change segment into a cubic Bezier arc.
    // First and last control point are already given by the vertex positions.    
    //        
    //  @param {number}             segmentIndex - must be in [0, this.getEdgeCount(loopIndex)]
    //  @param {BezierArcParams}    params
    //  @param {number} [loopIndex]
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, params) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      // Legacy support:
      // If cp1x, cp2x etc. are enlisted individually, reshape params to expected form.
      // It's a pain that JS doesn't have function overloads.
      var isParamObj = _typeof(params) === 'object';
      if (!isParamObj) {
        params = {
          cp1x: params,
          cp1y: loopIndex,
          cp2x: arguments.length <= 3 ? undefined : arguments[3],
          cp2y: arguments.length <= 4 ? undefined : arguments[4] };

        loopIndex = (arguments.length <= 5 ? undefined : arguments[5]) || 0;
      }

      var p = this._loops[loopIndex][segmentIndex];
      p.arcType = EdgeType.Bezier;
      BezierArcParams.prototype.copy.call(p, params);

      this.modified();
    } }, { key: "getBezierArcParams", value: function getBezierArcParams(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BezierArcParams();
      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Bezier && p;

      // return a copy if found, otherwise undefined
      return srcParams && target.copy(srcParams);
    }

    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.
    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
    //
    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {EllipseArcParams} arcParams 
  }, { key: "setEllipseArc", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var p = this._loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Ellipse;
      p.ellipseArcParams = arcParams.clone();

      this.modified();
    }

    // @param {number}           segmentIndex - must be a valid ellipse-arc edge
    // @param {EllipseArcParams} target
    // @returns {EllipseArcParams}
  }, { key: "getEllipseArcParams", value: function getEllipseArcParams(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArcParams();

      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;

      // Return a copy if found, otherwise undefined.
      return srcParams && target.copy(srcParams);
    }

    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.
    //  @param {number}     edgeIndex     - must be an ellipse arc
    //  @param {number}     [loopIndex=0] - loopIndex
    //  @param {EllipseArc} [target]      - optional
    //  @returns {EllipseArc}
  }, { key: "exportEllipseArc", value: function exportEllipseArc(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArc();

      var points = this._loops[loopIndex];

      // get start/end points
      var nextIndex = this.nextIndex(edgeIndex, loopIndex);
      var pStart = points[edgeIndex];
      var pEnd = points[nextIndex];
      var params = pStart.ellipseArcParams;

      target.setFromSvgArc(
      params.rx,
      params.ry,
      params.rotation,
      params.largeArcFlag,
      params.sweepFlag,
      pStart,
      pEnd);

      return target;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;
    } }, { key: "isEllipseArc", value: function isEllipseArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;
    } }, { key: "isArc", value: function isArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);
    }

    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.
    // Only allowed for Bezier arcs. Result is not normalized.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getStartTangent", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var target = outTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];
      target.x = p.cp1x - p.x;
      target.y = p.cp1y - p.y;
      return target;
    }

    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getEndTangent", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var target = outTarget || new THREE.Vector2();
      var endVertex = this.nextIndex(segmentIndex);

      // get start/end point of the segment
      var pStart = this.points[segmentIndex];
      var pEnd = this.points[endVertex];
      target.x = pStart.cp2x - pEnd.x;
      target.y = pStart.cp2y - pEnd.y;
      return target;
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setStartTangent", value: function setStartTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      p.cp1x = p.x + tangent.x;
      p.cp1y = p.y + tangent.y;
      this.modified();
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setEndTangent", value: function setEndTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      var pEnd = this.points[this.nextIndex(segmentIndex)];
      p.cp2x = pEnd.x + tangent.x;
      p.cp2y = pEnd.y + tangent.y;
      this.modified();
    }

    // Change Bezier or Ellipse arc back to simple line segment
  }, { key: "removeArc", value: function removeArc(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var p = this._loops[loopIndex][segmentIndex];

      if (p.arcType === EdgeType.Bezier) {
        p.cp1x = undefined;
        p.cp1y = undefined;
        p.cp2x = undefined;
        p.cp2y = undefined;
      }

      if (p.ellipseArcParams) p.ellipseArcParams = undefined;

      // reset type
      p.arcType = EdgeType.Line;

      this.modified();
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
    // @param {Vector2} [target]
    // @param {number}  [loopIndex]
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();
      var p = this._loops[loopIndex][segmentIndex];

      if (ctrlPointIndex === 1) {
        target.x = p.cp1x;
        target.y = p.cp1y;
      } else {
        target.x = p.cp2x;
        target.y = p.cp2y;
      }
      return target;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {var loopIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var p = this._loops[loopIndex][segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // Sample path into a Polygon or Polyline.
    //  @returns {Polygon|Polyline}
  }, { key: "toPoly", value: function toPoly() {var _this6 = this;var tessParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Autodesk.Extensions.CompGeom.DefaultTessParams;

      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(
      l) {

        // Build up a polygon from path commands
        var ctx = {
          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},
          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},
          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {

            // get last added point. Note that it always exists, because runLoop() always starts with moveTo.
            // so we know for sure that >=1 points were already added to this polygon loop.
            var points = poly._loops[l];
            var last = points[points.length - 1];

            // compute bbox of the arc - which we use as an estimate for required accuracy
            var arcBox = tmpBox2.makeEmpty();
            arcBox.expandByPoint(last);
            arcBox.expandByPoint(tmpVec2.set(x, y));
            arcBox.expandByPoint(tmpVec2.set(cp1x, cp1y));
            arcBox.expandByPoint(tmpVec2.set(cp2x, cp2y));
            var sz = arcBox.size(tmpVec).length();

            // sample arc into lineTo() segments
            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz, tessParams);
          },
          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {

            // use ellipse maxRadius a reference for required accuracy
            var sz = Math.max(rx, ry);

            // determine tesselation params                    
            var maxSegments = tessParams.numIterations;
            var minSegmentLength = tessParams.minSegLenFraction * sz;

            // tesselate arc
            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);
            arc.tesselate(ctx, maxSegments, minSegmentLength);
          },
          closePath: function closePath() {} // Polygon is closed anyway.
        };
        runLoop(ctx, _this6, l);};for (var l = 0; l < this.loopCount; l++) {_loop(l);
      }
      return poly;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      // Compute bbox of all vertices
      _get(_getPrototypeOf(Path.prototype), "computeBBox", this).call(this);

      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control
      // points. Therefore, we can simply add the control points to the bbox.
      //
      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.
      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.
      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
      var cp = new THREE.Vector2();
      for (var l = 0; l < this.loopCount; l++) {
        for (var i = 0; i < this.getVertexCount(l); i++) {

          if (this.isBezierArc(i, l)) {
            // add control point 1
            this.getControlPoint(i, 1, l, cp);
            this.bbox.expandByPoint(cp);

            // add control point 2
            this.getControlPoint(i, 2, l, cp);
            this.bbox.expandByPoint(cp);
          } else
          if (this.isEllipseArc(i, l)) {
            var arc = this.exportEllipseArc(i, l, getTmpArc());
            this.bbox.union(arc.computeBBox(tmpBox2));
          }
        }
      }
    } }, { key: "hitTest", value: function hitTest(

    x, y, hitRadius) {
      var poly = this.toPoly();
      return poly.hitTest(x, y, hitRadius);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    }

    // @param {Path} srcPath
    // @param {number} srcLoopIndex loop in srcPath to copy
    // @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      // If dstLoop is not set, it will be chosen by the super.addLoop().
      dstLoopIndex = _get(_getPrototypeOf(Path.prototype), "addLoop", this).call(this, srcPath, srcLoopIndex, dstLoopIndex);

      var srcPoints = srcPath._loops[srcLoopIndex];
      var dstPoints = this._loops[dstLoopIndex];

      // Copy extra information for arcs
      for (var i = 0; i < srcPoints.length; i++) {
        var type = srcPath.getEdgeType(i, srcLoopIndex);

        // Line segments are fully handled by the base class already
        if (type === EdgeType.Line) {
          continue;
        }

        var src = srcPoints[i];
        var dst = dstPoints[i];

        dst.arcType = src.arcType;

        switch (type) {
          case EdgeType.Bezier:{
              // copy control points
              dst.cp1x = src.cp1x;
              dst.cp1y = src.cp1y;
              dst.cp2x = src.cp2x;
              dst.cp2y = src.cp2y;
              break;
            }
          case EdgeType.Ellipse:{
              // copy arc params
              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();
              break;
            }}

      }

      this.modified();
      return this;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      _get(_getPrototypeOf(Path.prototype), "moveLoop", this).call(this, dx, dy, loopIndex);

      // Move affected control points as well
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        if (!this.isBezierArc(i, loopIndex)) {
          continue;
        }

        var p = points[i];
        p.cp1x += dx;
        p.cp1y += dy;
        p.cp2x += dx;
        p.cp2y += dy;
      }

      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.
    } }, { key: "getArea", value: function getArea(

    measureTransform) {
      if (!this.isClosed) {
        return undefined;
      }

      // Todo: If performance becomes an issue, this can be optimized by a less brute-force way.
      var poly = this.toPoly(AreaTessParam);

      // Since poly is just temporary, we can just share the loop infos to prevent poly.getArea()
      // from computing them again.
      poly._loopInfos = this._getLoopInfos();

      return poly.getArea(measureTransform);
    } }, { key: "getLength", value: function getLength(

    measureTransform) {
      var poly = this.toPoly();
      return poly.getLength(measureTransform);
    }

    // Get point on segment. This refines the implementation 
    // of PolyBase by supporting arc segments.
  }, { key: "getPointOnEdge", value: function getPointOnEdge(segmentIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var points = this._loops[loopIndex];
      var type = this.getEdgeType(segmentIndex, loopIndex);
      switch (type) {
        case EdgeType.Line:break;
        case EdgeType.Bezier:{
            // get segment start/end
            var a = points[segmentIndex];
            var b = points[this.nextIndex(segmentIndex)];

            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, target);
          }
        case EdgeType.Ellipse:{
            var arc = this.exportEllipseArc(segmentIndex, loopIndex, getTmpArc());

            // ignore arcs with NaN values
            if (!arc.isValid()) {
              break;
            }
            return arc.getPoint(t, target);
          }
        default:avp.logger.error('unexpected edge type');}


      return _get(_getPrototypeOf(Path.prototype), "getPointOnEdge", this).call(this, segmentIndex, t, loopIndex, target);
    }

    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    
    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
  }, { key: "runPathCommands", value: function runPathCommands(ctx) {
      runPath(ctx, this);
    }

    // Returns false if all edges of all loops are line segments.
  }, { key: "hasArcs", value: function hasArcs() {var _this7 = this;
      var filter = function filter(vertexIndex, loopIndex) {return _this7.isArc(vertexIndex, loopIndex);};
      return Boolean(this.findVertex(filter));
    } }]);return Path;}(PolyBase);


// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.
var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);var _super6 = _createSuper(PolygonPath);
  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _super6.call(this,
    points, true, style);
  }return PolygonPath;}(Path);
;

var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);var _super7 = _createSuper(PolylinePath);
  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _super7.call(this,
    points, false, style);
  }return PolylinePath;}(Path);
;

var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);var _super8 = _createSuper(Circle);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this8;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this8 = _super8.call(this, style);

    _this8.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this8.polygon.id = _this8.id;

    _this8.centerX = centerX;
    _this8.centerY = centerY;
    _this8.radius = radius;
    _this8.tessSegments = tessSegments;

    _this8.needsUpdate = true;return _this8;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
      return this;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);var _super9 = _createSuper(ShapeWrapper);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this9;_classCallCheck(this, ShapeWrapper);
    _this9 = _super9.call(this);
    _this9.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this9), 'bbox', {
      get: function get() {return _this9.shape.bbox;},
      set: function set(bbox) {_this9.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'id', {
      get: function get() {return _this9.shape.id;},
      set: function set(id) {_this9.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'bboxDirty', {
      get: function get() {return _this9.shape.bboxDirty;},
      set: function set(dirty) {_this9.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'name', {
      get: function get() {return _this9.shape.name;},
      set: function set(name) {_this9.shape.name = name;} });return _this9;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/EllipseArcGizmo.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/EllipseArcGizmo.js ***!
  \**********************************************/
/*! exports provided: getEllipseArcEdgeParams, EllipseArcGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEllipseArcEdgeParams", function() { return getEllipseArcEdgeParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcGizmo", function() { return EllipseArcGizmo; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var tmpVec2 = new THREE.Vector2();

// Get ellipse arc params in a way that the edge is bended inside or outside wrt.
// to the outer loop.
//
// @param {Path}   path       - not changed   
// @param {number} edgeIndex  - edge for which we compute the arc params
// @param {number} loopIndex
// @param {number} bendRadius - Signed distance between line-segment center and arc center. 
//                                 Positive values for outside, negative for inside.   
// @param {EllipseArcParams} [target]
// @returns {EllipseArcParams}
var getEllipseArcEdgeParams = function getEllipseArcEdgeParams(path, edgeIndex, loopIndex, bendRadius, target) {

  var params = target || new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

  // compute ellipse rotation, so that ellipse x-axis is parallel to the edge
  var dir = path.getEdgeDirection(edgeIndex, loopIndex, tmpVec2);
  var angle = Math.atan2(dir.y, dir.x);
  params.rotation = THREE.Math.radToDeg(angle);

  // Compute radius in a way that ellipse center matches with line-segment center
  params.rx = 0.5 * path.getEdgeLength(edgeIndex, loopIndex);

  // Apply bending by varying y-radius
  params.ry = Math.abs(bendRadius);

  // Always use shortest connection
  params.largeArcFlag = false;

  // Make sure that positive bendRadius bends outside, negative inside
  params.sweepFlag = Boolean(path.isCCW(loopIndex) ^ bendRadius < 0);

  return params;
};

// Gizmo class to pull ellipse arc centers. The gizmo implements the full interaction, but
// the owner controls when startDrag(), moveDrag(), and endDrag() are called.
var EllipseArcGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EllipseArcGizmo, _EdgeGizmo);var _super = _createSuper(EllipseArcGizmo);

  function EllipseArcGizmo(layer, gizmoManager, undoStack, visible) {var _this;_classCallCheck(this, EllipseArcGizmo);
    _this = _super.call(this, layer, visible);

    _this.container.classList.add('ellipse-arc-gizmo');

    _this.dragging = false;

    // arc params when drag had started
    _this.dragStartParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    // delta between exact dragStart position and gizmo-center at dragStart
    _this.dragOffset = new THREE.Vector2();

    // tmp values
    _this.tmpVec = new THREE.Vector2();
    _this.tmpVec2 = new THREE.Vector2();
    _this.tmpVec3 = new THREE.Vector2();
    _this.tmpParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    _this.gizmoManager = gizmoManager;
    _this.undoStack = undoStack;return _this;
  }_createClass(EllipseArcGizmo, [{ key: "isUnderMouse", value: function isUnderMouse()

    {
      return this.visible && this.edgeValid() && this.gizmoManager.isUnderMouse(this);
    } }, { key: "startDrag", value: function startDrag(

    canvasX, canvasY) {

      // Stop here if there is nothing to drag
      if (!this.edgeValid() || !this.isUnderMouse()) {
        return false;
      }

      // Usually, dragging will be false here unless in weird focus-change scenarios
      if (this.dragging) {
        return true;
      }

      this.dragging = true;

      // Highlight in green while dragging
      this.setSelected(true);

      // Store offset between exact mouse pos and the vertex we are dragging
      var pos = this.layerPos;
      var posScreen = this.layer.layerToCanvas(pos.x, pos.y);
      this.dragOffset.set(posScreen.x - canvasX, posScreen.y - canvasY);

      // Backup initial arc params
      this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.dragStartParams);

      return true;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      if (!this.dragging) {
        return false;
      }

      // Compute layer position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Compute vector (a => p), where a is the edge start
      var a = this.poly.getPoint(this.edgeIndex, this.loopIndex, this.tmpVec);
      var diff = this.tmpVec2.copy(p).sub(a); // vector from edge start towards new gizmo position

      // Compute distance of the new gizmo position from edge spanned by line segment (a,b)
      var normal = this.poly.getOuterNormal(this.edgeIndex, this.loopIndex, this.tmpVec3);
      var signedDistance = diff.dot(normal);

      // Configure ellipse arc, so that the distance of the arc midpoint is the same
      var params = getEllipseArcEdgeParams(this.poly, this.edgeIndex, this.loopIndex, signedDistance, this.tmpParams);

      // Update polygon
      this.poly.setEllipseArc(this.edgeIndex, params, this.loopIndex);
      this.update();
      this.layer.update();

      return true;
    } }, { key: "endDrag", value: function endDrag(

    canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);
      this.dragging = false;

      var newParams = this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.tmpParams);

      this.restoreArc();
      var polyIndex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: this.edgeIndex, loop: this.loopIndex });
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, newParams));

      // stop highlighting
      this.setSelected(false);
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      this.restoreArc();
      this.dragging = false;
      this.layer.update();
    }

    // Restore state of the arc before dragging it
  }, { key: "restoreArc", value: function restoreArc() {
      this.poly.setEllipseArc(this.edgeIndex, this.dragStartParams, this.loopIndex);
    } }]);return EllipseArcGizmo;}(_CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeGizmo"]);

/***/ }),

/***/ "./extensions/Edit2D/LoopContainment.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/LoopContainment.js ***!
  \**********************************************/
/*! exports provided: getFacesInsideLoop, computeLoopContainment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFacesInsideLoop", function() { return getFacesInsideLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLoopContainment", function() { return computeLoopContainment; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);
function _readOnlyError(name) {throw new Error("\"" + name + "\" is read-only");}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}



// Result values of classifySets
var SetContainment = {
  Contains: 0, // A contains B (not vice versa)
  IsContainedIn: 1, // B contains A (not vice versa)
  Disjoint: 2, // No common elements
  Overlapping: 3, // Intersecting, but not equal
  Equal: 4 // Sets are identical
};

// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop
// @param {Edges[]}            loopEdges    - edges of the loop that we test against.
// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.
var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {

  // Get all faces that we obtained by intersecting all edges against each other
  var regionFaces = solver.getFaces();

  // Get ordered array of loop edges within solver that correspond to the cutLoop
  var cutRegionEdges = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getRegionEdges"])(solver, loopEdges);

  // Find all faces that are 
  return Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getBoundedRegionFaces"])(regionFaces, cutRegionEdges);
};

// Tolerance for self-intersection tests: If intersections are very close to a shared vertex, we ignore them.
// Note that the tolerance is not in units but a fraction of an edge.
var Precision = 1.e-5;

// Check whether a single loop has self-intersections
// TODO: There is one edge case that we would not detect here: If a loop passes the same vertex multiple times.
var hasSelfIntersections = function hasSelfIntersections(loopEdges) {
  for (var _i = 0; _i < loopEdges.length; _i++) {
    var edge1 = loopEdges[_i];

    // Check all subsequent edges.
    for (var j = _i + 1; j < loopEdges.length; j++) {

      // Check intersections of both edges
      var edge2 = loopEdges[j];
      var cuts = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["computeCurveCurveIntersections"])(edge1, edge2, false, true);

      // Check if there are any intersections (except for shared vertices)
      for (var _i2 = 0; _i2 < cuts.length; _i2++) {
        var cut = cuts[_i2];

        // Ignore intersections at a shared vertex
        // Due to accuracy issues, the cut may also be just close to a vertex
        var param1 = cut.cutInfo.param;
        var param2 = cut.cutByInfo.param;

        var range1 = edge1.getRange();
        var range2 = edge2.getRange();

        // Check if both parameters are very close to range start/end of an edge
        var dist1 = Math.min(Math.abs(param1 - range1[0]), Math.abs(param1 - range1[1]));
        var dist2 = Math.min(Math.abs(param2 - range2[0]), Math.abs(param2 - range2[1]));
        var d = Math.max(dist1, dist2);

        // If cut was not approximately equal to a shared vertex,
        // consider it as a self-intersection.
        if (d > Precision) {
          return true;
        }
      }
    }
  }
  return false;
};

// Given two sets of values, faces, each indexed by integer faceIds, this function checks how the sets are related.
var classifySets = function classifySets(A, B) {

  // Track which kind of indices we found
  var foundCommon = false; // >=0 elems are in both
  var foundAOnly = false; // >=0 elems are only in set A
  var foundBOnly = false; // >=0 elems are only in set B

  var checkElems = function checkElems(elemIndex) {
    var isInA = A.has(elemIndex);
    var isInB = B.has(elemIndex);

    if (isInA && isInB) foundCommon = true;else
    if (isInA) foundAOnly = true;else
    if (isInB) foundBOnly = true;
  };var _iterator = _createForOfIteratorHelper(

  A),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var elem = _step.value;
      checkElems(elem);
    }} catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(

  B),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _elem = _step2.value;
      checkElems(_elem);
    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

  if (!foundCommon) {
    return SetContainment.Disjoint;
  }

  if (foundAOnly && !foundBOnly) {
    return SetContainment.Contains;
  }

  if (foundBOnly && !foundAOnly) {
    return SetContainment.IsContainedIn;
  }

  if (!foundAOnly && !foundBOnly) {
    return SetContainment.Equal;
  }

  return SetContainment.Overlapping;
};

// Contains loop containment for a path
var computeLoopContainment = function computeLoopContainment(path) {

  // Convert to SolidDef Path
  var pathSd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path);

  // get path as wires
  var wireBody = pathSd.getWireBody();
  var wires = wireBody.getWires();

  // get path as edge array
  var edges = wireBody.getEdges();

  // Init empty loop infos
  var loopInfos = [];
  for (var l = 0; l < wires.length; l++) {

    // Get loop edges
    var w = wires[l];
    var loopEdges = w.getEdges();

    loopInfos[l] = {
      containedLoops: [],
      rank: 0,

      // Indicates if loop containment could not properly computed. 
      // This happens if 
      //   a) The loop has self-intersections
      //   b) The loop is overlapping with another one
      //   c) The loop is exactly matching with another one
      error: hasSelfIntersections(loopEdges) // Initially, we detect only a)
    };
  }

  // For only a single loop or less, we are done here.
  if (wires.length < 2) {
    return loopInfos;
  }

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["SketchRegionSolver"]();
  solver.compute(edges);

  // check which of the faces are within path and cutPath
  var faces = solver.getFaces();

  // attach arrayIndex to each face
  faces.forEach(function (f, index) {return f.arrayIndex = index;});

  // for each loop l, collect a set facesPerLoop[l] that contains the array indices of all enclosed faces.     
  var facesPerLoop = [];var _loop = function _loop(
  _l) {

    // get edges of loop i
    var w = wires[_l];
    var loopEdges = w.getEdges();

    // If a loop has self-intersections, just mark it as invalid and skip it
    if (hasSelfIntersections(loopEdges)) {
      loopInfos[_l].error = true;
      facesPerLoop[_l] = new Set();
      return "continue";
    }

    // get all faces within this loop
    var enclosedFaceIds = new Set();
    var faces = getFacesInsideLoop(solver, loopEdges);
    faces.forEach(function (f) {
      enclosedFaceIds.add(f.arrayIndex);
    });

    facesPerLoop[_l] = enclosedFaceIds;};for (var _l = 0; _l < wires.length; _l++) {var _ret = _loop(_l);if (_ret === "continue") continue;
  }

  // Use the faceId sets to derive which loop is contained in which other    
  for (var a = 0; a < facesPerLoop.length; a++) {

    // indices of all faces enclosed by loop a
    var A = facesPerLoop[a];

    for (var b = a + 1; b < facesPerLoop.length; b++) {
      // indices of all faces enclosed by loop i
      var B = facesPerLoop[b];

      // Check set relation between A and B
      var cont = classifySets(A, B);
      switch (cont) {
        case SetContainment.Disjoint:
          // No common faces at all. E.g., for two holes.
          continue;
        case SetContainment.Contains:
          loopInfos[a].containedLoops.push(b);
          loopInfos[b].rank++;
          break;
        case SetContainment.IsContainedIn:
          loopInfos[b].containedLoops.push(b);
          loopInfos[a].rank++;
          break;
        default:
          loopInfos[a].error = true;
          loopInfos[b].error = true;}

    }
  }

  // If the original paths contained empty loops, we may have to reindex the loopInfos,
  // because empty loops will not produce a corresponding wire in the SolidDef representation.
  if (wires.length !== path.loopCount) {
    var reindexed = [];
    var srcIndex = 0;
    for (var _l2 = 0; _l2 < path.loopCount; _l2++) {
      // Only non-empty loops get loopInfos
      if (path.getVertexCount(_l2)) {
        reindexed[i] = loopInfos[(_readOnlyError("srcIndex"), srcIndex++)];
      }
    }
    loopInfos = (_readOnlyError("loopInfos"), reindexed);
  }

  return loopInfos;
};

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });
var tmpVec2d = new THREE.Vector2();
var tmpVec2d2 = new THREE.Vector2();

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

//  @param {Vector2} dir1, dir2           - No normalization required.
//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// see isPointOnEdge
var isPointOnLine = function isPointOnLine(p, a, b, precision) {
  return isPointOnEdge(p, a, b, precision, false);
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

// same as p1.distanceTo(p2), but working for any {x,y} object.
var distance2D = function distance2D(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Checks if a matrix changes the orientation.
//  @param {Matrix4} matrix
var changesOrientation = function changesOrientation(matrix) {
  return matrix.determinant() < 0;
};

// Compute a matrix that transforms fromBox into toBox.
//
//  @param {Box2}    fromBox
//  @param {Box2}    toBox
//  @param {Object}  [options]
//  @param {bool}    [options.flipY]           - include y-axis flip
//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)
//  @param {Matrix4} [target]
var getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();
  var fromSize = fromBox.size(tmpVec2d);
  var toSize = toBox.size(tmpVec2d2);

  // compute scale   
  var sx = toSize.x / fromSize.x;
  var sy = toSize.y / fromSize.y;

  // preserveAspect
  if (options.preserveAspect) {
    sx = Math.min(sx, sy);
    sy = sx;
  }

  // anchor is the point of fromBox that will be mapped to toBox.min
  var anchorX = fromBox.min.x;
  var anchorY = fromBox.min.y;

  // apply optional y-flip
  if (options.flipY) {
    sy *= -1;
    anchorY = fromBox.max.y;
  }

  // compute translation: after scaling, anchor should move to toBox.min
  var tx = -sx * anchorX + toBox.min.x;
  var ty = -sy * anchorY + toBox.min.y;

  // Create (scale + translate)-matrix.
  var matrix = target.makeScale(sx, sy, 1.0);
  matrix.elements[12] = tx;
  matrix.elements[13] = ty;

  return matrix;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  isPointOnLine: isPointOnLine,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear,
  distance2D: distance2D,
  changesOrientation: changesOrientation,
  getFitToBoxTransform: getFitToBoxTransform };

/***/ }),

/***/ "./extensions/Edit2D/MeasureTransform.js":
/*!***********************************************!*\
  !*** ./extensions/Edit2D/MeasureTransform.js ***!
  \***********************************************/
/*! exports provided: MeasureTransform, DefaultMeasureTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeasureTransform", function() { return MeasureTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMeasureTransform", function() { return DefaultMeasureTransform; });
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// Workaround to choose a viewport for a given 2d sheet.
// 
// Actually, we should choose it based on 2d-position. But, F2D doesn't give us proper data to 
// do this. Also, even with proper viewport outlines, it wouldn't always unique as viewports may overlap.
// Therefore, we have to use a workaround here to make it use for simple single-viewport sheets at least.
//
// @returns {number|-1} Either -1 or a valid viewportId.
var chooseViewportId = function chooseViewportId(model) {

  var data = model.getData();
  var viewports = data.viewports;
  if (!viewports) {
    return -1;
  }

  // find viewport with maximum number of dbIds    
  var vpIndex = -1;
  var maxDbIds = -1;
  for (var i = 0; i < viewports.length; i++) {

    // Skip viewports without transform
    var vp = viewports[i];
    if (!vp.transform) {
      continue;
    }

    // Use current vp if it has most dbIds
    var numDbIds = vp.geom_metrics.db_ids;
    if (numDbIds > maxDbIds) {
      vpIndex = i;
      maxDbIds = numDbIds;
    }
  }

  return vpIndex;
};

// A MeasureTransform allows for doing length/area measurements in another coordinate system than the actual shape geometry.
// The transform is applied to all points before doing calculations.
var MeasureTransform = /*#__PURE__*/function () {function MeasureTransform() {_classCallCheck(this, MeasureTransform);}_createClass(MeasureTransform, [{ key: "apply",

    // @param {Vector2} p - Point to be transformed in-place.
    value: function apply(p) {} }]);return MeasureTransform;}();
;


// Sets the pageToModel transform in LMV as MeasureTransform to make measurements consistent with Measure extension.
var DefaultMeasureTransform = /*#__PURE__*/function (_MeasureTransform) {_inherits(DefaultMeasureTransform, _MeasureTransform);var _super = _createSuper(DefaultMeasureTransform);

  function DefaultMeasureTransform(viewer) {var _this;_classCallCheck(this, DefaultMeasureTransform);
    _this = _super.call(this);
    _this.viewer = viewer;return _this;
  }

  // Transform geometry point to the coordinate system in which measurements should be computed and displayed.
  //
  // @param {vector2} p
  //
  // Note: Currently, we do some simplifying assumptions here that may need additional
  //       work to support scenarios with multiple viewports or multiple 2d models.
  _createClass(DefaultMeasureTransform, [{ key: "apply", value: function apply(p) {
      // Get viewportId
      var model = this.viewer.model;
      if (!model) {
        return;
      }

      var vpId = chooseViewportId(model);

      // In case there are no viewports, there still might be a pageToModelTransform,
      // which we need to take into account. This is the case for raster PDF.
      model.pageToModel(p, null, vpId);
    } }]);return DefaultMeasureTransform;}(MeasureTransform);

/***/ }),

/***/ "./extensions/Edit2D/ModifierMask.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/ModifierMask.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModifierMask; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper to check whether certain modifiers are currently hold or not.
// See https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/getModifierState for list of supported keys.
// E.g.:
//  "Control", "Shift", "Alt", ..
var ModifierMask = /*#__PURE__*/function () {

  function ModifierMask() {_classCallCheck(this, ModifierMask);
    // By default, don't check any modifers.
    this.checkedModifiers = {};
  }

  // Add a modifier to be checked. E.g. addCondition("Control", true).
  _createClass(ModifierMask, [{ key: "addCondition", value: function addCondition(modifierName, expectedState) {
      this.checkedModifiers[modifierName] = expectedState;
    }

    // Remove condition - accept any state of this modifier
  }, { key: "removeCondition", value: function removeCondition(modifierName) {
      delete this.checkedModifiers[modifierName];
    }

    // Check if current event meets all modifier conditions
  }, { key: "accepts", value: function accepts(event) {
      for (var key in this.checkedModifiers) {
        var state = event.getModifierState(key);
        var expected = this.checkedModifiers[key];
        if (state !== expected) {
          return false;
        }
      }
      return true;
    } }]);return ModifierMask;}();
;

/***/ }),

/***/ "./extensions/Edit2D/ScreenOverlay.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/ScreenOverlay.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScreenOverlay; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var avp = Autodesk.Viewing.Private;

//
// Utility class for drawing vector overlays in canvas-pixel coords.
//

// Base class for line-based gizmos that can be used in screen overlays
var ScreenOverlayGizmo = /*#__PURE__*/function () {

  function ScreenOverlayGizmo() {_classCallCheck(this, ScreenOverlayGizmo);
    // current opacity value
    this.opacity = 1.0;

    // Fade-in/out transition params
    this.fullOpacity = 1.0; // opacity after full fade-in
    this.fadeTime = 0.5; // in seconds

    // Used by parent ScreenOvelay for fade in/out
    this.fadeAnim = null;
  }

  // Update layer (=screen) coords of the gizmo based latest camera 
  _createClass(ScreenOverlayGizmo, [{ key: "update", value: function update(viewer) {}

    // Return shape representing this gizmo. Used by ScreenOverlay to add/remove shapes from/to layer.
  }, { key: "getShape", value: function getShape() {}

    // Opacity for fade-in/out
  }, { key: "setOpacity", value: function setOpacity(opacity) {
      this.opacity = opacity;
    } }, { key: "getOpacity", value: function getOpacity()
    {return this.opacity;} }, { key: "stopFadeAnim", value: function stopFadeAnim()

    {
      if (this.fadeAnim) {
        this.fadeAnim.stop();
        this.fadeAnim = null;
      }
    } }]);return ScreenOverlayGizmo;}();


// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.
var Line3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo) {_inherits(Line3DGizmo, _ScreenOverlayGizmo);var _super = _createSuper(Line3DGizmo);

  function Line3DGizmo(a, b) {var _this;_classCallCheck(this, Line3DGizmo);
    _this = _super.call(this);

    // 2D shape in pixel coords
    _this.line2D = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]().makeLine(0, 0, 0, 0);

    // 3D world positions
    _this.a = a || new THREE.Vector3();
    _this.b = b || new THREE.Vector3();return _this;
  }_createClass(Line3DGizmo, [{ key: "update", value: function update(

    viewer) {
      // project points to screen
      var p1 = viewer.impl.worldToClient(this.a);
      var p2 = viewer.impl.worldToClient(this.b);

      // update line
      this.line2D.updatePoint(0, p1.x, p1.y);
      this.line2D.updatePoint(1, p2.x, p2.y);
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      _get(_getPrototypeOf(Line3DGizmo.prototype), "setOpacity", this).call(this, opacity);
      this.line2D.style.lineAlpha = opacity;
    } }, { key: "setLine", value: function setLine(

    a, b) {
      this.a.copy(a);
      this.b.copy(b);
    } }, { key: "getShape", value: function getShape()

    {
      return this.line2D;
    } }]);return Line3DGizmo;}(ScreenOverlayGizmo);
;

// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.
var Arrow3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo2) {_inherits(Arrow3DGizmo, _ScreenOverlayGizmo2);var _super2 = _createSuper(Arrow3DGizmo);

  function Arrow3DGizmo(a, b) {var _this2;_classCallCheck(this, Arrow3DGizmo);
    _this2 = _super2.call(this);

    // 2D shape in pixel coords
    _this2.arrow = new _Arrow_js__WEBPACK_IMPORTED_MODULE_2__["default"]();

    // 3D world positions
    _this2.a = a || new THREE.Vector3();
    _this2.b = b || new THREE.Vector3();return _this2;
  }_createClass(Arrow3DGizmo, [{ key: "update", value: function update(

    viewer) {
      // project points to screen
      var p1 = viewer.impl.worldToClient(this.a);
      var p2 = viewer.impl.worldToClient(this.b);

      // update line
      this.arrow.setFrom(p1);
      this.arrow.setTo(p2);
    } }, { key: "getOpacity", value: function getOpacity()

    {
      return this.arrow.style.lineAlpha;
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      this.arrow.line.style.lineAlpha = opacity;
      this.arrow.head.style.fillAlpha = opacity;
    } }, { key: "stopFadeAnim", value: function stopFadeAnim()

    {
      if (this.fadeAnim) {
        this.fadeAnim.stop();
        this.fadeAnim = null;
      }
    } }, { key: "setFrom", value: function setFrom(

    a) {
      this.a.copy(a);
    } }, { key: "setTo", value: function setTo(

    b) {
      this.b.copy(b);
    } }, { key: "getShape", value: function getShape()

    {
      return this.arrow;
    } }]);return Arrow3DGizmo;}(ScreenOverlayGizmo);
;var

ScreenOverlay = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {string}   overlayName - Overlay that is created/owned by this EditLayer. Note that it is also destroyed in dtor, so it should not be shared.
  function ScreenOverlay(viewer) {var overlayName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Edit2D.ScreenOverlay';_classCallCheck(this, ScreenOverlay);
    this.viewer = viewer;

    this.overlayName = overlayName;
    this.layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](viewer);

    // create overlay scene, with orthographic Camera
    var canvas = viewer.canvas;
    var canvasWidth = canvas.clientWidth;
    var canvasHeight = canvas.clientHeight;
    this.camera = new THREE.OrthographicCamera(0, canvasWidth, 0, canvasHeight, -1, 1);

    // Create overlay with EditLayer geometry and ortho camera
    this.viewer.impl.createOverlayScene(overlayName, null, null, this.camera);
    this.viewer.impl.overlayScenes[overlayName].scene.add(this.layer.scene);

    // Make sure that camera is updated on screen resize
    this.onResize = this.onResize.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);

    // Update line gizmos on camera changes
    this.onCameraChange = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // Gizmos whose vertices are attached to 3D world positions
    this.gizmos = [];

    // Avoid default viewer cutplanes for screenspace gizmos
    this.layer.setCutPlanesEnabled(false);

    this.layer.setOverlayCamera(this.camera);
  }_createClass(ScreenOverlay, [{ key: "dtor", value: function dtor()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
      this.viewer.removeOverlayScene(this.overlayName);
    } }, { key: "onResize", value: function onResize()

    {
      // adjust ortho-camera to modified canvas
      this.camera.right = this.viewer.canvas.clientWidth;
      this.camera.bottom = this.viewer.canvas.clientHeight;
      this.camera.updateProjectionMatrix();
      this.update();
    }

    // Checks if a gizmo is currently shown in this overlay
  }, { key: "gizmoVisible", value: function gizmoVisible(gizmo) {
      return this.gizmos.includes(gizmo);
    }

    // Add gizmo (if needed) and fade its opacity 
  }, { key: "fadeInGizmo", value: function fadeInGizmo(gizmo) {var _this3 = this;

      // Choose start opacity
      var startOpacity = this.gizmoVisible(gizmo) ? gizmo.getOpacity() : 0.0;
      var endOpacity = gizmo.fullOpacity;

      // Make sure gizmo is visible
      this.setGizmoVisible(gizmo, true);

      // Avoid overlapping animations
      gizmo.stopFadeAnim();

      // update gizmo opacity on timer
      var onTimer = function onTimer(t) {

        t = avp.smootherStep(t);

        // blend opacity value
        var val = avp.lerp(startOpacity, endOpacity, t);
        gizmo.setOpacity(val);

        _this3.layer.update();
      };

      gizmo.setOpacity(startOpacity);
      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer);
    }

    // Fade-out gizmo and sets it to invisible when done (unless interrupted by fade-In)
  }, { key: "fadeOutGizmo", value: function fadeOutGizmo(gizmo) {var _this4 = this;

      if (!this.gizmoVisible(gizmo)) {
        return;
      }

      // Choose start opacity
      var startOpacity = gizmo.getOpacity();

      // Avoid overlapping animations
      gizmo.stopFadeAnim();

      // update gizmo opacity on timer
      var onTimer = function onTimer(t) {

        t = avp.smootherStep(t);

        // blend opacity value
        var val = avp.lerp(startOpacity, 0.0, t);
        gizmo.setOpacity(val);

        _this4.layer.update();
      };

      // If animation finished without interruptions, set gizmo to invisible
      var onEnd = function onEnd() {
        _this4.setGizmoVisible(gizmo, false);
      };

      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer, onEnd);
    } }, { key: "setGizmoVisible", value: function setGizmoVisible(

    gizmo, visible) {

      // If the gizmo was fading out or faded out before, make sure that the fade-out stops
      // and the full opacity is recovered.
      gizmo.stopFadeAnim();
      gizmo.setOpacity(gizmo.fullOpacity);

      // Check if gizmo is currently visible
      var index = this.gizmos.indexOf(gizmo);
      var wasVisible = index !== -1;

      if (visible == wasVisible) {
        return;
      }

      var shape = gizmo.getShape();
      if (visible) {
        // add gizmo
        this.gizmos.push(gizmo);
        this.layer.addShape(shape);
      } else {
        // remove gizmo
        this.gizmos.splice(index, 1);
        this.layer.removeShape(shape);
      }
      this.update();
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.update();
    } }, { key: "update", value: function update()

    {var _this5 = this;
      // reproject 3D gizmos
      this.gizmos.forEach(function (g) {return g.update(_this5.viewer);});
      this.layer.update();
    } }]);return ScreenOverlay;}();
;

ScreenOverlay.Line3DGizmo = Line3DGizmo;
ScreenOverlay.Arrow3DGizmo = Arrow3DGizmo;

/***/ }),

/***/ "./extensions/Edit2D/SegmentTree.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/SegmentTree.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SegmentTree; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Worker = __webpack_require__(/*! worker-loader?inline!./SegmentTreeWorker */ "./node_modules/worker-loader/dist/cjs.js?inline!./extensions/Edit2D/SegmentTreeWorker.js");

// 
// SegmentTree is a spatial datastructure that helps to quickly find all segments (lines, arcs) within a given 2d bbox.
//

var SegmentType = {
  Line: 1,
  CircularArc: 2,
  EllipticalArc: 3 };


// A segment is an object that describes a single line or arc segment.
// Properties depend on segment type (see functions below)
var createLineSegment = function createLineSegment(x1, y1, x2, y2, vpId) {return { type: SegmentType.Line, x1: x1, y1: y1, x2: x2, y2: y2, vpId: vpId };};
var createCircularArcSegment = function createCircularArcSegment(cx, cy, start, end, radius, vpId) {return { type: SegmentType.CirularArc, cx: cx, cy: cy, start: start, end: end, radius: radius, vpId: vpId };};
var createEllipticalArcSegment = function createEllipticalArcSegment(cx, cy, start, end, major, minor, tilt, vpId) {return { type: SegmentType.EllipticalArc, cx: cx, cy: cy, start: start, end: end, major: major, minor: minor, tilt: tilt, vpId: vpId };};

// Triggers the corresponding callbacks (onLineSegment, onCircularArc...) from a given segment object.
//  @param {Object} s             - Segment object whose data are sent to geomCb
//  @param {Object} geomCallbacks - Provides handlers for different segments. Same as used by VertexBufferReader.
var processSegment = function processSegment(s, geomCallbacks) {
  switch (s.type) {
    case SegmentType.Line:geomCallbacks.onLineSegment(s.x1, s.y1, s.x2, s.y2, s.vpId);break;
    case SegmentType.CirularArc:geomCallbacks.onCircularArc(s.cx, s.cy, s.start, s.end, s.radius, s.vpId);break;
    case SegmentType.EllipticalArc:geomCallbacks.onEllipticalArc(s.cx, s.cy, s.tart, s.end, s.major, s.minor, s.tilt, s.vpId);break;}

};

// Implements required functions to allow organizing segments in a quadtree
var SegmentHandler = /*#__PURE__*/function () {

  function SegmentHandler() {_classCallCheck(this, SegmentHandler);

    // Used BoundsCallback to get segment bboxes
    this.boundsCb = new Autodesk.Viewing.Private.BoundsCallback(new THREE.Box2());

    // Reused tmp values
    this.queryBox = new THREE.Box2();
    this.tmpPoint = new THREE.Vector2();
  }_createClass(SegmentHandler, [{ key: "getSegmentBox", value: function getSegmentBox(

    segment) {
      this.boundsCb.bounds.makeEmpty();
      processSegment(segment, this.boundsCb);
      return this.boundsCb.bounds;
    } }, { key: "getQueryBox", value: function getQueryBox(

    minx, miny, maxx, maxy) {
      // get query box
      this.queryBox.min.set(minx, miny);
      this.queryBox.max.set(maxx, maxy);
      return this.queryBox;
    } }, { key: "intersectsBox", value: function intersectsBox(

    segment, minx, miny, maxx, maxy) {
      var queryBox = this.getQueryBox(minx, miny, maxx, maxy);
      var segmentBox = this.getSegmentBox(segment);
      return queryBox.isIntersectionBox(segmentBox);
    }

    // Note that outPoint is just an {x,y} pair, not a Vector2
  }, { key: "getPoint", value: function getPoint(segment, outPoint) {
      // Just use bbox center for all segment types
      var center = this.getSegmentBox(segment).center(this.tmpPoint);
      outPoint.x = center.x;
      outPoint.y = center.y;
    } }]);return SegmentHandler;}();


var worker;var
SegmentTree = /*#__PURE__*/function () {function SegmentTree() {_classCallCheck(this, SegmentTree);}_createClass(SegmentTree, [{ key: "buildFromModel",

    // Build SegmentTree from 2D vector-data model (PDF or F2D).
    // Note: Make sure that the model is fully loaded - otherwise, the tree will be incomplete.
    value: function buildFromModel(model) {

      // The quadtree must know the extents in advance.
      var box = model.getBoundingBox(true);

      // Init quadtree that manages segments
      this.tree = new Autodesk.Extensions.CompGeom.QuadTree(box.min.x, box.min.y, box.max.x, box.max.y, 0.0, new SegmentHandler());

      if (!worker) {
        worker = new Worker();
      }

      // Add geomtry for all fragments
      var frags = model.getFragmentList();
      var count = frags.getCount();

      this.numProcessed = 0;
      this.totalGeoms = count;

      // Notify the worker with the expected number of geometries
      worker.postMessage({ totalGeoms: count });

      for (var i = 0; i < count; i++) {
        var geom = frags.getGeometry(i);
        this.addGeometry(geom);
      }
    }

    // Adds all segments from a given 2D LineShader geometry.
    //  @param {BufferGeometry} geom
    //
    // Precondition: Can only be called if tree has been initialized and geom is within the bbox used to initialize the tree
  }, { key: "addGeometry", value: function addGeometry(geom) {var _this = this;

      // This is the required geometry data that is required by the VertexBufferReader.
      // The real BufferGeometry instance cannot be serialized.
      var geomData = {
        vb: geom.vb,
        ib: geom.ib,
        vbstride: geom.vbstride,
        numInstances: geom.numInstances,
        unpackXform: geom.unpackXform,
        tIdColor: geom.tIdColor,
        attributes: geom.attributes };


      worker.postMessage([geomData]);
      worker.onmessage = function (e) {
        var batch = e.data;
        for (var i = 0; i < batch.length; i += 9) {
          var type = batch[i];
          switch (type) {
            case 1: // Line Segment
              _this.tree.addItem(createLineSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5]));
              break;
            case 2: // Circular Arc
              _this.tree.addItem(createCircularArcSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5], batch[i + 6]));
              break;
            case 3: // Elliptical Arc
              _this.tree.addItem(createEllipticalArcSegment(batch[i + 1], batch[i + 2], batch[i + 3], batch[i + 4], batch[i + 5], batch[i + 6], batch[i + 7], batch[i + 8]));
              break;
            case 9: // finished
              _this.numProcessed++;
              break;}

        }
      };
    }

    //  @param {Object} geomCallbacks - Visitor that provides callbacks to handle different segments. Same as used by VertexBufferReader.
  }, { key: "enumSegments", value: function enumSegments(minx, miny, maxx, maxy, geomCallbacks) {

      // Find all segments in the tree and invoke corresponding call on GeometryCallback
      this.tree.enumInBox(minx, miny, maxx, maxy, function (s) {return processSegment(s, geomCallbacks);});
    } }]);return SegmentTree;}();

/***/ }),

/***/ "./extensions/Edit2D/Selection.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Selection.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var av = Autodesk.Viewing;var

Selection = /*#__PURE__*/function () {

  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);

    av.EventDispatcher.prototype.apply(this);

    // Keys: shapeIds, Values: shapes
    this.isSelected = {};

    // For mouse-over highlighting. 0 = nothing highlighted (ShapeIds start at 1)
    this.hoveredId = 0;

    // Reused as temporary override style for shapes
    this.tmpStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();

    // Callback function that controls how to modify the style on selected shapes
    this.modifier = function (shape, style) {

      // only modify style for selected or hovered shapes
      var isSelected = _this.isSelected[shape.id];
      var isHovered = shape.id === _this.hoveredId;
      if (!isSelected && !isHovered) {
        return undefined;
      }

      // Create a tmp copy of the initial shape style that is modified to indicate highlighting.
      // Note that we can reuse tmpStyle for multiple shapes, because style modifiers are applied right before drawing.
      _this.tmpStyle.copy(style);

      if (isSelected) {
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      } else {
        // hovered
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.2, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      }

      return _this.tmpStyle;
    };

    this.layer = layer;
    this.onShapeRemoved = this.onShapeRemoved.bind(this);
    this.onLayerCleared = this.onLayerCleared.bind(this);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);

    this.layer.addStyleModifier(this.modifier);

    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone
    // or a RemoveShape action happened.
    this.undoStack = undoStack;
    this.onActionCb = function (a) {return _this.onAction(a);};
    this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

    this.selectionFilters = [this.defaultSelectionFilter];
  }_createClass(Selection, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeStyleModifier(this.modifier);
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);
    } }, { key: "addSelectionFilter", value: function addSelectionFilter(

    filter) {
      this.selectionFilters.push(filter);
    } }, { key: "removeSelectionFilter", value: function removeSelectionFilter(

    filter) {
      var index = this.selectionFilters.indexOf(filter);
      if (index == -1) {
        return false;
      }
      this.selectionFilters.splice(index, 1);
      return true;
    } }, { key: "defaultSelectionFilter", value: function defaultSelectionFilter(

    shapes) {
      return shapes.every(function (s) {return s.selectable;});
    }

    // @param {Shape[]) shapes
  }, { key: "setSelection", value: function setSelection(shapes) {
      // This works for null as well (unlike ES6 default params)
      shapes = shapes || [];

      // shapes must pass selection filters to get selected.
      if (!this.selectionFilters.every(function (sf) {return sf(shapes);})) {
        return;
      }

      var selected = this.getSelectedShapes();

      // Check if the set of ids changed
      var changed = false;
      if (selected.length != shapes.length) {
        changed = true;
      } else {
        // Check if any new shape was not selected before
        for (var i = 0; i < shapes.length; i++) {
          var shape = shapes[i];
          if (!this.isSelected[shape.id]) {
            changed = true;
          }
        }
      }

      if (!changed) {
        return;
      }

      // Add all shapes to this.isSelected
      this.isSelected = {};
      for (var _i = 0; _i < shapes.length; _i++) {
        var _shape = shapes[_i];
        this.isSelected[_shape.id] = _shape;
      }
      this.modified();
    } }, { key: "empty", value: function empty()

    {
      return !Object.keys(this.isSelected).length;
    }

    // Set selection to a single shape. Calling with null clears the selection.
  }, { key: "selectOnly", value: function selectOnly(shape) {
      this.setSelection(shape && [shape]);
    } }, { key: "shapeIsSelected", value: function shapeIsSelected(

    shape) {
      return shape && Boolean(this.isSelected[shape.id]);
    } }, { key: "toggleSelection", value: function toggleSelection(

    shape) {
      var wasSelected = Boolean(this.isSelected[shape.id]);
      this.isSelected[shape.id] = wasSelected ? null : shape;

      this.modified();
    } }, { key: "clear", value: function clear()

    {
      this.setSelection([]);
    }

    // Passes all selected shapes to the callback
  }, { key: "getSelectedShapes", value: function getSelectedShapes() {
      return Object.values(this.isSelected).filter(Boolean);
    } }, { key: "getSelectedIds", value: function getSelectedIds()

    {
      return this.getSelectedShapes().map(function (s) {return s.id;});
    } }, { key: "modified", value: function modified()

    {
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });
    } }, { key: "onAction", value: function onAction()

    {

      if (this.empty()) {
        return;
      }

      // Single-selection: Clear selection if selected shape has gone
      var selected = this.getSelectedShapes();
      if (selected.length == 1) {
        var exists = this.layer.findShapeById(selected[0].id);
        if (!exists) {
          this.clear();
        }
        return;
      }

      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections

      // Create dictionary of all shapes in the layer
      var shapeIdExists = {};
      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});

      // Clear all shapes from selection that don't exist anymore
      selected = selected.filter(function (s) {return shapeIdExists[s.id];});
      this.setSelection(selected);
    } }, { key: "onShapeRemoved", value: function onShapeRemoved(_ref)

    {var shape = _ref.shape;
      if (this.empty()) {
        return;
      }

      // Remove the shape from the selection if found.
      if (this.isSelected[shape.id]) {
        delete this.isSelected[shape.id];
        this.modified();
      }
    } }, { key: "onLayerCleared", value: function onLayerCleared()

    {
      if (this.empty()) {
        return;
      }

      this.clear();
    } }, { key: "setHoveredId", value: function setHoveredId(

    id) {

      if (id === this.hoveredId) {
        return;
      }

      this.hoveredId = id;
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_HOVER_CHANGED });
    }

    // Result may be null if selection is empty
    // @returns {Shape|null}
  }, { key: "getFirstSelected", value: function getFirstSelected() {
      var selected = this.getSelectedShapes();
      return selected.length ? selected[0] : null;
    } }]);return Selection;}();


Selection.Events = {
  SELECTION_CHANGED: 'selectionChanged',
  SELECTION_HOVER_CHANGED: 'selectionHoverChanged' };

/***/ }),

/***/ "./extensions/Edit2D/SolidDefConvert.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/SolidDefConvert.js ***!
  \**********************************************/
/*! exports provided: SolidDefConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidDefConvert", function() { return SolidDefConvert; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);





var tmpVec1 = new THREE.Vector3();
var tmpVec2 = new THREE.Vector3();

// Convert SolidDef float-array to THREE-Vector3
var toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();
  return target.set(ar[0], ar[1], ar[2]);
};

// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is
// assumed that it already ends at the start point of the new edge
//  @param {Path}                     path         - Edit2D path
//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef 
//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to
//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.
//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.
var addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var vertexCount = path.getVertexCount(loopIndex);

  // Add start vertex on first call
  if (vertexCount == 0) {
    var pStart = ce.getStartVertex().getPosition();
    path.addPoint(pStart[0], pStart[1], loopIndex);
  }

  // Add end point - unless this is the last edge of a loop.
  if (!lastLoopEdge) {
    var pEnd = ce.getEndVertex().getPosition();
    path.addPoint(pEnd[0], pEnd[1], loopIndex);
  }

  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.
  var isCoedge = ce instanceof _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Coedge"];
  var e = isCoedge ? ce.getEdge() : ce;

  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because
  // cedge as well as edge have their own isReversed flag.
  var ceReversed = isCoedge ? ce.isReversed() : false;
  var edgeReversed = e.isReversed();
  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)

  var type = e.getCurveType();

  // For line segments, we are done
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].LINE) {
    return;
  }

  // convert curve parameters for new edge
  var edgeIndex = Math.max(vertexCount - 1, 0);
  var curve = e.getCurve();

  // Bezier case
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].BCURVE) {

    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:
    //  1. Coedge or edge may be reversed (which may invert the order of the control points)
    //  2. The edge may not cover the whole curve, but only a part of it.
    //
    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.

    // get params at edge start/end
    var t0 = ce.t0();
    var t1 = ce.t1();

    // get start/end point
    var _pStart = ce.evaluatePosition(t0);
    var _pEnd = ce.evaluatePosition(t1);

    // get start/end tangent
    var tStart = ce.evaluateDt(t0);
    var tEnd = ce.evaluateDt(t1);

    // We are searching for a cubic Bezier B with the following properties:
    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex
    //  - Tangents at start/end positions are the same as for the given edge.

    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.
    var rangeScale = Math.abs(t1 - t0);
    tStart[0] *= rangeScale;
    tStart[1] *= rangeScale;
    tEnd[0] *= rangeScale;
    tEnd[1] *= rangeScale;

    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.
    // Same principle applies to cp2.
    var cp1x = _pStart[0] + tStart[0] / 3;
    var cp1y = _pStart[1] + tStart[1] / 3;
    var cp2x = _pEnd[0] - tEnd[0] / 3;
    var cp2y = _pEnd[1] - tEnd[1] / 3;

    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
    return;
  }

  // Ellipse arcs
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].ELLIPSE) {

    var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
    params.rx = curve.getMajorRadius();
    params.ry = curve.getMinorRadius();

    // compute axis rotation
    var xAxis = curve.getMajorAxis();
    var angle = Math.atan2(xAxis[1], xAxis[0]);
    params.rotation = THREE.Math.radToDeg(angle);

    // determine largeArc flag
    // Note that the edge may only use a subset of the curve. 
    // So, it's essential to get the range from the directed edge.
    var range = ce.getRange();
    var startAngle = range[0];
    var endAngle = range[1];
    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle

    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).
    // But it may be inverted if the edge direction is flipped.
    params.sweepFlag = !isReversed;

    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).
    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse
    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.
    //       If this happens, we have to invert the ellipse orientation.
    var yAxis = curve.getMinorAxis();
    var xDir = toVec3(xAxis, tmpVec1);
    var yDir = toVec3(yAxis, tmpVec2);
    var needsExtraFlip = xDir.cross(yDir).z < 0;
    if (needsExtraFlip) {
      params.sweepFlag = !params.sweepFlag;
    }

    path.setEllipseArc(edgeIndex, params, loopIndex);
    return;
  }

  console.error("Unexpected curve type");
};

// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.
//  @param {SolidDef.Loop} loop
//  @param {Path}          [target]
//  @returns {Path}
var loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // start new loop in target path
  var loopIndex = target.nextFreeLoop();

  // traverse coedges of the loop
  var coedges = loop.getCoedges();
  for (var i = 0; i < coedges.length; i++) {
    var ce = coedges[i];

    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex
    var lastLoopEdge = i == coedges.length - 1;

    // add next edge to target
    addCoedge(target, ce, loopIndex, lastLoopEdge);
  }

  return target;
};

// Convert SolidDef face into one or more Edit2D Paths.
// Todo: If we support multiple loops per Path, result will be a single Path
//  @param {SolidDef.Face} face
//  @param {Path}          [target]
//  @returns {Path}
var faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // convert loops and collect them into target path
  face.getLoops().forEach(function (l) {
    target = loopToShape(l, target);
  });
  return target;
};

// Convert array of faces to array of shapes
var facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  faces.forEach(function (f) {
    target = faceToShape(f, target);
  });
  return target;
};

// Convert SolidDef wire to an Edit2D Path.
//
// Note: This function only works for wires that don't branch and have already ordered edges.
//       This is true for wires that we get from SolidDef.Path.
//  @param {SolidDef.Wire} wire
var wireToShape = function wireToShape(wire) {

  // create empty path
  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  path.isClosed = wire.isClosed();

  // add edges    
  var edges = wire.getOrderedEdges().edges;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;
    addCoedge(path, edge, 0, lastLoopEdge);
  }
  return path;
};

// Convert SolidDef path to an array of shapes
var pathToShape = function pathToShape(path) {
  var body = path.getWireBody();
  var wires = body.getWires();

  if (wires.length == 0) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  }

  var result = wireToShape(wires[0]);

  // convert additional loops (if any)
  for (var i = 1; i < wires.length; i++) {
    var wire = wires[i];
    var tmp = wireToShape(wire);
    result.addLoop(tmp, 0);
  }

  return result;
};

// Convert Edit2D Path to SolidDef Path2D
var toSolidDefPath = function toSolidDefPath(path) {
  var path2D = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Path2D"]();
  Object(_EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["runPath"])(path2D, path);
  return path2D;
};

var SolidDefConvert = {
  addCoedge: addCoedge,
  loopToShape: loopToShape,
  faceToShape: faceToShape,
  facesToShape: facesToShape,
  wireToShape: wireToShape,
  pathToShape: pathToShape,
  toSolidDefPath: toSolidDefPath };

/***/ }),

/***/ "./extensions/Edit2D/Svg.js":
/*!**********************************!*\
  !*** ./extensions/Edit2D/Svg.js ***!
  \**********************************/
/*! exports provided: Svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CompGeom_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CompGeom/bezier.js */ "./extensions/CompGeom/bezier.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}



var domParser = null;

// SVG (de)serialization for EditShapes

// Url of XML-Namespace for SVG
var SvgNs = "http://www.w3.org/2000/svg";

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var domToCircle = function domToCircle(circleNode) {

  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {
    throw 'No attributes available on the <circle/> node';
  }
  var circle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]();
  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {
    var attr = circleNode.attributes[i];
    switch (attr.name) {
      case 'cx':
        circle.centerX = parseFloat(attr.value);
        break;
      case 'cy':
        circle.centerY = parseFloat(attr.value);
        break;
      case 'r':
        circle.radius = parseFloat(attr.value);
        break;}

  }
  return circle;
};

var circleToSvg = function circleToSvg(circle) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var stylePostFix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "<circle cx=\"".concat(limitDigits(circle.centerX, digits), "\" cy=\"").concat(limitDigits(circle.centerY, digits), "\" r=\"").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, "\"/>");
};

var domToPath = function domToPath(pathNode) {

  var d = pathNode.getAttribute('d');
  if (!d) {
    return;
  }

  return parsePath(d);
};

// For closed paths, remove last point of each loop if it is just a repetition of the start vertex.
var removeDuplicateLoopEndPoints = function removeDuplicateLoopEndPoints(path) {

  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
  if (path.isClosed) {
    var pStart = new THREE.Vector2();
    var pEnd = new THREE.Vector2();
    var loopCount = path.loopCount;
    for (var l = 0; l < loopCount; l++) {

      // skip invalid loops
      var lastIndex = path.getVertexCount(l) - 1;
      if (lastIndex < 1) {
        continue;
      }

      // get start/end
      pStart = path.getPoint(0, l, pStart);
      pEnd = path.getPoint(lastIndex, l, pEnd);

      var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(pStart, pEnd, 0);
      if (!delta) {
        path.removePoint(lastIndex, l);
      }

    }
  }
};

var parsePath = function parsePath(svgPath) {
  // split at all chars but keep the char using positive look ahead
  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
  // results into list with glyph with position array:
  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);
  var validChars = "MLHVCZA";

  // Reused per cycle
  var ellipseParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var nextPoint = new THREE.Vector2();

  // the current loop that we are adding edges to
  var loopIndex = 0;

  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();

  for (var i = 0; i < pointStrings.length; i++) {

    // Check for unexpected characters
    var pointString = pointStrings[i];
    if (validChars.indexOf(pointString[0]) === -1) {
      throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);
    }

    var segmentIndex = path.getVertexCount(loopIndex) - 1;

    // Determine edge type, position, and extra params for arcs
    var value = pointString.substring(1);
    switch (pointString[0]) {
      case 'M':
        // start new loop
        loopIndex = path.nextFreeLoop();
      case 'L':
        var coords = value.split(',');
        nextPoint.x = parseFloat(coords[0]);
        nextPoint.y = parseFloat(coords[1]);
        break;
      case 'H':
        nextPoint.x = parseFloat(value);
        break;
      case 'V':
        nextPoint.y = parseFloat(value);
        break;
      case 'C':

        // tokenize params
        var bezierCoords = value.split(',');

        // get position
        nextPoint.x = parseFloat(bezierCoords[4]);
        nextPoint.y = parseFloat(bezierCoords[5]);

        // get bezier params                
        var cp1x = parseFloat(bezierCoords[0]);
        var cp1y = parseFloat(bezierCoords[1]);
        var cp2x = parseFloat(bezierCoords[2]);
        var cp2y = parseFloat(bezierCoords[3]);

        if (segmentIndex >= 0) {
          path.setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "C" command');
        }
        break;

      case 'A':
        // tokenize params
        var src = value.split(',');

        // get position
        nextPoint.x = parseFloat(src[5]);
        nextPoint.y = parseFloat(src[6]);

        // read ellipse params.                
        ellipseParams.rx = parseFloat(src[0]);
        ellipseParams.ry = parseFloat(src[1]);
        ellipseParams.rotation = parseFloat(src[2]);
        ellipseParams.largeArcFlag = Boolean(parseFloat(src[3]));
        ellipseParams.sweepFlag = Boolean(parseFloat(src[4]));

        if (segmentIndex >= 0) {
          path.setEllipseArc(segmentIndex, ellipseParams, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "A" command');
        }
        break;
      case 'Z':
        // we are done
        path.isClosed = true;
        continue;}


    // add next point
    path.addPoint(nextPoint.x, nextPoint.y, loopIndex);
  }

  removeDuplicateLoopEndPoints(path);

  return path;
};

var pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!path.vertexCount) {
    return [];
  }

  // Shortcut for restricting number of digits
  var ld = function ld(num) {return limitDigits(num, digits);};

  var svgPath = [];

  // reused per loop cycle
  var p = new THREE.Vector2();
  var pPrev = new THREE.Vector2();
  var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var cp1 = new THREE.Vector2();
  var cp2 = new THREE.Vector2();

  var loopCount = path.loopCount;
  for (var l = 0; l < loopCount; l++) {

    // Add M command for first vertex
    var edgeCount = path.getEdgeCount(l);
    if (edgeCount > 0) {
      p = path.getPoint(0, l, p);
      svgPath.push("M ".concat(ld(p.x), ",").concat(ld(p.y)));
    }

    for (var i = 0; i < edgeCount; i++) {

      // Vertex i is the end point of segment i-1, which defines edge type and arc params
      var segmentIndex = i;
      var edgeType = path.isPath() ? path.getEdgeType(segmentIndex, l) : _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line;

      // get next point. Note: If the path is closed, p will be the start vertex of the loop again.
      var edgeEndVertex = path.nextIndex(segmentIndex, l);
      p = path.getPoint(edgeEndVertex, l, p);

      var value = '';
      switch (edgeType) {

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:
          params = path.getEllipseArcParams(segmentIndex, l, params);

          // Convert boolean flags to 1/0
          var largeArc = params.largeArcFlag ? 1 : 0;
          var sweep = params.sweepFlag ? 1 : 0;

          value = "A ".concat(params.rx, ",").concat(params.ry, ",").concat(params.rotation, ",").concat(largeArc, ",").concat(sweep, ",").concat(p.x, ",").concat(p.y);
          break;

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:
          cp1 = path.getControlPoint(segmentIndex, 1, l, cp1);
          cp2 = path.getControlPoint(segmentIndex, 2, l, cp2);
          value = "C ".concat(ld(cp1.x, digits), ",").concat(ld(cp1.y, digits), ",").concat(ld(cp2.x, digits), ",").concat(ld(cp2.y, digits), ",").concat(ld(p.x, digits), ",").concat(ld(p.y, digits));
          break;

        default:
          {
            // skip empty/duplicate points
            pPrev = path.getPoint(i, l, pPrev);
            var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(pPrev, p, digits);
            if (!delta) {
              continue;
            }

            if (Math.abs(delta.x) <= precision) {
              value = "V ".concat(ld(p.y));
            } else if (Math.abs(delta.y) <= precision) {
              value = "H ".concat(ld(p.x));
            } else {
              value = "L ".concat(ld(p.x), ",").concat(ld(p.y));
            }
          }}


      // For closed paths, the edge end vertex will be 0. Repeating the start vertex is only necessary if the
      // last segment is an arc: Without repeating the start vertex at the loop end, we could not store the arc parameters in SVG.
      var isRepeatedStartVertex = edgeEndVertex === 0;
      if (isRepeatedStartVertex && edgeType === _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
        // Last segment of the loop is a line. We don't need to repeat the start vertex in this case.
        continue;
      }

      svgPath.push(value);
    }

    // For a closed path, repeat the end vertex. This is necessary to preserve arc params
    if (path.isClosed) {
      // close loop
      svgPath.push('Z');
    }
  }

  return svgPath;
};

// Extract dictionary of SVG style attributes from Edit2D style
//  @param {Style} style
//  @returns {Object}
var getSvgStyleAttributes = function getSvgStyleAttributes(style) {

  var target = {};
  target["stroke"] = style.lineColor;
  target["fill"] = style.fillColor;
  target["stroke-width"] = style.lineWidth;

  // omit opacities if they are 1 (default)
  if (style.lineAlpha != 1) target["stroke-opacity"] = style.lineAlpha;
  if (style.fillAlpha != 1) target["fill-opacity"] = style.fillAlpha;

  return target;
};

// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it
// to other attributes, it contains a preceding space. 
// Example: ' stroke="rgb(0,0,0)" fill="rgb(0,0,255)" ... '
var getAttributePostFix = function getAttributePostFix(attribs) {
  var str = '';
  for (var key in attribs) {
    str += " ".concat(key, "=\"").concat(attribs[key], "\"");
  }
  return str;
};

// Apply all given attributes to a Dom Element
var applyAttributes = function applyAttributes(domElement, attribs) {
  for (var key in attribs) {
    domElement.setAttribute(key, attribs[key]);
  }
};

// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),
// style attributes are only exported if specified in options.
//
// @param {Shape} shape
// @param {Object} [options]
// @param {number} [options.precision=0]       - accuracy for unifying duplicate points 
// @param {number} [options.digis=0]           - number of digits for number strings 
// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes
//
// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.
var toSvg = function toSvg(shape, options) {

  var precision = options && options.precision || 0;
  var digits = options && options.digits || null; // means no limitation of digits
  var exportStyle = options && options.exportStyle || false;

  // add style params if wanted
  var stylePostfix = '';
  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    stylePostfix = getAttributePostFix(attribs);
  }

  // Legacy: Keep old code using that still passes precision/digits separately
  // Todo: Remove this when checked with clients.
  if (_typeof(options) !== 'object') {
    if (typeof arguments[1] == 'number') precision = arguments[1];
    if (typeof arguments[2] == 'number') digits = arguments[2];
  }

  if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]) {
    return circleToSvg(shape, digits, stylePostfix);
  }

  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  // PolyBase and Path are translated to SVG Path
  var path = pathToSvgPath(shape, precision, digits);

  return "<path d=\"".concat(path.join(' '), "\"").concat(stylePostfix, "/>");
};

// see toSvg for options.
var createSvgShape = function createSvgShape(shape, options) {
  var precision = options && options.precision || 0;
  var digits = options && options.digits || 0;
  var exportStyle = options && options.exportStyle || true;

  // Todo: support circles and other shapes if anyone needs it.
  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  var path = document.createElementNS(SvgNs, 'path');
  path.setAttribute('d', pathToSvgPath(shape, precision, digits));

  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    applyAttributes(path, attribs);
  }

  return path;
};

// @param {string}  svg - e.g. '<path d="M 13.882,4.8592 L 14.6757,4.738"/>'
var fromSvg = function fromSvg(svg) {
  if (!svg) {
    return;
  }

  // init on first use
  domParser = domParser || new DOMParser();

  var dom = domParser.parseFromString(svg, 'application/xml');

  if (dom.childNodes.length !== 1) {
    throw 'Function does only support svg with a single element: path, circle';
  }
  var node = dom.firstChild;
  if (node.nodeName === 'circle') {
    return domToCircle(node);
  } else
  if (node.nodeName === 'path') {
    return domToPath(node);
  }

  throw "Unsupported svg node type: ".concat(node.nodeName);
};

// Converts several shapes to an SVG element.
//  @param {Object} [options]
//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.
//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.
// see toSvg() for other options
var createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // get summed box of all shapes
  var sumBox = new THREE.Box2();
  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});

  var srcBox = options.srcBox || sumBox;
  var dstBox = options.dstBox || sumBox;

  // Note that we always have to swap y-axis, because the y-axis direction is flipped when 
  // converting 2D world coords in LMV to SVG.
  var scaleOptions = {
    preserveAspect: true,
    flipY: true };

  var tf = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getFitToBoxTransform(srcBox, dstBox, scaleOptions);

  // get required size of svg
  var width = dstBox.max.x - dstBox.min.x;
  var height = dstBox.max.y - dstBox.min.y;

  // create svg root element      
  var svg = document.createElementNS(SvgNs, 'svg');
  svg.setAttribute('height', width);
  svg.setAttribute('width', height);

  // rescale & convert each shape
  shapes.forEach(function (shape) {
    var scaledShape = shape.clone().applyMatrix4(tf);
    var path = createSvgShape(scaledShape, options);
    svg.appendChild(path);
  });

  return svg;
};

var Svg = {
  toSvg: toSvg,
  fromSvg: fromSvg,
  createSvgShape: createSvgShape,
  createSvgElement: createSvgElement };

/***/ }),

/***/ "./extensions/Edit2D/TangentGizmo.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/TangentGizmo.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TangentGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // A tangent gizmo is a dashed line with two vertex gizmos at the end.
// It is used to control tangents for Bezier arcs.






var tangentGizmoName = function tangentGizmoName(vertexIndex, loopIndex, sideIndex) {
  return "TangentGizmo-$loopIndex-$vertexIndex-$sideIndex";
};

// Indicates which endpoint of the tangent is being dragged
var DragIndex = {
  None: -1, // Nothing dragged
  Start: 0, // Dragging start point
  End: 1 // Dragging end point
};

var tmpVec = new THREE.Vector2();var

TangentGizmo = /*#__PURE__*/function () {

  function TangentGizmo(path, index, loopIndex, layer, gizmoLayer, gizmoManager, undoStack) {_classCallCheck(this, TangentGizmo);

    this.path = path;
    this.gizmoLayer = gizmoLayer;
    this.layer = layer;
    this.gizmoManager = gizmoManager; // Used to track which gizmo is under mouse
    this.undoStack = undoStack;

    // index of the vertex whose tangent we control
    this.index = index;
    this.loopIndex = loopIndex;

    // dashed tangent line
    this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]();
    this.lineVisible = false;

    // configure style of dashed line
    this.line.style.isScreenSpace = true;
    this.line.style.lineColor = 'rgb(255, 0, 255)',
    this.line.style.lineWidth = 1.0,
    this.line.style.lineStyle = 10;
    this.line.style.lineAlpha = 1.0;

    // VertexGizmos at both ends of the tangent line
    this.vertexGizmo1 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 1));
    this.vertexGizmo2 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 2));

    // Hide vertex gizmos until we have proper positions
    this.vertexGizmo1.setVisible(false);
    this.vertexGizmo2.setVisible(false);

    // Start/end vertex of tangent Gizmo
    this.pStart = new THREE.Vector2();
    this.pEnd = new THREE.Vector2();

    // Add this to main layer. This triggers this.update() on layer updates to respond to
    // vertex position changes.
    this.layer.addCanvasGizmo(this);

    // 0: dragging startPoint, 1: dragging endPoint, 2: nothing dragged
    this.dragIndex = DragIndex.None;

    // Last tracked dragging position for currently dragged vertex
    this.lastDragPos = new THREE.Vector2(); // in layer coords

    // When dragging vertices, we store the offset (in layer-coords) between 
    // the accurate click position and the center of the clicked vertex gizmo
    this.dragOffset = new THREE.Vector2(0, 0); // in pixels

    // An action used during a drag operation
    this.action = null;

    this.update();
  }_createClass(TangentGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
      this.layer.removeCanvasGizmo(this);
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      this.vertexGizmo1.setVisible(visible);
      this.vertexGizmo2.setVisible(visible);

      // Show/Hide tangent line gizmo
      if (visible !== this.lineVisible) {
        if (visible) {
          this.gizmoLayer.addShape(this.line);
        } else {
          this.gizmoLayer.removeShape(this.line);
        }
      }
      this.lineVisible = visible;
    } }, { key: "update", value: function update()

    {

      // get index of previous edge (ending at the vertex)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);

      // prev/next edge may not exist in case of polyline paths
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Check which of the adjacent edges are arcs
      var prevIsArc = prevEdgeExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex);
      var nextIsArc = nextEdgeExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex);

      // If none of the edges is an Arc, just hide all gizmos
      if (!prevIsArc && !nextIsArc) {
        this.setVisible(false);
        return;
      }

      // Compute both endpoints of tangent gizmo
      var p = this.path.getPoint(this.index, this.loopIndex, tmpVec);
      if (nextIsArc) {

        // End point is first control point of the arc starting at p
        this.pEnd = this.path.getControlPoint(this.index, 1, this.loopIndex, this.pEnd);

        // In general, the start point would be cp2 of the previous arc. 
        // But, we enforce tangents to be identical for previous edge and next edge.
        // Therefore, we obtain the other endpoint by mirroring the tangent of the leaving edge
        // on point p
        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pEnd, p, this.pStart);
      } else {
        // Only previous edge is an arc: We have to obtain the tangent from
        // control point 2 of the previous edge.
        this.pStart = this.path.getControlPoint(prevEdgeIndex, 2, this.loopIndex, this.pStart);

        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pStart, p, this.pEnd);
      }

      // update vertex gizmos
      this.vertexGizmo1.setPosition(this.pStart.x, this.pStart.y);
      this.vertexGizmo2.setPosition(this.pEnd.x, this.pEnd.y);

      // update line gizmo
      this.line.makeLine(this.pStart.x, this.pStart.y, this.pEnd.x, this.pEnd.y);
      this.gizmoLayer.update();

      this.setVisible(true);
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "updateAction", value: function updateAction(pStart, pEnd) {

      // Init action for the current drag-interaction (if needed)
      if (!this.action) {
        this.action = new _Actions_js__WEBPACK_IMPORTED_MODULE_3__["Actions"].ChangeBezierTangent(this.layer, this.path, this.index, this.loopIndex, pStart, pEnd);
      } else {
        // However, for this specific action, it makes no difference.            
        this.action.setTangent(pStart, pEnd);
      }

      // In general, we need to undo() an action before calling redo() again. But, for this specific action,
      // it does not make a difference, because we are overwriting the same control points.
      this.action.redo();

      // update gizmos
      this.update();
    }

    // @param {Vector2} newPos - new position in layer coords
  }, { key: "onStartVertexMoved", value: function onStartVertexMoved(startPos) {
      // get new tangent end point by mirroring on vertex position
      var center = this.path.getPoint(this.index, this.loopIndex);
      var endPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(startPos, center);

      this.updateAction(startPos, endPos);
    }

    // @param {Vector2} startPos - new position in layer coords
  }, { key: "onEndVertexMoved", value: function onEndVertexMoved(endPos) {
      // get new tangent start point by mirroring on vertex position
      var center = this.path.getPoint(this.index, this.loopIndex);
      var startPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(endPos, center);

      this.updateAction(startPos, endPos);
    }

    // @param {DragIndex} dragIndex
  }, { key: "startDrag", value: function startDrag(canvasX, canvasY, dragIndex) {

      this.dragIndex = dragIndex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = dragIndex === DragIndex.Start ? this.pStart : this.pEnd;
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - canvasX, vposScreen.y - canvasY);

      this.lastDragPos.copy(vpos);
    }

    // process last position and finish dragging
  }, { key: "endDrag", value: function endDrag(canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);

      // Mark action as finished. It is important to do this before running the action,
      // because PolygonEditTool cancels unfinished dragging operations on external actions.
      this.dragIndex = DragIndex.None;

      // apply the action
      if (this.action) {
        this.undoStack.run(this.action);
        this.action = null;
      }
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (!this.isDragging()) {
        return;
      }

      this.dragIndex = DragIndex.None;
      this.action && this.action.undo();
      this.action = null;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      // Compute canvas position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Move tangent vertex by dx/dy
      if (this.dragIndex === DragIndex.Start) {
        this.onStartVertexMoved(p);
      } else if (this.dragIndex === DragIndex.End) {
        this.onEndVertexMoved(p);
      }

      this.layer.update();
    }

    // @returns {bool} true if dragging started
  }, { key: "onButtonDown", value: function onButtonDown(canvasX, canvasY) {

      var startDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo1);
      var endDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo2);

      if (!startDragged && !endDragged) {
        return false;
      }

      var dragIndex = startDragged ? DragIndex.Start : DragIndex.End;
      this.startDrag(canvasX, canvasY, dragIndex);

      return true;
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.dragIndex !== DragIndex.None;
    } }]);return TangentGizmo;}();
;

/***/ }),

/***/ "./extensions/Edit2D/Trackings.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Trackings.js ***!
  \****************************************/
/*! exports provided: Trackings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Trackings", function() { return Trackings; });
var Drag = 'drag';
var Click = 'click';
var ButtonDown = 'buttonDown';
var ButtonUp = 'buttonUp';

var Trackings = {
  ButtonDown: ButtonDown,
  ButtonUp: ButtonUp,
  Click: Click,
  Drag: Drag };

/***/ }),

/***/ "./extensions/Edit2D/UndoStack.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/UndoStack.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoStack; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;var

UndoStack = /*#__PURE__*/function () {

  function UndoStack() {_classCallCheck(this, UndoStack);

    av.EventDispatcher.prototype.apply(this);

    // Array of action objects
    this.stack = [];

    // By default, this simply points to the end of this.stack. Only if undo has been called, 
    // it points to the next operation to be run on a redo() call
    this.current = 0;
  }

  // Executes an action and pushes it to the undo stack
  _createClass(UndoStack, [{ key: "run", value: function run(action) {
      // If we did a couple of undos before, a new operation will clear all redo steps
      this.stack.length = this.current;

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });

      this.stack.push(action);
      this.current = this.stack.length;
    } }, { key: "undo", value: function undo()

    {
      if (!this.current) {
        // We reached the beginning of the stack
        return false;
      }
      this.current--;

      var action = this.stack[this.current];

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });

      action.undo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });

      action.layer.update();

      return true;
    } }, { key: "redo", value: function redo()

    {
      var action = this.stack[this.current];
      if (!action) {
        // Nothing to redo
        return false;
      }

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });

      this.current++;

      action.layer.update();

      return true;
    } }, { key: "clear", value: function clear()

    {
      this.stack.length = 0;
      this.current = 0;
    } }]);return UndoStack;}();


// Events sent before/after any action is executed by UndoStack
UndoStack.BEFORE_ACTION = 'beforeAction';
UndoStack.AFTER_ACTION = 'afterAction';

/***/ }),

/***/ "./extensions/Edit2D/UnitHandler.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/UnitHandler.js ***!
  \******************************************/
/*! exports provided: UnitHandler, SimpleUnitHandler, DefaultUnitHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitHandler", function() { return UnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleUnitHandler", function() { return SimpleUnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUnitHandler", function() { return DefaultUnitHandler; });
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var avp = Autodesk.Viewing.Private;

// Interface to control display of length/area units.
var UnitHandler = /*#__PURE__*/function () {

  function UnitHandler() {_classCallCheck(this, UnitHandler);
    // Optional: Returns a transform that is applied to all points for length/area calculations.
    //  @returns {MeasureTransform}
    this.measureTransform = null;
  }

  // @param   {number} val - length in layer coords
  // @returns {string} String to display, including units.
  _createClass(UnitHandler, [{ key: "lengthToString", value: function lengthToString(val) {
      console.error('Not implemented');
    }

    // @param   {number} val - area in layer coords
    // @returns {string} String to display - including units.
  }, { key: "areaToString", value: function areaToString(val) {
      console.error('Not implemented');
    } }]);return UnitHandler;}();
;

// If nothing is specified, we display with 2 digits and assume all unit in inches.
var DefaultPrecision = 2;
var DefaultUnits = "inch";

// Format length / area strings based on:
//  - layerUnits:  We assume the layer to be specified in these units.
//  - displayUnit: Values are converted from layerUnits to displayUnits for display
//  - precision:   Number of digits shown
//  - scaleFactor: Optional scale factor applied to all values
var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);var _super = _createSuper(SimpleUnitHandler);

  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);
    _this = _super.call(this);

    _this.viewer = viewer;

    _this.config = {
      // {string} We assume layers to be in these units (in GNU units format)
      layerUnits: DefaultUnits,

      // {string} Units in which we display lengths/areas (in GNU units format)
      displayUnits: DefaultUnits,

      // {number} Number of digits that we display
      precision: DefaultPrecision,

      // {number} Optional scale factor applied to all values
      scaleFactor: 1.0,

      // {string} Optional area suffix to alter display unit
      areaSuffix: '^2',

      // {boolean} Optional flag for mixed unit measurements such as m-and-cm to fallback to the larger unit
      noMixedArea: false,

      // {boolean} Optional flag for inches and feet, use 'in' and 'ft' over ' and " respectively.
      preferLetters: false };return _this;

  }_createClass(SimpleUnitHandler, [{ key: "lengthToString", value: function lengthToString(

    val) {
      var cfg = this.config;

      // Convert length units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);

      // Format length value with unit string
      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision, { preferLetters: cfg.preferLetters });
    } }, { key: "areaToString", value: function areaToString(

    val) {
      var cfg = this.config;

      // Convert area units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');

      // Format area value with unit string
      var units = cfg.displayUnits ? "".concat(cfg.displayUnits).concat(cfg.areaSuffix) : null;
      return avp.formatValueWithUnits(val, units, 3, cfg.precision, { noMixedArea: cfg.noMixedArea, preferLetters: cfg.preferLetters });
    } }]);return SimpleUnitHandler;}(UnitHandler);


// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model 
// and current settings from MeasureToolExtension:
//  - If MeasureExtension is loaded, it displays in the same way as Measure tools
//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.
//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)
var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);var _super2 = _createSuper(DefaultUnitHandler);

  function DefaultUnitHandler(viewer) {var _this2;_classCallCheck(this, DefaultUnitHandler);
    _this2 = _super2.call(this, viewer);

    _this2.measureTransform = new _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__["DefaultMeasureTransform"](viewer);return _this2;
  }_createClass(DefaultUnitHandler, [{ key: "updateConfig", value: function updateConfig()

    {
      var cfg = this.config;

      // Assume values to be in model units or default units
      var model = this.viewer.model;
      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;

      // Set other configuration values
      var ext = this.viewer.getExtension('Autodesk.Measure');
      var msrCfg = ext && ext.sharedMeasureConfig;
      if (msrCfg) {
        // get from measure extension
        cfg.displayUnits = msrCfg.units;
        cfg.precision = msrCfg.precision;
        cfg.scaleFactor = msrCfg.calibrationFactor || 1.0;
      } else {
        // No Measure extension available => use defaults
        cfg.displayUnits = this.config.layerUnits;
        cfg.precision = DefaultPrecision;
        cfg.scaleFactor = 1.0;
      }
    } }, { key: "lengthToString", value: function lengthToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "areaToString", this).call(this, val);
    } }, { key: "getPrecision", value: function getPrecision()

    {
      this.updateConfig();
      return this.config.precision;
    }

    // Convert from current display units to the given units, considering the scale factor backwards.
  }, { key: "fromDisplayUnits", value: function fromDisplayUnits(toUnits, value) {
      this.updateConfig();
      return avp.convertUnits(this.config.displayUnits, toUnits, 1.0 / this.config.scaleFactor, value);
    }

    // Same for Vec3 value
  }, { key: "fromDisplayUnitsVec3", value: function fromDisplayUnitsVec3(toUnits, vec) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3();
      this.updateConfig();
      target.x = this.fromDisplayUnits(toUnits, vec.x);
      target.y = this.fromDisplayUnits(toUnits, vec.y);
      target.z = this.fromDisplayUnits(toUnits, vec.z);
      return target;
    }

    // Convert from current given fromUnits to display units, considering the current scale factor.
  }, { key: "toDisplayUnits", value: function toDisplayUnits(fromUnits, value) {
      this.updateConfig();
      return avp.convertUnits(fromUnits, this.config.displayUnits, this.config.scaleFactor, value);
    }

    // Same for Vec3 value
  }, { key: "toDisplayUnitsVec3", value: function toDisplayUnitsVec3(fromUnits, vec) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector3();
      this.updateConfig();
      target.x = this.toDisplayUnits(fromUnits, vec.x);
      target.y = this.toDisplayUnits(fromUnits, vec.y);
      target.z = this.toDisplayUnits(fromUnits, vec.z);
      return target;
    }

    // @returns {string} name of the display unit, e.g. "ft" or "m".
  }, { key: "getDisplayUnit", value: function getDisplayUnit() {
      this.updateConfig();
      return this.config.displayUnits;
    }

    // @returns {string} Similar to getDisplayUnit(), but simplifies combined units like "decimal-feet" or "ft-and-fractional-in" stuff to just "ft".
  }, { key: "getMainDisplayUnit", value: function getMainDisplayUnit() {
      var unit = this.getDisplayUnit();
      return Autodesk.Viewing.Private.getMainUnit(unit);
    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);

/***/ }),

/***/ "./extensions/Edit2D/locales.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/locales.js ***!
  \**************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../res/locales/en/nobundle-edit2d.loc */ "./res/locales/en/nobundle-edit2d.loc.json");
var _res_locales_en_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en/nobundle-edit2d.loc */ "./res/locales/en/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_en_GB_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../res/locales/en-GB/nobundle-edit2d.loc */ "./res/locales/en-GB/nobundle-edit2d.loc.json");
var _res_locales_en_GB_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/en-GB/nobundle-edit2d.loc */ "./res/locales/en-GB/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_cs_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../res/locales/cs/nobundle-edit2d.loc */ "./res/locales/cs/nobundle-edit2d.loc.json");
var _res_locales_cs_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/cs/nobundle-edit2d.loc */ "./res/locales/cs/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_de_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../res/locales/de/nobundle-edit2d.loc */ "./res/locales/de/nobundle-edit2d.loc.json");
var _res_locales_de_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/de/nobundle-edit2d.loc */ "./res/locales/de/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_es_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../res/locales/es/nobundle-edit2d.loc */ "./res/locales/es/nobundle-edit2d.loc.json");
var _res_locales_es_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/es/nobundle-edit2d.loc */ "./res/locales/es/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_fr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../res/locales/fr/nobundle-edit2d.loc */ "./res/locales/fr/nobundle-edit2d.loc.json");
var _res_locales_fr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/fr/nobundle-edit2d.loc */ "./res/locales/fr/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_fr_CA_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../res/locales/fr-CA/nobundle-edit2d.loc */ "./res/locales/fr-CA/nobundle-edit2d.loc.json");
var _res_locales_fr_CA_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/fr-CA/nobundle-edit2d.loc */ "./res/locales/fr-CA/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_it_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../res/locales/it/nobundle-edit2d.loc */ "./res/locales/it/nobundle-edit2d.loc.json");
var _res_locales_it_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/it/nobundle-edit2d.loc */ "./res/locales/it/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_ja_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../res/locales/ja/nobundle-edit2d.loc */ "./res/locales/ja/nobundle-edit2d.loc.json");
var _res_locales_ja_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_8___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/ja/nobundle-edit2d.loc */ "./res/locales/ja/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_ko_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../res/locales/ko/nobundle-edit2d.loc */ "./res/locales/ko/nobundle-edit2d.loc.json");
var _res_locales_ko_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_9___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/ko/nobundle-edit2d.loc */ "./res/locales/ko/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_pl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../res/locales/pl/nobundle-edit2d.loc */ "./res/locales/pl/nobundle-edit2d.loc.json");
var _res_locales_pl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_10___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/pl/nobundle-edit2d.loc */ "./res/locales/pl/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_pt_BR_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../res/locales/pt-BR/nobundle-edit2d.loc */ "./res/locales/pt-BR/nobundle-edit2d.loc.json");
var _res_locales_pt_BR_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/pt-BR/nobundle-edit2d.loc */ "./res/locales/pt-BR/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_ru_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../res/locales/ru/nobundle-edit2d.loc */ "./res/locales/ru/nobundle-edit2d.loc.json");
var _res_locales_ru_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_12___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/ru/nobundle-edit2d.loc */ "./res/locales/ru/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_tr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../res/locales/tr/nobundle-edit2d.loc */ "./res/locales/tr/nobundle-edit2d.loc.json");
var _res_locales_tr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/tr/nobundle-edit2d.loc */ "./res/locales/tr/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANS_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../res/locales/zh-HANS/nobundle-edit2d.loc */ "./res/locales/zh-HANS/nobundle-edit2d.loc.json");
var _res_locales_zh_HANS_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_14___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/zh-HANS/nobundle-edit2d.loc */ "./res/locales/zh-HANS/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANT_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../res/locales/zh-HANT/nobundle-edit2d.loc */ "./res/locales/zh-HANT/nobundle-edit2d.loc.json");
var _res_locales_zh_HANT_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_15___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/zh-HANT/nobundle-edit2d.loc */ "./res/locales/zh-HANT/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_zh_HK_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../res/locales/zh-HK/nobundle-edit2d.loc */ "./res/locales/zh-HK/nobundle-edit2d.loc.json");
var _res_locales_zh_HK_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_16___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/zh-HK/nobundle-edit2d.loc */ "./res/locales/zh-HK/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_nl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../res/locales/nl/nobundle-edit2d.loc */ "./res/locales/nl/nobundle-edit2d.loc.json");
var _res_locales_nl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_17___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/nl/nobundle-edit2d.loc */ "./res/locales/nl/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_sv_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../res/locales/sv/nobundle-edit2d.loc */ "./res/locales/sv/nobundle-edit2d.loc.json");
var _res_locales_sv_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_18___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/sv/nobundle-edit2d.loc */ "./res/locales/sv/nobundle-edit2d.loc.json", 1);
/* harmony import */ var _res_locales_da_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../res/locales/da/nobundle-edit2d.loc */ "./res/locales/da/nobundle-edit2d.loc.json");
var _res_locales_da_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_19___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../res/locales/da/nobundle-edit2d.loc */ "./res/locales/da/nobundle-edit2d.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */






















var locales = {
  en: _res_locales_en_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_0__,
  "en-GB": _res_locales_en_GB_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_1__,
  cs: _res_locales_cs_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_2__,
  de: _res_locales_de_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_3__,
  es: _res_locales_es_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_4__,
  fr: _res_locales_fr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_5__,
  "fr-CA": _res_locales_fr_CA_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_6__,
  it: _res_locales_it_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_7__,
  ja: _res_locales_ja_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_8__,
  ko: _res_locales_ko_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_9__,
  pl: _res_locales_pl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_10__,
  "pt-BR": _res_locales_pt_BR_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_11__,
  ru: _res_locales_ru_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_12__,
  tr: _res_locales_tr_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_13__,
  "zh-HANS": _res_locales_zh_HANS_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_14__,
  "zh-HANT": _res_locales_zh_HANT_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_15__,
  "zh-HK": _res_locales_zh_HK_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_16__,
  nl: _res_locales_nl_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_17__,
  sv: _res_locales_sv_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_18__,
  da: _res_locales_da_nobundle_edit2d_loc__WEBPACK_IMPORTED_MODULE_19__ };

/***/ }),

/***/ "./extensions/Edit2D/tools/CopyTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/CopyTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Clipboard.js */ "./extensions/Edit2D/Clipboard.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var CopyToolName = 'Edit2_CopyTool';

var av = Autodesk.Viewing;

// Apply constant offset in x/y for each paste step, so that pasted shapes are not exactly on top of the src shapes.
var PasteOffset = 30;var

CopyTool = /*#__PURE__*/function () {

  function CopyTool(ctx) {var _this = this;_classCallCheck(this, CopyTool);

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.clipboard = ctx.clipboard;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    this.enableCut = false;

    // Track when this tool is posting shapes to the clipboard.
    // Used to avoid modifying the pasteCounter when this tool is posting shapes.
    // This is a reference to the array being posted or null. An array is used rather than
    // a flag in case a clipboard listener posts to the clipboard during a callback.
    this.shapesBeingPosted = null;
    // Tracks the number of times the clipboard contents have been pasted.
    // Pasted shapes are offset whenever the counter is greater than zero.
    // Set the counter to a negative value to prevent offsetting for some pastes.
    this.pasteCounter = 0;

    this.onClipboardContentChanged = function (event) {
      if (event.shapes !== _this.shapesBeingPosted) {
        // Do not apply offset to the first paste of content placed on the clipboard by other code
        // to preserve its location
        _this.pasteCounter = -1;
      }
    };
  }_createClass(CopyTool, [{ key: "register", value: function register()

    {
      this.clipboard.addEventListener(_Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"].CONTENT_CHANGED, this.onClipboardContentChanged);
    } }, { key: "deregister", value: function deregister()

    {
      this.clipboard.removeEventListener(_Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"].CONTENT_CHANGED, this.onClipboardContentChanged);
    } }, { key: "_postSelectedShapesToClipboard", value: function _postSelectedShapesToClipboard()

    {
      var shapes = this.selection.getSelectedShapes();

      this.shapesBeingPosted = shapes;
      this.clipboard.postShapes(shapes);
      this.shapesBeingPosted = null;

      return shapes;
    }


    /**
       * Copy the currently selected shapes to the clipboard.
       *
       * Each time the shapes are pasted, they will be offset from their original positions (first paste)
       * or their last pasted positions. The offset currently doesn't change with the undo/redo of paste operations.
       */ }, { key: "copy", value: function copy()
    {
      this._postSelectedShapesToClipboard();
      this.pasteCounter = 0;
    }

    /**
       * Cut the currently selected shapes to the clipboard.
       *
       * Each time the shapes are pasted, they will be in their original positions (first paste)
       * or offset from their last pasted positions. The offset currently doesn't change with the
       * undo/redo of paste operations.
       */ }, { key: "cut", value: function cut()
    {
      var shapes = this._postSelectedShapesToClipboard();
      // Do not apply offset to the first paste
      this.pasteCounter = -1;

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
    }

    /**
       * Paste clones of the shapes from the clipboard.
       *
       * Pasting will not occur if the BEFORE_PASTE event is vetoed.
       * Shapes may be offset from their original or previously pasted positions depending on
       * how they were posted to the clipboard (whether by this tool's copy/cut operations,
       * or application code)
       */ }, { key: "paste", value: function paste()
    {
      this.pasteCounter++;
      var shapes = this.clipboard.cloneShapes();

      var beforePasteEvent = { type: CopyTool.BEFORE_PASTE, veto: false };
      this.dispatchEvent(beforePasteEvent);
      if (beforePasteEvent.veto) {
        return;
      }

      if (this.pasteCounter > 0) {
        // Compute how far we want to shift the copy that we create.
        // We shift by 30 pixels, then by 60, etc.
        var shapeOffset = this.pasteCounter * PasteOffset * this.layer.getUnitsPerPixel();
        shapes.forEach(function (shape) {return shape.move(shapeOffset, shapeOffset);});
      }

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].AddShapes(this.layer, shapes));
      // Change selection to new shapes
      this.selection.setSelection(shapes);

      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, shapes: shapes });
    }

    /**
       * Delete all selected shapes
       */ }, { key: "delete", value: function _delete()
    {
      var shapes = this.selection.getSelectedShapes();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
      this.selection.clear();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      // Accept command key on Mac as alternative to ctrl.
      var ctrlKey = event.ctrlKey || event.metaKey;

      if (!this.selection.empty()) {
        if (keyCode === av.KeyCode.DELETE) {
          this.delete();
          return true;
        }

        if (ctrlKey) {
          if (keyCode === av.KeyCode.c) {
            this.copy();
            return true;
          }
          if (this.enableCut && keyCode === av.KeyCode.x) {
            this.cut();
            return true;
          }
        }
      }

      if (this.clipboard.hasShapes() && ctrlKey && keyCode === av.KeyCode.v) {
        this.paste();
        return true;
      }

      return false;
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return CopyToolName + this.nameSuffix;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }]);return CopyTool;}();
;

CopyTool.BEFORE_PASTE = "BEFORE_PASTE";
CopyTool.AFTER_PASTE = "AFTER_PASTE";

/***/ }),

/***/ "./extensions/Edit2D/tools/EdgeMoveTool.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EdgeMoveTool.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EdgeMoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}






var EdgeMoveToolName = "Edit2_EdgeMoveTool";

var av = Autodesk.Viewing;

var edgeGizmoName = function edgeGizmoName(index) {
  return 'PolygonEditTool_edgeGizmo_' + index.toString();
};

// Given a Polyline/Polygon and a vertex index, check if the two edges next to 'vertex' are collinear.
// Returns false if vertex does not have 2 different neighbor edges.
var edgesCollinear = function edgesCollinear(poly, vertex, loopIndex) {

  // If polygon/polyline just contains 0 or 1 edges, just return false.
  var vertexCount = poly.getVertexCount(loopIndex);
  if (vertexCount < 3) {
    return false;
  }

  // check if neighbor edges exist
  var isLine = poly.isPolyline();
  var prevExists = !(isLine && vertex === 0);
  var nextExists = !(isLine && vertex === vertexCount - 1);

  // If poly has only 1 edge or 'vertex' is an end vertex of a polyline, stop here.
  if (!prevExists || !nextExists) {
    return false;
  }

  // get points before and after vertex
  var prevIndex = poly.prevIndex(vertex, loopIndex);
  var nextIndex = poly.nextIndex(vertex, loopIndex);

  var precision = 1.e-5;

  var a = poly.getPoint(prevIndex, loopIndex);
  var b = poly.getPoint(vertex, loopIndex);
  var c = poly.getPoint(nextIndex, loopIndex);
  return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].isPointOnLine(b, a, c, precision);
};var

EdgeMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(EdgeMoveTool, _EditToolBase);var _super = _createSuper(EdgeMoveTool);

  function EdgeMoveTool(ctx) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EdgeMoveTool);
    _this = _super.call(this, ctx);

    _this.options = options;
    _this.layer = ctx.layer;
    _this.selection = ctx.selection;
    _this.nameSuffix = "_".concat(ctx.toolSetName);

    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;

    // When dragging an edge, this stores a copy of its original position
    _this.dragEdgeStartPos = {
      a: new THREE.Vector2(),
      b: new THREE.Vector2() };


    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();

    // Index of the edge being dragged or -1
    _this.draggedEdge = null; // {PolyIndex}

    // When dragging an edge, selectedEdge is the same as draggedEdge. After the interaction, draggedEdge is reset to -1, but
    // the edge keeps selected until clicking somewhere else.
    _this.selectedEdge = null; // {PolyIndex}

    // In some cases, we duplicate start/end vertex when beginning to drag an edge. This may shift this.draggedEdge by 1 or 2.
    // draggedEdgeBefore stores the original edgeIndex before duplicating vertices.
    _this.draggedEdgeBefore = null; //{PolyIndex};

    // Reused to store edge normal of dragged edge
    _this.draggedEdgeNormal = new THREE.Vector2();

    // When dragging edges, we store the offset (in layer-coords) between the accurate click position and the center of the clicked edge gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Used when dragging an edge: Indicates whether we had to duplicate
    // start/end vertex of the edge in order to move it.
    _this.duplicateStartVertex = false;
    _this.duplicateEndVertex = false;

    // {EdgeGizmo[][]} Array of Gizmos per loop for moving edges.
    _this.edgeGizmos = [];

    // gizmos are enabled by default.
    _this.gizmosEnabled = true;

    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.
    _this.edgeGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polyline"]();
    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer

    // Displays dashed lines that connect start/end vertex of arc segments
    _this.arcEdgeGizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["ArcEdgeGizmo"](ctx.layer, ctx.gizmoLayer);

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // Constant color for highlighted edges
    _this.edgeHighlightStyle = _this.options.edgeHighlightStyle || new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Style"]({ lineColor: 'rgb(0, 255, 0)' });

    _this.gizmoClassName = _this.options.gizmoClassName;return _this;
  }_createClass(EdgeMoveTool, [{ key: "getName", value: function getName()

    {
      return EdgeMoveToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "deactivate", this).call(this);
      this.reset();
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      if (!this.poly) {
        return;
      }

      this.setSelectedEdge(null);

      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it
      var selectedEdgeGizmo = this.getEdgeIndex();

      if (this.edgeMovePossible() && selectedEdgeGizmo) {
        this.startedDragging = true;
        this.startDragEdge(event, selectedEdgeGizmo);
        return true;
      }

      return false;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleMouseMove", this).call(this, event);

      this.updateEdgeGizmo();

      if (!this.poly) {
        return false;
      }

      if (this.draggedEdge) {
        this.moveDragEdge(event);

        return true;
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleButtonUp", this).call(this, event, button);

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      if (!this.poly) {
        return;
      }

      if (this.draggedEdge) {
        this.endDragEdge();
        return true;
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && wasDragging;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.CancelEdit) {
        handled = this.cancelDrag();
      }

      return handled;
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.
      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedEdge) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    }

    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)
    // (x,y) are in layer-coords
    //  @returns {PolyIndex}
  }, { key: "getEdgeIndex", value: function getEdgeIndex() {
      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        var index = this.gizmoManager.getGizmoIndex(gizmos);
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedEdge) {
        this.restoreDragEdge();
        this.draggedEdge = null;
        needsUpdate = true;
      }

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      this.snapper.clearSnappingGizmos();

      return needsUpdate;
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {

      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {
        this.setSelectedEdge(hint.edge);

        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // If poly was modified from outside, we can't know if the selected vertex or edge
      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.
      this.setSelectedEdge(null);
    } }, { key: "startDragEdge", value: function startDragEdge(

    event, draggedEdge) {
      var edgeIndex = draggedEdge.vertex;
      var loopIndex = draggedEdge.loop;

      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // store edge normal for the edge being dragged
      this.draggedEdgeNormal = this.poly.getLeftEdgeNormal(edgeIndex, loopIndex, this.draggedEdgeNormal);

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, a, b, loopIndex);

      // get edge direction
      var edgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);

      // compute projection of p to the line spanned by the edge
      var pointOnEdge = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(pointOnEdge, a, edgeDir);

      // Set inital dragging point exactly on edge
      this.lastDragPoint.copy(pointOnEdge);

      // Store offset between exact mouse pos and the edge we are dragging
      var edgePosScreen = this.layer.layerToCanvas(pointOnEdge.x, pointOnEdge.y);
      this.dragOffset.set(edgePosScreen.x - event.canvasX, edgePosScreen.y - event.canvasY);

      // store original position of the two edge vertices
      var ia = edgeIndex;
      var ib = (edgeIndex + 1) % this.poly.getVertexCount(loopIndex);
      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia, loopIndex));
      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib, loopIndex));

      // Check if we need to duplicate start and/or end vertex of the edge.
      // This happens when the neighbor edges are collinear with the ones being moved.
      this.duplicateStartVertex = edgesCollinear(this.poly, ia, loopIndex);
      this.duplicateEndVertex = edgesCollinear(this.poly, ib, loopIndex);

      // Duplicate start/end vertices if necessary
      _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.duplicateVertices(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // Store initial edge index (not considering any duplicated vertices)
      this.draggedEdgeBefore = draggedEdge;

      // Select the edge - using its index after duplicating vertices
      var newEdgeIndex = _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.getNewEdgeIndex(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
      var polyIndex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({ vertex: newEdgeIndex, loop: loopIndex });
      this.setSelectedEdge(polyIndex);

      // Set the edge being dragged
      this.draggedEdge = polyIndex;

      // Make sure that all gizmos are updated if we duplicated vertices
      if (this.duplicateStartVertex || this.duplicateEndVertex) {
        this.updateAllGizmos();
      }
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;
      this.draggedEdge = null;
      this.selectedEdge = null;

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      this.lengthLabel.setShape(null);

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }

      var polyline = poly && poly.isPolyline() ? poly : null;
      this.lengthLabel.setShape(polyline);
    }

    // Update edgeGizmos to this.poly or hide all if poly is null
  }, { key: "createEdgeGizmos", value: function createEdgeGizmos() {
      // Make sure that we don't leak outdated ones
      this.clearEdgeGizmos();

      if (!this.gizmosEnabled) {
        // gizmos not enabled, so don't add them.
        return;
      }

      var hasEdgeMoveGizmos = false;

      var loopCount = this.poly ? this.poly.loopCount : 0;
      for (var l = 0; l < loopCount; l++) {

        // Create gizmo per edge
        var edgeCount = this.poly.getEdgeCount(l);

        // For simple lines, we don't show the edge-move gizmo: It does not make sense to
        // move an edge, because you can simply move the whole shape instead.
        var needEdgeMoveGizmos = edgeCount >= 2;

        var gizmos = [];
        if (needEdgeMoveGizmos) {
          for (var i = 0; i < edgeCount; i++) {
            var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["EdgeMoveGizmo"](this.layer, edgeGizmoName(i), undefined, this.gizmoClassName);
            gizmo.attachToEdge(this.poly, i, l);
            gizmos.push(gizmo);
          }

          hasEdgeMoveGizmos = true;
        }

        // add gizmos for this loop
        this.edgeGizmos.push(gizmos);
      }

      // attach arcEdgeGizmo to current shape, so that dashed lines are displayed for its arc segments
      this.arcEdgeGizmo.setPoly(this.poly);

      this.updateEdgeGizmoHighlighting();

      // Shift label a bit up to avoid it from occluding the move-edge gizmo
      var yOffset = hasEdgeMoveGizmos ? 20 : 0;
      this.lengthLabel.pixelOffset.set(0, yOffset);
    } }, { key: "moveDragEdge", value: function moveDragEdge(

    event) {

      if (!this.draggedEdge) {
        return;
      }

      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      // Note that the edge we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a edge gizmo at drag-start.
      var x = event.canvasX + this.dragOffset.x;
      var y = event.canvasY + this.dragOffset.y;

      var p = this.getSnapPosition(x, y);

      // get delta between last and current position
      var delta = p.clone().sub(this.lastDragPoint);

      // get indices of prev and next edge
      var prevEdgeIndex = this.poly.prevEdgeIndex(edgeIndex, loopIndex);
      var nextEdgeIndex = this.poly.nextEdgeIndex(edgeIndex, loopIndex);

      // prev/next edge may not exist if we are at the end of a polyline
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Will contain the new edge endpoints
      var newEdgeA = new THREE.Vector2();
      var newEdgeB = new THREE.Vector2();

      // get edge vertices
      var curEdgeA = new THREE.Vector2();
      var curEdgeB = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, curEdgeA, curEdgeB, loopIndex);

      if (!prevEdgeExists && !nextEdgeExists) {
        // If prev/next are both missing, we are moving an isoldated line segment around.
        // In this case, we can just allow unconstrained moving and are done here.
        newEdgeA.copy(curEdgeA).add(delta);
        newEdgeB.copy(curEdgeB).add(delta);
      } else {

        // get next/previous edge (if existing)
        var prevEdgeA = new THREE.Vector2();
        var prevEdgeB = new THREE.Vector2();
        var nextEdgeA = new THREE.Vector2();
        var nextEdgeB = new THREE.Vector2();
        prevEdgeExists && this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB, loopIndex);
        nextEdgeExists && this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB, loopIndex);

        // Handle start edges of polylines: Choose some "assumed" previous edge if there is none.
        if (!prevEdgeExists) {

          prevEdgeB.copy(curEdgeA);

          if (!this.duplicateEndVertex) {
            // Assume previous edge to be parallel to the next one. In this
            // way, we constrain the movement only along one direction.
            prevEdgeA.copy(nextEdgeB).sub(curEdgeB).add(curEdgeA);
          } else {
            // The second edge was collinear with the first, so we had to add an extra vertex at dragStart.
            // Therefore, nextEdge is degenerated and we cannot use it.
            // For this case, we just assume prevEdge to be perpendicular to the current edge.
            prevEdgeA.copy(curEdgeA).add(this.draggedEdgeNormal);
          }
        }

        // Handle end edges of polylines: Choose some "assumed" next edge if there is none
        if (!nextEdgeExists) {

          nextEdgeA.copy(curEdgeB);

          if (!this.duplicateStartVertex) {
            // Assume next edge to be parallel to the previous one. In this
            // way, we constrain the movement only along one direction.
            nextEdgeB.copy(prevEdgeA).sub(curEdgeA).add(curEdgeB);
          } else {
            // The previous edge was collinear with the current one, so we had to add an extra vertex at dragStart.
            // Therefore, prevEdge is degenerated and we cannot use it.
            // For this case, we just assume nextEdge to be perpendicular to the current edge.
            nextEdgeB.copy(curEdgeB).add(this.draggedEdgeNormal);
          }
        }

        // Compute directions for each edge to intersect
        var prevEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(prevEdgeA, prevEdgeB);
        var curEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(curEdgeA, curEdgeB);
        var nextEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(nextEdgeA, nextEdgeB);

        // Apply move offset
        curEdgeA.add(delta);
        curEdgeB.add(delta);

        // If we added extra vertices, the (newly inserted) neighbor edges will be degenerated
        // and the edge directions will be invalid. In this case, we choose the edge direction
        // perpendicular to the edge that we are dragging.
        if (this.duplicateStartVertex) prevEdgeDir.copy(this.draggedEdgeNormal);
        if (this.duplicateEndVertex) nextEdgeDir.copy(this.draggedEdgeNormal);

        // Compute new edge endpoints as intersection of prev/next edge with the moved line
        if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||
        !_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {
          // If we don't find an intersection, reject this edge move attempt, because
          // it's not possible to move the edge in this way by enlarging the neighbor edges.
          return;
        }
      }

      // get indices of the points to modify
      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      // The intersections gives us the new position for the edge vertices
      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y, loopIndex);
      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y, loopIndex);

      this.gizmoLayer.update();
      this.layer.update();

      this.lastDragPoint.copy(p);

      // We moved the edge => Keep gizmo in-sync
      this.updateEdgeGizmo();
    }

    // While dragging an edge, this function restores the original position at drag start
  }, { key: "restoreDragEdge", value: function restoreDragEdge() {

      if (!this.draggedEdge) {
        return;
      }

      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      var a = this.dragEdgeStartPos.a;
      var b = this.dragEdgeStartPos.b;

      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      this.poly.updatePoint(ia, a.x, a.y, loopIndex);
      this.poly.updatePoint(ib, b.x, b.y, loopIndex);

      // Revert insertion of extra vertices
      _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.revertDuplicateVertices(this.poly, this.draggedEdgeBefore.vertex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // If we duplicated vertices at dragStart and reverted it now,
      // the index of the selected edge may have shifted. So, we must change it to the old one to keep to (visually) keep the same
      // edge selected as before.
      this.selectedEdge = this.draggedEdgeBefore;
    } }, { key: "endDragEdge", value: function endDragEdge()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.draggedEdge) {
        return;
      }
      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      // get final position of the edge vertices
      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      var newPos1 = this.poly.getPoint(ia, loopIndex);
      var newPos2 = this.poly.getPoint(ib, loopIndex);

      this.restoreDragEdge();

      // If the edge was hardly moved at all, we drop the operation. Otherwise, the only effect would be to add invisible
      // vertex duplicates.
      var delta = this.dragEdgeStartPos.a.distanceTo(newPos1) * this.layer.getPixelsPerUnit();
      if (delta >= 3) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge(this.layer, this.poly, this.draggedEdgeBefore, newPos1, newPos2, this.duplicateStartVertex, this.duplicateEndVertex));

        // If the action duplicated vertices, make sure that the selected edge is updated to
        // the index that the selected edge has after the action.
        this.selectedEdge = this.draggedEdge;
      }

      // Reset draggedEdge, but the edge keeps selected (we don't reset this.selectedEdge)
      this.draggedEdge = null;

      // update all gizmos
      this.updateAllGizmos();
    } }, { key: "edgeMovePossible", value: function edgeMovePossible(

    loopIndex) {
      return this.poly && this.poly.getVertexCount(loopIndex) > 2;
    }

    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.
  }, { key: "updateEdgeGizmo", value: function updateEdgeGizmo() {

      // Check if mouse is on an edge gizmo
      var edgeUnderMouse = this.getEdgeIndex(); // {PolyIndex}

      var edgeMovePossible = this.edgeMovePossible();

      // Check if we need any highlight
      var edgeSelected = Boolean(this.poly && this.selectedEdge);
      var edgeHovered = edgeMovePossible && edgeUnderMouse;

      // If edge is an arc and hovered, we just colorize the arcEdgeGizmo and don't need the extra edge-highlight gizmo
      var arcEdgeHovered = edgeHovered && this.poly.isPath() && this.poly.isArc(edgeUnderMouse.vertex, edgeUnderMouse.loop);

      // We show the gizmo if an edge is selected or a line-segment is hovered. If gizmos are not enabled, don't show it
      // regardless of mouse position.
      var gizmoNeeded = this.gizmosEnabled ? edgeSelected || edgeHovered && !arcEdgeHovered : false;

      // Make sure that edge gizmo is shown if needed
      if (gizmoNeeded && !this.edgeGizmoShown) {
        this.gizmoLayer.addShape(this.edgeGizmo);
        this.edgeGizmoShown = true;
      } else
      if (!gizmoNeeded && this.edgeGizmoShown) {
        this.gizmoLayer.removeShape(this.edgeGizmo);
        this.edgeGizmoShown = false;
      }

      // get index of the edge to be highlighted
      var polyIndex = edgeSelected ? this.selectedEdge : edgeUnderMouse; // {PolyBase}
      var edgeToHighlight = polyIndex ? polyIndex.vertex : -1;
      var loopIndex = polyIndex ? polyIndex.loop : -1;

      // Only for arcs: Colorize ArcEdgeGizmo if needed. For hover, this replaces the highlight gizmo. For select, we just set it to the same color to avoid color conflicts.
      var colorizeArcEdge = this.edgeGizmoShown || arcEdgeHovered;
      colorizeArcEdge ? this.arcEdgeGizmo.setEdgeHighlighted(edgeToHighlight, loopIndex, this.edgeHighlightStyle.lineColor) : this.arcEdgeGizmo.clearEdgeHighlighting();

      // If we just had to hide it, we are done here
      if (!gizmoNeeded) {
        return;
      }

      // Update edge gizmo position...

      // get the two vertex positions of the edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeToHighlight, a, b, loopIndex);

      // copy values to edge gizmo
      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);

      this.edgeGizmo.style = this.edgeHighlightStyle;

      // Adopt lineWidth from selected polygon
      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;
      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;

      if (edgeSelected) {
        this.edgeGizmo.style.lineAlpha = 1.0;
      } else {
        // Just make it a bit brighter using a semitransparent white overlay
        this.edgeGizmo.style.lineAlpha = 0.5;
      }

      this.gizmoLayer.update();
    }

    // @param {PolyIndex}
  }, { key: "setSelectedEdge", value: function setSelectedEdge(polyIndex) {
      this.selectedEdge = polyIndex;
      this.updateEdgeGizmo();
      this.updateEdgeGizmoHighlighting();
    } }, { key: "clearEdgeGizmos", value: function clearEdgeGizmos()

    {
      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].dtor();
        }
      }
      this.edgeGizmos.length = 0;

      // Clear dashed lines between start/endPoint of arcs.
      this.arcEdgeGizmo.setPoly(null);
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // Update edge gizmos (for edge highlighting)
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateEdgeGizmo();
      this.createEdgeGizmos();
      this.updateEdgeGizmoHighlighting();
      this.snapper.clearSnappingGizmos();
    } }, { key: "setAllGizmosEnabled", value: function setAllGizmosEnabled(

    enabled) {
      this.gizmosEnabled = enabled;

      this.updateAllGizmos();
    }

    // Update selection highlighting for edge gizmos
  }, { key: "updateEdgeGizmoHighlighting", value: function updateEdgeGizmoHighlighting() {
      if (!this.gizmosEnabled) {
        // if gizmos are not enabled, there is nothing to highlight
        return;
      }

      var edgeIndex = this.selectedEdge ? this.selectedEdge.vertex : -1;
      var loopIndex = this.selectedEdge ? this.selectedEdge.loop : -1;

      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          var gizmo = gizmos[i];
          var selected = i === edgeIndex && l === loopIndex;
          gizmo.setSelected(selected);
        }
      }
    } }]);return EdgeMoveTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/EditToolBase.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EditToolBase.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditToolBase; });
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var av = Autodesk.Viewing;


// Utility class shared by Edit2D tools to facilitate snapping
var EditToolBase = /*#__PURE__*/function () {

  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);

    this.viewer = ctx.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.snapper = ctx.snapper;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.unitHandler = ctx.unitHandler;
    this.nameSuffix = "_".concat(ctx.toolSetName);
    this.mouseTracker = ctx.mouseTracker; // needed for tracking mouse in Edit 2D

    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.
    this.ignoreDragging = false;

    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.
    this.ignoreActions = false;

    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.
    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.
    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. 
    this.onActionCb = function (event) {
      if (!_this.ignoreActions) {
        _this.handleExternalAction(event.action, event.isUndo);
      }
    };

    // indicates if snapping is currently suppressed by hold modifier key
    this.suppressSnapping = false;

    this.keyMap = {
      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping
      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in
    };

    // When using selection, register a handler to notify about selection changed
    if (this.selection) {
      this.selectionCb = function () {

        // Only respond if tool is activated
        if (!_this.active) {
          return;
        }

        // Call handler if derived class defines one
        _this.onSelectionChanged && _this.onSelectionChanged();
      };

      this.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
    }

    this.active = false;

    // Track last mouse position in canvas coords. Note that derived classes must call
    // the base class mouse handlers to keep this value valid.
    this.canvasPos = new THREE.Vector2();

    // Tracks which gizmo is under mouse
    this.gizmoManager = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["GizmoManager"]();

    // Track which keys are currently hold down
    this.keyState = {
      ctrl: false,
      shift: false,
      alt: false };

  }_createClass(EditToolBase, [{ key: "getSnapPosition", value: function getSnapPosition(

    canvasX, canvasY) {var _this2 = this;
      var useSnapper = this.snapper && !this.suppressSnapping;
      if (useSnapper) {
        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});
      } else {
        // Make sure that we don't keep outdated snapping gizmos
        this.snapper.clearSnappingGizmos();

        // Just convert canvas pos to layer pos
        return this.layer.canvasToLayer(canvasX, canvasY);
      }
    } }, { key: "dtor", value: function dtor()

    {
      if (this.selectionCb) {
        this.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
      }
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      this.keyState[keyCode] = true;

      // Hold key to suppress snapping
      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {
        this.suppressSnapping = true;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise
      // the customer might lose his drawings when he's in an editing session, does a invalid selection and
      // hits backspace.
      if (keyCode === av.KeyCode.BACKSPACE) {
        return true;
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = true;
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {

      this.keyState[keyCode] = false;

      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {
        this.suppressSnapping = false;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = false;
      }
    }

    // Invoked whenever another tool triggered 
  }, { key: "handleExternalAction", value: function handleExternalAction(action, isUndo) {}

    // Run an action without triggering handleExternalAction
  }, { key: "runAction", value: function runAction(action) {
      this.ignoreActions = true;
      this.undoStack.run(action);
      this.ignoreActions = false;
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

      // Make sure we don't keep outdated snapping indicators
      this.snapper && this.snapper.clearSnappingGizmos();
    } }, { key: "register", value: function register()

    {}

    // Maps a key event to a function key in the key-map.
  }, { key: "mapKey", value: function mapKey(event, keyMap) {

      for (var key in keyMap) {
        var assigned = keyMap[key];

        // Skip disabled key commands
        if (assigned === null) {
          continue;
        }

        // If a single key is assigned to this function and it matches, return the function key
        if (event.keyCode == assigned) {
          return key;
        }

        // If multiple keys are assigned, check if one matches.
        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {
          return key;
        }

        // If it is an object, it may define modifiers and a custom filter
        if (_typeof(assigned) === 'object') {
          var ctrl = assigned.ctrlKey === undefined ? true : assigned.ctrlKey === event.ctrlKey;
          var shift = assigned.shiftKey === undefined ? true : assigned.shiftKey === event.shiftKey;
          var alt = assigned.altKey === undefined ? true : assigned.altKey === event.altKey;
          var meta = assigned.meta === undefined ? true : assigned.metaKey === event.metaKey;

          // return true if code and all (assigned) modifiers match
          var match = assigned.keyCode === event.keyCode && ctrl && shift && alt && meta;
          if (match) {
            return key;
          }
        }

        // Allow generic key-handler function
        if (typeof assigned === 'function' && assigned(event)) {
          return key;
        }
      }
      // event does not match any assigned keyCode
      return null;
    } }, { key: "snappingFilter",

    // By default, we consider all EditShapes for snapping
    value: function snappingFilter() {
      return true;
    }

    // pass mouse changes to method provided to extension
  }, { key: "trackMouseHook", value: function trackMouseHook(event) {
      if (this.mouseTracker) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
        this.mouseTracker.trackMouse(event, p);
      }
    }

    // Remember last mouse position
  }, { key: "trackMousePos", value: function trackMousePos(e) {
      this.trackMouseHook(e);
      this.canvasPos.set(e.canvasX, e.canvasY);
      this.gizmoManager.update(e);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    e) {this.trackMousePos(e);} }, { key: "handleSingleClick", value: function handleSingleClick(
    e) {this.trackMousePos(e);} }, { key: "handleDoubleClick", value: function handleDoubleClick(
    e) {this.trackMousePos(e);} }, { key: "handleButtonUp", value: function handleButtonUp(
    e) {this.trackMousePos(e);} }, { key: "handleButtonDown", value: function handleButtonDown(
    e) {this.trackMousePos(e);} }]);return EditToolBase;}();
;

av.GlobalManagerMixin.call(EditToolBase.prototype);

/***/ }),

/***/ "./extensions/Edit2D/tools/InsertSymbolTool.js":
/*!*****************************************************!*\
  !*** ./extensions/Edit2D/tools/InsertSymbolTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InsertSymbolTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var InsertSymbolToolName = "Edit2_InsertSymbolTool";var

InsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);var _super = _createSuper(InsertSymbolTool);

  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);
    _this = _super.call(this, ctx);

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.symbol = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"](0, 0,
    0.2,
    new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      fillAlpha: 1.0,
      lineWidth: 0.01,
      fillColor: 'rgb(255, 255, 0)' }));return _this;

  }_createClass(InsertSymbolTool, [{ key: "getName", value: function getName()

    {
      return InsertSymbolToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "setSymbol", value: function setSymbol(

    symbol) {
      this.symbol = symbol;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event) {

      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var symbol = this.symbol.clone();
      symbol.move(res.x, res.y);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, symbol));

      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });

      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      return true;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return InsertSymbolTool;}(_EditToolBase__WEBPACK_IMPORTED_MODULE_2__["default"]);


InsertSymbolTool.SYMBOL_INSERTED = "symbolInserted";

/***/ }),

/***/ "./extensions/Edit2D/tools/LineTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/LineTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CanvasGizmo */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}







var LineToolName = "Edit2_LineTool";

var av = Autodesk.Viewing;

// Draws lines with single drag
var LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);var _super = _createSuper(LineTool);

  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, LineTool);
    _this = _super.call(this, ctx);

    _this.style = style;

    // New polyline created by dragging
    _this.line = null;

    // Start/Endpoint of the line being dragged
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the length labels (public API)
  _createClass(LineTool, [{ key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return LineToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Make sure that we consider latest end-coords
      this.handleMouseMove(event);

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.line) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }
      var points = [startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.line = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolylinePath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"](points, style);
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.line);
    } }, { key: "updateLine", value: function updateLine()

    {

      if (!this.isDragging()) {
        return;
      }

      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);
      this.gizmoLayer.update();

      this.lengthLabel.setShape(this.line);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateLine();
    } }, { key: "endDrag", value: function endDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.line) {
        return false;
      }

      // Remove temporary gizmo shape
      this.gizmoLayer.removeShape(this.line);

      // Add line shape if valid
      var lineValid = !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].edgeIsDegenerated(this.startPoint, this.endPoint);
      if (lineValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.line));
      }

      this.line = null;

      this.lengthLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.line) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.line);
        this.line = null;

        this.dragCanceled = true;

        this.lengthLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.line);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(false);
      }
    } }]);return LineTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/MoveTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/MoveTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var MoveToolName = "Edit2_MoveTool";

var av = Autodesk.Viewing;var

MoveTool = /*#__PURE__*/function () {

  function MoveTool(ctx) {_classCallCheck(this, MoveTool);
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // Only set during dragging
    this.shapes = null; // Shape[]

    // Optioanl: Only move a single loop. Only supported if only a single shape is selected.
    this.loopIndex = -1;

    // drag-start position in layer coords
    this.dragStartPoint = new THREE.Vector2();

    // backup original shapes on drag-start as long as we are modifying it on-hover
    this.backupShapes = null; // Shape[]

    this.keyMap = {
      CancelEdit: av.KeyCode.ESCAPE };


    // Remember last mouse-pos on mouse-move events
    this.lastMousePos = new THREE.Vector2(); // in layer coords

    this.mouseTracker = ctx.mouseTracker;

    this.moveFilters = [this.defaultMoveFilter];
  }_createClass(MoveTool, [{ key: "addMoveFilter", value: function addMoveFilter(

    filter) {
      this.moveFilters.push(filter);
    } }, { key: "removeMoveFilter", value: function removeMoveFilter(

    filter) {
      var index = this.moveFilters.indexOf(filter);
      if (index == -1) {
        return false;
      }
      this.moveFilters.splice(index, 1);
      return true;
    } }, { key: "defaultMoveFilter", value: function defaultMoveFilter(

    shapes) {
      return shapes.every(function (s) {return s.movable;});
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return MoveToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleSingleClick", value: function handleSingleClick()

    /*event , button */{
      var shapesToMove = this.selection.getSelectedShapes();
      return shapesToMove && shapesToMove.length > 0;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      var shapesToMove = this.selection.getSelectedShapes();
      return shapesToMove && shapesToMove.length > 0;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var hitShape = this.layer.hitTest(p.x, p.y);

      if (!hitShape) {
        this.selection.clear();
        return false;
      }

      // If shape was not selected before, select it
      var wasSelected = hitShape && this.selection.shapeIsSelected(hitShape);
      if (!wasSelected) {
        this.selection.selectOnly(hitShape);
      }

      // Move all selected shapes
      var shapesToMove = this.selection.getSelectedShapes();
      if (shapesToMove.length > 0) {
        this.startDrag(shapesToMove, p);
      }

      return true;
    }

    // Start dragging one or more shapes
    //  @param {Shape[]} shapes
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(shapes, startPos) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var allShapesCanBeMoved = this.moveFilters.every(function (m) {return m(shapes);});
      if (!allShapesCanBeMoved) {
        // if any of the selected shapes cannot be moved, don't allow the group to be moved.
        return false;
      }

      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      this.shapes = shapes;
      this.loopIndex = loopIndex;
      this.dragStartPoint.copy(startPos);
      this.backupShapes = shapes.map(function (s) {return s.clone();});
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p) {var _this = this;
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      // Apply this offset to shape. We always start with the original shape as a reference 
      // to avoid accumulating delta inaccuracies.
      this.shapes.forEach(function (shape, i) {
        shape.copy(_this.backupShapes[i]);

        if (_this.loopIndex === -1) {
          // Default: Move whole shape(s)
          shape.move(dx, dy);
        } else {
          // Only move single loop
          shape.moveLoop(dx, dy, _this.loopIndex);
        }
      });
      this.layer.update();
      this.gizmoLayer.update();
    }

    // Clean up data hold during a drag interaction
  }, { key: "resetDragging", value: function resetDragging() {
      this.shapes = null;
      this.loopIndex = -1;
      this.backupShapes = null;
    } }, { key: "endDrag", value: function endDrag(

    p) {var _this2 = this;
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // No drag active
      if (!this.shapes) {
        return;
      }

      // Revert any temporary modifications done during mouse move
      this.shapes.forEach(function (shape, i) {return shape.copy(_this2.backupShapes[i]);});

      // Apply move operation
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      if (this.loopIndex === -1) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveShapes(this.layer, this.shapes, dx, dy));
      } else {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveLoop(this.layer, this.shapes[0], this.loopIndex, dx, dy));
      }

      this.shapes = null;
      this.loopIndex = -1;
      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {var _this3 = this;
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.isDragging()) {

        // Revert shape o state when dragging was started
        this.shapes.forEach(function (shape, i) {return shape.copy(_this3.backupShapes[i]);});
        this.layer.update();
        this.gizmoLayer.update();

        this.resetDragging();

        this.startedDragging = true;

        return true;
      }

      return false;
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.shapes);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get and store latest mouse position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.lastMousePos.copy(p);

      if (!this.shapes) {
        return false;
      }

      // get delta between last and current position        
      this.moveDrag(p);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.endDrag(p) || wasDragging;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (keyCode === this.keyMap.CancelEdit) {
        return this.cancelDrag();
      }

      return;
    }

    // Display move cursor if a shape is under mouse or if we are dragging
  }, { key: "getCursor", value: function getCursor() {
      // this.shape is defined when we are dragging
      if (this.shapes) {
        return 'move';
      }

      // Show move cursor if a shape is under mouse
      var shapeAtMouse = this.layer.hitTest(this.lastMousePos.x, this.lastMousePos.y);

      if (shapeAtMouse) {
        var canBeMoved = this.moveFilters.every(function (m) {return m([shapeAtMouse]);});
        if (canBeMoved) {
          // if any of the selected shapes cannot be moved, don't allow the group to be moved.
          return 'move';
        }
      }
      return undefined;
    } }]);return MoveTool;}();

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonEditTool.js":
/*!****************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonEditTool.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonEditTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../EllipseArcGizmo.js */ "./extensions/Edit2D/EllipseArcGizmo.js");
/* harmony import */ var _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VertexMoveTool.js */ "./extensions/Edit2D/tools/VertexMoveTool.js");
/* harmony import */ var _EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EdgeMoveTool.js */ "./extensions/Edit2D/tools/EdgeMoveTool.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}












var PolygonEditToolName = 'Edit2_PolygonEditTool';

var av = Autodesk.Viewing;

// Allow to pick an edge within 
var EdgeSelectTolerance = 17;var

PolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);var _super = _createSuper(PolygonEditTool);

  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);
    _this = _super.call(this, ctx);

    _this.moveTool = new _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);
    _this.edgeMoveTool = new _EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_8__["default"](ctx);
    _this.vertexMoveTool = new _VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_7__["default"](ctx);

    // Only set during dragging
    _this.poly = null;

    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;
    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;
    _this.keyMap.ChangeToArc = av.KeyCode.a; // Change selected edge to arc
    _this.keyMap.ChangeToLine = av.KeyCode.l; // Change selected edge to line
    _this.keyMap.ChangeToEllipse = av.KeyCode.e; // Change selected edge to ellipse arc

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // {TangentGizmo[]} Array of TangentGizmos for BezierArcs
    _this.tangentGizmos = [];

    _this.tangentGizmosEnabled = true;
    _this.ellipseArcGizmosEnabled = true;

    // If true, we apply hover-highlight on shape under mouse.
    _this.hoverEnabled = true;

    // If true, we allow changing edge type to ellipse arcs.
    _this.enableEllipseArcs = false;

    // Ellipse-arc gizmo. Only shown if an ellipse-edge is selected
    _this.ellipseArcGizmo = new _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["EllipseArcGizmo"](ctx.layer, _this.gizmoManager, ctx.undoStack, false);

    // Used in mouseDown handler: Indicates that mouse-down has been consumed by this tool, so that
    // other LMV tools shouldn't handle the singleClick either. This avoids unwanted LMV object selection
    // after ctrl-click on Edit2D shapes.
    _this.clickConsumed = false;return _this;
  }_createClass(PolygonEditTool, [{ key: "setTangentGizmosEnabled", value: function setTangentGizmosEnabled(

    enabled) {
      this.tangentGizmosEnabled = enabled;
      if (enabled) {
        this.updateTangentGizmos();
      } else {
        this.clearTangentGizmos();
      }
    } }, { key: "setEllipseArcGizmoEnabled", value: function setEllipseArcGizmoEnabled(

    enabled) {
      this.ellipseArcGizmosEnabled = enabled;
      this.updateEllipseArcGizmo();
    } }, { key: "setAllGizmosEnabled", value: function setAllGizmosEnabled(

    enabled) {
      this.setTangentGizmosEnabled(enabled);
      this.setEllipseArcGizmoEnabled(enabled);
      this.vertexMoveTool.setAllGizmosEnabled(enabled);
      this.edgeMoveTool.setAllGizmosEnabled(enabled);
    } }, { key: "setHoverEnabled", value: function setHoverEnabled(

    enabled) {

      // On disable, make sure that we don't leave any highlight behind
      if (this.hoverEnabled && !enabled) {
        this.selection.setHovered(null);
      }

      this.hoverEnabled = enabled;
    }

    // Enable the area labels (public API)
  }, { key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.edgeMoveTool.setLengthLabelVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return PolygonEditToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "deactivate", this).call(this);
      this.reset();
    }

    // Update vertex-gizmos, and tangent gizmos.
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateTangentGizmos();
      this.updateEllipseArcGizmo();
      this.updateMouseOverHighlights();
      this.vertexMoveTool.updateAllGizmos();
      this.edgeMoveTool.updateAllGizmos();
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;

      this.vertexMoveTool.reset();
      this.edgeMoveTool.reset();

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      // Cleanup area and length labels
      this.areaLabel.setShape(null);

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }

      // Sync label with polygon or polyline. If this.poly is null, it will be hidden
      var polygon = poly && poly.isPolygon() ? poly : null;
      this.areaLabel.setShape(polygon);
    } }, { key: "insertPoint", value: function insertPoint(

    polyIndex, p) {

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddVertex(this.layer, this.poly, polyIndex, p));

      // removeupdate edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Display polygon change and new gizmo
      this.layer.update();
    }

    // Remove loop (including any other loop it contains)
  }, { key: "removeLoop", value: function removeLoop(loopIndex) {

      // Collect all loops to remove
      var loopsToRemove = this.poly.getChildLoops(loopIndex);
      loopsToRemove.push(loopIndex);

      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveLoops(this.layer, this.poly, loopsToRemove);
      this.runAction(action);

      // Reset vertex/edge selection. We cannot keep it because the meaning of loopIndices has changed.
      this.vertexMoveTool.setSelectedVertex(null);
      this.edgeMoveTool.setSelectedEdge(null);

      this.updateAllGizmos();
      this.layer.update();
    } }, { key: "removePoint", value: function removePoint(

    polyIndex) {var

      loop = polyIndex.loop;

      // If removing a vertex would make the loop degenerate, remove it completely        
      var minVerts = this.poly.isPolygon() ? 3 : 2;
      if (this.poly.getVertexCount(loop) <= minVerts) {
        this.removeLoop(loop);
        return;
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveVertex(this.layer, this.poly, polyIndex));

      // update vertex gizmos
      this.vertexMoveTool.updateVertexGizmos();

      // update edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Make sure that this vertex is not selected anymore
      if (polyIndex.equals(this.vertexMoveTool.selectedVertex)) {
        this.vertexMoveTool.setSelectedVertex(null);
      }

      // Unselect edge if edgeIndex got invalid        
      this.edgeMoveTool.setSelectedEdge(null);

      this.layer.update();
    } }, { key: "isSingleLine", value: function isSingleLine()

    {
      return this.poly && this.poly.loopCount === 1 && this.poly.getVertexCount(0) === 2;
    }

    // If the given mousePos (in layerCoords) is located close to an edge (not edge gizmo), 
    // the edge index is returned, otherwise null.
    //  @returns {PolyIndex|null}
  }, { key: "findEdgeUnderMouse", value: function findEdgeUnderMouse(pos) {
      if (!this.poly) {
        return null;
      }

      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
      for (var l = 0; l < this.poly.loopCount; l++) {
        var index = this.poly.findEdgeIndex(pos, precision, l);
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    }

    // Checks if a point p can be inserted to split the given edge. If so, it returns the projected
    // position that is located exactly on edge to be split.
    //
    //  @param {Vector2} p           - pos in layer coords - usually close to given edge.
    //  @param {PolyIndex} polyIndex - index of the edge to be split by this vertex
    //  @returns {Vector2|null} Adjusted position where the new point will be added.
  }, { key: "getNewVertexPosition", value: function getNewVertexPosition(p, polyIndex) {

      if (!this.poly || !polyIndex) {
        return null;
      }

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;
      if (!this.poly.edgeIndexValid(edgeIndex, loopIndex)) {
        return null;
      }

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, a, b, loopIndex);

      // get edge direction
      var edgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(a, b);

      // compute projection of p to the line spanned by the edge
      var newPos = p.clone();
      _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].projectToLine(newPos, a, edgeDir);

      // Reject position if the projection is outside the segment
      if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].isPointOnEdge(newPos, a, b, 0.0001)) {
        return null;
      }

      // Return position where to insert the new vertex
      return newPos;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      if (this.vertexMoveTool.handleButtonDown(event, button)) {
        this.edgeMoveTool.setSelectedEdge(null);
        return true;
      }

      // Note: In LMV, ToolController handles command key and ctrl key in the same way.
      //       For consistency, we do the same here.
      var ctrlHold = event.ctrlKey || event.metaKey;

      // Handle Vertex-Add: Check if we hold ctrl and hit an edge
      var newVertex = -1;
      if (ctrlHold) {
        // Is mouse close to an edge and can be projected onto that edge?
        var _edgeIndex = this.findEdgeUnderMouse(this.mousePos);
        var newVertexPos = this.getNewVertexPosition(this.mousePos, _edgeIndex);
        if (newVertexPos) {
          // We don't insert exactly at the mouse position. Instead, new vertices
          // are always located exactly on the edge being split. Therefore, newVertexPos is
          // usually slightly different from mousePos.

          // insert new vertex after edge starting point
          newVertex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: _edgeIndex.vertex + 1, loop: _edgeIndex.loop });
          this.insertPoint(newVertex, newVertexPos);

          // Allow to drag the new vertex immediately
          if (this.mouseTracker) {
            this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);
          }
          this.vertexMoveTool.startDragVertex(event, newVertex);

          return true;
        }
      }

      // Handle dragging of TangentGizmo control points for Bezier arcs.
      for (var i = 0; i < this.tangentGizmos.length; i++) {
        var gizmo = this.tangentGizmos[i];
        if (gizmo.onButtonDown(event.canvasX, event.canvasY)) {
          // We started dragging of a Bezier control point
          return true;
        }
      }

      // Handle dragging of EllipseArc gizmo
      if (this.ellipseArcGizmo.startDrag(event.canvasX, event.canvasY)) {
        if (this.mouseTracker) {
          this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);
        }
        // We started dragging an ellipse arc
        return true;
      }

      // Reset selection highlighting of vertices.
      this.vertexMoveTool.setSelectedVertex(null);

      if (this.edgeMoveTool.handleButtonDown(event, button)) {
        this.updateTangentGizmos();
        this.updateEllipseArcGizmo();
        return true;
      }

      // Check which polygon was hit
      var newPolygon = this.layer.hitTest(p.x, p.y);

      // Handle multiselect
      if (this.enableMultiselection && ctrlHold && newPolygon) {
        this.selection.toggleSelection(newPolygon);

        // eat mouseUp event as well. Otherwise, LMV defaultHandler will select objects in the background in parallel
        this.clickConsumed = true;
        return true;
      }

      // Check if click was close to an edge of the current polygon.
      var edgeIndex = this.poly && this.findEdgeUnderMouse(this.mousePos);

      // Since tolerance for edge selection is higher, the edge shape hitTest may slightly miss
      // the polygon, but we may be close to an edge. In this case, consider the shape as being it as well.
      if (!newPolygon && edgeIndex) {
        newPolygon = this.poly;
      }

      // If we just clicked inside the already selected polygon, delegate it to MoveTool.        
      if (this.selection.shapeIsSelected(newPolygon)) {

        var loopIndex = edgeIndex ? edgeIndex.loop : -1;

        // Allow moving loops - unless it is a single outer one
        var mainLoops = this.poly && this.poly.getMainLoops();
        var isOnlyMainLoop = mainLoops && mainLoops.length === 1 && mainLoops[0] === loopIndex;

        // Handle single-loop move
        var moveLoop = edgeIndex && !isOnlyMainLoop;
        if (moveLoop) {
          // Move single loop
          this.moveTool.startDrag([this.poly], p, loopIndex);
        } else {
          // Move selected shape(s)
          var shapesToMove = this.selection.getSelectedShapes();
          this.moveTool.startDrag(shapesToMove, p);
        }
        return true;
      }

      // If the clicked object is neither polygon nor polyline, ignore it.
      var isPolygon = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
      var isPolyline = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"];
      var isPath = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];
      if (!isPolygon && !isPolyline && !isPath) {
        newPolygon = null;
      }

      // Set selection to current polygon. This will also trigger setEditPoly() 
      // via selectionChanged event.
      this.selection.selectOnly(newPolygon);

      return false;
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    e) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleSingleClick", this).call(this, e);

      var handled = this.clickConsumed || Boolean(this.poly);

      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      this.clickConsumed = false;
      return handled;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));
      this.updateMouseOverHighlights();

      if (this.moveTool.isDragging()) {
        this.moveTool.moveDrag(this.mousePos);
      }

      if (!this.poly) {
        return false;
      }

      if (this.vertexMoveTool.handleMouseMove(event)) {
        return true;
      }

      if (this.edgeMoveTool.handleMouseMove(event)) {
        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the ellipseArc gizmo
      if (this.ellipseArcGizmo.dragging) {
        return this.ellipseArcGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonUp", this).call(this, event, button);

      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves
      this.ignoreActions = true;
      var handled = this.vertexMoveTool.handleButtonUp(event, button);
      this.ignoreActions = false;

      if (handled) {
        return true;
      }

      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves
      this.ignoreActions = true;
      handled = this.edgeMoveTool.handleButtonUp(event, button);
      this.ignoreActions = false;

      if (handled) {
        return true;
      }

      if (this.moveTool.isDragging()) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);

        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves
        this.ignoreActions = true;
        this.moveTool.endDrag(p);
        this.ignoreActions = false;

        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);
        }
        tangentGizmo.endDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the center of an ellipse arc
      if (this.ellipseArcGizmo.dragging) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);
        }
        this.ellipseArcGizmo.endDrag(event.canvasX, event.canvasY);

      }

      // We let other tools down the stack such as the MoveTool and EdgeMoveTool handle the button up.
      return false;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }

      this.vertexMoveTool.onSelectionChanged();
      this.edgeMoveTool.onSelectionChanged();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // Needed in order to update suppressSnapping
      this.vertexMoveTool.handleKeyDown(event, keyCode);
      this.edgeMoveTool.handleKeyDown(event, keyCode);

      if (keyCode === this.keyMap.DeleteSelectedVertex) {
        if (this.poly && this.vertexMoveTool.selectedVertex) {
          this.removePoint(this.vertexMoveTool.selectedVertex);
          handled = true;
        }
      }

      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
        return true;
      }

      // Check if we have an edge to work on
      var targetEdge = this.isSingleLine() ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: 0, loop: 0 }) : this.edgeMoveTool.selectedEdge; // If we have just a single segment, we don't need edge selection.
      var targetEdgeValid = Boolean(this.poly && targetEdge && this.poly.edgeIndexValid(targetEdge.vertex, targetEdge.loop));

      if (keyCode === this.keyMap.ChangeToArc) {

        // If a line segment is selected, convert it to an arc
        var lineSegmentSelected = targetEdgeValid && !this.poly.isBezierArc(targetEdge.vertex, targetEdge.loop);
        if (lineSegmentSelected) {
          this.changeEdgeToBezier(targetEdge);
        }
        return true;
      }

      if (keyCode === this.keyMap.ChangeToEllipse) {

        // If a line segment is selected, convert it to an arc
        var segmentSelected = targetEdgeValid && !this.poly.isEllipseArc(targetEdge.vertex, targetEdge.loop);
        if (segmentSelected) {
          this.changeEdgeToEllipse(targetEdge);
        }
        return true;
      }

      if (keyCode === this.keyMap.ChangeToLine) {
        // If an arc segment is selected, convert it to a line
        var arcSegmentSelected = targetEdgeValid && this.poly.isArc(targetEdge.vertex, targetEdge.loop);
        if (arcSegmentSelected) {
          this.changeEdgeToLine(targetEdge);
        }
      }

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyUp", this).call(this, event, keyCode);

      // Needed in order to update suppressSnapping
      this.vertexMoveTool.handleKeyUp(event, keyCode);
      this.edgeMoveTool.handleKeyUp(event, keyCode);

      return handled;
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.vertexMoveTool.onSnappingToggled(canvasX, canvasY);
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.vertexMoveTool.cancelDrag()) {
        needsUpdate = true;
      }

      if (this.edgeMoveTool.cancelDrag()) {
        needsUpdate = true;
      }

      if (this.moveTool.cancelDrag()) {
        needsUpdate = true;
      }

      this.tangentGizmos.forEach(function (tg) {
        if (tg.isDragging()) {
          tg.cancelDrag();
          needsUpdate = true;
        }
      });

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      if (this.ellipseArcGizmo.dragging) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
        }
        this.ellipseArcGizmo.cancelDrag();
        this.updateAllGizmos();
      }

      this.snapper.clearSnappingGizmos();
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {

      // If the action is invoked by our own TangentGizmo, attach the currently selected item on first run.
      // This allows us to recover later whether a vertex or an edge was selected.
      if (action instanceof _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeBezierTangent) {
        var _hint = action.getSelectionHint(isUndo);
        if (!_hint) {
          action.setSelectionItem(
          this.vertexMoveTool.selectedVertex,
          this.edgeMoveTool.selectedEdge);

        }
      }

      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {

        // apply shape selection
        var shapes = hint.shape ? [hint.shape] : hint.shapes;
        this.selection.setSelection(shapes);

        this.vertexMoveTool.setSelectedVertex(hint.vertex);
        this.edgeMoveTool.setSelectedEdge(hint.edge);

        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // If poly was modified from outside, we can't know if the selected vertex or edge
      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.
      this.vertexMoveTool.setSelectedVertex(null);
      this.edgeMoveTool.setSelectedEdge(null);
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    } }, { key: "updateMouseOverHighlights", value: function updateMouseOverHighlights()


    {
      // Handle mouse-over highlighting for shapes
      if (this.hoverEnabled) {
        var shape = this.layer.hitTest(this.mousePos.x, this.mousePos.y);
        this.selection.setHoveredId(shape ? shape.id : 0);
      }
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.

      var p = this.mousePos;

      // Indicate: "Moving whole shape"
      // While dragging, keep the move-cursor, even if the mouse is temporarily leaving polygon and gizmos
      if (this.moveTool.isDragging()) {
        return 'move';
      }

      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      var vertexEdgeCursor = this.vertexMoveTool.getCursor() || this.edgeMoveTool.getCursor();
      if (vertexEdgeCursor) {
        return vertexEdgeCursor;
      }

      // Indicate: "Moving a ellipse-arc gizmo" to modify radius of an ellipse arc.
      if (this.ellipseArcGizmo.dragging) {
        return 'move';
      }

      // Check if mouse is close to an edge
      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
      var edgeIndex = this.findEdgeUnderMouse(this.mousePos, precision);

      // Indicate: "Click to insert new vertex"
      //
      // If we are holding down Ctrl (or command) and hover over an edge, clicking would insert a vertex.
      var ctrlHold = this.keyState[av.KeyCode.CONTROL];
      if (ctrlHold) {
        if (edgeIndex) {
          return 'copy';
        }
      }

      // Are we about to move a shape?
      var hitRadius = this.layer.getLineHitRadius(this.poly);
      var moveShape = edgeIndex || this.poly.hitTest(p.x, p.y, hitRadius);
      if (moveShape) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }, { key: "clearTangentGizmos", value: function clearTangentGizmos()

    {
      this.tangentGizmos.forEach(function (g) {return g.dtor();});
      this.tangentGizmos.length = 0;
    } }, { key: "updateTangentGizmos", value: function updateTangentGizmos()

    {

      // Clear any previous gizmos (if any)
      this.clearTangentGizmos();

      if (!this.poly || !this.poly.isPath()) {
        return;
      }

      // We only show a tangent gizmo if it has relevance for the selected vertex or edge:
      // For a vertex v with neighbor edges prevEdge und nextEdge, we show a tangent gizmo if...
      //  - v, prevEdge, or nextEdge is selected
      //  - If an edge is selected, the selected edge is an arc
      //  - If v is selected, prevEdge or nextEdge is an arc
      for (var l = 0; l < this.poly.loopCount; l++) {
        var vertexCount = this.poly.getVertexCount(l);
        for (var i = 0; i < vertexCount; i++) {

          var sv = this.vertexMoveTool.selectedVertex;
          var vertexSelected = Boolean(sv && sv.vertex === i && sv.loop === l);

          // get prev/next edge. 
          var prevEdge = this.poly.edgeBeforeVertex(i, l);
          var nextEdge = this.poly.edgeAfterVertex(i, l);

          // edges may not exist at polyline ends
          var prevExists = prevEdge !== -1;
          var nextExists = nextEdge !== -1;

          // check if any neighbor edge is selected
          var se = this.edgeMoveTool.selectedEdge;
          var prevSelected = Boolean(prevExists && se && se.vertex === prevEdge && se.loop === l);
          var nextSelected = Boolean(nextExists && se && se.vertex === nextEdge && se.loop === l);

          // check if any neighbor edge is an arc
          var prevIsArc = prevExists && this.poly.isBezierArc(prevEdge, l);
          var nextIsArc = nextExists && this.poly.isBezierArc(nextEdge, l);

          // If we just have a single line segment, always show the tangent gizmos
          var isSingleLine = this.isSingleLine();

          // Check if we selected an arc edge or a vertex of one
          var arcVertexSelected = vertexSelected && (prevIsArc || nextIsArc);
          var arcEdgeSelected = prevSelected && prevIsArc || nextSelected && nextIsArc;

          // show the gizmo if anything is selected and one of the edges is an arc
          var showTangents = isSingleLine || arcVertexSelected || arcEdgeSelected;
          if (showTangents) {
            this.tangentGizmos.push(new _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.poly, i, l, this.layer, this.gizmoLayer, this.gizmoManager, this.undoStack));
          }
        }
      }
    } }, { key: "updateEllipseArcGizmo", value: function updateEllipseArcGizmo()

    {
      var se = this.edgeMoveTool.selectedEdge;

      var edgeSelected = Boolean(se);

      // if ellipse arc gizmos are enabled, check if edge is selected and we the polygon at hand is a path, as well
      // if the selected edge's vertex and loop is an ellipse arc. If ellipse arc gizmos are not enabled, then dettach
      // them from the edge and return.
      var showGizmo = this.ellipseArcGizmosEnabled ?
      edgeSelected && this.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"] && this.poly.isEllipseArc(se.vertex, se.loop) :
      false;

      this.ellipseArcGizmo.setVisible(showGizmo);

      if (!showGizmo) {
        // Make sure that ellipseArcGizmo doesn't keep bound to an edge. Otherwise, it may
        // cause an error later if that edge is removed.
        this.ellipseArcGizmo.detachFromEdge();
        return;
      }

      this.ellipseArcGizmo.attachToEdge(this.poly, se.vertex, se.loop);
    }

    // If any tangent gizmo is being dragged, it is returned.
    // Result is null if nothing is dragged.
  }, { key: "findDraggedTangentGizmo", value: function findDraggedTangentGizmo() {
      return this.tangentGizmos.find(function (gizmo) {return gizmo.isDragging();});
    }

    // Heuristic for choosing the tangent length when turning a line segment into an arc.
    // The basic idea here is
    //  - When turning all 4 lines of a square into arcs, we should get something that approximates a circle.
    //  - When generalizing that to more fancy cases, it should at least behave consistent and sort-of reasonable (e.g. always keep within a reasonable ratio to segment lengths)
    //
    // Note: It's probably cleaner to always approximate some sort of elliptical arcs for the general case. But that will make things a lot harder (and possibly slower).
    //       So let's get away with the linear-scale cheating for now.
  }, { key: "getVertexTangentLength", value: function getVertexTangentLength(prevLength, nextLength) {

      // Given a square of edge length sqrt(2), the circle passing through all 4 vertices can be
      // approximated by 4 cubic bezier arc segments. The tangents for these bezier arcs all have this length:
      // (See here: http://spencermortensen.com/articles/bezier-circle/)
      var c = 0.551915024494;

      // Scaling down the quad/beziers to a unit quad, we obtain the corresponding tangent lengths for a unit quad as:
      var unitQuadTangentLength = c / Math.SQRT2;

      // For a square of length l, the tangent length scales up accordingly.
      // For different segment lengths, we simply use the average of both lengths.
      var l = 0.5 * (prevLength + nextLength);

      return l * unitQuadTangentLength;
    }

    // Given a corner vertex p and its previous and next neighbor, this function computes an averaged tangent
    // vector that we use if (prev, p) and (p, next) are replaced by Bezier arcs.
  }, { key: "getVertexTangent", value: function getVertexTangent(prev, p, next) {

      // get tangent direction by averaging the edge directions.
      var tangent = new THREE.Vector2().copy(next).sub(prev).normalize();

      // Scale tangent direction
      var prevLength = p.distanceTo(prev);
      var nextLength = p.distanceTo(next);
      var tangentLength = this.getVertexTangentLength(prevLength, nextLength);

      return tangent.multiplyScalar(tangentLength);
    } }, { key: "changeEdgeToEllipse", value: function changeEdgeToEllipse(

    polyIndex) {

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;

      // By default, bend outsidde by half of the edge length. In this way, we get a circle centered
      // at the line-segment midpoint.
      var bendRadius = 0.5 * this.poly.getEdgeLength(edgeIndex, loopIndex);
      var arcParams = Object(_EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["getEllipseArcEdgeParams"])(this.poly, edgeIndex, loopIndex, bendRadius);
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, arcParams));

      this.layer.update();
      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }, { key: "changeEdgeToBezier", value: function changeEdgeToBezier(

    polyIndex) {

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;

      var path = this.poly;

      // get neighbor edges
      var prevEdgeIndex = path.prevEdgeIndex(edgeIndex, loopIndex);
      var nextEdgeIndex = path.nextEdgeIndex(edgeIndex, loopIndex);

      // check if neighbor edge exist (usually true unless at the end of a polyline)
      var prevExists = prevEdgeIndex !== -1;
      var nextExists = nextEdgeIndex !== -1;

      // get start/end position of the segment
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      path.getEdge(edgeIndex, a, b, loopIndex);

      // If previous/next edge exist, get their start/endVertex as well
      var prevEdgeA = prevExists && path.getPoint(prevEdgeIndex, loopIndex);
      var nextEdgeB = nextExists && path.getPoint(path.nextIndex(nextEdgeIndex, loopIndex), loopIndex);

      // If prev/nextEdge do not exist, we simply assume length and angle of the missing edge to be the same as the current edge.
      if (!prevExists) prevEdgeA = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(b, a);
      if (!nextExists) nextEdgeB = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(a, b);

      // Control points 0 and 3 are already given by edge a and b
      // Below, we have to determine cp1, cp2 to define the tangents
      var cp1 = null;
      var cp2 = null;

      // Check if previous and next edges are arcs as well
      var prevIsArc = prevExists && path.isBezierArc(prevEdgeIndex, loopIndex);
      var nextIsArc = nextExists && path.isBezierArc(nextEdgeIndex, loopIndex);

      // Determine control point for start tangent cp1
      if (prevIsArc) {
        // Previous edge is an arc: Get start tangent by mirroring the end tangent of that arc.
        var prevCp2 = path.getControlPoint(prevEdgeIndex, 2, loopIndex);
        cp1 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(prevCp2, a);
      } else {
        // Previous edge is a line: Use average direction of both segments to choose the new tangent
        cp1 = this.getVertexTangent(prevEdgeA, a, b).add(a);
      }

      // Analog for end tangent cp2
      if (nextIsArc) {
        // Next edge is an arc: Get end tangent by mirroring the start tangent of that arc.
        var nextCp1 = path.getControlPoint(nextEdgeIndex, 1, loopIndex);
        cp2 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(nextCp1, b);
      } else {
        // Next edge is a line: Use average direction of both segments to choose the new tangent
        // Note that we must pass the points in backward order for the end tangent.
        cp2 = this.getVertexTangent(nextEdgeB, b, a).add(b);
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier, cp1, cp2));

      this.layer.update();

      // select the edge so that you can edit its tangents
      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }, { key: "changeEdgeToLine", value: function changeEdgeToLine(

    polyIndex) {
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line));
      this.layer.update();

      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }]);return PolygonEditTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonTool.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonTool.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _LineTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}







var Mode = {
  Polyline: 1,
  Polygon: 2 };


var PolygonToolName = "Edit2_PolygonTool";
var PolylineToolName = "Edit2_PolylineTool";

var av = Autodesk.Viewing;
var DefaultStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();var

PolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);var _super = _createSuper(PolygonTool);

  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, PolygonTool);
    _this = _super.call(this, ctx);

    // Delegate single-drag interactions: 
    _this.lineRectTool = mode === Mode.Polygon ?
    new _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx, style) : // PolygonMode: Draw rect/quad on drag
    new _LineTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx, style) // PolylineMode: Draw simple line on drag
    ;

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    // Circle shapes per vertex
    _this.vertexGizmos = [];

    // The polygon/polyline we are currently creating (if tool is active)
    _this.poly = undefined;

    // Style used for polygon creation
    _this.style = style;

    // Style used to display the thin line to connect last added vertex with current mouse position.        
    _this.edgePreviewStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineWidth: 2,
      isScreenSpace: true,
      lineStyle: 11 // dashed line
    });

    // whether editing Polylines or Polygons
    _this.mode = mode;

    // last canvas position where we added a vertex
    _this.lastClickX = undefined;
    _this.lastClickY = undefined;

    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;
    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;
    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];

    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos
    _this.fillGizmo = null;

    // OutlineGizmo: Polyline that connects all added vertices
    _this.outlineGizmo = null;

    // Line to connect last added vertex with mouse position
    _this.edgePreviewGizmo = null;

    // Last tracked mouse-pos in layer-coords (after considering snapping)
    _this.mousePos = new THREE.Vector2();

    // Label to display polygon area - hidden by default
    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["AreaLabel"](null, _this.gizmoLayer, _this.unitHandler, false);

    // Label to display polyline length
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeLabel"](_this.gizmoLayer, false);

    // If true, we always create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(PolygonTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(

    visible) {
      this.lengthLabel.setVisible(visible);
    }

    // If true, all new shapes are Paths instead of Polygons/Polylines.
  }, { key: "setArcsEnabled", value: function setArcsEnabled(enable) {
      this.enableArcs = enable;
      this.lineRectTool.enableArcs = enable;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonTool.prototype), "deactivate", this).call(this);
      this.cancelEdit();
    }

    // Returns true when editing a Polygon, false when editing a Polyline or nothing.
  }, { key: "isPolygon", value: function isPolygon() {
      return this.poly && this.poly.isPolygon();
    }

    /**
       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines
       * that appear during drawing. Style.isScreenSpace won't be considered.
       * @param {Style} style         - a Style instance
       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style
       */ }, { key: "setStyles", value: function setStyles(
    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {
        this.style.lineColor = style.lineColor;
      }
      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {
        this.style.lineAlpha = style.lineAlpha;
      }
      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {
        this.style.lineWidth = style.lineWidth;
        this.lineRectTool.style.lineWidth = style.lineWidth;
        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;
      }
      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {
        this.style.lineStyle = style.lineStyle;
        this.lineRectTool.style.lineStyle = style.lineStyle;
        // skip this.edgePreviewStyle.lineStyle
      }

      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {
        this.style.fillColor = style.fillColor;
      }
      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {
        this.style.fillAlpha = style.fillAlpha;
      }

      // skip isScreenSpace
    }

    // Initialize all gizmos when starting to edit a Polygon/Polyline
  }, { key: "initGizmos", value: function initGizmos() {

      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos
      if (this.isPolygon()) {
        this.fillGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        this.fillGizmo.style.lineAlpha = 0;
        this.gizmoLayer.addShape(this.fillGizmo);
      }

      // OutlineGizmo: Connect added vertices
      this.outlineGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      this.gizmoLayer.addShape(this.outlineGizmo);

      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.
      this.edgePreviewGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.edgePreviewStyle);
      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;
      this.gizmoLayer.addShape(this.edgePreviewGizmo);

      this.areaLabel.setShape(this.fillGizmo);

      // For Polylines, attach label to preview edge that displays the summed length
      if (this.poly && this.poly.isPolyline()) {
        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);
      }
    } }, { key: "clearGizmos", value: function clearGizmos()

    {
      if (this.fillGizmo) {
        this.gizmoLayer.removeShape(this.fillGizmo);
        this.fillGizmo = null;
      }

      this.areaLabel.setShape(null);
      this.lengthLabel.detachFromEdge();

      if (this.outlineGizmo) {
        this.gizmoLayer.removeShape(this.outlineGizmo);
        this.outlineGizmo = null;
      }

      if (this.edgePreviewGizmo) {
        this.gizmoLayer.removeShape(this.edgePreviewGizmo);
        this.edgePreviewGizmo = null;
      }

      // clear vertex gizmos
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    }

    // Update gizmos and snapping if polygon was modified
  }, { key: "polyModified", value: function polyModified() {
      this.updateGizmos();

      // Configure angle snapping to consider latest state of the polygon
      // Note that angleSnapper requires the shape including "vertex under mouse", while
      // this.poly only contains the already added/clicked vertices.
      // Note that we cannot use fillGizmo here, because it does not exist for polylines.
      var snapGeom = this.poly.clone();
      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);
      this.snapper.startAngleSnapping(snapGeom, this.poly.vertexCount, 0); // For new polygons, loopIndex is always 0
    }

    // Update gizmos if vertices of current polygon/polyline have changed
  }, { key: "updateGizmos", value: function updateGizmos() {

      // FillGizmo: Show fill without outline for the polygon formed by all added
      // vertices + current mousePos
      if (this.fillGizmo) {
        // copy vertices of main polygon (not geom, not style)
        this.fillGizmo.clear();
        for (var i = 0; i < this.poly.vertexCount; i++) {
          var p = this.poly.getPoint(i);
          this.fillGizmo.addPoint(p.x, p.y);
        }
        // add additional point that traces mouse-pos
        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);
      }

      // OutlineGizmo: Solid polyline that connects all added vertices
      this.outlineGizmo.clear();
      if (this.poly.vertexCount >= 2) {
        for (var _i = 0; _i < this.poly.vertexCount; _i++) {
          var _p = this.poly.getPoint(_i);
          this.outlineGizmo.addPoint(_p.x, _p.y);
        }
      }

      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position
      this.edgePreviewGizmo.clear();
      if (this.poly.vertexCount >= 1) {
        var pLast = this.poly.getPoint(this.poly.vertexCount - 1);
        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);
        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);

        this.updateLengthLabel();
      }

      this.gizmoLayer.update();
    } }, { key: "updateLengthLabel", value: function updateLengthLabel()

    {
      // Compute resulting length of polyline including previewEdge
      if (this.poly && this.poly.isPolyline()) {
        // get transform from geometry coords to measure coordinate system
        var transform = this.unitHandler.measureTransform;

        var length = this.poly.getLength(transform) + this.edgePreviewGizmo.getLength(transform);
        var lengthStr = this.unitHandler.lengthToString(length);
        this.lengthLabel.setText(lengthStr);
      }
    } }, { key: "getName", value: function getName()

    {
      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleMouseMove", this).call(this, event);

      if (!event.buttons) {
        // When not dragging, we always return false here. Otherwise, the event will not propagated
        // to navigation tools, so that the zoom focus is not updated properly.
        this.onHover(event.canvasX, event.canvasY);
        return false;
      }
      return this.lineRectTool.handleMouseMove(event);
    } }, { key: "onHover", value: function onHover(

    canvasX, canvasY) {
      // Check if shape editing is already in progress
      if (!this.poly) {

        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.
        this.getSnapPosition(canvasX, canvasY);
        return;
      }

      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);

      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators
      var closingAllowed = this.poly.vertexCount >= 3;
      var startVertexHit = closingAllowed && this.gizmoManager.isUnderMouse(this.vertexGizmos[0]);
      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex
      if (startVertexHit) {
        // Remove snapping indicators
        this.snapper.clearSnappingGizmos();

        // snap position to vertex center
        pLayer.copy(this.vertexGizmos[0].layerPos);
      } else {
        // Standard case: If mouse is not on start vertex, allow standard snapping
        pLayer = this.getSnapPosition(canvasX, canvasY);
      }

      // track last mouse pos
      this.mousePos.copy(pLayer);

      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo
      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);
      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.vertexCount - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline
      this.gizmoLayer.update();
      this.updateLengthLabel();
    }

    // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.
  }, { key: "handleStartVertexClicked", value: function handleStartVertexClicked(event) {

      if (!this.poly && this.poly.vertexCount < 3) {
        return;
      }

      // For polylines, we have to repeat the first vertex to close it
      if (this.poly.isPolyline()) {
        var pStart = this.poly.getPoint(0);
        this.addVertex(pStart.x, pStart.y);
      }

      // Finish editing
      this.finishPolygon();

      // Make sure that the event is not passed on to ToolManager. Otherwise,
      // we would evaluate it a second time in handleSingleClick()
      event.stopPropagation();
    }

    // Add vertex on single-click
  }, { key: "handleSingleClick", value: function handleSingleClick(event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleSingleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      // Avoid duplicate vertices on double-clicks
      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {
        return true;
      }

      this.lastClickX = event.canvasX;
      this.lastClickY = event.canvasY;

      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));

      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      // Init polygon on first click
      if (!this.poly) {
        this.startPoly(this.mousePos.x, this.mousePos.y);
      }

      this.addVertex(this.mousePos.x, this.mousePos.y);
      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.
      if (this.ignoreDragging) {
        return false;
      }

      // If no clicks have been made so far, allow to drag line/rectangle.
      if (!this.poly) {
        // Clear the selection, this will make sure all other gizmos get removed
        this.selection.clear();

        return this.lineRectTool.handleButtonDown(event, button);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return this.lineRectTool.handleButtonUp(event, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleDoubleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      this.finishPolygon();
      return true;
    }

    // Start new polyline or polygon
  }, { key: "startPoly", value: function startPoly(x, y) {

      if (this.enableArcs) {
        // Arcs enabled: Always create Paths
        var isClosed = this.mode === Mode.Polygon;
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]([], isClosed, this.style.clone());
      } else {
        // No arcs enabled: Create Polygons or Polylines
        if (this.mode === Mode.Polygon) {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        } else {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
        }
      }

      this.initGizmos();
    } }, { key: "addVertex", value: function addVertex(

    x, y) {var _this2 = this;

      // add "next" point - which will follow the mouse motion 
      // until next click
      this.poly.addPoint(x, y);

      // add vertex-gizmo
      var name = 'PolygonTool_vertexGizmo_' + this.vertexGizmos.length;
      var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["VertexGizmo"](this.gizmoLayer, x, y, name);
      this.vertexGizmos.push(vertex);

      // For the start vertex-gizmo, we register a handler to finish the polygon when clicking it again
      var isStartVertex = this.vertexGizmos.length === 1;
      if (isStartVertex) {
        vertex.container.addEventListener('click', function (e) {return _this2.handleStartVertexClicked(e);});
      }

      this.polyModified();
    } }, { key: "removeLastVertex", value: function removeLastVertex()

    {
      if (!this.poly || !this.poly.vertexCount) {
        return;
      }

      // Cancel edit if there was only the starting point.
      if (this.poly.vertexCount <= 1) {
        this.cancelEdit();
        return;
      }

      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      this.poly.removePoint(this.poly.vertexCount - 1);

      // remove last added vertex gizmo
      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];
      lastGizmo.dtor();
      this.vertexGizmos.pop();

      this.polyModified();
    } }, { key: "finishPolygon", value: function finishPolygon()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      // remove all vertex gizmos
      this.clearGizmos();

      // Stop snapping to edges of this polygon
      this.snapper.stopAngleSnapping();

      // move polygon to main layer
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].AddShape(this.layer, this.poly));

      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });

      // Start another polygon on next click
      this.poly = null;
    } }, { key: "cancelEdit", value: function cancelEdit()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      if (this.lineRectTool.isDragging()) {
        this.lineRectTool.cancelDrag();
      }

      if (this.poly) {
        this.gizmoLayer.removeShape(this.poly);
        this.poly = null;
      }

      this.clearGizmos();
      this.snapper.stopAngleSnapping();
    } }, { key: "handleFinishKey", value: function handleFinishKey(

    event) {
      if (!this.poly) {
        return false;
      }

      // Avoid closing if it would result in a polygon that is degenerated to a line.
      if (this.isPolygon() && this.poly.vertexCount < 3) {
        return false;
      }

      this.finishPolygon();
      return true;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // delegate to rectTool
      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;

      // Map event to any known key in this.keyMap
      var funcKey = this.mapKey(event, this.keyMap);
      switch (funcKey) {
        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;
        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;
        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyUp", this).call(this, event, keyCode);
      this.lineRectTool.handleKeyUp(event, keyCode);
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.onHover(canvasX, canvasY);
    } }, { key: "mouseOnStartVertex", value: function mouseOnStartVertex()

    {
      if (!this.vertexGizmos[0]) {
        return false;
      }

      // Check if start vertex was clicked
      return this.gizmoManager(this.this.vertexGizmos[0]);
    } }, { key: "setStartVertexHighlighted", value: function setStartVertexHighlighted(

    enable) {
      if (this.vertexGizmos[0]) {
        this.vertexGizmos[0].setSelected(enable);
      }
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return PolygonTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


PolygonTool.POLYGON_ADDED = "polygonAdded";
PolygonTool.Mode = Mode;

/***/ }),

/***/ "./extensions/Edit2D/tools/RectangleTool.js":
/*!**************************************************!*\
  !*** ./extensions/Edit2D/tools/RectangleTool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ModifierMask.js */ "./extensions/Edit2D/ModifierMask.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}








var RectangleToolName = "Edit2_RectangleTool";

var av = Autodesk.Viewing;

// Creates rectangles by dragging
var RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);var _super = _createSuper(RectangleTool);

  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, RectangleTool);
    _this = _super.call(this, ctx);

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.style = style;

    // New polygon created by dragging
    _this.rect = null;

    // First corner of the new rectangle
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // Allow to enable/disable tool based on modifiers
    _this.modifiers = new _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(RectangleTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return RectangleToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Check if modifers allow starting an interaction
      if (!this.modifiers.accepts(event)) {
        return false;
      }

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return false;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      // Make sure that we consider latest mouse position
      this.handleMouseMove(event);

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.rect) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }
      var points = [startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.rect = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"](points, style);

      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.rect);
    } }, { key: "updateRect", value: function updateRect(

    forceQuad) {

      if (!this.isDragging()) {
        return;
      }

      var p0 = this.startPoint;
      var p1 = this.endPoint;

      if (forceQuad) {

        // Use maximum of dx/dy as edge length
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));

        // Consider drag direction to span quad right/left resp. up/down
        var sx = Math.sign(dx);
        var sy = Math.sign(dy);

        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);
        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);
        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);

      } else {
        this.rect.updatePoint(1, p1.x, p0.y);
        this.rect.updatePoint(2, p1.x, p1.y);
        this.rect.updatePoint(3, p0.x, p1.y);
      }

      this.gizmoLayer.update();

      this.areaLabel.setShape(this.rect);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateRect(forceQuad);
    } }, { key: "endDrag", value: function endDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.rect) {
        return false;
      }

      // Check if rect is valid
      var dx = this.endPoint.x - this.startPoint.x;
      var dy = this.endPoint.y - this.startPoint.y;
      var Eps = 1.e-10;
      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;

      // Move shape to main layer (or just remove if invalid)
      this.gizmoLayer.removeShape(this.rect);
      if (rectValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.rect));
      }

      this.rect = null;

      this.areaLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.rect) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.rect);
        this.rect = null;

        this.dragCanceled = true;

        this.areaLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.rect);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(false);
      }
    } }]);return RectangleTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/UndoTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/UndoTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolName = 'Edit2_UndoTool';

var av = Autodesk.Viewing;

// Simple tool that triggers undo/redo in response to a keyboard shortcut
var UndoTool = /*#__PURE__*/function () {

  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);
    this.undoStack = undoStack;
  }_createClass(UndoTool, [{ key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Undo
      //  - Ctrl + Z (Windows)
      //  - Command + Z (Mac)
      // Redo
      // - Ctrl + Shift + Z (Windows)
      // - Command + Shift + Z (Mac)
      // - Ctrl + Y (Used on Windows but not Mac)

      if ((event.ctrlKey || event.metaKey) && keyCode === av.KeyCode.z) {
        if (event.shiftKey) {
          this.undoStack.redo();
        } else {
          this.undoStack.undo();
        }

        return true;
      }

      if (event.ctrlKey && keyCode === av.KeyCode.y) {
        this.undoStack.redo();
        return true;
      }

      return false;
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return UndoToolName;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return UndoTool;}();
;

/***/ }),

/***/ "./extensions/Edit2D/tools/VertexMoveTool.js":
/*!***************************************************!*\
  !*** ./extensions/Edit2D/tools/VertexMoveTool.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexMoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}






var VertexMoveToolName = "Edit2_VertexMoveTool";

var av = Autodesk.Viewing;

var vertexGizmoName = function vertexGizmoName(index, loopIndex) {
  return 'PolygonEditTool_vertexGizmo_' + loopIndex.toString() + '_' + index.toString();
};var

VertexMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(VertexMoveTool, _EditToolBase);var _super = _createSuper(VertexMoveTool);

  function VertexMoveTool(ctx) {var _this;_classCallCheck(this, VertexMoveTool);
    _this = _super.call(this, ctx);

    _this.layer = ctx.layer;
    _this.selection = ctx.selection;
    _this.nameSuffix = "_".concat(ctx.toolSetName);

    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;
    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Array of VertexGizmo per loop
    _this.vertexGizmos = []; // VertexGizmo[][]

    // Index of the vertex currently being dragged (or -1 if no dragging is active)
    _this.draggedVertex = null; // {PolyIndex}

    // When dragging a vertex, this stores a copy of its original position
    _this.dragVertexStartPos = new THREE.Vector2();

    // gizmos are enabled by default.
    _this.gizmosEnabled = true;

    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex,
    // but (unlike draggedVertex) keeps the same after dragEnd.
    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.
    _this.selectedVertex = null; // {PolyIndex}

    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();return _this;
  }_createClass(VertexMoveTool, [{ key: "getName", value: function getName()

    {
      return VertexMoveToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "deactivate", this).call(this);
      this.reset();
    } }, { key: "setAllGizmosEnabled", value: function setAllGizmosEnabled(

    enabled) {
      this.gizmosEnabled = enabled;

      this.updateVertexGizmos();
    }

    // create VertexGizmos for a single loop
  }, { key: "updateVertexGizmoLoop", value: function updateVertexGizmoLoop(loopIndex) {

      var gizmos = [];
      var vertexCount = this.poly.getVertexCount(loopIndex);
      for (var i = 0; i < vertexCount; i++) {

        // create new vertex gizmo
        var p = this.poly.getPoint(i, loopIndex);
        var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, vertexGizmoName(i, loopIndex));
        vertex.attachToVertex(this.poly, i, loopIndex);
        gizmos.push(vertex);

        // We implement drag-behavior, so we want hover-highlight
        vertex.setHoverEnabled(true);
      }

      this.vertexGizmos[loopIndex] = gizmos;
    }

    // Create VertexGizmos for all loops
  }, { key: "updateVertexGizmos", value: function updateVertexGizmos() {
      // clear any outdated ones
      this.clearVertexGizmos();

      if (!this.gizmosEnabled) {
        return;
      }

      if (this.poly) {
        for (var l = 0; l < this.poly.loopCount; l++) {
          this.updateVertexGizmoLoop(l);
        }
      }

      // Make sure that vertex-highlighting is up to date
      this.updateVertexHighlighting();
    } }, { key: "clearVertexGizmos", value: function clearVertexGizmos()

    {
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].dtor();
        }
      }
      this.vertexGizmos.length = 0;
    }

    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)
  }, { key: "updateVertexHighlighting", value: function updateVertexHighlighting() {
      var selected = this.selectedVertex;
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].setSelected(selected && selected.vertex === i && selected.loop === l);
        }
      }
    }

    // Update vertex-gizmos, and tangent gizmos.
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateVertexGizmos();
    }

    // @param{PolyIndex} polyIndex
  }, { key: "setSelectedVertex", value: function setSelectedVertex(polyIndex) {
      this.selectedVertex = this.poly ? polyIndex : null;
      this.updateVertexHighlighting();
    }

    // Return index of the vertex gizmo under mouse. (or null if no vertexGizmo is hit)
    // returns {PolyIndex}
  }, { key: "findVertexUnderMouse", value: function findVertexUnderMouse() {
      var vertexIndex = -1;
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        vertexIndex = this.gizmoManager.getGizmoIndex(gizmos);

        // Return vertex index if we found one.
        if (vertexIndex >= 0) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({
            loop: l,
            vertex: vertexIndex });

        }
      }
      return null;
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;
      this.draggedVertex = null;
      this.selectedVertex = null;

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      // If we hit an existing vertex, start dragging it
      var draggedVertex = this.findVertexUnderMouse();
      if (draggedVertex) {
        this.startDragVertex(event, draggedVertex);
        this.startedDragging = true;
        return true;
      }

      return false;
    }


    // @param {Event} event
    // @param {PolyIndex} draggedVertex
  }, { key: "startDragVertex", value: function startDragVertex(event, draggedVertex) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // Configure angle snapping to consider latest state of the polygon
      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex.vertex, draggedVertex.loop);

      this.draggedVertex = draggedVertex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = this.poly.getPoint(this.draggedVertex.vertex, this.draggedVertex.loop);
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);

      // highlight the vertex we clicked on
      this.setSelectedVertex(this.draggedVertex);

      this.lastDragPoint.copy(vpos);
      this.dragVertexStartPos.copy(vpos);
    } }, { key: "moveDragVertex", value: function moveDragVertex(

    canvasX, canvasY) {var _this$draggedVertex =

      this.draggedVertex,loop = _this$draggedVertex.loop,vertex = _this$draggedVertex.vertex;

      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;

      // get delta between last and current position
      var p = this.getSnapPosition(x, y);
      var dx = p.x - this.lastDragPoint.x;
      var dy = p.y - this.lastDragPoint.y;

      // apply this offset to polygon point
      var point = this.poly.getPoint(vertex, loop);
      this.poly.updatePoint(vertex, point.x + dx, point.y + dy, loop);

      // re-center gizmo at new point position
      var vertexGizmo = this.vertexGizmos[loop][vertex];
      vertexGizmo.setPosition(point.x, point.y);

      this.gizmoLayer.update(); // we moved the vertex gizmo
      this.layer.update(); // we changed the main polygon

      this.lastDragPoint.copy(p);
    } }, { key: "restoreDragVertex", value: function restoreDragVertex()

    {
      this.poly.updatePoint(this.draggedVertex.vertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y, this.draggedVertex.loop);
    } }, { key: "endDragVertex", value: function endDragVertex()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // First, restore "before move" position of the vertex
      this.restoreDragVertex();

      var pBefore = this.dragVertexStartPos;
      var pAfter = this.lastDragPoint;

      // don't add extra undo-operation if the vertex was hardly moved at all
      var minDist = this.layer.getUnitsPerPixel() * 0.5;
      var moved = pBefore.distanceTo(pAfter) > minDist;

      if (moved) {
        // Finalize vertex-move
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));
      }

      this.draggedVertex = null;
      this.snapper.clearSnappingGizmos();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));

      if (!this.poly) {
        return false;
      }

      if (this.draggedVertex) {
        this.moveDragVertex(event.canvasX, event.canvasY);
        return true;
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleButtonUp", this).call(this, event, button);

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      if (this.draggedVertex) {
        this.endDragVertex();
        return true;
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && wasDragging;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(VertexMoveTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.CancelEdit) {
        handled = this.cancelDrag();
      }

      return handled;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedVertex) {
        this.restoreDragVertex();
        this.draggedVertex = null;
        needsUpdate = true;
      }

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      this.snapper.clearSnappingGizmos();

      return needsUpdate;
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {

      // If we are dragging a vertex, toggling snapping will affect the result and 
      // we should update line gizmos and snapping lines.
      if (this.draggedVertex) {
        this.moveDragVertex(canvasX, canvasY);
      }
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {
      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {
        this.setSelectedVertex(hint.vertex);
        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      this.setSelectedVertex(null);
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.
      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedVertex) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }]);return VertexMoveTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/***/ }),

/***/ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@adsk/solid-definition/dist/solid-definition.min.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);} /*!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2017 Autodesk, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This computer source code and related instructions and comments are the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * unpublished confidential and proprietary information of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * and are protected under applicable copyright and trade secret law. They
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * may not be disclosed to, copied or used by any third party without the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * prior written consent of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */
!function (e, t) {"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["solid-definition"] = t() : e.SolidDefinition = t();}("undefined" != typeof self ? self : this, function () {return function (e) {var t = {};function r(n) {if (t[n]) return t[n].exports;var o = t[n] = { i: n, l: !1, exports: {} };return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;}return r.m = e, r.c = t, r.d = function (e, t, n) {r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });}, r.r = function (e) {"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });}, r.t = function (e, t) {if (1 & t && (e = r(e)), 8 & t) return e;if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;var n = Object.create(null);if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) {r.d(n, o, function (t) {return e[t];}.bind(null, o));}return n;}, r.n = function (e) {var t = e && e.__esModule ? function () {return e.default;} : function () {return e;};return r.d(t, "a", t), t;}, r.o = function (e, t) {return Object.prototype.hasOwnProperty.call(e, t);}, r.p = "", r(r.s = 86);}([function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1;"undefined" != typeof window && window.isJaguar && (t.isSceneComposerEnv = n = !0);var o = !1;n && (t.USE_LEGACY_LEIDS = o = window.isJaguar && window.isJaguar() || !!JSON.parse(localStorage.getItem("USE_LEGACY_LEIDS"))), t.KERNEL_TOLERANCE = 1e-6, t.KERNEL_ANGULAR_TOLERANCE = 1e-10, t.PARAMETER_SPACE_TOLERANCE = 1e-10, t.SPLINE_TANGENT_HANDLE_SCALE = 1, t.SPLINE_DISTANCE_TOLERANCE = 1e-4, t.DEFAULT_CURVE_RESOLUTION = 64, t.isSceneComposerEnv = n, t.NO_ID = "", t.USE_LEGACY_LEIDS = o, t.TESSELLATION = { LINEAR_PRECISION: 1e-4, ANGULAR_PRECISION: 1e-5 }, t.GEOMETRY_TYPES = { POINT: 1, BCURVE: 2, CIRCLE: 3, ELLIPSE: 4, HAPCURVE: 5, LINE: 6, BSURFACE: 7, CONE: 8, CYLINDER: 9, ELLIPTICAL_CONE: 10, ELLIPTICAL_CYLINDER: 11, PLANE: 12, SPHERE: 13, TORUS: 14, toString: function toString(e) {switch (e) {case this.POINT:return "Point";case this.BCURVE:return "BCurve";case this.CIRCLE:return "Circle";case this.ELLIPSE:return "Ellipse";case this.HAPCURVE:return "HapCurve";case this.LINE:return "Line";case this.BSURFACE:return "BSurface";case this.CONE:return "Cone";case this.CYLINDER:return "Cylinder";case this.ELLIPTICAL_CONE:return "EllipticalCone";case this.ELLIPTICAL_CYLINDER:return "EllipticalCylinder";case this.PLANE:return "Plane";case this.SPHERE:return "Sphere";case this.TORUS:return "Torus";default:return "unknown";}} }, t.TOPOLOGY_TYPES = { VERTEX: 1, EDGE: 2, COEDGE: 3, LOOP: 4, FACE: 5, SHELL: 6, LUMP: 7, BODY: 8, WIRE: 9, WIREBODY: 10, toString: function toString(e) {switch (e) {case this.VERTEX:return "Vertex";case this.EDGE:return "Edge";case this.COEDGE:return "Coedge";case this.LOOP:return "Loop";case this.FACE:return "Face";case this.SHELL:return "Shell";case this.LUMP:return "Lump";case this.BODY:return "Body";case this.WIRE:return "Wire";case this.WIREBODY:return "WireBody";default:return "unknown";}} };}, function (e, t, r) {"use strict";r.r(t), r.d(t, "Vector2", function () {return s;}), r.d(t, "Vector3", function () {return c;}), r.d(t, "Vector4", function () {return l;}), r.d(t, "Matrix22", function () {return d;}), r.d(t, "Matrix33", function () {return p;}), r.d(t, "Matrix44", function () {return v;}), r.d(t, "Quat", function () {return y;}), r.d(t, "ProjectionUtils", function () {return m;}), r.d(t, "FLOAT64_TOLERANCE", function () {return n;}), r.d(t, "FLOAT32_TOLERANCE", function () {return o;});var n = 1e-12,o = 1e-6;var i = { createFloat32: function createFloat32() {var e = new Float32Array(2);return e[0] = 0, e[1] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(2);return e[0] = 0, e[1] = 0, e;}, createNumber: function createNumber() {return [0, 0];}, clone: function clone(e) {var t = new e.constructor(2);return t[0] = e[0], t[1] = e[1], t;}, createFloat32FromValues: function createFloat32FromValues(e, t) {var r = new Float32Array(2);return r[0] = e, r[1] = t, r;} };i.asFloat32 = i.createFloat32FromValues, i.createFloat64FromValues = function (e, t) {var r = new Float64Array(2);return r[0] = e, r[1] = t, r;}, i.asFloat64 = i.createFloat64FromValues, i.createNumberFromValues = function (e, t) {return [e, t];}, i.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e;}, i.set = function (e, t, r) {return e[0] = t, e[1] = r, e;}, i.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;}, i.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;}, i.sub = i.subtract, i.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;}, i.mul = i.multiply, i.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;}, i.div = i.divide, i.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;}, i.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;}, i.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;}, i.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;}, i.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;}, i.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e;}, i.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;}, i.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return Math.sqrt(r * r + n * n);}, i.dist = i.distance, i.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return r * r + n * n;}, i.sqrDist = i.squaredDistance, i.length = function (e) {var t = e[0],r = e[1];return Math.sqrt(t * t + r * r);}, i.len = i.length, i.squaredLength = function (e) {var t = e[0],r = e[1];return t * t + r * r;}, i.sqrLen = i.squaredLength, i.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e;}, i.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e;}, i.normalize = function (e, t) {var r = t[0],n = t[1],o = r * r + n * n;return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o), e;}, i.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1];}, i.cross = function (e, t, r) {var n = t[0] * r[1] - t[1] * r[0];return e[0] = e[1] = 0, e[2] = n, e;}, i.lerp = function (e, t, r, n) {var o = t[0],i = t[1];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e;}, i.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI;return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;}, i.transformMatrix22 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[2] * o, e[1] = r[1] * n + r[3] * o, e;}, i.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[3] * o + r[6], e[1] = r[1] * n + r[4] * o + r[7], e;}, i.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[4] * o + r[12], e[1] = r[1] * n + r[5] * o + r[13], e;}, i.angle = function (e, t) {var r = i.clone(e),n = i.clone(t);i.normalize(r, r), i.normalize(n, n);var o = i.dot(r, n),s = Math.abs(r[0] * n[1] - r[1] * n[0]);return Math.atan2(s, o);}, i.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var s = e[0] * t[1] - e[1] * t[0];return !(s * s > o * o * i.squaredLength(e) * i.squaredLength(t)) && (r > 0 ? i.dot(e, t) > 0 : !(r < 0) || i.dot(e, t) < 0);}, i.isOrthogonal = function (e, t, r) {r = r || n;var o = i.dot(e, t);return o * o <= r * r * i.squaredLength(e) * i.squaredLength(t);}, i.toString = function (e) {return "[" + e[0] + ", " + e[1] + "]";}, i.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1];}, i.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r;};var s = i,a = { createFloat32: function createFloat32() {var e = new Float32Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(3);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r) {var n = new Float32Array(3);return n[0] = e, n[1] = t, n[2] = r, n;} };a.asFloat32 = a.createFloat32FromValues, a.createFloat64FromValues = function (e, t, r) {var n = new Float64Array(3);return n[0] = e, n[1] = t, n[2] = r, n;}, a.asFloat64 = a.createFloat64FromValues, a.createNumberFromValues = function (e, t, r) {return [e, t, r];}, a.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;}, a.set = function (e, t, r, n) {return e[0] = t, e[1] = r, e[2] = n, e;}, a.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;}, a.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;}, a.sub = a.subtract, a.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;}, a.mul = a.multiply, a.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;}, a.div = a.divide, a.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;}, a.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;}, a.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;}, a.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;}, a.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;}, a.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;}, a.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;}, a.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return Math.sqrt(r * r + n * n + o * o);}, a.dist = a.distance, a.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return r * r + n * n + o * o;}, a.sqrDist = a.squaredDistance, a.length = function (e) {var t = e[0],r = e[1],n = e[2];return Math.sqrt(t * t + r * r + n * n);}, a.len = a.length, a.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2];return t * t + r * r + n * n;}, a.sqrLen = a.squaredLength, a.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;}, a.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;}, a.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = r * r + n * n + o * o;return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i), e;}, a.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];}, a.cross = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2];return e[0] = o * c - i * a, e[1] = i * s - n * c, e[2] = n * a - o * s, e;}, a.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e;}, a.hermite = function (e, t, r, n, o, i) {var s = i * i,a = s * (2 * i - 3) + 1,c = s * (i - 2) + i,u = s * (i - 1),l = s * (3 - 2 * i);return e[0] = t[0] * a + r[0] * c + n[0] * u + o[0] * l, e[1] = t[1] * a + r[1] * c + n[1] * u + o[1] * l, e[2] = t[2] * a + r[2] * c + n[2] * u + o[2] * l, e;}, a.bezier = function (e, t, r, n, o, i) {var s = 1 - i,a = s * s,c = i * i,u = a * s,l = 3 * i * a,h = 3 * c * s,d = c * i;return e[0] = t[0] * u + r[0] * l + n[0] * h + o[0] * d, e[1] = t[1] * u + r[1] * l + n[1] * h + o[1] * d, e[2] = t[2] * u + r[2] * l + n[2] * h + o[2] * d, e;}, a.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI,n = 2 * Math.random() - 1,o = Math.sqrt(1 - n * n) * t;return e[0] = Math.cos(r) * o, e[1] = Math.sin(r) * o, e[2] = n * t, e;}, a.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12], e[1] = r[1] * n + r[5] * o + r[9] * i + r[13], e[2] = r[2] * n + r[6] * o + r[10] * i + r[14], e;}, a.transformAsDirectionMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i, e[1] = r[1] * n + r[5] * o + r[9] * i, e[2] = r[2] * n + r[6] * o + r[10] * i, e;}, a.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = n * r[0] + o * r[3] + i * r[6], e[1] = n * r[1] + o * r[4] + i * r[7], e[2] = n * r[2] + o * r[5] + i * r[8], e;}, a.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e;}, a.setFromMatrixScale = function (e, t) {var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = r, e[1] = n, e[2] = o, e;}, a.rotateX = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0], i[1] = o[1] * Math.cos(n) - o[2] * Math.sin(n), i[2] = o[1] * Math.sin(n) + o[2] * Math.cos(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateY = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[2] * Math.sin(n) + o[0] * Math.cos(n), i[1] = o[1], i[2] = o[2] * Math.cos(n) - o[0] * Math.sin(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateZ = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n), i[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n), i[2] = o[2], e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.angle = function (e, t) {var r = a.clone(e),n = a.clone(t);a.normalize(r, r), a.normalize(n, n);var o = a.dot(r, n),i = a.length(a.cross(r, r, n));return Math.atan2(i, o);}, a.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var i = a.createFloat64();return a.cross(i, e, t), !(a.squaredLength(i) > o * o * a.squaredLength(e) * a.squaredLength(t)) && (r > 0 ? a.dot(e, t) > 0 : !(r < 0) || a.dot(e, t) < 0);}, a.isOrthogonal = function (e, t, r) {r = r || n;var o = a.dot(e, t);return o * o <= r * r * a.squaredLength(e) * a.squaredLength(t);}, a.computeOrthogonal = function (e, t) {return t[0] * t[0] > t[2] * t[2] ? a.set(e, t[1], -t[0], 0) : a.set(e, 0, t[2], -t[1]), e;}, a.setEulerFromRotationMatrix = function (e, t, r) {var o = 1 - n;function i(e) {return Math.min(Math.max(e, -1), 1);}var s = t[0],a = t[4],c = t[8],u = t[1],l = t[5],h = t[9],d = t[2],g = t[6],p = t[10];return void 0 === r || "XYZ" === r ? (e[1] = Math.asin(i(c)), Math.abs(c) < o ? (e[0] = Math.atan2(-h, p), e[2] = Math.atan2(-a, s)) : (e[0] = Math.atan2(g, l), e[2] = 0)) : "YXZ" === r ? (e[0] = Math.asin(-i(h)), Math.abs(h) < o ? (e[1] = Math.atan2(c, p), e[2] = Math.atan2(u, l)) : (e[1] = Math.atan2(-d, s), e[2] = 0)) : "ZXY" === r ? (e[0] = Math.asin(i(g)), Math.abs(g) < o ? (e[1] = Math.atan2(-d, p), e[2] = Math.atan2(-a, l)) : (e[1] = 0, e[2] = Math.atan2(u, s))) : "ZYX" === r ? (e[1] = Math.asin(-i(d)), Math.abs(d) < o ? (e[0] = Math.atan2(g, p), e[2] = Math.atan2(u, s)) : (e[0] = 0, e[2] = Math.atan2(-a, l))) : "YZX" === r ? (e[2] = Math.asin(i(u)), Math.abs(u) < o ? (e[0] = Math.atan2(-h, l), e[1] = Math.atan2(-d, s)) : (e[0] = 0, e[1] = Math.atan2(c, p))) : "XZY" === r && (e[2] = Math.asin(-i(a)), Math.abs(a) < o ? (e[0] = Math.atan2(g, l), e[1] = Math.atan2(c, s)) : (e[0] = Math.atan2(-h, p), e[1] = 0)), e;}, a.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + "]";}, a.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];}, a.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r;};var c = a,u = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(4);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };u.asFloat32 = u.createFloat32FromValues, u.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, u.asFloat64 = u.createFloat64FromValues, u.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, u.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, u.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, u.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, u.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, u.sub = u.subtract, u.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;}, u.mul = u.multiply, u.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;}, u.div = u.divide, u.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;}, u.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;}, u.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;}, u.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;}, u.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;}, u.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, u.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, u.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return Math.sqrt(r * r + n * n + o * o + i * i);}, u.dist = u.distance, u.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return r * r + n * n + o * o + i * i;}, u.sqrDist = u.squaredDistance, u.length = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return Math.sqrt(t * t + r * r + n * n + o * o);}, u.len = u.length, u.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return t * t + r * r + n * n + o * o;}, u.sqrLen = u.squaredLength, u.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;}, u.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;}, u.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i;return s > 0 && (s = 1 / Math.sqrt(s), e[0] = r * s, e[1] = n * s, e[2] = o * s, e[3] = i * s), e;}, u.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];}, u.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e[3] = a + n * (r[3] - a), e;}, u.random = function (e, t) {return t = t || 1, e[0] = Math.random(), e[1] = Math.random(), e[2] = Math.random(), e[3] = Math.random(), u.normalize(e, e), u.scale(e, e, t), e;}, u.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12] * s, e[1] = r[1] * n + r[5] * o + r[9] * i + r[13] * s, e[2] = r[2] * n + r[6] * o + r[10] * i + r[14] * s, e[3] = r[3] * n + r[7] * o + r[11] * i + r[15] * s, e;}, u.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e[3] = t[3], e;}, u.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, u.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, u.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[2] - t[2]) <= r;};var l = u,h = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };h.asFloat32 = h.createFloat32FromValues, h.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, h.asFloat64 = h.createFloat64FromValues, h.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, h.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, h.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, h.transpose = function (e, t) {if (e === t) {var r = t[1];e[1] = t[2], e[2] = r;} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];return e;}, h.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * i - o * n;return s ? (s = 1 / s, e[0] = i * s, e[1] = -n * s, e[2] = -o * s, e[3] = r * s, e) : null;}, h.determinant = function (e) {return e[0] * e[3] - e[2] * e[1];}, h.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * a + i * c, e[1] = o * a + s * c, e[2] = n * u + i * l, e[3] = o * u + s * l, e;}, h.mul = h.multiply, h.scale = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1];return e[0] = n * a, e[1] = o * a, e[2] = i * c, e[3] = s * c, e;}, h.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, h.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, h.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, h.sub = h.subtract, h.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, h.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, h.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, h.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r;};var d = h,g = { createFloat32: function createFloat32() {var e = new Float32Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 1, 0, 0, 0, 1];}, fromMatrix44: function fromMatrix44(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c) {var u = new Float32Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;} };g.asFloat32 = g.createFloat32FromValues, g.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c) {var u = new Float64Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;}, g.asFloat64 = g.createFloat64FromValues, g.createNumberFromValues = function (e, t, r, n, o, i, s, a, c) {return [e, t, r, n, o, i, s, a, c];}, g.set = function (e, t, r, n, o, i, s, a, c, u) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e;}, g.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[5];e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = o;} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];return e;}, g.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = l * s - a * u,d = -l * i + a * c,g = u * i - s * c,p = r * h + n * d + o * g;return p ? (p = 1 / p, e[0] = h * p, e[1] = (-l * n + o * u) * p, e[2] = (a * n - o * s) * p, e[3] = d * p, e[4] = (l * r - o * c) * p, e[5] = (-a * r + o * i) * p, e[6] = g * p, e[7] = (-u * r + n * c) * p, e[8] = (s * r - n * i) * p, e) : null;}, g.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8];return t * (u * i - s * c) + r * (-u * o + s * a) + n * (c * o - i * a);}, g.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = r[0],g = r[1],p = r[2],f = r[3],v = r[4],_ = r[5],y = r[6],m = r[7],E = r[8];return e[0] = d * n + g * s + p * u, e[1] = d * o + g * a + p * l, e[2] = d * i + g * c + p * h, e[3] = f * n + v * s + _ * u, e[4] = f * o + v * a + _ * l, e[5] = f * i + v * c + _ * h, e[6] = y * n + m * s + E * u, e[7] = y * o + m * a + E * l, e[8] = y * i + m * c + E * h, e;}, g.mul = g.multiply, g.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;}, g.fromRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[3] = l - _, e[6] = d + v, e[1] = l + _, e[4] = 1 - u - p, e[7] = g - f, e[2] = d - v, e[5] = g + f, e[8] = 1 - u - h, e;}, g.normalFromMatrix44 = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (c * T - s * L - u * V) * O, e[2] = (s * b - a * T + u * P) * O, e[3] = (o * b - n * L - i * C) * O, e[4] = (r * L - o * T + i * V) * O, e[5] = (n * T - r * b - i * P) * O, e[6] = (f * A - v * R + _ * x) * O, e[7] = (v * E - p * A - _ * m) * O, e[8] = (p * R - f * E + _ * y) * O, e) : null;}, g.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + "]";}, g.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;}, g.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;}, g.sub = g.subtract, g.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;}, g.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;}, g.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];}, g.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r;};var p = g,f = { createFloat32: function createFloat32() {var e = new Float32Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(16);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float32Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;} };f.asFloat32 = f.createFloat32FromValues, f.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float64Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;}, f.asFloat64 = f.createFloat64FromValues, f.createNumberFromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {return [e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f];}, f.set = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e[9] = l, e[10] = h, e[11] = d, e[12] = g, e[13] = p, e[14] = f, e[15] = v, e;}, f.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[3],i = t[6],s = t[7],a = t[11];e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = o, e[13] = s, e[14] = a;} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];return e;}, f.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (o * b - n * L - i * C) * O, e[2] = (f * A - v * R + _ * x) * O, e[3] = (d * R - h * A - g * x) * O, e[4] = (c * T - s * L - u * V) * O, e[5] = (r * L - o * T + i * V) * O, e[6] = (v * E - p * A - _ * m) * O, e[7] = (l * A - d * E + g * m) * O, e[8] = (s * b - a * T + u * P) * O, e[9] = (n * T - r * b - i * P) * O, e[10] = (p * R - f * E + _ * y) * O, e[11] = (h * E - l * R - g * y) * O, e[12] = (a * V - s * C - c * P) * O, e[13] = (r * C - n * V + o * P) * O, e[14] = (f * m - p * x - v * y) * O, e[15] = (l * x - h * m + d * y) * O, e) : null;}, f.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8],l = e[9],h = e[10],d = e[11],g = e[12],p = e[13],f = e[14],v = e[15];return (t * s - r * i) * (h * v - d * f) - (t * a - n * i) * (l * v - d * p) + (t * c - o * i) * (l * f - h * p) + (r * a - n * s) * (u * v - d * g) - (r * c - o * s) * (u * f - h * g) + (n * c - o * a) * (u * p - l * g);}, f.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = t[9],g = t[10],p = t[11],f = t[12],v = t[13],_ = t[14],y = t[15],m = r[0],E = r[1],x = r[2],R = r[3];return e[0] = m * n + E * a + x * h + R * f, e[1] = m * o + E * c + x * d + R * v, e[2] = m * i + E * u + x * g + R * _, e[3] = m * s + E * l + x * p + R * y, m = r[4], E = r[5], x = r[6], R = r[7], e[4] = m * n + E * a + x * h + R * f, e[5] = m * o + E * c + x * d + R * v, e[6] = m * i + E * u + x * g + R * _, e[7] = m * s + E * l + x * p + R * y, m = r[8], E = r[9], x = r[10], R = r[11], e[8] = m * n + E * a + x * h + R * f, e[9] = m * o + E * c + x * d + R * v, e[10] = m * i + E * u + x * g + R * _, e[11] = m * s + E * l + x * p + R * y, m = r[12], E = r[13], x = r[14], R = r[15], e[12] = m * n + E * a + x * h + R * f, e[13] = m * o + E * c + x * d + R * v, e[14] = m * i + E * u + x * g + R * _, e[15] = m * s + E * l + x * p + R * y, e;}, f.mul = f.multiply, f.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;}, f.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotation = function (e, t, r) {var o,i,s,a = r[0],c = r[1],u = r[2],l = Math.sqrt(a * a + c * c + u * u);return Math.abs(l) < n ? null : (a *= l = 1 / l, c *= l, u *= l, o = Math.sin(t), s = 1 - (i = Math.cos(t)), e[0] = a * a * s + i, e[1] = c * a * s + u * o, e[2] = u * a * s - c * o, e[3] = 0, e[4] = a * c * s - u * o, e[5] = c * c * s + i, e[6] = u * c * s + a * o, e[7] = 0, e[8] = a * u * s + c * o, e[9] = c * u * s - a * o, e[10] = u * u * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);}, f.fromXRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromYRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromZRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotationTranslation = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = n + n,c = o + o,u = i + i,l = n * a,h = n * c,d = n * u,g = o * c,p = o * u,f = i * u,v = s * a,_ = s * c,y = s * u;return e[0] = 1 - (g + f), e[1] = h + y, e[2] = d - _, e[3] = 0, e[4] = h - y, e[5] = 1 - (l + f), e[6] = p + v, e[7] = 0, e[8] = d + _, e[9] = p - v, e[10] = 1 - (l + g), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.getTranslation = function (e, t) {return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;}, f.extractRotation = function (e, t) {var r = 1 / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = 1 / Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = 1 / Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;}, f.getRotation = function (e, t) {var r = t[0] + t[5] + t[10],n = 0;return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;}, f.fromRotationTranslationScale = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3],c = o + o,u = i + i,l = s + s,h = o * c,d = o * u,g = o * l,p = i * u,f = i * l,v = s * l,_ = a * c,y = a * u,m = a * l,E = n[0],x = n[1],R = n[2];return e[0] = (1 - (p + v)) * E, e[1] = (d + m) * E, e[2] = (g - y) * E, e[3] = 0, e[4] = (d - m) * x, e[5] = (1 - (h + v)) * x, e[6] = (f + _) * x, e[7] = 0, e[8] = (g + y) * R, e[9] = (f - _) * R, e[10] = (1 - (h + p)) * R, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.fromRotationTranslationScaleOrigin = function (e, t, r, n, o) {var i = t[0],s = t[1],a = t[2],c = t[3],u = i + i,l = s + s,h = a + a,d = i * u,g = i * l,p = i * h,f = s * l,v = s * h,_ = a * h,y = c * u,m = c * l,E = c * h,x = n[0],R = n[1],A = n[2],P = o[0],V = o[1],T = o[2];return e[0] = (1 - (f + _)) * x, e[1] = (g + E) * x, e[2] = (p - m) * x, e[3] = 0, e[4] = (g - E) * R, e[5] = (1 - (d + _)) * R, e[6] = (v + y) * R, e[7] = 0, e[8] = (p + m) * A, e[9] = (v - y) * A, e[10] = (1 - (d + f)) * A, e[11] = 0, e[12] = r[0] + P - (e[0] * P + e[4] * V + e[8] * T), e[13] = r[1] + V - (e[1] * P + e[5] * V + e[9] * T), e[14] = r[2] + T - (e[2] * P + e[6] * V + e[10] * T), e[15] = 1, e;}, f.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[1] = l + _, e[2] = d - v, e[3] = 0, e[4] = l - _, e[5] = 1 - u - p, e[6] = g + f, e[7] = 0, e[8] = d + v, e[9] = g - f, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.setRotationFromEuler = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = Math.cos(n),a = Math.sin(n),c = Math.cos(o),u = Math.sin(o),l = Math.cos(i),h = Math.sin(i);if (void 0 === r || "XYZ" === r) {var d = s * l,g = s * h,p = a * l,f = a * h;e[0] = c * l, e[4] = -c * h, e[8] = u, e[1] = g + p * u, e[5] = d - f * u, e[9] = -a * c, e[2] = f - d * u, e[6] = p + g * u, e[10] = s * c;} else if ("YXZ" === r) {var v = c * l,_ = c * h,y = u * l,m = u * h;e[0] = v + m * a, e[4] = y * a - _, e[8] = s * u, e[1] = s * h, e[5] = s * l, e[9] = -a, e[2] = _ * a - y, e[6] = m + v * a, e[10] = s * c;} else if ("ZXY" === r) v = c * l, _ = c * h, y = u * l, m = u * h, e[0] = v - m * a, e[4] = -s * h, e[8] = y + _ * a, e[1] = _ + y * a, e[5] = s * l, e[9] = m - v * a, e[2] = -s * u, e[6] = a, e[10] = s * c;else if ("ZYX" === r) d = s * l, g = s * h, p = a * l, f = a * h, e[0] = c * l, e[4] = p * u - g, e[8] = d * u + f, e[1] = c * h, e[5] = f * u + d, e[9] = g * u - p, e[2] = -u, e[6] = a * c, e[10] = s * c;else if ("YZX" === r) {var E = s * c,x = s * u,R = a * c,A = a * u;e[0] = c * l, e[4] = A - E * h, e[8] = R * h + x, e[1] = h, e[5] = s * l, e[9] = -a * l, e[2] = -u * l, e[6] = x * h + R, e[10] = E - A * h;} else "XZY" === r && (E = s * c, x = s * u, R = a * c, A = a * u, e[0] = c * l, e[4] = -h, e[8] = u * l, e[1] = E * h + A, e[5] = s * l, e[9] = x * h - R, e[2] = R * h - x, e[6] = a * l, e[10] = A * h + E);return e;}, f.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + "]";}, f.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;}, f.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;}, f.sub = f.subtract, f.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;}, f.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;}, f.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];}, f.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r && Math.abs(e[9] - t[9]) <= r && Math.abs(e[10] - t[10]) <= r && Math.abs(e[11] - t[11]) <= r && Math.abs(e[12] - t[12]) <= r && Math.abs(e[13] - t[13]) <= r && Math.abs(e[14] - t[14]) <= r && Math.abs(e[15] - t[15]) <= r;};var v = f,_ = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [0, 0, 0, 1];} };_.rotationTo = function () {var e = c.createFloat64(),t = c.createFloat64FromValues(1, 0, 0),r = c.createFloat64FromValues(0, 1, 0);return function (o, i, s) {var a = c.dot(i, s);return a < -1 + n ? (c.cross(e, t, i), c.length(e) < n && c.cross(e, r, i), c.normalize(e, e), _.setAxisAngle(o, e, Math.PI), o) : a > 1 - n ? (o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1, o) : (c.cross(e, i, s), o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = 1 + a, _.normalize(o, o));};}(), _.setAxes = function () {var e = p.createFloat64();return function (t, r, n, o) {return e[0] = n[0], e[3] = n[1], e[6] = n[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], _.normalize(t, _.fromMatrix33(t, e));};}(), _.clone = l.clone, _.createFloat32FromValues = l.createFloat32FromValues, _.createFloat64FromValues = l.createFloat64FromValues, _.createNumberFromValues = l.createNumberFromValues, _.asFloat32 = l.createFloat32FromValues, _.asFloat64 = l.createFloat64FromValues, _.copy = l.copy, _.set = l.set, _.identity = function (e) {return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, _.setAxisAngle = function (e, t, r) {r *= .5;var n = Math.sin(r);return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = Math.cos(r), e;}, _.getAxisAngle = function (e, t) {var r = 2 * Math.acos(t[3]),n = Math.sin(r / 2);return 0 !== n ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 1, e[1] = 0, e[2] = 0), r;}, _.add = l.add, _.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * l + s * a + o * u - i * c, e[1] = o * l + s * c + i * a - n * u, e[2] = i * l + s * u + n * c - o * a, e[3] = s * l - n * a - o * c - i * u, e;}, _.mul = _.multiply, _.scale = l.scale, _.rotateX = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + s * a, e[1] = o * c + i * a, e[2] = i * c - o * a, e[3] = s * c - n * a, e;}, _.rotateY = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c - i * a, e[1] = o * c + s * a, e[2] = i * c + n * a, e[3] = s * c - o * a, e;}, _.rotateZ = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + o * a, e[1] = o * c - n * a, e[2] = i * c + s * a, e[3] = s * c - i * a, e;}, _.calculateW = function (e, t) {var r = t[0],n = t[1],o = t[2];return e[0] = r, e[1] = n, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - r * r - n * n - o * o)), e;}, _.dot = l.dot, _.lerp = l.lerp, _.slerp = function (e, t, r, o) {var i,s,a,c,u,l = t[0],h = t[1],d = t[2],g = t[3],p = r[0],f = r[1],v = r[2],_ = r[3];return (s = l * p + h * f + d * v + g * _) < 0 && (s = -s, p = -p, f = -f, v = -v, _ = -_), 1 - s > n ? (i = Math.acos(s), a = Math.sin(i), c = Math.sin((1 - o) * i) / a, u = Math.sin(o * i) / a) : (c = 1 - o, u = o), e[0] = c * l + u * p, e[1] = c * h + u * f, e[2] = c * d + u * v, e[3] = c * g + u * _, e;}, _.sqlerp = function () {var e = _.createFloat64(),t = _.createFloat64();return function (r, n, o, i, s, a) {return _.slerp(e, n, s, a), _.slerp(t, o, i, a), _.slerp(r, e, t, 2 * a * (1 - a)), r;};}(), _.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i,a = s ? 1 / s : 0;return e[0] = -r * a, e[1] = -n * a, e[2] = -o * a, e[3] = i * a, e;}, _.conjugate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;}, _.length = l.length, _.len = _.length, _.squaredLength = l.squaredLength, _.sqrLen = _.squaredLength, _.normalize = l.normalize, _.fromMatrix33 = function (e, t) {var r,n = t[0] + t[4] + t[8];if (n > 0) r = Math.sqrt(n + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[5] - t[7]) * r, e[1] = (t[6] - t[2]) * r, e[2] = (t[1] - t[3]) * r;else {var o = 0;t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);var i = (o + 1) % 3,s = (o + 2) % 3;r = Math.sqrt(t[3 * o + o] - t[3 * i + i] - t[3 * s + s] + 1), e[o] = .5 * r, r = .5 / r, e[3] = (t[3 * i + s] - t[3 * s + i]) * r, e[i] = (t[3 * i + o] + t[3 * o + i]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r;}return e;}, _.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, _.exactEquals = l.exactEquals, _.equals = l.equals;var y = _,m = { frustum: function frustum(e, t, r, n, o, i, s) {var a = 1 / (r - t),c = 1 / (o - n),u = 1 / (i - s);return e[0] = 2 * i * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (o + n) * c, e[10] = (s + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i * 2 * u, e[15] = 0, e;}, perspective: function perspective(e, t, r, n, o) {var i = 1 / Math.tan(t / 2),s = 1 / (n - o);return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (o + n) * s, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * o * n * s, e[15] = 0, e;}, ortho: function ortho(e, t, r, n, o, i, s) {var a = 1 / (t - r),c = 1 / (n - o),u = 1 / (i - s);return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + r) * a, e[13] = (o + n) * c, e[14] = (s + i) * u, e[15] = 1, e;}, lookAt: function lookAt(e, t, r, o) {var i,s,a,c,u,l,h,d,g,p,f = t[0],_ = t[1],y = t[2],m = o[0],E = o[1],x = o[2],R = r[0],A = r[1],P = r[2];return Math.abs(f - R) < n && Math.abs(_ - A) < n && Math.abs(y - P) < n ? v.identity(e) : (h = f - R, d = _ - A, g = y - P, i = E * (g *= p = 1 / Math.sqrt(h * h + d * d + g * g)) - x * (d *= p), s = x * (h *= p) - m * g, a = m * d - E * h, (p = Math.sqrt(i * i + s * s + a * a)) ? (i *= p = 1 / p, s *= p, a *= p) : (i = 0, s = 0, a = 0), c = d * a - g * s, u = g * i - h * a, l = h * s - d * i, (p = Math.sqrt(c * c + u * u + l * l)) ? (c *= p = 1 / p, u *= p, l *= p) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = s, e[5] = u, e[6] = d, e[7] = 0, e[8] = a, e[9] = l, e[10] = g, e[11] = 0, e[12] = -(i * f + s * _ + a * y), e[13] = -(c * f + u * _ + l * y), e[14] = -(h * f + d * _ + g * y), e[15] = 1, e);}, transformProjectionMatrix: function transformProjectionMatrix(e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[3] * n + r[7] * o + r[11] * i + r[15];return s = s || 1, e[0] = (r[0] * n + r[4] * o + r[8] * i + r[12]) / s, e[1] = (r[1] * n + r[5] * o + r[9] * i + r[13]) / s, e[2] = (r[2] * n + r[6] * o + r[10] * i + r[14]) / s, e;} };t.default = { Vector2: s, Vector3: c, Vector4: l, Matrix22: d, Matrix33: p, Matrix44: v, Quat: y, ProjectionUtils: m, FLOAT64_TOLERANCE: n, FLOAT32_TOLERANCE: o };}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { assert: function assert(e, t) {if (!e) throw new Error(t);} };t.ConsoleUtils = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.definePlaneThroughPoints = t.getPlaneTransforms = t.limitRange = t.PI2 = t.sortedIndex = t.clamp = t.orient2D = t.signedDistanceTo2DLine = t.intersectIntervals = t.solveTwoEquationsTwoVariables = t.closestPointToTriangle = t.closestPointToPolyline = t.distancePointToLineSegment = t.projectPointToLineSegment = t.angleDifference = t.periodicDifference = t.minMaxCosSinFunc = t.convertToOtherPeriodicRange = t.adjustParameterToPeriodicRange = t.getShortestParametricRange = t.isParameterWithinPeriodicRange = t.normalizeSegmentsToPeriodicRange = t.normalizeParametricRange = t.normalizeParametricRangeToShiftedRange = t.normalizeParameterToShiftedRange = t.adjustAngleToRange = t.normalizeAngleRange = t.normalizeAngle = t.normalizeParameter = t.foldNearTo = t.foldAbove = t.fold = t.modulus = t.getSignedAngle = t.isPointInsidePolygon2D = t.binomialCoefficients = void 0;var n = r(1),o = r(0),i = r(2),s = 2 * Math.PI,a = [];!function () {for (var e = 0; e < 8; ++e) {a[e] = [1];for (var t = 1; t < e; ++t) {a[e][t] = a[e - 1][t - 1] + a[e - 1][t];}a[e][e] = 1;}}();var c = function c(e, t, r) {return Math.min(Math.max(t, e), r);},u = function u(e, t) {return e - t * Math.floor(e / t);},l = function l(e, t) {var r = e % t;return r < 0 ? r + t : r;},h = function h(e, t, r) {return l(e - t, r) + t;},d = function d(e, t) {return e < 0 ? t + e % t : e % t;},g = function g(e, t) {return d(e - t[0], t[1] - t[0]) + t[0];},p = function p(e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRange: in_range ends not in order.");var r = e[1] - e[0],n = d(e[0], t);return [n, n + r];},f = function f(e, t, r, n, o) {if (!isFinite(r)) return e;var i = p(t, r),s = d(e, r),a = s + r;if (n = !!n, s >= i[0] && s <= i[1]) return t[0] + (s - i[0]);if (a >= i[0] && a <= i[1]) return t[0] + (a - i[0]);var c = Math.abs(i[0] - s),u = Math.abs(s - i[1]),l = Math.abs(i[0] - a),h = Math.abs(a - i[1]);return o ? Math.min(c, l) < Math.min(u, h) ? t[0] : t[1] : Math.min(c, u) > Math.min(l, h) && !n ? t[0] + (a - i[0]) : t[0] + (s - i[0]);},v = function v(e, t, r) {var n = Math.abs(e - t);return isFinite(r) && (n %= r) > r / 2 ? r - n : n;},_ = function _(e, t, r) {var i = n.Vector3.sub(n.Vector3.createFloat64(), t, e),s = n.Vector3.dot(i, i);if (s < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var a = n.Vector3.sub(n.Vector3.createFloat64(), r, e);return n.Vector3.dot(a, i) / s;};t.binomialCoefficients = a, t.isPointInsidePolygon2D = function (e, t) {for (var r = !1, n = t.length, o = 0, i = n - 2; o < n; o += 2) {t[o + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[o]) * (e[1] - t[o + 1]) / (t[i + 1] - t[o + 1]) + t[o] && (r = !r), i = o;}return r;}, t.getSignedAngle = function (e, t) {var r = c(n.Vector2.dot(e, t), -1, 1),o = t[0] * e[1] - t[1] * e[0];return 0 === o ? .5 * Math.PI * (r - 1) : o < 0 ? -Math.acos(r) : Math.acos(r);}, t.modulus = u, t.fold = l, t.foldAbove = h, t.foldNearTo = function (e, t, r) {return h(e, t - r / 2, r);}, t.normalizeParameter = d, t.normalizeAngle = function (e) {return d(e, s);}, t.normalizeAngleRange = function (e) {return p(e, 2 * Math.PI);}, t.adjustAngleToRange = function (e, t) {return f(e, t, 2 * Math.PI);}, t.normalizeParameterToShiftedRange = g, t.normalizeParametricRangeToShiftedRange = function (e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRangeToShiftedRange: in_range ends not in order.");var r = e[1] - e[0],n = g(e[0], t);return [n, n + r];}, t.normalizeParametricRange = p, t.normalizeSegmentsToPeriodicRange = function (e, t, r, n, i) {for (var s = void 0 !== n ? n : o.KERNEL_TOLERANCE, a = void 0 !== i ? i : t[1] - t[0], c = [], u = 0; u < e.length; u++) {var l = g(e[u][0], t),h = e[u][1] - e[u][0];if (h >= a) return [[t[0], t[1]]];var d = l + h;d < t[1] ? c.push([l, d]) : (c.push([l, t[1]]), c.push([t[0], d - t[1] + t[0]]));}var p = [];for (c.sort(function (e, t) {return e[0] - t[0];}), u = 0; u < c.length; u++) {for (var f = c[u]; u + 1 < c.length && c[u + 1][0] < f[1];) {f[1] = Math.max(f[1], c[u + 1][1]), u++;}(Math.abs(f[1] - f[0]) > s || !r) && p.push(f);}return p;}, t.isParameterWithinPeriodicRange = function (e, t, r, n) {var o = f(e, t, r);return n = n || 0, o > t[0] - n && o < t[1] + n;}, t.getShortestParametricRange = function (e, t, r) {if ((e = d(e, r)) > (t = d(t, r))) {var n = e;e = t, t = n;}return e - t + r < t - e ? [t, e + r] : [e, t];}, t.adjustParameterToPeriodicRange = f, t.convertToOtherPeriodicRange = function (e, t, r, n) {if (!isFinite(r)) return i.ConsoleUtils.assert(e[0] >= t[0] - n, "The start of the input range doesn't lie in the target range."), i.ConsoleUtils.assert(e[1] <= t[1] + n, "The input range doesn't lie within the target range."), e;if (n = n || 0, e[1] - e[0] >= r - n) return t[1] - t[0] < r - n && console.error("The input range is larger than the target range."), t;var o = f(e[0], t, r);i.ConsoleUtils.assert(o >= t[0] - n, "The start of the input range doesn't lie in the target range.");var s = o + e[1] - e[0];return i.ConsoleUtils.assert(s <= t[1] + n, "The input range doesn't lie within the target range."), [o, s];}, t.minMaxCosSinFunc = function (e, t, r, n) {if (0 === e && 0 === t) return [r, r];var o,i = p(n, 2 * Math.PI),s = f(Math.atan(t / e), i, Math.PI, !0),a = [];for (o = 0; o < 3; ++o) {i[0] <= s && i[1] >= s && a.push(e * Math.cos(s) + t * Math.sin(s)), s += Math.PI;}if (n[1] - n[0] < 2 * Math.PI) for (o = 0; o < 2; o++) {a.push(e * Math.cos(n[o]) + t * Math.sin(n[o]));}return [Math.min.apply(null, a) + r, Math.max.apply(null, a) + r];}, t.periodicDifference = v, t.angleDifference = function (e, t) {return v(e, t, 2 * Math.PI);}, t.projectPointToLineSegment = _, t.distancePointToLineSegment = function (e, t, r, o) {var i = _(e, t, r);i = c(i, 0, 1);var s = o || n.Vector3.createFloat64();return n.Vector3.lerp(s, e, t, i), n.Vector3.distance(s, r);}, t.closestPointToPolyline = function (e, t, r, o, i) {for (var s = "number" == typeof t[0], a = s ? t.length / 3 : t.length, u = void 0, l = Number.POSITIVE_INFINITY, h = n.Vector3.createFloat64(), d = 0; d < a - 1; ++d) {var g = r ? r[d] : d,p = r ? r[d + 1] : d + 1,f = 0,v = 1;if (!(o && (o[0] > g && (f = (o[0] - g) / (p - g)), o[1] < p && (v = (o[1] - g) / (p - g)), v < f))) {var y, m;s ? (y = [t[3 * d], t[3 * d + 1], t[3 * d + 2]], m = [t[3 * d + 3], t[3 * d + 4], t[3 * d + 5]]) : (y = t[d], m = t[d + 1]);var E = _(y, m, e);E = c(E, f, v), n.Vector3.lerp(h, y, m, E);var x = n.Vector3.squaredDistance(h, e);x < l && (u = (1 - E) * g + E * p, l = x, i && n.Vector3.copy(i, h));}}return u;}, t.closestPointToTriangle = function (e, t, r, i, s) {var a,u,l = n.Vector3.sub(n.Vector3.createFloat64(), r, t),h = n.Vector3.sub(n.Vector3.createFloat64(), i, t),d = n.Vector3.sub(n.Vector3.createFloat64(), e, t),g = n.Vector3.squaredLength(l),p = n.Vector3.squaredLength(h),f = n.Vector3.dot(l, h),v = n.Vector3.dot(d, l),y = n.Vector3.dot(d, h);if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = u = 0;else if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = 0, u = c(y / p, 0, 1);else if (p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = c(v / g, 0, 1), u = 0;else {var m = n.Matrix22.createFloat64FromValues(g, f, f, p);if (Math.abs(n.Matrix22.determinant(m)) > n.FLOAT64_TOLERANCE) {n.Matrix22.invert(m, m);var E = [v, y];n.Vector2.transformMatrix22(E, E, m), a = E[0], u = E[1];} else u = y / p, (a = v / g) <= 0 || u <= 0 ? (a = c(a, 0, 1), u = c(u, 0, 1)) : a < u ? (a = c(a, 0, 1), u = 0) : (a = 0, u = c(u, 0, 1));}if (a < 0 && y >= 0 && y <= p && (a = 0, u = y / p), u < 0 && v >= 0 && v <= g && (a = v / g, u = 0), a + u > 1) {var x = _(r, i, e);x >= 0 && x <= 1 && (a = 1 - x, u = x);}if (a < 0 || u < 0 || a + u > 1) {var R = n.Vector3.squaredLength(d),A = n.Vector3.squaredDistance(e, r),P = n.Vector3.squaredDistance(e, i);A <= R && A <= P ? (a = 1, u = 0) : P <= R && P <= A ? (a = 0, u = 1) : a = u = 0;}return s && (n.Vector3.scaleAndAdd(s, t, l, a), n.Vector3.scaleAndAdd(s, s, h, u)), { coordA: a, coordB: u };}, t.solveTwoEquationsTwoVariables = function (e) {var t = e[0][0],r = e[0][1],n = e[1][0],o = e[1][1],i = t * o - r * n;if (0 !== i) {var s = o * e[0][2] - r * e[1][2],a = -n * e[0][2] + t * e[1][2];return [s /= i, a /= i];}}, t.intersectIntervals = function (e, t, r) {r = r || 0;for (var n = [], o = 0; o < e.length; o++) {for (var i = 0; i < t.length; i++) {var s = Math.max(e[o][0], t[i][0]),a = Math.min(e[o][1], t[i][1]);a - r > s && (a > s ? n.push([s, a]) : n.push([a, a]));}}return n;}, t.signedDistanceTo2DLine = function (e, t, r) {var n = r[0] - e[0],o = r[1] - e[1];return t[1] * n - t[0] * o;}, t.orient2D = function (e, t, r) {var n = e[0] - r[0],o = t[0] - r[0],i = e[1] - r[1];return n * (t[1] - r[1]) - i * o;}, t.clamp = c, t.sortedIndex = function (e, t) {for (var r = 0, n = e.length; n > r;) {var o = Math.floor((r + n) / 2);t > e[o] ? r = o + 1 : n = o;}return n;}, t.PI2 = s, t.limitRange = function (e, t, r, o) {if (i.ConsoleUtils.assert(2 === t.length), i.ConsoleUtils.assert(t[0] <= t[1]), r) return t[1] - t[0] < o + n.FLOAT64_TOLERANCE ? [t[0], t[1]] : (console.warn("limitRange : in_limitRange length cannot be greater than in_period"), [t[0], t[0] + o]);var s = Math.max(e[0], t[0]),a = Math.min(e[1], t[1]);return s > a && (s > a + n.FLOAT64_TOLERANCE && console.warn("limitRange : requested range must overlap in_oldRange"), s = a = t[0] > e[1] ? e[1] : e[0]), [s, a];}, t.getPlaneTransforms = function (e) {var t,r,o = e.evaluateDu(0, 0),i = e.evaluateDv(0, 0),s = e.getOrigin();if (!n.Vector3.isParallel(o, [1, 0, 0], 1) || !n.Vector3.isParallel(i, [0, 1, 0], 1) || Math.abs(s[2]) > n.FLOAT64_TOLERANCE) {var a = e.evaluateNormal(0, 0);t = n.Matrix44.createFloat64FromValues(o[0], o[1], o[2], 0, i[0], i[1], i[2], 0, a[0], a[1], a[2], 0, s[0], s[1], s[2], 1), r = n.Matrix44.createFloat64(), n.Matrix44.invert(r, t);}return { uvToThreeSpace: t, threeSpaceToUV: r };}, t.definePlaneThroughPoints = function (e) {var t,r,i,s = [0, 0, 0],a = [0, 0, 0];if (!(e.length < 3)) {var c = [0, 0, 0];for (t = 0; t < e.length; ++t) {n.Vector3.add(c, c, e[t]);}n.Vector3.scale(c, c, 1 / e.length);var l = [0, 0, 0];r = 0;var h = 0,d = 0;for (t = 0; t < e.length; ++t) {(i = n.Vector3.squaredDistance(c, e[t])) > d && (d = i, h = t), (i /= 100) > r && (r = i, n.Vector3.sub(l, e[t], c));var g = (t + 1) % e.length;(i = n.Vector3.squaredDistance(e[t], e[g])) > r && (r = i, n.Vector3.sub(l, e[g], e[t]));}if (!(d < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(l, l);var p = [0, 0, 0];for (r = 0, t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c), n.Vector3.cross(s, s, l), (i = n.Vector3.squaredLength(s)) > r && (r = i, n.Vector3.copy(p, s));}if (!(r < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(p, p);var f = e[h],v = e[u(h - 1, e.length)],_ = e[u(h + 1, e.length)];n.Vector3.sub(s, v, f), n.Vector3.sub(a, _, f), n.Vector3.dot(n.Vector3.cross(a, a, s), p) < 0 && n.Vector3.negate(p, p);var y = [0, 0, 0];n.Vector3.cross(y, p, l), n.Vector3.normalize(y, y);var m = Number.POSITIVE_INFINITY,E = Number.NEGATIVE_INFINITY,x = Number.POSITIVE_INFINITY,R = Number.NEGATIVE_INFINITY;for (t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c);var A = n.Vector3.dot(s, l),P = n.Vector3.dot(s, y);m = Math.min(m, A), E = Math.max(E, A), x = Math.min(x, P), R = Math.max(R, P);}return { origin: c, normal: p, uAxis: l, vAxis: y, uRange: [m, E], vRange: [x, R] };}}}};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BoundingBox = void 0;var n = r(1),o = r(0),i = function i(e, t) {this.min = e ? n.Vector3.createFloat64FromValues(e[0], e[1], e[2]) : n.Vector3.createFloat64FromValues(1 / 0, 1 / 0, 1 / 0), this.max = t ? n.Vector3.createFloat64FromValues(t[0], t[1], t[2]) : n.Vector3.createFloat64FromValues(-1 / 0, -1 / 0, -1 / 0);};i.prototype.toString = function () {return "(x:" + this.min[0] + ", y:" + this.min[1] + ", z:" + this.min[2] + ") -> (x:" + this.max[0] + ", y:" + this.max[1] + ", z:" + this.max[2] + ")";}, i.prototype.copy = function (e) {return n.Vector3.copy(this.min, e.min), n.Vector3.copy(this.max, e.max), this;}, i.prototype.clone = function () {return new i(this.min, this.max);}, i.prototype.getWidth = function (e) {var t = 0;return 0 <= e && e <= 2 ? (t = this.max[e] - this.min[e], isFinite(t) ? t : 0) : (console.error("wrong axis argument supplied to BoundingBox.getWidth(): " + e), 0);}, i.prototype.getMaxMinAligned = function (e, t, r) {for (var o, s, a, c = this.getCorners(), u = [], l = [], h = [], d = 0; d < c.length; ++d) {o = n.Vector3.dot(c[d], e), s = n.Vector3.dot(c[d], t), a = n.Vector3.dot(c[d], r), u.push(o), l.push(s), h.push(a);}var g = Math.min.apply(void 0, u),p = Math.min.apply(void 0, l),f = Math.min.apply(void 0, h),v = Math.max.apply(void 0, u),_ = Math.max.apply(void 0, l),y = Math.max.apply(void 0, h);return new i([g, p, f], [v, _, y]);}, i.prototype.include = function (e) {return this.includeX(e.min[0], e.max[0]), this.includeY(e.min[1], e.max[1]), this.includeZ(e.min[2], e.max[2]), this;}, i.prototype.includeX = function (e, t) {return this.min[0] = Math.min(this.min[0], e), this.max[0] = Math.max(this.max[0], t), this;}, i.prototype.includeY = function (e, t) {return this.min[1] = Math.min(this.min[1], e), this.max[1] = Math.max(this.max[1], t), this;}, i.prototype.includeZ = function (e, t) {return this.min[2] = Math.min(this.min[2], e), this.max[2] = Math.max(this.max[2], t), this;}, i.prototype.includeSphere = function (e) {var t = e.getCenter(),r = e.getRadius();return this.includeX(t[0] - r, t[0] + r), this.includeY(t[1] - r, t[1] + r), this.includeZ(t[2] - r, t[2] + r), this;}, i.prototype.translate = function (e) {return n.Vector3.add(this.min, this.min, e), n.Vector3.add(this.max, this.max, e), this;}, i.prototype.getCorners = function () {var e = this.getDiagonal();return [n.Vector3.clone(this.min), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2] + e[2]), n.Vector3.clone(this.max)];}, i.prototype.transform = function (e) {if (!this.isEmpty()) {var t = this.getCorners();this.max[0] = -1 / 0, this.max[1] = -1 / 0, this.max[2] = -1 / 0, this.min[0] = 1 / 0, this.min[1] = 1 / 0, this.min[2] = 1 / 0;for (var r = 0; r < t.length; ++r) {n.Vector3.transformMatrix44(t[r], t[r], e), n.Vector3.max(this.max, this.max, t[r]), n.Vector3.min(this.min, this.min, t[r]);}}return this;}, i.prototype.includePointXYZ = function (e) {return this.includeX(e.x, e.x), this.includeY(e.y, e.y), this.includeZ(e.z, e.z), this;}, i.prototype.includePoint = function (e) {return this.includeX(e[0], e[0]), this.includeY(e[1], e[1]), this.includeZ(e[2], e[2]), this;}, i.prototype.getCenter = function () {var e = n.Vector3.createFloat64();return n.Vector3.add(e, this.min, this.max), n.Vector3.scale(e, e, .5), e;}, i.prototype.getDiagonal = function () {var e = n.Vector3.createFloat64();return n.Vector3.sub(e, this.max, this.min), e;}, i.prototype.isPointInside = function (e) {return !(e[0] < this.min[0] || e[0] > this.max[0] || e[1] < this.min[1] || e[1] > this.max[1] || e[2] < this.min[2] || e[2] > this.max[2]);}, i.prototype.isPointInsideWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e[0] < this.min[0] - t || e[0] > this.max[0] + t || e[1] < this.min[1] - t || e[1] > this.max[1] + t || e[2] < this.min[2] - t || e[2] > this.max[2] + t);}, i.prototype.intersects = function (e) {return !(e.min[0] > this.max[0] || e.max[0] < this.min[0] || e.min[1] > this.max[1] || e.max[1] < this.min[1] || e.min[2] > this.max[2] || e.max[2] < this.min[2]);}, i.prototype.intersectsWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e.min[0] > this.max[0] + t || e.max[0] < this.min[0] - t || e.min[1] > this.max[1] + t || e.max[1] < this.min[1] - t || e.min[2] > this.max[2] + t || e.max[2] < this.min[2] - t);}, i.prototype.isEmpty = function () {return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];}, i.prototype.setEmpty = function () {return this.max[0] = -1 / 0, this.min[0] = 1 / 0, this.max[1] = -1 / 0, this.min[1] = 1 / 0, this.max[2] = -1 / 0, this.min[2] = 1 / 0, this;}, i.prototype.isBounded = function () {return isFinite(this.max[0]) && isFinite(this.max[1]) && isFinite(this.max[2]) && isFinite(this.min[0]) && isFinite(this.min[1]) && isFinite(this.min[2]);}, t.BoundingBox = i;}, function (e, t, r) {"use strict";var n,o,i = e.exports = r(10),s = r(61);i.codegen = r(99), i.fetch = r(100), i.path = r(101), i.fs = i.inquire("fs"), i.toArray = function (e) {if (e) {for (var t = Object.keys(e), r = new Array(t.length), n = 0; n < t.length;) {r[n] = e[t[n++]];}return r;}return [];}, i.toObject = function (e) {for (var t = {}, r = 0; r < e.length;) {var n = e[r++],o = e[r++];void 0 !== o && (t[n] = o);}return t;};var a = /\\/g,c = /"/g;i.isReserved = function (e) {return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e);}, i.safeProp = function (e) {return !/^[$\w_]+$/.test(e) || i.isReserved(e) ? '["' + e.replace(a, "\\\\").replace(c, '\\"') + '"]' : "." + e;}, i.ucFirst = function (e) {return e.charAt(0).toUpperCase() + e.substring(1);};var u = /_([a-z])/g;i.camelCase = function (e) {return e.substring(0, 1) + e.substring(1).replace(u, function (e, t) {return t.toUpperCase();});}, i.compareFieldsById = function (e, t) {return e.id - t.id;}, i.decorateType = function (e, t) {if (e.$type) return t && e.$type.name !== t && (i.decorateRoot.remove(e.$type), e.$type.name = t, i.decorateRoot.add(e.$type)), e.$type;n || (n = r(63));var o = new n(t || e.name);return i.decorateRoot.add(o), o.ctor = e, Object.defineProperty(e, "$type", { value: o, enumerable: !1 }), Object.defineProperty(e.prototype, "$type", { value: o, enumerable: !1 }), o;};var l = 0;i.decorateEnum = function (e) {if (e.$type) return e.$type;o || (o = r(11));var t = new o("Enum" + l++, e);return i.decorateRoot.add(t), Object.defineProperty(e, "$type", { value: t, enumerable: !1 }), t;}, Object.defineProperty(i, "decorateRoot", { get: function get() {return s.decorated || (s.decorated = new (r(71))());} });}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Point = void 0;var n = r(1),o = r(43),i = r(4),s = r(0),a = function a(e) {o.BaseGeometry.call(this), this._position = n.Vector3.createFloat64(), e && n.Vector3.copy(this._position, e);};(a.prototype = Object.create(o.BaseGeometry.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.POINT;}, a.prototype.clone = function () {var e = new a();return e.copy(this), e;}, a.prototype.copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this.copyPosition(e.getPosition());}, a.prototype.getPosition = function () {return this._position;}, a.prototype.copyPosition = function (e) {n.Vector3.copy(this._position, e);}, a.prototype.setPosition = function (e, t, r) {n.Vector3.set(this._position, e, t, r);}, a.prototype.getBoundingBox = function () {var e = new i.BoundingBox();return e.includePoint(this.getPosition()), e;}, a.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e);}, a.prototype.toObject = function () {return { position: this.vectorToObject(this._position) };}, t.Point = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Line = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = function l() {a.Curve.call(this), this._position = n.Vector3.createFloat64FromValues(0, 0, 0), this._direction = n.Vector3.createFloat64FromValues(1, 0, 0);};(l.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.LINE;}, l.prototype.set = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.copy(this._position, e), n.Vector3.copy(this._direction, t);}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.tessellate = function (e, t) {var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);var n = e[0];r.positions.push(this.evaluatePosition(n));for (var o = 1; o < e.length; ++o) {var i = e[o];r.positions.push(this.evaluatePosition(i)), r.offsets.push(r.positions.length - 1), n = i;}return r;}, l.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._position, e._position), n.Vector3.copy(this._direction, e._direction);}, l.prototype.getRangeUnlimited = function () {return [-1 / 0, 1 / 0];}, l.prototype.isPeriodicUnlimited = function () {return !1;}, l.prototype.isClosedUnlimited = function () {return !1;}, l.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(t, this._position, this._direction, e);}, l.prototype.evaluateDt = function (e) {return n.Vector3.clone(this._direction);}, l.prototype.tangentLength = function (e) {return n.Vector3.length(this._direction);}, l.prototype.getTangentCone = function (e) {var t = n.Vector3.createFloat64();return new i.TangentCone(n.Vector3.normalize(t, this.evaluateDt(0)), 0);}, l.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), isFinite(e[0]) && isFinite(e[1]) ? (e[1] - e[0]) * n.Vector3.length(this._direction) : 1 / 0;}, l.prototype.getParameterFromArcLength = function (e, t) {if (void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), isFinite(t[0]) && isFinite(t[1])) {var r = t[0] + e / n.Vector3.length(this._direction);return (0, c.clamp)(r, t[0], t[1]);}return NaN;}, l.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = new o.BoundingBox();return isFinite(e[0]) && isFinite(e[1]) ? (t.includePoint(this.evaluatePosition(e[0])), t.includePoint(this.evaluatePosition(e[1]))) : (t.includePoint([1 / 0, 1 / 0, 1 / 0]), t.includePoint([-1 / 0, -1 / 0, -1 / 0])), t;}, l.prototype.closestToRayParam = function (e, t, r, o) {var i = n.Vector3.createFloat64();n.Vector3.sub(i, this._position, e);var s = n.Vector3.squaredLength(this._direction),a = n.Vector3.squaredLength(t),c = n.Vector3.dot(this._direction, t),u = n.Vector3.dot(i, this._direction),l = n.Vector3.dot(i, t),h = s * a - c * c,d = (c * l - a * u) / h,g = (c * u - s * l) / h;if (isFinite(d) && isFinite(g)) {if (r) if (d < r[0]) {if (d = r[0], void 0 !== o) {var p = this.evaluatePosition(r[0]),f = n.Vector3.createFloat64();n.Vector3.sub(f, p, e), g = n.Vector3.dot(f, t) / a;}} else if (d > r[1] && (d = r[1], void 0 !== o)) {var v = this.evaluatePosition(r[1]);f = n.Vector3.createFloat64(), n.Vector3.sub(f, v, e), g = n.Vector3.dot(f, t) / a;}if (void 0 !== o) {var _ = this.evaluatePosition(d),y = n.Vector3.createFloat64();if (n.Vector3.scaleAndAdd(y, e, t, g), n.Vector3.squaredDistance(_, y) > o * o) return;}return d;}}, l.prototype.setFromEndpoints = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredDistance(e, t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._position = n.Vector3.clone(e), n.Vector3.normalize(this._direction, n.Vector3.sub(this._direction, t, e)), this.unlimitRange();}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e), n.Vector3.transformAsDirectionMatrix44(this._direction, this._direction, e);}, l.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._position);var o = this._direction,i = n.Vector3.dot(r, o) / n.Vector3.squaredLength(o);return isFinite(t[0]) && isFinite(t[1]) ? (0, c.clamp)(i, t[0], t[1]) : i;}, l.prototype.suggestSplittingParam = function (e) {}, l.prototype.toObject = function () {return { position: this.vectorToObject(this._position), direction: this.vectorToObject(this._direction), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Line = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1,o = !1,i = {},s = { init3D: function init3D(e) {for (var t in n = !0, e) {"function" == typeof e[t] && (s[t] = e[t].bind(e));}}, setLevel: function setLevel(e, t) {var r = i[e];return i[e] = t, console.log("Debug of " + e + " set to level " + t), r;}, level: function level(e) {if (!n) return 0;var t = i[e];return void 0 === t ? 0 : t;}, setConsoleWarnings: function setConsoleWarnings(e) {o = e;}, warn: function warn(e) {o && console.warn(e);} };t.DebugUtils = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseTopology = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this), this._attributes = [];};(i.prototype = Object.create(n.Base.prototype)).getTopologyType = function () {console.warn("BaseTopology.getTopologyType : abstract method invoked!");}, i.prototype.getBoundingBox = function () {console.warn("BaseTopology.getBoundingBox : abstract method invoked!");}, i.prototype.getBody = function () {console.warn("BaseTopology.getBody : abstract method invoked!");}, i.prototype.collectFaces = function (e) {return console.warn("BaseTopology.collectFaces : abstract method invoked!"), e || new Set();}, i.prototype.collectEdges = function (e) {return console.warn("BaseTopology.collectEdges : abstract method invoked!"), e || new Set();}, i.prototype.collectVertices = function (e) {return console.warn("BaseTopology.collectVertices : abstract method invoked!"), e || new Set();}, i.prototype.getAttributes = function () {return this._attributes;}, i.prototype.addAttribute = function (e) {this._attributes ? this._attributes.push(e) : this._attributes = [e], e.addTopology(this);}, i.prototype.removeAttribute = function (e) {var t = this._attributes.indexOf(e);return t > -1 && (this._attributes.splice(t, 1), e.removeTopology(this), !0);}, i.prototype.removeAllAttributes = function () {if (this._attributes) for (var _e2 = 0; _e2 < this._attributes.length; _e2++) {this.removeAttribute(this._attributes[_e2]);}}, i.prototype.isVertex = function () {return this.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX;}, i.prototype.getFaces = function () {return Array.from(this.collectFaces());}, i.prototype.getEdges = function () {return Array.from(this.collectEdges());}, i.prototype.getVertices = function () {return Array.from(this.collectVertices());}, i.prototype.addAllToModelObject = function (e, t) {if (!e.topologies[this.getGuid()]) {var _t2 = {};_t2[o.TOPOLOGY_TYPES.toString(this.getTopologyType()).toLowerCase()] = this.toObject(), e.topologies[this.getGuid()] = _t2;}t.forEach(function (t) {null != t && (Array.isArray(t) ? t.forEach(function (t) {t.addToModelObject(e);}) : t.addToModelObject(e));});}, t.BaseTopology = i;}, function (e, t, r) {"use strict";(function (e) {var n = t;function o(e, t, r) {for (var n = Object.keys(t), o = 0; o < n.length; ++o) {void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);}return e;}function i(e) {function t(e, r) {if (!(this instanceof t)) return new t(e, r);Object.defineProperty(this, "message", { get: function get() {return e;} }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), r && o(this, r);}return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", { get: function get() {return e;} }), t.prototype.toString = function () {return this.name + ": " + this.message;}, t;}n.asPromise = r(58), n.base64 = r(90), n.EventEmitter = r(91), n.float = r(92), n.inquire = r(59), n.utf8 = r(93), n.pool = r(94), n.LongBits = r(95), n.global = "undefined" != typeof window && window || void 0 !== e && e || "undefined" != typeof self && self || this, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isNode = Boolean(n.global.process && n.global.process.versions && n.global.process.versions.node), n.isInteger = Number.isInteger || function (e) {return "number" == typeof e && isFinite(e) && Math.floor(e) === e;}, n.isString = function (e) {return "string" == typeof e || e instanceof String;}, n.isObject = function (e) {return e && "object" == _typeof(e);}, n.isset = n.isSet = function (e, t) {var r = e[t];return !(null == r || !e.hasOwnProperty(t)) && ("object" != _typeof(r) || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);}, n.Buffer = function () {try {var e = n.inquire("buffer").Buffer;return e.prototype.utf8Write ? e : null;} catch (e) {return null;}}(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function (e) {return "number" == typeof e ? n.Buffer ? n._Buffer_allocUnsafe(e) : new n.Array(e) : n.Buffer ? n._Buffer_from(e) : "undefined" == typeof Uint8Array ? e : new Uint8Array(e);}, n.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function (e) {return e ? n.LongBits.from(e).toHash() : n.LongBits.zeroHash;}, n.longFromHash = function (e, t) {var r = n.LongBits.fromHash(e);return n.Long ? n.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));}, n.merge = o, n.lcFirst = function (e) {return e.charAt(0).toLowerCase() + e.substring(1);}, n.newError = i, n.ProtocolError = i("ProtocolError"), n.oneOfGetter = function (e) {for (var t = {}, r = 0; r < e.length; ++r) {t[e[r]] = 1;}return function () {for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) {if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];}};}, n.oneOfSetter = function (e) {return function (t) {for (var r = 0; r < e.length; ++r) {e[r] !== t && delete this[e[r]];}};}, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function () {var e = n.Buffer;e ? (n._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {return new e(t, r);}, n._Buffer_allocUnsafe = e.allocUnsafe || function (t) {return new e(t);}) : n._Buffer_from = n._Buffer_allocUnsafe = null;};}).call(this, r(57));}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "Enum";var o = r(30),i = r(5);function s(e, t, r, o, i) {if (n.call(this, e, r), t && "object" != _typeof(t)) throw TypeError("values must be an object");if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = o, this.comments = i || {}, this.reserved = void 0, t) for (var s = Object.keys(t), a = 0; a < s.length; ++a) {"number" == typeof t[s[a]] && (this.valuesById[this.values[s[a]] = t[s[a]]] = s[a]);}}s.fromJSON = function (e, t) {var r = new s(e, t.values, t.options, t.comment, t.comments);return r.reserved = t.reserved, r;}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", t ? this.comment : void 0, "comments", t ? this.comments : void 0]);}, s.prototype.add = function (e, t, r) {if (!i.isString(e)) throw TypeError("name must be a string");if (!i.isInteger(t)) throw TypeError("id must be an integer");if (void 0 !== this.values[e]) throw Error("duplicate name '" + e + "' in " + this);if (this.isReservedId(t)) throw Error("id " + t + " is reserved in " + this);if (this.isReservedName(e)) throw Error("name '" + e + "' is reserved in " + this);if (void 0 !== this.valuesById[t]) {if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + t + " in " + this);this.values[e] = t;} else this.valuesById[this.values[e] = t] = e;return this.comments[e] = r || null, this;}, s.prototype.remove = function (e) {if (!i.isString(e)) throw TypeError("name must be a string");var t = this.values[e];if (null == t) throw Error("name '" + e + "' does not exist in " + this);return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;}, s.prototype.isReservedId = function (e) {return o.isReservedId(this.reserved, e);}, s.prototype.isReservedName = function (e) {return o.isReservedName(this.reserved, e);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Surface = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = function a() {o.BaseGeometry.call(this), this._subrangeU = [], this._subrangeV = [];};(a.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrangeU = e.isLimitedU() ? [e._subrangeU[0], e._subrangeU[1]] : [], this._subrangeV = e.isLimitedV() ? [e._subrangeV[0], e._subrangeV[1]] : [];}, a.prototype.isLimitedU = function () {return this._subrangeU.length > 0;}, a.prototype.isLimitedV = function () {return this._subrangeV.length > 0;}, a.prototype.getRangeU = function () {return this.isLimitedU() ? this._subrangeU : this.getRangeUnlimitedU();}, a.prototype.getRangeV = function () {return this.isLimitedV() ? this._subrangeV : this.getRangeUnlimitedV();}, a.prototype.getRangeUnlimitedU = function () {console.warn("Surface.getRangeUnlimitedU : abstract method invoked!");}, a.prototype.getRangeUnlimitedV = function () {console.warn("Surface.getRangeUnlimitedV : abstract method invoked!");}, a.prototype.limitRangeU = function (e) {var t = this.getRangeU();this._subrangeU = (0, s.limitRange)(t, e, this.isPeriodicU(), this.getPeriodU());}, a.prototype.limitRangeV = function (e) {var t = this.getRangeV();this._subrangeV = (0, s.limitRange)(t, e, this.isPeriodicV(), this.getPeriodV());}, a.prototype.unlimitRangeU = function () {this._subrangeU = [];}, a.prototype.unlimitRangeV = function () {this._subrangeV = [];}, a.prototype.isPeriodicU = function () {return this.isPeriodicUnlimitedU() && !this.isLimitedU();}, a.prototype.isPeriodicV = function () {return this.isPeriodicUnlimitedV() && !this.isLimitedV();}, a.prototype.isPeriodicUnlimitedU = function () {console.warn("Surface.isPeriodicUnlimitedU : abstract method invoked!");}, a.prototype.isPeriodicUnlimitedV = function () {console.warn("Surface.isPeriodicUnlimitedV : abstract method invoked!");}, a.prototype.getPeriodU = function () {return this.isLimitedU() ? void 0 : this.getPeriodUnlimitedU();}, a.prototype.getPeriodV = function () {return this.isLimitedV() ? void 0 : this.getPeriodUnlimitedV();}, a.prototype.getPeriodUnlimitedU = function () {if (this.isPeriodicUnlimitedU()) {var e = this.getRangeUnlimitedU();return e[1] - e[0];}}, a.prototype.getPeriodUnlimitedV = function () {if (this.isPeriodicUnlimitedV()) {var e = this.getRangeUnlimitedV();return e[1] - e[0];}}, a.prototype.isClosedU = function () {if (this.isClosedUnlimitedU()) {if (this.isLimitedU()) {var e = this.getRangeUnlimitedU(),t = e[1] - e[0];return this._subrangeU[1] - this._subrangeU[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedV = function () {if (this.isClosedUnlimitedV()) {if (this.isLimitedV()) {var e = this.getRangeUnlimitedV(),t = e[1] - e[0];return this._subrangeV[1] - this._subrangeV[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedUnlimitedU = function () {console.warn("Surface.isClosedUnlimitedU : abstract method invoked!");}, a.prototype.isClosedUnlimitedV = function () {console.warn("Surface.isClosedUnlimitedV : abstract method invoked!");}, a.prototype.evaluatePosition = function (e, t) {console.warn("Surface.evaluatePosition : abstract method invoked");}, a.prototype.evaluateDu = function (e, t) {console.warn("Surface.evaluateDu : abstract method invoked");}, a.prototype.evaluateDv = function (e, t) {console.warn("Surface.evaluateDv : abstract method invoked");}, a.prototype.evaluateNormal = function (e, t) {var r = this.evaluateDu(e, t);return n.Vector3.cross(r, r, this.evaluateDv(e, t)), n.Vector3.normalize(r, r), r;}, a.prototype.closestParam = function (e) {console.warn("Surface.closestParam : abstract method invoked");}, a.prototype.vParamLine = function (e) {console.warn("Surface.vParamLine : abstract method invoked, returning undefined");}, a.prototype.uParamLine = function (e) {console.warn("Surface.uParamLine : abstract method invoked, returning undefined");}, a.prototype.getBoundingBox = function (e, t) {console.warn("Surface.getBoundingBox : abstract method invoked, returning undefined");}, a.prototype.transform = function (e) {console.warn("Surface.transform : abstract method invoked");}, t.Surface = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Loop = void 0;var n = r(9),o = r(0),i = function i() {n.BaseTopology.call(this), this._coedges = [], this._face = void 0;};(i.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LOOP;}, i.prototype.getFace = function () {return this._face;}, i.prototype.setFace = function (e) {this._face = e;}, i.prototype.getCoedges = function () {return this._coedges;}, i.prototype.setCoedges = function (e) {this._coedges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._coedges[t] = e[t];}}, i.prototype.addCoedge = function (e) {this._coedges ? this._coedges.push(e) : this._coedges = [e], e.setLoop(this);}, i.prototype.addCoedges = function (e) {this._coedges || (this._coedges = []);for (var t = 0; t < e.length; ++t) {e[t].setLoop(this);}this._coedges = this._coedges.concat(e);}, i.prototype.removeCoedge = function (e) {var t = this._coedges.indexOf(e);return t > -1 && (this._coedges.splice(t, 1), e.getLoop() === this && e.setLoop(void 0), !0);}, i.prototype.getBody = function () {return this._face ? this._face.getBody() : void 0;}, i.prototype.collectFaces = function (e) {return e = e || new Set(), this._face && e.add(this._face), e;}, i.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectEdges(e);}return e;}, i.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectVertices(e);}return e;}, i.prototype.toString = function () {return "Loop";}, i.prototype.toObject = function () {return { coedges: this.refsToStrings(this._coedges), attributes: this.refsToStrings(this._attributes) };}, i.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._coedges, this._attributes]);}, t.Loop = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Circle = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = r(50),h = function h() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._radius = 1;};(h.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.CIRCLE;}, h.prototype.set = function (e, t, r) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._radius = n.Vector3.length(r), this._computeYAxis();}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.getNormal = function () {return this._normal;}, h.prototype.setNormal = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis());}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.setOrigin = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, h.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimited = function () {return !0;}, h.prototype.isClosedUnlimited = function () {return !0;}, h.prototype._computeRadiusVector = function () {return n.Vector3.scale(n.Vector3.createFloat64(), this._xAxis, this._radius);}, h.prototype.tessellate = function (e, t) {t = t || s.TESSELLATION.LINEAR_PRECISION;var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);for (var n = e[0], o = 1; o < e.length; ++o) {var i = e[o],a = l.CurveTessellator.getCircularArcRenderPoints(this, [n, i], t, 1 === o, r.positions);r.offsets.push(r.positions.length - 1), n = i, r.tolerance = Math.max(r.tolerance, a);}return r;}, h.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._radius), n.Vector3.add(t, t, this._center), t;}, h.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._radius), t;}, h.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._radius), t;}, h.prototype.tangentLength = function (e) {return this.getRadius();}, h.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), this.getRadius() * (e[1] - e[0]);}, h.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = t[0] + e / this.getRadius();return (0, c.clamp)(r, t[0], t[1]);}, h.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._radius, this._yAxis[0] * this._radius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._radius, this._yAxis[1] * this._radius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._radius, this._yAxis[2] * this._radius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, h.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = .5 * (e[0] + e[1]),r = n.Vector3.createFloat64FromValues(0, 0, 0);n.Vector3.scaleAndAdd(r, r, this._xAxis, -Math.sin(t)), n.Vector3.scaleAndAdd(r, r, this._yAxis, Math.cos(t));var o = Math.min(Math.PI, .5 * (e[1] - e[0]));return new i.TangentCone(r, o);}, h.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, h.prototype.getRadiusAndRangeFromEndpoints = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var i = n.Vector3.createFloat64();n.Vector3.sub(i, t, this._center);var a,u = .5 * (n.Vector3.length(o) + n.Vector3.length(i)),l = n.Vector3.dot(o, this._xAxis),h = n.Vector3.dot(o, this._yAxis),d = (0, c.normalizeAngle)(Math.atan2(h, l));if (e === t || n.Vector3.squaredDistance(e, t) < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) a = d + c.PI2;else {var g = n.Vector3.dot(i, this._xAxis),p = n.Vector3.dot(i, this._yAxis);if ((a = (0, c.normalizeAngle)(Math.atan2(p, g))) < d && (a += c.PI2), r) {var f = a;a = d, d = f - c.PI2;}}return { radius: u, range: [d, a] };}, h.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o,i = n.Vector3.dot(r, this._xAxis),a = n.Vector3.dot(r, this._yAxis);return o = i * i + a * a < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE ? .5 * Math.PI : Math.atan2(a, i), o = (0, c.foldNearTo)(o, .5 * (t[0] + t[1]), 2 * Math.PI), (0, c.clamp)(o, t[0], t[1]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._radius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), this._radius = n.Vector3.length(this._xAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis();}, h.prototype.suggestSplittingParam = function (e) {}, h.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Circle = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Face = void 0;var n = r(1),o = r(9),i = r(0),s = r(8),a = function a(e) {o.BaseTopology.call(this), this._surface = e, this._reversed = !1, this._loops = [], this._shell = void 0;};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.FACE;}, a.prototype.getSurfaceType = function () {return this._surface ? this._surface.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._surface = this._surface ? this._surface.clone() : void 0, e._reversed = this._reversed, e.setLoops(this._loops), e._shell = this._shell, e._vertexUvData = void 0, e;}, a.prototype.getSurface = function () {return this._surface;}, a.prototype.setSurface = function (e) {this._surface = e;}, a.prototype.getShell = function () {return this._shell;}, a.prototype.setShell = function (e) {this._shell = e;}, a.prototype.getLoops = function () {return this._loops;}, a.prototype.setLoops = function (e) {this._loops = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._loops[t] = e[t];}}, a.prototype.addLoop = function (e) {this._loops ? this._loops.push(e) : this._loops = [e], e.setFace(this);}, a.prototype.addLoops = function (e) {this._loops || (this._loops = []);for (var t = 0; t < e.length; ++t) {e[t].setFace(this);}this._loops = this._loops.concat(e);}, a.prototype.removeLoop = function (e) {var t = this._loops.indexOf(e);return t > -1 && (this._loops.splice(t, 1), e.getFace() === this && e.setFace(void 0), !0);}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getVertices = function () {return Array.from(this.collectVertices());}, a.prototype.evaluatePosition = function (e, t) {return this._surface.evaluatePosition(e, t);}, a.prototype.evaluateNormal = function (e, t) {var r = this._surface.evaluateNormal(e, t);return !0 === this.isReversed() && n.Vector3.negate(r, r), r;}, a.prototype.getBody = function () {return this._shell ? this._shell.getBody() : void 0;}, a.prototype.collectFaces = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {var e = this._surface.getRangeU(),t = this._surface.getRangeV();return isFinite(e[0]) && isFinite(e[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in u."), e = [0, 1]), isFinite(t[0]) && isFinite(t[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in v."), t = [0, 1]), this._surface.getBoundingBox(e, t);}, a.prototype.closestParam = function (e) {return this._surface.closestParam(e);}, a.prototype.isPlanarFace = function () {return this.getSurfaceType() === i.GEOMETRY_TYPES.PLANE;}, a.prototype.toObject = function () {return { loops: this.refsToStrings(this._loops), reversed: this._reversed, geometry: this.refToString(this._surface), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._loops, this._surface, this._attributes]);}, t.Face = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Vertex = void 0;var n = r(9),o = r(0),i = r(2),s = r(78),a = function a(e) {n.BaseTopology.call(this), this._point = e, this._precision = 0, this._edges = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.VERTEX;}, a.prototype.getPoint = function () {return this._point;}, a.prototype.setPoint = function (e) {this._point = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {i.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.getEdges = function () {return this._edges;}, a.prototype.isAdjacentEdge = function (e) {return -1 !== this._edges.indexOf(e);}, a.prototype.getOtherEdge = function (e) {for (var t = 0; t < this._edges.length; t++) {var r = this._edges[t];if (r !== e) return r;}return null;}, a.prototype.getOtherEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r];n !== e && t.push(n);}return t;}, a.prototype.getAdjacentVertices = function () {for (var e = [], t = 0; t < this._edges.length; t++) {var r = this._edges[t].getOtherVertex(this);r !== this && e.indexOf(r) < 0 && e.push(r);}return e;}, a.prototype.getCommonEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r],o = n.getStartVertex(),i = n.getEndVertex();(o === this && i === e || i === this && o === e) && t.push(n);}return t;}, a.prototype.addEdge = function (e) {-1 === this._edges.indexOf(e) && this._edges.push(e);}, a.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t >= 0 && (this._edges.splice(t, 1), !0);}, a.prototype.getPosition = function () {return this._point.getPosition();}, a.prototype.getBody = function () {return this._edges.length > 0 ? this._edges[0].getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, a.prototype.collectVertices = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.getBoundingBox = function () {return this._point.getBoundingBox();}, a.prototype.toString = function () {return String(this._point.getPosition());}, a.prototype.getOrderedFaces = function () {var e = [],t = (0, s.getOrderedFacesOnVertex)(this);for (var _r = 0; _r < t.length; _r++) {t[_r].faces.forEach(function (t) {e.push(t);});}return e;}, a.prototype.toObject = function () {return { geometry: this.refToString(this._point), precision: this.getPrecision(), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._point, this._attributes]);}, t.Vertex = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.controlPointsFromHomogeneous = t.controlPointsToHomogeneous = t.getUniqueKnots = t.findKnotSpanAndMultiplicity = t.findKnotSpan = void 0;var n = r(0),o = r(2),i = function i(e, t) {var r = 0,n = t.length - 1;if (e <= t[r]) {for (; t[r] === t[r + 1] && r < n - 1;) {r += 1;}return r;}if (e >= t[n]) {for (; t[n] === t[n - 1] && n > r + 1;) {n -= 1;}return n - 1;}for (var o = Math.floor((r + n) / 2); e < t[o] || e >= t[o + 1];) {e < t[o] ? n = o : r = o, o = Math.floor((r + n) / 2);}return o;};t.findKnotSpan = i, t.findKnotSpanAndMultiplicity = function (e, t) {var r = n.PARAMETER_SPACE_TOLERANCE,o = i(e, t),s = 0,a = e,c = o;if (e < t[c] + r) for (a = t[c]; c >= 0 && Math.abs(t[c] - a) < r;) {--c, ++s;} else if (e > t[c + 1] - r) {for (a = t[++c]; c < t.length && Math.abs(t[c] - a) < r;) {++c, ++s;}a = c < t.length ? t[o = c - 1] : t[t.length - 1];}return { span: o, multiplicity: s, knot: a };}, t.getUniqueKnots = function (e) {for (var t = [e[0]], r = 1; r < e.length; ++r) {e[r] !== e[r - 1] && t.push(e[r]);}return t;}, t.controlPointsToHomogeneous = function (e, t) {o.ConsoleUtils.assert(e.length > 0 && e.length === 3 * t.length);for (var r = t.length, n = new Array(4 * r), i = 0; i < r; ++i) {var s = t[i];n[4 * i] = e[3 * i] * s, n[4 * i + 1] = e[3 * i + 1] * s, n[4 * i + 2] = e[3 * i + 2] * s, n[4 * i + 3] = s;}return n;}, t.controlPointsFromHomogeneous = function (e) {o.ConsoleUtils.assert(e.length > 0 && e.length % 4 == 0);for (var t = e.length / 4, r = new Array(3 * t), n = new Array(t), i = 0; i < t; ++i) {var s = e[4 * i + 3];r[3 * i] = e[4 * i] / s, r[3 * i + 1] = e[4 * i + 1] / s, r[3 * i + 2] = e[4 * i + 2] / s, n[i] = s;}return { P: r, w: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Plane = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(2),u = function u() {s.Surface.call(this), this._origin = n.Vector3.createFloat64(), this._normal = n.Vector3.createFloat64(), this._uAxis = n.Vector3.createFloat64(), this._vAxis = n.Vector3.createFloat64();};(u.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.PLANE;}, u.prototype.clone = function () {var e = new u();return e.copy(this), e;}, u.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), n.Vector3.copy(this._origin, e._origin), n.Vector3.copy(this._normal, e._normal), n.Vector3.copy(this._uAxis, e._uAxis), n.Vector3.copy(this._vAxis, e._vAxis);}, u.prototype._computeVAxis = function () {n.Vector3.cross(this._vAxis, this._normal, this._uAxis);}, u.prototype.set = function (e, t, r) {n.Vector3.copy(this._origin, e), c.ConsoleUtils.assert(n.Vector3.squaredLength(t) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, t), void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)) : (c.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._uAxis, r)), this._computeVAxis();}, u.prototype.getOrigin = function () {return this._origin;}, u.prototype.setOrigin = function (e) {n.Vector3.copy(this._origin, e);}, u.prototype.getNormal = function () {return this._normal;}, u.prototype.setNormal = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, e), (n.Vector3.squaredLength(this._uAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._uAxis, this._normal, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)), this._computeVAxis();}, u.prototype.getUAxis = function () {return this._uAxis;}, u.prototype.setUAxis = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.copy(this._uAxis, e), this._computeVAxis();}, u.prototype.evaluatePosition = function (e, t) {var r = n.Vector3.clone(this._origin);return n.Vector3.scaleAndAdd(r, r, this._uAxis, e), n.Vector3.scaleAndAdd(r, r, this._vAxis, t), r;}, u.prototype.evaluateNormal = function (e, t) {return n.Vector3.clone(this._normal);}, u.prototype.evaluateDu = function (e, t) {return n.Vector3.clone(this._uAxis);}, u.prototype.evaluateDv = function (e, t) {return n.Vector3.clone(this._vAxis);}, u.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.sub(t, e, this._origin), { u: n.Vector3.dot(t, this._uAxis) / n.Vector3.squaredLength(this._uAxis), v: n.Vector3.dot(t, this._vAxis) / n.Vector3.squaredLength(this._vAxis) };}, u.prototype.vParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(e, 0), this._vAxis), t;}, u.prototype.uParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(0, e), this._uAxis), t;}, u.prototype.getBoundingBox = function (e, t) {var r = new o.BoundingBox();return e && t ? (r.includePoint(this.evaluatePosition(e[0], t[0])), r.includePoint(this.evaluatePosition(e[0], t[1])), r.includePoint(this.evaluatePosition(e[1], t[1])), r.includePoint(this.evaluatePosition(e[1], t[0]))) : (r.includePoint([-1 / 0, -1 / 0, -1 / 0]), r.includePoint([1 / 0, 1 / 0, 1 / 0])), r;}, u.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._origin, this._origin, e), n.Vector3.transformAsDirectionMatrix44(this._uAxis, this._uAxis, e), n.Vector3.transformAsDirectionMatrix44(this._vAxis, this._vAxis, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.normalize(this._normal, this._normal);}, u.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, u.prototype.getRangeUnlimitedV = function () {return [-1 / 0, 1 / 0];}, u.prototype.isPeriodicUnlimitedU = function () {return !1;}, u.prototype.isPeriodicUnlimitedV = function () {return !1;}, u.prototype.isClosedUnlimitedU = function () {return !1;}, u.prototype.isClosedUnlimitedV = function () {return !1;}, u.prototype.toObject = function () {return { origin: this.vectorToObject(this._origin), normal: this.vectorToObject(this._normal), uAxis: this.vectorToObject(this._uAxis), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Plane = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeConnectedFaces = t.mergeFaces = t.findConnectedFaces = t.findConnectedEdges = t.mergeCoincidentVertices = t.transformTopology = t.reverseFace = void 0;var n = r(1),o = r(0),i = r(13),s = r(2),a = function a(e) {e.setReversed(!e.isReversed());},c = function c(e, t) {var r = !1,n = !0,o = new Set();t && (void 0 !== t.inputFacesOnly && (r = t.inputFacesOnly), void 0 !== t.allowVertexConnections && (n = t.allowVertexConnections), void 0 !== t.barrierEdges && (o = new Set(t.barrierEdges)));var i = new Set(),s = new Set(e);function a(t) {s.delete(t), i.add(t), i.forEach(function (t) {var a = new Set();n ? t.collectVertices().forEach(function (e) {e.collectEdges(a);}) : (t.collectEdges(a), o.forEach(function (e) {a.delete(e);})), a.forEach(function (t) {for (var n = t.getCoedge(), o = n; o;) {if (o.getLoop()) {var a = o.getLoop().getFace();i.has(a) || r && !(e.indexOf(a) >= 0) || (i.add(a), s.delete(a));}(o = o.getPartner()) === n && (o = void 0);}});});}for (var c = []; s.size > 0;) {i.clear(), a(s.values().next().value), c.push(Array.from(i));}return c;},u = function u(e) {if (1 !== e.length) {var t = new Set();e.forEach(function (e) {e.collectEdges(t);});var r = new Set(),n = [];t.forEach(function (t) {var o = t.getCoedges(),i = o.map(function (t) {return e.indexOf(t.getFace()) >= 0;});if (2 === o.length && i[0] && i[1]) n.push(t);else for (var s = 0; s < o.length; s++) {i[s] && (r.add(o[s]), o[s].resetUVCurve());}});for (var o = []; r.size > 0;) {for (var a = [], c = r.values().next().value; c;) {a.push(c), r.delete(c);var u = c,l = void 0,h = 2 * c.getEndVertex().getEdges().length;do {if (u = u.getNext(), r.has(u)) {l = u;break;}u = u.getPartner();} while (u && u !== c && --h > 0);c = l;}s.ConsoleUtils.assert(a[0].getStartVertex() === a[a.length - 1].getEndVertex()), o.push(a);}n.forEach(function (e) {e.setStartVertex(null), e.setEndVertex(null);});var d = e[0];d.setLoops([]), o.forEach(function (e) {var t = new i.Loop();t.addCoedges(e), d.addLoop(t);});for (var g = 1; g < e.length; g++) {e[g].getShell() && e[g].getShell().removeFace(e[g]);}var p = d.getSurface();p.unlimitRangeU(), p.unlimitRangeV();}};t.reverseFace = function (e) {e.setReversed(!e.isReversed());for (var t = e.getLoops(), r = 0; r < t.length; ++r) {for (var n = t[r].getCoedges(), o = 0; o < n.length; ++o) {a(n[o]);}n.reverse();}}, t.transformTopology = function (e, t) {Array.isArray(e) || (e = [e]);for (var r = new Set(), n = new Set(), i = new Set(), s = 0; s < e.length; ++s) {var a = e[s],c = a.getTopologyType();a.collectVertices(r), c !== o.TOPOLOGY_TYPES.VERTEX && a.collectEdges(n), c !== o.TOPOLOGY_TYPES.VERTEX && c !== o.TOPOLOGY_TYPES.EDGE && c !== o.TOPOLOGY_TYPES.COEDGE && c !== o.TOPOLOGY_TYPES.LOOP && a.collectFaces(i);}r.forEach(function (e) {e.getPoint() && e.getPoint().transform(t);}), n.forEach(function (e) {e.getCurve() && e.getCurve().transform(t);}), i.forEach(function (e) {e.getSurface() && e.getSurface().transform(t);});}, t.mergeCoincidentVertices = function (e) {for (var t = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, r = [], i = 0; i < e.length; ++i) {var s,a = e[i],c = a.getStartVertex(),u = a.getEndVertex();for (s = 0; s < r.length && !(n.Vector3.squaredDistance(c.getPosition(), r[s].getPosition()) < t); ++s) {;}if (s === r.length ? r.push(c) : (r[s].setPrecision(Math.max(r[s].getPrecision(), c.getPrecision())), a.setStartVertex(r[s])), c !== u) for (s = 0; s < r.length && !(n.Vector3.squaredDistance(u.getPosition(), r[s].getPosition()) < t); ++s) {;}s === r.length ? r.push(u) : (r[s].setPrecision(Math.max(r[s].getPrecision(), u.getPrecision())), a.setEndVertex(r[s]));}}, t.findConnectedEdges = function (e, t) {for (var r = t || !1, n = [], o = new Set(), i = 0; i < e.length; ++i) {var s = e[i];if (!o.has(s)) {for (var a = [], c = [s], u = 0; u < c.length; ++u) {var l = c[u];o.has(l) || r && !(e.indexOf(l) >= 0) || (o.add(l), a.push(l), c = c.concat(l.getStartVertex().getEdges(), l.getEndVertex().getEdges()));}n.push(a);}}return n;}, t.findConnectedFaces = c, t.mergeFaces = u, t.mergeConnectedFaces = function (e) {var t = [];return c(e, { inputFacesOnly: !0, allowVertexConnections: !1 }).forEach(function (e) {u(e), t.push(e[0]);}), t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Edge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = function a(e) {o.BaseTopology.call(this), this._curve = e, this._reversed = !1, this._vertices = [null, null], this._range = [0, 0], this._precision = 0, this._coedge = void 0, this._wire = void 0, this._tessellationPoints = [];};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.EDGE;}, a.prototype.getCurveType = function () {return this._curve ? this._curve.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._curve = this._curve ? this._curve.clone() : void 0, e._reversed = this._reversed, e._vertices[0] = this._vertices[0], e._vertices[1] = this._vertices[1], e._range[0] = this._range[0], e._range[1] = this._range[1], e._precision = this._precision, e._coedge = this._coedge, e._wire = this._wire, e._tessellationPoints = [], e;}, a.prototype.getCurve = function () {return this._curve;}, a.prototype.setCurve = function (e) {this._curve = e;}, a.prototype.getArcLength = function () {var e = this.getRange();return this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getArcLength(e);}, a.prototype.getVertices = function () {return this._vertices;}, a.prototype.getVertex = function (e) {return s.ConsoleUtils.assert(0 === e || 1 === e), this._vertices[e];}, a.prototype.getStartVertex = function () {return this._vertices[0];}, a.prototype.getEndVertex = function () {return this._vertices[1];}, a.prototype.setCoedge = function (e) {this._coedge = e;}, a.prototype.getCoedge = function () {return this._coedge;}, a.prototype.getCoedges = function () {for (var e = [], t = this._coedge; t;) {e.push(t), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.setWire = function (e) {this._wire = e;}, a.prototype.getWire = function () {return this._wire;}, a.prototype.getRange = function () {return this._range;}, a.prototype.setRange = function (e) {s.ConsoleUtils.assert(2 === e.length), this._range[0] = e[0], this._range[1] = e[1];}, a.prototype.t0 = function () {return this._range[0];}, a.prototype.sett0 = function (e) {this._range[0] = e;}, a.prototype.t1 = function () {return this._range[1];}, a.prototype.sett1 = function (e) {this._range[1] = e;}, a.prototype.isClosed = function () {return this._curve && this._vertices[0] && this._vertices[0] === this._vertices[1];}, a.prototype.getOtherVertex = function (e) {return s.ConsoleUtils.assert(this._vertices[0] === e || this._vertices[1] === e), this._vertices[0] === e ? this._vertices[1] : this._vertices[0];}, a.prototype.getCommonVertex = function (e) {var t = this.getStartVertex(),r = this.getEndVertex(),n = e.getStartVertex(),o = e.getEndVertex();return t === n || t === o ? t : r === n || r === o ? r : null;}, a.prototype.setVertex = function (e, t) {s.ConsoleUtils.assert(0 === e || 1 === e), t !== this._vertices[e] && (this._vertices[e] && this._vertices[0] !== this._vertices[1] && this._vertices[e].removeEdge(this), this._vertices[e] = t, t && this._vertices[e].addEdge(this));}, a.prototype.setStartVertex = function (e) {this.setVertex(0, e);}, a.prototype.setEndVertex = function (e) {this.setVertex(1, e);}, a.prototype.getCoedgeForFace = function (e) {for (var t = this._coedge; t;) {if (t.getFace() === e) return t;if ((t = t.getPartner()) === this._coedge) break;}}, a.prototype.getOtherFace = function (e) {var t = this.getCoedgeForFace(e);s.ConsoleUtils.assert(t);var r = t.getPartner();if (r && r !== t) return r.getFace();}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {s.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.evaluatePosition = function (e) {return this.isReversed() && (e = -e), this._curve.evaluatePosition(e);}, a.prototype.evaluateDt = function (e) {this.isReversed() && (e = -e);var t = this._curve.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}, a.prototype.evaluateCurvature = function (e, t) {return this.isReversed() && (e = -e), this._curve.evaluateCurvature(e, t);}, a.prototype.closestToPointParam = function (e, t) {if (this._curve) {var r = t || this.getRange();this.isReversed() && (r = [-r[1], -r[0]]);var n = this._curve.closestToPointParam(e, r);return this.isReversed() ? -n : n;}}, a.prototype.includesPoint = function (e) {var t = Math.max(this.getPrecision(), i.KERNEL_TOLERANCE),r = this.closestToPointParam(e),o = this.evaluatePosition(r);return n.Vector3.squaredDistance(o, e) < t * t;}, a.prototype.distanceToPoint = function (e) {var t = this.closestToPointParam(e),r = this.evaluatePosition(t);return n.Vector3.distance(r, e);}, a.prototype.tessellate = function (e, t) {var r, o;if (!1 === this.isReversed()) r = e || [this._range[0], this._range[1]];else if (e) {r = new Array(e.length);for (var i = 0; i < e.length; ++i) {r[i] = -e[e.length - 1 - i];}} else r = [-this._range[1], -this._range[0]];var s,a = this._curve.tessellate(r, t);if (this._tessellationPoints.length !== a.positions.length) for (this._tessellationPoints = new Array(a.positions.length), i = 0; i < a.positions.length; i++) {this._tessellationPoints[i] = n.Vector3.createFloat64();}if (!1 === this.isReversed()) for (s = a.offsets, o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[o]);} else {for (o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[a.positions.length - 1 - o]);}for (s = new Array(a.offsets.length), o = 0; o < a.offsets.length; ++o) {s[o] = a.positions.length - 1 - a.offsets[a.offsets.length - 1 - o];}}return { positions: this._tessellationPoints, offsets: s, tolerance: a.tolerance };}, a.prototype.getBody = function () {return s.ConsoleUtils.assert(void 0 === this._coedge || void 0 === this._wire), this._coedge ? this._coedge.getBody() : this._wire ? this._wire.getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = this._coedge; t;) {t.collectFaces(e), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.collectEdges = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._vertices.length; ++t) {this._vertices[t] && e.add(this._vertices[t]);}return e;}, a.prototype.getBoundingBox = function () {var e = this.getRange();return !0 === this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getBoundingBox(e);}, a.prototype.closestToRayParam = function (e, t, r) {var n = this.getRange();!0 === this.isReversed() && (n = [-n[1], -n[0]]);var o = this._curve.closestToRayParam(e, t, n, r);return !0 === this.isReversed() ? -o : o;}, a.prototype.toString = function () {return i.GEOMETRY_TYPES.toString(this.getCurveType()) + " " + String(this.getStartVertex()) + " -> " + String(this.getEndVertex());}, a.prototype.getLoops = function () {var e = this.getCoedges(),t = new Set();for (var _r2 = 0; _r2 < e.length; _r2++) {t.add(e[_r2].getLoop());}return Array.from(t);}, a.prototype.toObject = function () {return { vertex0: this.refToString(this._vertices[0]), vertex1: this.refToString(this._vertices[1]), precision: this._precision, range: this.rangeToObject(this._range, !0), reversed: this._reversed, geometry: this.refToString(this._curve), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._vertices[0], this._vertices[1], this._curve, this._attributes]);}, t.Edge = a;}, function (e, t, r) {"use strict";e.exports = i, i.className = "ReflectionObject";var n,o = r(5);function i(e, t) {if (!o.isString(e)) throw TypeError("name must be a string");if (t && !o.isObject(t)) throw TypeError("options must be an object");this.options = t, this.name = e, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;}Object.defineProperties(i.prototype, { root: { get: function get() {for (var e = this; null !== e.parent;) {e = e.parent;}return e;} }, fullName: { get: function get() {for (var e = [this.name], t = this.parent; t;) {e.unshift(t.name), t = t.parent;}return e.join(".");} } }), i.prototype.toJSON = function () {throw Error();}, i.prototype.onAdd = function (e) {this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = !1;var t = e.root;t instanceof n && t._handleAdd(this);}, i.prototype.onRemove = function (e) {var t = e.root;t instanceof n && t._handleRemove(this), this.parent = null, this.resolved = !1;}, i.prototype.resolve = function () {return this.resolved || this.root instanceof n && (this.resolved = !0), this;}, i.prototype.getOption = function (e) {if (this.options) return this.options[e];}, i.prototype.setOption = function (e, t, r) {return r && this.options && void 0 !== this.options[e] || ((this.options || (this.options = {}))[e] = t), this;}, i.prototype.setOptions = function (e, t) {if (e) for (var r = Object.keys(e), n = 0; n < r.length; ++n) {this.setOption(r[n], e[r[n]], t);}return this;}, i.prototype.toString = function () {var e = this.constructor.className,t = this.fullName;return t.length ? e + " " + t : e;}, i._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = u;var n = r(21);((u.prototype = Object.create(n.prototype)).constructor = u).className = "Field";var o,i = r(11),s = r(31),a = r(5),c = /^required|optional|repeated$/;function u(e, t, r, o, i, u, l) {if (a.isObject(o) ? (l = i, u = o, o = i = void 0) : a.isObject(i) && (l = u, u = i, i = void 0), n.call(this, e, u), !a.isInteger(t) || t < 0) throw TypeError("id must be a non-negative integer");if (!a.isString(r)) throw TypeError("type must be a string");if (void 0 !== o && !c.test(o = o.toString().toLowerCase())) throw TypeError("rule must be a string rule");if (void 0 !== i && !a.isString(i)) throw TypeError("extend must be a string");this.rule = o && "optional" !== o ? o : void 0, this.type = r, this.id = t, this.extend = i || void 0, this.required = "required" === o, this.optional = !this.required, this.repeated = "repeated" === o, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!a.Long && void 0 !== s.long[r], this.bytes = "bytes" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;}u.fromJSON = function (e, t) {return new u(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);}, Object.defineProperty(u.prototype, "packed", { get: function get() {return null === this._packed && (this._packed = !1 !== this.getOption("packed")), this._packed;} }), u.prototype.setOption = function (e, t, r) {return "packed" === e && (this._packed = null), n.prototype.setOption.call(this, e, t, r);}, u.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return a.toObject(["rule", "optional" !== this.rule && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, u.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof o ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof i && "string" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof i) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = a.Long.fromNumber(this.typeDefault, "u" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && "string" == typeof this.typeDefault) {var e;a.base64.test(this.typeDefault) ? a.base64.decode(this.typeDefault, e = a.newBuffer(a.base64.length(this.typeDefault)), 0) : a.utf8.write(this.typeDefault, e = a.newBuffer(a.utf8.length(this.typeDefault)), 0), this.typeDefault = e;}return this.map ? this.defaultValue = a.emptyObject : this.repeated ? this.defaultValue = a.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue), n.prototype.resolve.call(this);}, u.d = function (e, t, r, n) {return "function" == typeof t ? t = a.decorateType(t).name : t && "object" == _typeof(t) && (t = a.decorateEnum(t).name), function (o, i) {a.decorateType(o.constructor).add(new u(i, e, t, r, { default: n }));};}, u._configure = function (e) {o = e;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Ellipse = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(35),l = r(2),h = r(50),d = function d() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._majorRadius = 0, this._minorRadius = 0, this._tessellationCache = new h.TessellationCache();};(d.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPSE;}, d.prototype.set = function (e, t, r, o) {l.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), l.ConsoleUtils.assert(o > n.FLOAT64_TOLERANCE && o <= 1, "Invalid radius ratio"), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._majorRadius = n.Vector3.length(r), this._minorRadius = this._majorRadius * o, this._computeYAxis(), this._dirtyTessellation();}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, d.prototype.getCenter = function () {return this._center;}, d.prototype.getNormal = function () {return this._normal;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e), this._dirtyTessellation();}, d.prototype.setNormal = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis(), this._dirtyTessellation());}, d.prototype.setMajorAxis = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.getMinorAxis = function () {return this._yAxis;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMajorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e, this._dirtyTessellation();}, d.prototype.setMinorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e, this._dirtyTessellation();}, d.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimited = function () {return !0;}, d.prototype.isClosedUnlimited = function () {return !0;}, d.prototype._dirtyTessellation = function () {this._tessellationCache.setDirty(!0);}, d.prototype._evaluateArcLengthIntegrand = function (e) {var t = this._majorRadius * Math.sin(e),r = this._minorRadius * Math.cos(e);return Math.sqrt(t * t + r * r);}, d.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = e[0], r = 0; t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {for (var n = t, o = [this._evaluateArcLengthIntegrand(t)]; o.length < 5 && t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {t += .01, o.push(this._evaluateArcLengthIntegrand(t));}switch (n = t - n, o.length) {case 1:break;case 2:r += (o[0] + o[1]) * n / 2;break;case 3:r += (o[0] + 4 * o[1] + o[2]) * n / 6;break;case 4:r += (o[0] + 3 * o[1] + 3 * o[2] + o[3]) * n / 8;break;default:r += (7 * o[0] + 32 * o[1] + 12 * o[2] + 32 * o[3] + 7 * o[4]) * n / 90;}(n = t - e[1]) > s.PARAMETER_SPACE_TOLERANCE && (r -= this._evaluateArcLengthIntegrand(e[1]) * n);}return r;}, d.prototype.getParameterFromArcLength = function (e, t) {return void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), (0, u.invertIntegral1D)(this._evaluateArcLengthIntegrand.bind(this), e, t);}, d.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._minorRadius), n.Vector3.add(t, t, this._center), t;}, d.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._minorRadius), t;}, d.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._minorRadius), t;}, d.prototype._getFullTessellation = function (e) {var t = [-Math.PI, -Math.PI / 2, 0, Math.PI / 2, Math.PI],r = h.CurveTessellator.getAdaptiveRenderPoints(this, e, [-Math.PI, Math.PI], t);return r.didRetessellate = !0, r;}, d.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, d.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._majorRadius, this._yAxis[0] * this._minorRadius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._majorRadius, this._yAxis[1] * this._minorRadius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._majorRadius, this._yAxis[2] * this._minorRadius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, d.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluateDt(e[0]);n.Vector3.normalize(t, t);var r = this.evaluateDt(e[1]);n.Vector3.normalize(r, r);var o = n.Vector3.createFloat64(),a = n.Vector3.dot(t, r),u = n.Vector3.dot(n.Vector3.cross(o, t, r), this._normal),l = Math.atan2(u, a);l < 0 ? l += c.PI2 : e[1] - e[0] > c.PI2 - s.PARAMETER_SPACE_TOLERANCE && (l = c.PI2), l *= .5, a = Math.cos(l), u = Math.sin(l);var h = n.Vector3.clone(t);return n.Vector3.scale(h, h, a), n.Vector3.cross(o, this._normal, t), n.Vector3.scaleAndAdd(h, h, o, u), new i.TangentCone(h, l);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._majorRadius), n.Vector3.scale(this._yAxis, this._yAxis, this._minorRadius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), this._majorRadius = n.Vector3.length(this._xAxis), this._minorRadius = n.Vector3.length(this._yAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, d.prototype.isCircular = function () {return Math.abs(this._majorRadius - this._minorRadius) < s.KERNEL_TOLERANCE;}, d.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o = n.Vector3.dot(r, this._xAxis),i = n.Vector3.dot(r, this._yAxis);if (o * o + i * i < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) {var a = .5 * Math.PI;if (((a = (0, c.adjustParameterToPeriodicRange)(a, t, c.PI2)) < t[0] || a > t[1]) && (a = (0, c.adjustParameterToPeriodicRange)(.5 * -Math.PI, t, c.PI2)), a < t[0] || a > t[1]) {var l = this.evaluatePosition(t[0]),h = this.evaluatePosition(t[1]);a = n.Vector3.squaredDistance(this._center, l) < n.Vector3.squaredDistance(this._center, h) ? t[0] : t[1];}return a;}var d = this._majorRadius,g = this._minorRadius,p = Math.atan2(d * i, g * o),f = this.evaluatePosition(p);n.Vector3.sub(f, f, this._center), o * o + i * i < n.Vector3.squaredLength(f) && (p = (i < s.KERNEL_TOLERANCE ? -1 : 1) * Math.acos(o / d));var v,_ = n.FLOAT64_TOLERANCE,y = function y(t) {var r = this.evaluatePosition(t),n = this.evaluateDt(t),o = this.evaluateDtt(t),i = [r[0] - e[0], r[1] - e[1], r[2] - e[2]];return { val: 2 * (i[0] * n[0] + i[1] * n[1] + i[2] * n[2]), deriv: 2 * (i[0] * o[0] + i[1] * o[1] + i[2] * o[2] + (n[0] * n[0] + n[1] * n[1] + n[2] * n[2])) };},m = (0, u.newtonRaphson1D)(y.bind(this), void 0, p, _, 32);(m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? (m = (0, u.newtonRaphson1D)(y.bind(this), void 0, -m, _, 32), v = (m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? 1 / 0 : n.Vector3.squaredDistance(e, this.evaluatePosition(m))) : v = n.Vector3.squaredDistance(e, this.evaluatePosition(m));var E = n.Vector3.squaredDistance(e, this.evaluatePosition(t[0])),x = n.Vector3.squaredDistance(e, this.evaluatePosition(t[1]));return E < v && (v = E, m = t[0]), x < v && (m = t[1]), m;}, d.prototype.suggestSplittingParam = function (e) {}, d.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Ellipse = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Body = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._lumps = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.BODY;}, a.prototype.getLumps = function () {return this._lumps;}, a.prototype.setLumps = function (e) {this._lumps = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._lumps[t] = e[t];}}, a.prototype.addLump = function (e) {this._lumps ? this._lumps.push(e) : this._lumps = [e], e.setBody(this);}, a.prototype.addLumps = function (e) {this._lumps || (this._lumps = []);for (var t = 0; t < e.length; ++t) {e[t].setBody(this);}this._lumps = this._lumps.concat(e);}, a.prototype.removeLump = function (e) {var t = this._lumps.indexOf(e);return t > -1 && (this._lumps.splice(t, 1), e.getBody() === this && e.setBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._lumps.length; ++t) {e.include(this._lumps[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toObject = function () {return { lumps: this.refsToStrings(this._lumps), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._lumps, this._attributes]);}, t.Body = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Lump = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._shells = [], this._body = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LUMP;}, s.prototype.getBody = function () {return this._body;}, s.prototype.setBody = function (e) {this._body = e;}, s.prototype.getShells = function () {return this._shells;}, s.prototype.setShells = function (e) {this._shells = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._shells[t] = e[t];}}, s.prototype.addShell = function (e) {this._shells ? this._shells.push(e) : this._shells = [e], e.setLump(this);}, s.prototype.addShells = function (e) {this._shells || (this._shells = []);for (var t = 0; t < e.length; ++t) {e[t].setLump(this);}this._shells = this._shells.concat(e);}, s.prototype.removeShell = function (e) {var t = this._shells.indexOf(e);return t > -1 && (this._shells.splice(t, 1), e.getLump() === this && e.setLump(void 0), !0);}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectFaces(e);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._shells.length; ++t) {e.include(this._shells[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Lump";}, s.prototype.toObject = function () {return { shells: this.refsToStrings(this._shells), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._shells, this._attributes]);}, t.Lump = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Shell = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._faces = [], this._lump = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.SHELL;}, s.prototype.getLump = function () {return this._lump;}, s.prototype.setLump = function (e) {this._lump = e;}, s.prototype.getFaces = function () {return this._faces;}, s.prototype.setFaces = function (e) {this._faces = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._faces[t] = e[t];}}, s.prototype.addFace = function (e) {this._faces ? this._faces.push(e) : this._faces = [e], e.setShell(this);}, s.prototype.addFaces = function (e) {this._faces || (this._faces = []);for (var t = 0; t < e.length; ++t) {e[t].setShell(this);}this._faces = this._faces.concat(e);}, s.prototype.removeFace = function (e) {var t = this._faces.indexOf(e);return t > -1 && (this._faces.splice(t, 1), e.getShell() === this && e.setShell(void 0), !0);}, s.prototype.getBody = function () {return this._lump ? this._lump.getBody() : void 0;}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {e.add(this._faces[t]);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._faces.length; ++t) {e.include(this._faces[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Shell";}, s.prototype.toObject = function () {return { faces: this.refsToStrings(this._faces), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._faces, this._attributes]);}, t.Shell = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Coedge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = r(3),c = r(36),u = function u(e) {o.BaseTopology.call(this), this._reversed = !1, this._edge = e, this._loop = void 0, this._partner = void 0, this._uvCurve = void 0;};(u.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.COEDGE;}, u.prototype.getEdge = function () {return this._edge;}, u.prototype.getLoop = function () {return this._loop;}, u.prototype.getPartner = function () {return this._partner;}, u.prototype.setEdge = function (e) {this._edge = e;}, u.prototype.setLoop = function (e) {this._loop = e;}, u.prototype.setPartner = function (e) {this._partner = e;}, u.prototype.getStartVertex = function () {return this._reversed ? this._edge.getEndVertex() : this._edge.getStartVertex();}, u.prototype.getEndVertex = function () {return this._reversed ? this._edge.getStartVertex() : this._edge.getEndVertex();}, u.prototype.getFace = function () {return this._loop ? this._loop.getFace() : void 0;}, u.prototype.getNext = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(t + 1) % e.length];}}, u.prototype.getPrevious = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(0, a.modulus)(t - 1, e.length)];}}, u.prototype.isReversed = function () {return this._reversed;}, u.prototype.setReversed = function (e) {this._reversed = e;}, u.prototype.getRange = function () {if (this._edge) return this._reversed ? [-this._edge.t1(), -this._edge.t0()] : [this._edge.t0(), this._edge.t1()];}, u.prototype.t0 = function () {if (this._edge) return this._reversed ? -this._edge.t1() : this._edge.t0();}, u.prototype.t1 = function () {if (this._edge) return this._reversed ? -this._edge.t0() : this._edge.t1();}, u.prototype.evaluatePosition = function (e) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluatePosition(e);}, u.prototype.evaluateDt = function (e) {if (this._edge) {this.isReversed() && (e = -e);var t = this._edge.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}}, u.prototype.evaluateCurvature = function (e, t) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluateCurvature(e, t);}, u.prototype.evaluateFaceUV = function (e) {var t = this.getFace();if (t) {var r = this.evaluatePosition(e);return t.closestParam(r);}}, u.prototype.evaluateInwardDirection = function (e) {var t = this.getFace();if (t) {var r = this.evaluateDt(e),o = this.evaluateFaceUV(e),i = t.evaluateNormal(o.u, o.v),s = [0, 0, 0];return n.Vector3.cross(s, i, r), n.Vector3.normalize(s, s), s;}}, u.prototype.getBoundingBox = function () {if (this._edge) return this._edge.getBoundingBox();}, u.prototype.generateUVCurve = function (e) {if (!this._uvCurve && this._edge) {var t = this._edge.getCurve();if (t && this._loop && this._loop.getFace()) {var r = this._loop.getFace().getSurface();r && r.getGeometryType() === i.GEOMETRY_TYPES.PLANE && (e || (e = (0, a.getPlaneTransforms)(r).threeSpaceToUV), e ? (this._uvCurve = t.clone(), this._uvCurve.transform(e)) : this._uvCurve = t);}}}, u.prototype.resetUVCurve = function () {this._uvCurve = void 0;}, u.prototype.uvAngleSubtended = function (e) {var t = this._loop.getFace().getSurface().closestParam(e),r = [t.u, t.v, 0];this.generateUVCurve(), s.ConsoleUtils.assert(this._uvCurve);var o = this.getRange(),u = 1;this.isReversed() !== this._edge.isReversed() && (o = [-o[1], -o[0]], u = -1), this._loop && this._loop.getFace() && this._loop.getFace().isReversed() && (u *= -1);var l = !1,h = this._uvCurve.getRange();this._uvCurve.isClosed() && o[1] - o[0] >= h[1] - h[0] - 2 * i.PARAMETER_SPACE_TOLERANCE && (l = !0);var d = this._uvCurve.evaluatePosition(o[0]),g = this._uvCurve.evaluatePosition(o[1]),p = n.Vector3.createFloat64();n.Vector3.sub(p, d, r), n.Vector3.normalize(p, p);var f = n.Vector3.createFloat64();n.Vector3.sub(f, g, r), n.Vector3.normalize(f, f);var v = (0, a.getSignedAngle)(p, f),_ = v < 0,y = !1,m = !1;switch (this._edge.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:m = this._uvCurve.getNormal()[2] > 0, y = n.Vector3.distance(r, this._uvCurve.getCenter()) < this._uvCurve.getRadius(), l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.ELLIPSE:m = this._uvCurve.getNormal()[2] > 0;var E = n.Vector3.sub([0, 0, 0], r, this._uvCurve.getCenter()),x = n.Vector3.dot(E, this._uvCurve.getMajorAxis()) / this._uvCurve.getMajorRadius(),R = n.Vector3.dot(E, this._uvCurve.getMinorAxis()) / this._uvCurve.getMinorRadius();y = x * x + R * R <= 1, l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.BCURVE:this._uvCurve.isPlanarXY() || console.warn("Unsupported non-planar curve for uvAngleSubtended");var A = [r[0], r[1]];y = c.SplineCurveHelper.isPointInsideSplineRegionXYPlanar3D(A, this._uvCurve, o), m = !0;break;default:throw new Error("Unsupported curve type for uvAngleSubtended");}return l ? v = y ? 2 * Math.PI * (m ? -1 : 1) : 0 : y && (v < 0 ? v = 2 * Math.PI + v : v -= 2 * Math.PI), v * u;}, u.prototype.getBody = function () {return this._loop ? this._loop.getBody() : void 0;}, u.prototype.collectFaces = function (e) {return e = e || new Set(), this._loop && this._loop.collectFaces(e), e;}, u.prototype.collectEdges = function (e) {return e = e || new Set(), this._edge && e.add(this._edge), e;}, u.prototype.collectVertices = function (e) {return e = e || new Set(), this._edge && this._edge.collectVertices(e), e;}, u.prototype.toString = function () {return "Coedge";}, u.prototype.toObject = function () {return { edge: this.refToString(this._edge), partner: this.refToString(this._partner), reversed: this._reversed, attributes: this.refsToStrings(this._attributes) };}, u.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edge, this._attributes]);}, t.Coedge = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createShellsFromFaces = t.createWiresFromEdges = t.createEdgesFromCurves = t.createEdgeFromCurve = t.createLoopFromPolyline = t.createFaceFromPolyline = t.makeConeOrCylinderVParamLoop = t.createCoedgeOnEdge = t.createLineEdge = t.createLineEdgeBetweenVertices = void 0;var n = r(1),o = r(0),i = r(2),s = r(6),a = r(7),c = r(18),u = r(27),l = r(16),h = r(26),d = r(20),g = r(13),p = r(15),f = r(40),v = r(3),_ = r(19),y = function y(e, t) {var r = e.getPosition(),o = t.getPosition(),i = new a.Line();i.setFromEndpoints(r, o);var s = new d.Edge(i);return s.setRange([0, n.Vector3.distance(r, o)]), s.setStartVertex(e), s.setEndVertex(t), s;},m = function m(e) {var t = new u.Coedge();t.setEdge(e);var r = e.getCoedge();return r ? (i.ConsoleUtils.assert(!r.getPartner()), r.setPartner(t), t.setPartner(r), t.setReversed(!r.isReversed())) : e.setCoedge(t), t;},E = function E(e) {for (var t = e.length, r = new Array(t), n = 0; n < t; ++n) {r[n] = new l.Vertex(new s.Point(e[n]));}var o = new Array(t);for (n = 0; n < t; ++n) {var i = (n + 1) % t,a = y(r[n], r[i]);o[n] = m(a);}var c = new g.Loop();return c.addCoedges(o), c;},x = function x(e) {var t = new d.Edge(e),r = e.getRange();r[0] !== -1 / 0 && r[1] !== 1 / 0 ? (t.sett0(r[0]), t.sett1(r[1])) : (t.sett0(0), t.sett1(1));var n = t.evaluatePosition(t.t0());if (t.setStartVertex(new l.Vertex(new s.Point(n))), e.isClosed()) t.setEndVertex(t.getStartVertex());else {var o = t.evaluatePosition(t.t1());t.setEndVertex(new l.Vertex(new s.Point(o)));}return t;};t.createLineEdgeBetweenVertices = y, t.createLineEdge = function (e, t) {var r = new l.Vertex(new s.Point(e)),n = new l.Vertex(new s.Point(t));return y(r, n);}, t.createCoedgeOnEdge = m, t.makeConeOrCylinderVParamLoop = function (e, t) {i.ConsoleUtils.assert(e.getGeometryType() === o.GEOMETRY_TYPES.CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.CONE || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CONE), i.ConsoleUtils.assert(e.isPeriodicV());var r,n = new d.Edge(),a = e.vParamLine(t);a.getGeometryType() === o.GEOMETRY_TYPES.POINT ? r = a : (r = new s.Point(a.evaluatePosition(a.getRange()[0])), n.setCurve(a), n.setRange(a.getRange()));var c = new l.Vertex(r);n.setStartVertex(c), n.setEndVertex(c);var u = new g.Loop();return u.addCoedge(m(n)), u;}, t.createFaceFromPolyline = function (e) {var t = E(e),r = (0, v.definePlaneThroughPoints)(e),n = new c.Plane();n.set(r.origin, r.normal, r.uAxis), n.limitRangeU(r.uRange), n.limitRangeV(r.vRange);var o = new p.Face(n);return o.addLoop(t), o;}, t.createLoopFromPolyline = E, t.createEdgeFromCurve = x, t.createEdgesFromCurves = function (e) {for (var t = [], r = 0; r < e.length; ++r) {t.push(x(e[r]));}return (0, _.mergeCoincidentVertices)(t), t;}, t.createWiresFromEdges = function (e) {for (var t = (0, _.findConnectedEdges)(e), r = [], n = 0; n < t.length; ++n) {var o = new f.Wire();o.addEdges(t[n]), r.push(o);}return r;}, t.createShellsFromFaces = function (e) {for (var t = (0, _.findConnectedFaces)(e), r = new Array(t.length), n = 0; n < t.length; ++n) {var o = new h.Shell();o.addFaces(t[n]), r[n] = o;}return r;};}, function (e, t, r) {"use strict";r.r(t), function (e) {r.d(t, "default", function () {return _;}), r.d(t, "VERSION", function () {return y;}), r.d(t, "iteratee", function () {return x;}), r.d(t, "restArguments", function () {return A;}), r.d(t, "each", function () {return S;}), r.d(t, "forEach", function () {return S;}), r.d(t, "map", function () {return M;}), r.d(t, "collect", function () {return M;}), r.d(t, "reduce", function () {return N;}), r.d(t, "foldl", function () {return N;}), r.d(t, "inject", function () {return N;}), r.d(t, "reduceRight", function () {return F;}), r.d(t, "foldr", function () {return F;}), r.d(t, "find", function () {return I;}), r.d(t, "detect", function () {return I;}), r.d(t, "filter", function () {return D;}), r.d(t, "select", function () {return D;}), r.d(t, "reject", function () {return j;}), r.d(t, "every", function () {return B;}), r.d(t, "all", function () {return B;}), r.d(t, "some", function () {return U;}), r.d(t, "any", function () {return U;}), r.d(t, "contains", function () {return k;}), r.d(t, "includes", function () {return k;}), r.d(t, "include", function () {return k;}), r.d(t, "invoke", function () {return G;}), r.d(t, "pluck", function () {return z;}), r.d(t, "where", function () {return Y;}), r.d(t, "findWhere", function () {return K;}), r.d(t, "max", function () {return q;}), r.d(t, "min", function () {return W;}), r.d(t, "shuffle", function () {return H;}), r.d(t, "sample", function () {return X;}), r.d(t, "sortBy", function () {return J;}), r.d(t, "groupBy", function () {return Z;}), r.d(t, "indexBy", function () {return Q;}), r.d(t, "countBy", function () {return ee;}), r.d(t, "toArray", function () {return re;}), r.d(t, "size", function () {return ne;}), r.d(t, "partition", function () {return oe;}), r.d(t, "first", function () {return ie;}), r.d(t, "head", function () {return ie;}), r.d(t, "take", function () {return ie;}), r.d(t, "initial", function () {return se;}), r.d(t, "last", function () {return ae;}), r.d(t, "rest", function () {return ce;}), r.d(t, "tail", function () {return ce;}), r.d(t, "drop", function () {return ce;}), r.d(t, "compact", function () {return ue;}), r.d(t, "flatten", function () {return he;}), r.d(t, "without", function () {return de;}), r.d(t, "uniq", function () {return ge;}), r.d(t, "unique", function () {return ge;}), r.d(t, "union", function () {return pe;}), r.d(t, "intersection", function () {return fe;}), r.d(t, "difference", function () {return ve;}), r.d(t, "unzip", function () {return _e;}), r.d(t, "zip", function () {return ye;}), r.d(t, "object", function () {return me;}), r.d(t, "findIndex", function () {return xe;}), r.d(t, "findLastIndex", function () {return Re;}), r.d(t, "sortedIndex", function () {return Ae;}), r.d(t, "indexOf", function () {return Ve;}), r.d(t, "lastIndexOf", function () {return Te;}), r.d(t, "range", function () {return Ce;}), r.d(t, "chunk", function () {return be;}), r.d(t, "bind", function () {return Oe;}), r.d(t, "partial", function () {return Se;}), r.d(t, "bindAll", function () {return Me;}), r.d(t, "memoize", function () {return we;}), r.d(t, "delay", function () {return Ne;}), r.d(t, "defer", function () {return Fe;}), r.d(t, "throttle", function () {return Ie;}), r.d(t, "debounce", function () {return De;}), r.d(t, "wrap", function () {return je;}), r.d(t, "negate", function () {return Be;}), r.d(t, "compose", function () {return Ue;}), r.d(t, "after", function () {return ke;}), r.d(t, "before", function () {return Ge;}), r.d(t, "once", function () {return ze;}), r.d(t, "keys", function () {return We;}), r.d(t, "allKeys", function () {return He;}), r.d(t, "values", function () {return Xe;}), r.d(t, "mapObject", function () {return Je;}), r.d(t, "pairs", function () {return $e;}), r.d(t, "invert", function () {return Ze;}), r.d(t, "functions", function () {return Qe;}), r.d(t, "methods", function () {return Qe;}), r.d(t, "extend", function () {return tt;}), r.d(t, "extendOwn", function () {return rt;}), r.d(t, "assign", function () {return rt;}), r.d(t, "findKey", function () {return nt;}), r.d(t, "pick", function () {return it;}), r.d(t, "omit", function () {return st;}), r.d(t, "defaults", function () {return at;}), r.d(t, "create", function () {return ct;}), r.d(t, "clone", function () {return ut;}), r.d(t, "tap", function () {return lt;}), r.d(t, "isMatch", function () {return ht;}), r.d(t, "isEqual", function () {return dt;}), r.d(t, "isEmpty", function () {return gt;}), r.d(t, "isElement", function () {return pt;}), r.d(t, "isArray", function () {return vt;}), r.d(t, "isObject", function () {return _t;}), r.d(t, "isArguments", function () {return yt;}), r.d(t, "isFunction", function () {return mt;}), r.d(t, "isString", function () {return Et;}), r.d(t, "isNumber", function () {return xt;}), r.d(t, "isDate", function () {return Rt;}), r.d(t, "isRegExp", function () {return At;}), r.d(t, "isError", function () {return Pt;}), r.d(t, "isSymbol", function () {return Vt;}), r.d(t, "isMap", function () {return Tt;}), r.d(t, "isWeakMap", function () {return Ct;}), r.d(t, "isSet", function () {return bt;}), r.d(t, "isWeakSet", function () {return Lt;}), r.d(t, "isFinite", function () {return St;}), r.d(t, "isNaN", function () {return Mt;}), r.d(t, "isBoolean", function () {return wt;}), r.d(t, "isNull", function () {return Nt;}), r.d(t, "isUndefined", function () {return Ft;}), r.d(t, "has", function () {return It;}), r.d(t, "identity", function () {return Dt;}), r.d(t, "constant", function () {return jt;}), r.d(t, "noop", function () {return Bt;}), r.d(t, "property", function () {return Ut;}), r.d(t, "propertyOf", function () {return kt;}), r.d(t, "matcher", function () {return Gt;}), r.d(t, "matches", function () {return Gt;}), r.d(t, "times", function () {return zt;}), r.d(t, "random", function () {return Yt;}), r.d(t, "now", function () {return Kt;}), r.d(t, "escape", function () {return Xt;}), r.d(t, "unescape", function () {return Jt;}), r.d(t, "result", function () {return $t;}), r.d(t, "uniqueId", function () {return Qt;}), r.d(t, "templateSettings", function () {return er;}), r.d(t, "template", function () {return ir;}), r.d(t, "chain", function () {return sr;}), r.d(t, "mixin", function () {return cr;});var n = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self && self || "object" == _typeof(e) && e.global === e && e || Function("return this")() || {},o = Array.prototype,i = Object.prototype,s = "undefined" != typeof Symbol ? Symbol.prototype : null,a = o.push,c = o.slice,u = i.toString,l = i.hasOwnProperty,h = Array.isArray,d = Object.keys,g = Object.create,p = n.isNaN,f = n.isFinite,v = function v() {};function _(e) {return e instanceof _ ? e : this instanceof _ ? void (this._wrapped = e) : new _(e);}var y = _.VERSION = "1.10.2";function m(e, t, r) {if (void 0 === t) return e;switch (null == r ? 3 : r) {case 1:return function (r) {return e.call(t, r);};case 3:return function (r, n, o) {return e.call(t, r, n, o);};case 4:return function (r, n, o, i) {return e.call(t, r, n, o, i);};}return function () {return e.apply(t, arguments);};}function E(e, t, r) {return null == e ? Dt : mt(e) ? m(e, t, r) : _t(e) && !vt(e) ? Gt(e) : Ut(e);}function x(e, t) {return E(e, t, 1 / 0);}function R(e, t, r) {return _.iteratee !== x ? _.iteratee(e, t) : E(e, t, r);}function A(e, t) {return t = null == t ? e.length - 1 : +t, function () {for (var r = Math.max(arguments.length - t, 0), n = Array(r), o = 0; o < r; o++) {n[o] = arguments[o + t];}switch (t) {case 0:return e.call(this, n);case 1:return e.call(this, arguments[0], n);case 2:return e.call(this, arguments[0], arguments[1], n);}var i = Array(t + 1);for (o = 0; o < t; o++) {i[o] = arguments[o];}return i[t] = n, e.apply(this, i);};}function P(e) {if (!_t(e)) return {};if (g) return g(e);v.prototype = e;var t = new v();return v.prototype = null, t;}function V(e) {return function (t) {return null == t ? void 0 : t[e];};}function T(e, t) {return null != e && l.call(e, t);}function C(e, t) {for (var r = t.length, n = 0; n < r; n++) {if (null == e) return;e = e[t[n]];}return r ? e : void 0;}_.iteratee = x;var b = Math.pow(2, 53) - 1,L = V("length");function O(e) {var t = L(e);return "number" == typeof t && t >= 0 && t <= b;}function S(e, t, r) {var n, o;if (t = m(t, r), O(e)) for (n = 0, o = e.length; n < o; n++) {t(e[n], n, e);} else {var i = We(e);for (n = 0, o = i.length; n < o; n++) {t(e[i[n]], i[n], e);}}return e;}function M(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = Array(o), s = 0; s < o; s++) {var a = n ? n[s] : s;i[s] = t(e[a], a, e);}return i;}function w(e) {return function (t, r, n, o) {var i = arguments.length >= 3;return function (t, r, n, o) {var i = !O(t) && We(t),s = (i || t).length,a = e > 0 ? 0 : s - 1;for (o || (n = t[i ? i[a] : a], a += e); a >= 0 && a < s; a += e) {var c = i ? i[a] : a;n = r(n, t[c], c, t);}return n;}(t, m(r, o, 4), n, i);};}var N = w(1),F = w(-1);function I(e, t, r) {var n = (O(e) ? xe : nt)(e, t, r);if (void 0 !== n && -1 !== n) return e[n];}function D(e, t, r) {var n = [];return t = R(t, r), S(e, function (e, r, o) {t(e, r, o) && n.push(e);}), n;}function j(e, t, r) {return D(e, Be(R(t)), r);}function B(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (!t(e[s], s, e)) return !1;}return !0;}function U(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (t(e[s], s, e)) return !0;}return !1;}function k(e, t, r, n) {return O(e) || (e = Xe(e)), ("number" != typeof r || n) && (r = 0), Ve(e, t, r) >= 0;}var G = A(function (e, t, r) {var n, o;return mt(t) ? o = t : vt(t) && (n = t.slice(0, -1), t = t[t.length - 1]), M(e, function (e) {var i = o;if (!i) {if (n && n.length && (e = C(e, n)), null == e) return;i = e[t];}return null == i ? i : i.apply(e, r);});});function z(e, t) {return M(e, Ut(t));}function Y(e, t) {return D(e, Gt(t));}function K(e, t) {return I(e, Gt(t));}function q(e, t, r) {var n,o,i = -1 / 0,s = -1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n > i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) > s || o === -1 / 0 && i === -1 / 0) && (i = e, s = o);});return i;}function W(e, t, r) {var n,o,i = 1 / 0,s = 1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n < i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) < s || o === 1 / 0 && i === 1 / 0) && (i = e, s = o);});return i;}function H(e) {return X(e, 1 / 0);}function X(e, t, r) {if (null == t || r) return O(e) || (e = Xe(e)), e[Yt(e.length - 1)];var n = O(e) ? ut(e) : Xe(e),o = L(n);t = Math.max(Math.min(t, o), 0);for (var i = o - 1, s = 0; s < t; s++) {var a = Yt(s, i),c = n[s];n[s] = n[a], n[a] = c;}return n.slice(0, t);}function J(e, t, r) {var n = 0;return t = R(t, r), z(M(e, function (e, r, o) {return { value: e, index: n++, criteria: t(e, r, o) };}).sort(function (e, t) {var r = e.criteria,n = t.criteria;if (r !== n) {if (r > n || void 0 === r) return 1;if (r < n || void 0 === n) return -1;}return e.index - t.index;}), "value");}function $(e, t) {return function (r, n, o) {var i = t ? [[], []] : {};return n = R(n, o), S(r, function (t, o) {var s = n(t, o, r);e(i, t, s);}), i;};}var Z = $(function (e, t, r) {T(e, r) ? e[r].push(t) : e[r] = [t];}),Q = $(function (e, t, r) {e[r] = t;}),ee = $(function (e, t, r) {T(e, r) ? e[r]++ : e[r] = 1;}),te = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;function re(e) {return e ? vt(e) ? c.call(e) : Et(e) ? e.match(te) : O(e) ? M(e, Dt) : Xe(e) : [];}function ne(e) {return null == e ? 0 : O(e) ? e.length : We(e).length;}var oe = $(function (e, t, r) {e[r ? 0 : 1].push(t);}, !0);function ie(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[0] : se(e, e.length - t);}function se(e, t, r) {return c.call(e, 0, Math.max(0, e.length - (null == t || r ? 1 : t)));}function ae(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[e.length - 1] : ce(e, Math.max(0, e.length - t));}function ce(e, t, r) {return c.call(e, null == t || r ? 1 : t);}function ue(e) {return D(e, Boolean);}function le(e, t, r, n) {for (var o = (n = n || []).length, i = 0, s = L(e); i < s; i++) {var a = e[i];if (O(a) && (vt(a) || yt(a))) {if (t) for (var c = 0, u = a.length; c < u;) {n[o++] = a[c++];} else le(a, t, r, n), o = n.length;} else r || (n[o++] = a);}return n;}function he(e, t) {return le(e, t, !1);}var de = A(function (e, t) {return ve(e, t);});function ge(e, t, r, n) {wt(t) || (n = r, r = t, t = !1), null != r && (r = R(r, n));for (var o = [], i = [], s = 0, a = L(e); s < a; s++) {var c = e[s],u = r ? r(c, s, e) : c;t && !r ? (s && i === u || o.push(c), i = u) : r ? k(i, u) || (i.push(u), o.push(c)) : k(o, c) || o.push(c);}return o;}var pe = A(function (e) {return ge(le(e, !0, !0));});function fe(e) {for (var t = [], r = arguments.length, n = 0, o = L(e); n < o; n++) {var i = e[n];if (!k(t, i)) {var s;for (s = 1; s < r && k(arguments[s], i); s++) {;}s === r && t.push(i);}}return t;}var ve = A(function (e, t) {return t = le(t, !0, !0), D(e, function (e) {return !k(t, e);});});function _e(e) {for (var t = e && q(e, L).length || 0, r = Array(t), n = 0; n < t; n++) {r[n] = z(e, n);}return r;}var ye = A(_e);function me(e, t) {for (var r = {}, n = 0, o = L(e); n < o; n++) {t ? r[e[n]] = t[n] : r[e[n][0]] = e[n][1];}return r;}function Ee(e) {return function (t, r, n) {r = R(r, n);for (var o = L(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e) {if (r(t[i], i, t)) return i;}return -1;};}var xe = Ee(1),Re = Ee(-1);function Ae(e, t, r, n) {for (var o = (r = R(r, n, 1))(t), i = 0, s = L(e); i < s;) {var a = Math.floor((i + s) / 2);r(e[a]) < o ? i = a + 1 : s = a;}return i;}function Pe(e, t, r) {return function (n, o, i) {var s = 0,a = L(n);if ("number" == typeof i) e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;else if (r && i && a) return n[i = r(n, o)] === o ? i : -1;if (o != o) return (i = t(c.call(n, s, a), Mt)) >= 0 ? i + s : -1;for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e) {if (n[i] === o) return i;}return -1;};}var Ve = Pe(1, xe, Ae),Te = Pe(-1, Re);function Ce(e, t, r) {null == t && (t = e || 0, e = 0), r || (r = t < e ? -1 : 1);for (var n = Math.max(Math.ceil((t - e) / r), 0), o = Array(n), i = 0; i < n; i++, e += r) {o[i] = e;}return o;}function be(e, t) {if (null == t || t < 1) return [];for (var r = [], n = 0, o = e.length; n < o;) {r.push(c.call(e, n, n += t));}return r;}function Le(e, t, r, n, o) {if (!(n instanceof t)) return e.apply(r, o);var i = P(e.prototype),s = e.apply(i, o);return _t(s) ? s : i;}var Oe = A(function (e, t, r) {if (!mt(e)) throw new TypeError("Bind must be called on a function");var n = A(function (o) {return Le(e, n, t, this, r.concat(o));});return n;}),Se = A(function (e, t) {var r = Se.placeholder,n = function n() {for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++) {s[a] = t[a] === r ? arguments[o++] : t[a];}for (; o < arguments.length;) {s.push(arguments[o++]);}return Le(e, n, this, this, s);};return n;});Se.placeholder = _;var Me = A(function (e, t) {var r = (t = le(t, !1, !1)).length;if (r < 1) throw new Error("bindAll must be passed function names");for (; r--;) {var n = t[r];e[n] = Oe(e[n], e);}});function we(e, t) {var r = function r(n) {var o = r.cache,i = "" + (t ? t.apply(this, arguments) : n);return T(o, i) || (o[i] = e.apply(this, arguments)), o[i];};return r.cache = {}, r;}var Ne = A(function (e, t, r) {return setTimeout(function () {return e.apply(null, r);}, t);}),Fe = Se(Ne, _, 1);function Ie(e, t, r) {var n,o,i,s,a = 0;r || (r = {});var c = function c() {a = !1 === r.leading ? 0 : Kt(), n = null, s = e.apply(o, i), n || (o = i = null);},u = function u() {var u = Kt();a || !1 !== r.leading || (a = u);var l = t - (u - a);return o = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), a = u, s = e.apply(o, i), n || (o = i = null)) : n || !1 === r.trailing || (n = setTimeout(c, l)), s;};return u.cancel = function () {clearTimeout(n), a = 0, n = o = i = null;}, u;}function De(e, t, r) {var n,o,i = function i(t, r) {n = null, r && (o = e.apply(t, r));},s = A(function (s) {if (n && clearTimeout(n), r) {var a = !n;n = setTimeout(i, t), a && (o = e.apply(this, s));} else n = Ne(i, t, this, s);return o;});return s.cancel = function () {clearTimeout(n), n = null;}, s;}function je(e, t) {return Se(t, e);}function Be(e) {return function () {return !e.apply(this, arguments);};}function Ue() {var e = arguments,t = e.length - 1;return function () {for (var r = t, n = e[t].apply(this, arguments); r--;) {n = e[r].call(this, n);}return n;};}function ke(e, t) {return function () {if (--e < 1) return t.apply(this, arguments);};}function Ge(e, t) {var r;return function () {return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = null), r;};}var ze = Se(Ge, 2),Ye = !{ toString: null }.propertyIsEnumerable("toString"),Ke = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];function qe(e, t) {var r = Ke.length,n = e.constructor,o = mt(n) && n.prototype || i,s = "constructor";for (T(e, s) && !k(t, s) && t.push(s); r--;) {(s = Ke[r]) in e && e[s] !== o[s] && !k(t, s) && t.push(s);}}function We(e) {if (!_t(e)) return [];if (d) return d(e);var t = [];for (var r in e) {T(e, r) && t.push(r);}return Ye && qe(e, t), t;}function He(e) {if (!_t(e)) return [];var t = [];for (var r in e) {t.push(r);}return Ye && qe(e, t), t;}function Xe(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = e[t[o]];}return n;}function Je(e, t, r) {t = R(t, r);for (var n = We(e), o = n.length, i = {}, s = 0; s < o; s++) {var a = n[s];i[a] = t(e[a], a, e);}return i;}function $e(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = [t[o], e[t[o]]];}return n;}function Ze(e) {for (var t = {}, r = We(e), n = 0, o = r.length; n < o; n++) {t[e[r[n]]] = r[n];}return t;}function Qe(e) {var t = [];for (var r in e) {mt(e[r]) && t.push(r);}return t.sort();}function et(e, t) {return function (r) {var n = arguments.length;if (t && (r = Object(r)), n < 2 || null == r) return r;for (var o = 1; o < n; o++) {for (var i = arguments[o], s = e(i), a = s.length, c = 0; c < a; c++) {var u = s[c];t && void 0 !== r[u] || (r[u] = i[u]);}}return r;};}var tt = et(He),rt = et(We);function nt(e, t, r) {t = R(t, r);for (var n, o = We(e), i = 0, s = o.length; i < s; i++) {if (t(e[n = o[i]], n, e)) return n;}}function ot(e, t, r) {return t in r;}var it = A(function (e, t) {var r = {},n = t[0];if (null == e) return r;mt(n) ? (t.length > 1 && (n = m(n, t[1])), t = He(e)) : (n = ot, t = le(t, !1, !1), e = Object(e));for (var o = 0, i = t.length; o < i; o++) {var s = t[o],a = e[s];n(a, s, e) && (r[s] = a);}return r;}),st = A(function (e, t) {var r,n = t[0];return mt(n) ? (n = Be(n), t.length > 1 && (r = t[1])) : (t = M(le(t, !1, !1), String), n = function n(e, r) {return !k(t, r);}), it(e, n, r);}),at = et(He, !0);function ct(e, t) {var r = P(e);return t && rt(r, t), r;}function ut(e) {return _t(e) ? vt(e) ? e.slice() : tt({}, e) : e;}function lt(e, t) {return t(e), e;}function ht(e, t) {var r = We(t),n = r.length;if (null == e) return !n;for (var o = Object(e), i = 0; i < n; i++) {var s = r[i];if (t[s] !== o[s] || !(s in o)) return !1;}return !0;}function dt(e, t) {return function e(t, r, n, o) {if (t === r) return 0 !== t || 1 / t == 1 / r;if (null == t || null == r) return !1;if (t != t) return r != r;var i = _typeof(t);return ("function" === i || "object" === i || "object" == _typeof(r)) && function (t, r, n, o) {t instanceof _ && (t = t._wrapped), r instanceof _ && (r = r._wrapped);var i = u.call(t);if (i !== u.call(r)) return !1;switch (i) {case "[object RegExp]":case "[object String]":return "" + t == "" + r;case "[object Number]":return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r;case "[object Date]":case "[object Boolean]":return +t == +r;case "[object Symbol]":return s.valueOf.call(t) === s.valueOf.call(r);}var a = "[object Array]" === i;if (!a) {if ("object" != _typeof(t) || "object" != _typeof(r)) return !1;var c = t.constructor,l = r.constructor;if (c !== l && !(mt(c) && c instanceof c && mt(l) && l instanceof l) && "constructor" in t && "constructor" in r) return !1;}o = o || [];for (var h = (n = n || []).length; h--;) {if (n[h] === t) return o[h] === r;}if (n.push(t), o.push(r), a) {if ((h = t.length) !== r.length) return !1;for (; h--;) {if (!e(t[h], r[h], n, o)) return !1;}} else {var d,g = We(t);if (h = g.length, We(r).length !== h) return !1;for (; h--;) {if (!T(r, d = g[h]) || !e(t[d], r[d], n, o)) return !1;}}return n.pop(), o.pop(), !0;}(t, r, n, o);}(e, t);}function gt(e) {return null == e || (O(e) && (vt(e) || Et(e) || yt(e)) ? 0 === e.length : 0 === We(e).length);}function pt(e) {return !(!e || 1 !== e.nodeType);}function ft(e) {return function (t) {return u.call(t) === "[object " + e + "]";};}var vt = h || ft("Array");function _t(e) {var t = _typeof(e);return "function" === t || "object" === t && !!e;}var yt = ft("Arguments"),mt = ft("Function"),Et = ft("String"),xt = ft("Number"),Rt = ft("Date"),At = ft("RegExp"),Pt = ft("Error"),Vt = ft("Symbol"),Tt = ft("Map"),Ct = ft("WeakMap"),bt = ft("Set"),Lt = ft("WeakSet");!function () {yt(arguments) || (yt = function yt(e) {return T(e, "callee");});}();var Ot = n.document && n.document.childNodes;function St(e) {return !Vt(e) && f(e) && !p(parseFloat(e));}function Mt(e) {return xt(e) && p(e);}function wt(e) {return !0 === e || !1 === e || "[object Boolean]" === u.call(e);}function Nt(e) {return null === e;}function Ft(e) {return void 0 === e;}function It(e, t) {if (!vt(t)) return T(e, t);for (var r = t.length, n = 0; n < r; n++) {var o = t[n];if (null == e || !l.call(e, o)) return !1;e = e[o];}return !!r;}function Dt(e) {return e;}function jt(e) {return function () {return e;};}function Bt() {}function Ut(e) {return vt(e) ? function (t) {return C(t, e);} : V(e);}function kt(e) {return null == e ? function () {} : function (t) {return vt(t) ? C(e, t) : e[t];};}function Gt(e) {return e = rt({}, e), function (t) {return ht(t, e);};}function zt(e, t, r) {var n = Array(Math.max(0, e));t = m(t, r, 1);for (var o = 0; o < e; o++) {n[o] = t(o);}return n;}function Yt(e, t) {return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));}"object" != (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) && "function" != typeof Ot && (mt = function mt(e) {return "function" == typeof e || !1;});var Kt = Date.now || function () {return new Date().getTime();},qt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" },Wt = Ze(qt);function Ht(e) {var t = function t(_t3) {return e[_t3];},r = "(?:" + We(e).join("|") + ")",n = RegExp(r),o = RegExp(r, "g");return function (e) {return e = null == e ? "" : "" + e, n.test(e) ? e.replace(o, t) : e;};}var Xt = Ht(qt),Jt = Ht(Wt);function $t(e, t, r) {vt(t) || (t = [t]);var n = t.length;if (!n) return mt(r) ? r.call(e) : r;for (var o = 0; o < n; o++) {var i = null == e ? void 0 : e[t[o]];void 0 === i && (i = r, o = n), e = mt(i) ? i.call(e) : i;}return e;}var Zt = 0;function Qt(e) {var t = ++Zt + "";return e ? e + t : t;}var er = _.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g },tr = /(.)^/,rr = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" },nr = /\\|'|\r|\n|\u2028|\u2029/g,or = function or(e) {return "\\" + rr[e];};function ir(e, t, r) {!t && r && (t = r), t = at({}, t, _.templateSettings);var n,o = RegExp([(t.escape || tr).source, (t.interpolate || tr).source, (t.evaluate || tr).source].join("|") + "|$", "g"),i = 0,s = "__p+='";e.replace(o, function (t, r, n, o, a) {return s += e.slice(i, a).replace(nr, or), i = a + t.length, r ? s += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : n ? s += "'+\n((__t=(" + n + "))==null?'':__t)+\n'" : o && (s += "';\n" + o + "\n__p+='"), t;}), s += "';\n", t.variable || (s = "with(obj||{}){\n" + s + "}\n"), s = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + s + "return __p;\n";try {n = new Function(t.variable || "obj", "_", s);} catch (e) {throw e.source = s, e;}var a = function a(e) {return n.call(this, e, _);},c = t.variable || "obj";return a.source = "function(" + c + "){\n" + s + "}", a;}function sr(e) {var t = _(e);return t._chain = !0, t;}function ar(e, t) {return e._chain ? _(t).chain() : t;}function cr(e) {return S(Qe(e), function (t) {var r = _[t] = e[t];_.prototype[t] = function () {var e = [this._wrapped];return a.apply(e, arguments), ar(this, r.apply(_, e));};}), _;}S(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (e) {var t = o[e];_.prototype[e] = function () {var r = this._wrapped;return t.apply(r, arguments), "shift" !== e && "splice" !== e || 0 !== r.length || delete r[0], ar(this, r);};}), S(["concat", "join", "slice"], function (e) {var t = o[e];_.prototype[e] = function () {return ar(this, t.apply(this._wrapped, arguments));};}), _.prototype.value = function () {return this._wrapped;}, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function () {return String(this._wrapped);};}.call(this, r(57));}, function (e, t, r) {"use strict";e.exports = l;var n = r(21);((l.prototype = Object.create(n.prototype)).constructor = l).className = "Namespace";var o,i,s,a = r(22),c = r(5);function u(e, t) {if (e && e.length) {for (var r = {}, n = 0; n < e.length; ++n) {r[e[n].name] = e[n].toJSON(t);}return r;}}function l(e, t) {n.call(this, e, t), this.nested = void 0, this._nestedArray = null;}function h(e) {return e._nestedArray = null, e;}l.fromJSON = function (e, t) {return new l(e, t.options).addJSON(t.nested);}, l.arrayToJSON = u, l.isReservedId = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if ("string" != typeof e[r] && e[r][0] <= t && e[r][1] >= t) return !0;}return !1;}, l.isReservedName = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (e[r] === t) return !0;}return !1;}, Object.defineProperty(l.prototype, "nestedArray", { get: function get() {return this._nestedArray || (this._nestedArray = c.toArray(this.nested));} }), l.prototype.toJSON = function (e) {return c.toObject(["options", this.options, "nested", u(this.nestedArray, e)]);}, l.prototype.addJSON = function (e) {if (e) for (var t, r = Object.keys(e), n = 0; n < r.length; ++n) {t = e[r[n]], this.add((void 0 !== t.fields ? o.fromJSON : void 0 !== t.values ? s.fromJSON : void 0 !== t.methods ? i.fromJSON : void 0 !== t.id ? a.fromJSON : l.fromJSON)(r[n], t));}return this;}, l.prototype.get = function (e) {return this.nested && this.nested[e] || null;}, l.prototype.getEnum = function (e) {if (this.nested && this.nested[e] instanceof s) return this.nested[e].values;throw Error("no such enum: " + e);}, l.prototype.add = function (e) {if (!(e instanceof a && void 0 !== e.extend || e instanceof o || e instanceof s || e instanceof i || e instanceof l)) throw TypeError("object must be a valid nested object");if (this.nested) {var t = this.get(e.name);if (t) {if (!(t instanceof l && e instanceof l) || t instanceof o || t instanceof i) throw Error("duplicate name '" + e.name + "' in " + this);for (var r = t.nestedArray, n = 0; n < r.length; ++n) {e.add(r[n]);}this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, !0);}} else this.nested = {};return this.nested[e.name] = e, e.onAdd(this), h(this);}, l.prototype.remove = function (e) {if (!(e instanceof n)) throw TypeError("object must be a ReflectionObject");if (e.parent !== this) throw Error(e + " is not a member of " + this);return delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0), e.onRemove(this), h(this);}, l.prototype.define = function (e, t) {if (c.isString(e)) e = e.split(".");else if (!Array.isArray(e)) throw TypeError("illegal path");if (e && e.length && "" === e[0]) throw Error("path must be relative");for (var r = this; e.length > 0;) {var n = e.shift();if (r.nested && r.nested[n]) {if (!((r = r.nested[n]) instanceof l)) throw Error("path conflicts with non-namespace objects");} else r.add(r = new l(n));}return t && r.addJSON(t), r;}, l.prototype.resolveAll = function () {for (var e = this.nestedArray, t = 0; t < e.length;) {e[t] instanceof l ? e[t++].resolveAll() : e[t++].resolve();}return this.resolve();}, l.prototype.lookup = function (e, t, r) {if ("boolean" == typeof t ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), c.isString(e) && e.length) {if ("." === e) return this.root;e = e.split(".");} else if (!e.length) return this;if ("" === e[0]) return this.root.lookup(e.slice(1), t);var n = this.get(e[0]);if (n) {if (1 === e.length) {if (!t || t.indexOf(n.constructor) > -1) return n;} else if (n instanceof l && (n = n.lookup(e.slice(1), t, !0))) return n;} else for (var o = 0; o < this.nestedArray.length; ++o) {if (this._nestedArray[o] instanceof l && (n = this._nestedArray[o].lookup(e, t, !0))) return n;}return null === this.parent || r ? null : this.parent.lookup(e, t);}, l.prototype.lookupType = function (e) {var t = this.lookup(e, [o]);if (!t) throw Error("no such type: " + e);return t;}, l.prototype.lookupEnum = function (e) {var t = this.lookup(e, [s]);if (!t) throw Error("no such Enum '" + e + "' in " + this);return t;}, l.prototype.lookupTypeOrEnum = function (e) {var t = this.lookup(e, [o, s]);if (!t) throw Error("no such Type or Enum '" + e + "' in " + this);return t;}, l.prototype.lookupService = function (e) {var t = this.lookup(e, [i]);if (!t) throw Error("no such Service '" + e + "' in " + this);return t;}, l._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";var n = t,o = r(5),i = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];function s(e, t) {var r = 0,n = {};for (t |= 0; r < e.length;) {n[i[r + t]] = e[r++];}return n;}n.basic = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n.defaults = s([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, "", o.emptyArray, null]), n.long = s([0, 0, 0, 1, 1], 7), n.mapKey = s([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n.packed = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Curve = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = r(2),c = function c() {o.BaseGeometry.call(this), this._subrange = [];};(c.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrange = e.isLimited() ? [e._subrange[0], e._subrange[1]] : [];}, c.prototype.isLimited = function () {return this._subrange.length > 0;}, c.prototype.getRange = function () {return this.isLimited() ? this._subrange : this.getRangeUnlimited();}, c.prototype.getRangeUnlimited = function () {console.warn("Curve.getRangeUnlimited : abstract method invoked!");}, c.prototype.limitRange = function (e) {this._subrange = (0, s.limitRange)(this.getRange(), e, this.isPeriodic(), this.getPeriod());}, c.prototype.unlimitRange = function () {this._subrange = [];}, c.prototype.isPeriodic = function () {return this.isPeriodicUnlimited() && !this.isLimited();}, c.prototype.isPeriodicUnlimited = function () {console.warn("Curve.isPeriodicUnlimited : abstract method invoked!");}, c.prototype.getPeriod = function () {return this.isLimited() ? void 0 : this.getPeriodUnlimited();}, c.prototype.getPeriodUnlimited = function () {if (this.isPeriodicUnlimited()) {var e = this.getRangeUnlimited();return e[1] - e[0];}}, c.prototype.isClosed = function () {if (this.isClosedUnlimited()) {if (this.isLimited()) {var e = this.getRangeUnlimited(),t = e[1] - e[0];return this._subrange[1] - this._subrange[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, c.prototype.isClosedUnlimited = function () {console.warn("Curve.isClosedUnlimited : abstract method invoked!");}, c.prototype._restrictRangeToUnlimited = function (e) {a.ConsoleUtils.assert(2 === e.length), a.ConsoleUtils.assert(e[0] <= e[1]);var t = this.getRangeUnlimited(),r = [];if (this.isPeriodicUnlimited()) {var o = t[1] - t[0];if (e[1] - e[0] > o - i.PARAMETER_SPACE_TOLERANCE) r.push([t[0], t[1]]);else {var c = (0, s.foldAbove)(e[0], t[0], o) - e[0];r.push([e[0] + c, e[1] + c]), r[0][1] > t[1] + i.PARAMETER_SPACE_TOLERANCE && (r.push([t[0], r[0][1] - o]), r[0][1] = t[1]);}} else {var u = Math.max(e[0], t[0]),l = Math.min(e[1], t[1]);u > t[1] ? u < t[1] + n.FLOAT64_TOLERANCE && r.push([t[1], t[1]]) : l < t[0] ? l > t[0] - n.FLOAT64_TOLERANCE && r.push([t[0], t[0]]) : r.push([u, l]);}return r;}, c.prototype.transform = function (e) {console.warn("Curve.transform : abstract method invoked! Doing nothing.");}, c.prototype.evaluatePosition = function (e) {console.warn("Curve.evaluatePosition : abstract method invoked! Returning undefined.");}, c.prototype.evaluateDt = function (e) {console.warn("Curve.evaluateDt : abstract method invoked! Returning undefined.");}, c.prototype.evaluateCurvature = function (e, t) {var r = this.evaluateDt(e),o = this.evaluateDt(e + i.KERNEL_TOLERANCE);n.Vector3.sub(o, o, r);var s = n.Vector3.createFloat64();n.Vector3.scale(s, o, 1 / i.KERNEL_TOLERANCE), t && (n.Vector3.copy(t, s), n.Vector3.normalize(t, t));var a = n.Vector3.squaredLength(r);return n.Vector3.cross(s, r, s), n.Vector3.length(s) / Math.pow(a, 1.5);}, c.prototype.tangentLength = function (e) {return n.Vector3.length(this.evaluateDt(e));}, c.prototype.suggestSplittingParam = function (e) {console.warn("Curve.suggestSplittingParam : abstract method invoked! Returning undefined.");}, c.prototype.getTangentCone = function (e) {console.warn("Curve.getTangentCone : abstract method invoked! Returning undefined.");}, c.prototype.closestToRayParam = function (e, t, r) {console.warn("Curve.closestToRayParam : abstract method invoked! Returning undefined.");}, c.prototype.closestToPointParam = function (e, t) {console.warn("Curve.closestToPointParam : abstract method invoked! Returning undefined.");}, c.prototype.getArcLength = function (e) {console.warn("Curve.getArcLength : abstract method invoked!");}, c.prototype.getParameterFromArcLength = function (e, t) {console.warn("Curve.getParameterFromArcLength : abstract method invoked!");}, c.prototype.getBoundingBox = function (e) {console.warn("Curve.getBoundingBox : abstract method invoked! Returning undefined.");}, c.prototype.tessellate = function (e, t) {console.warn("Curve.tessellate : abstract method invoked! Returning undefined.");}, t.Curve = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BCurve = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(7),u = r(3),l = r(35),h = r(2),d = r(8),g = r(50),p = r(36),f = r(17),v = r(37),_ = r(102),y = r(73),m = function m() {a.Curve.call(this), this._controlPoints = [], this._weights = [], this._degree = 0, this._knots = [], this._isRational = void 0, this._isPeriodic = void 0, this._isClosed = void 0, this._isPlanarXY = void 0, this._discretizationCache = void 0, this._segments = void 0, this._hasDirtySegments = !0, this._isDirtyControlPoint = [], this._tessellationCache = new g.TessellationCache();};(m.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.BCURVE;}, m.prototype.clone = function () {var e = new m();return e.copy(this), e;}, m.prototype.getControlPointsVector3 = function () {for (var e = new Array(this._controlPoints.length / 3), t = 0; t < this._controlPoints.length / 3; t++) {e[t] = n.Vector3.createFloat64FromValues(this._controlPoints[3 * t], this._controlPoints[3 * t + 1], this._controlPoints[3 * t + 2]);}return e;}, m.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), this._isRational = e._isRational, this._weights = e._weights.slice(0), this._degree = e._degree, this._knots = e._knots.slice(0), this._isPeriodic = e._isPeriodic, this._isClosed = e._isClosed, this._weights = e._weights.slice(0), this._controlPoints = e._controlPoints.slice(0), this._isPlanarXY = e._isPlanarXY, this._hasDirtySegments = !0, this._tessellationCache.reset();}, m.prototype.set = function (e, t, r, o) {this.dirtyCurveRepresentation(), this._weights = Array.prototype.slice.call(t), this._degree = r;var i = 0;if (this._isRational = !1, this._weights.length !== t.length) {this._weights = Array.prototype.slice.call(t);var s = this._weights[0];for (i = 1; i < this._weights.length; ++i) {if (Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE) {this._isRational = !0;break;}}} else for (s = this._weights[0], i = 1; i < this._weights.length; ++i) {this._weights[i] = t[i], Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE && (this._isRational = !0);}if (this._knots.length !== o.length) this._knots = Array.prototype.slice.call(o);else for (i = 0; i < this._knots.length; ++i) {this._knots[i] = o[i];}var a = e.length / 3;if (0 === this._weights.length) for (this._weights = new Array(a), i = 0; i < a; ++i) {this._weights[i] = 1;}if (this._controlPoints.length !== e.length) this._controlPoints = Array.prototype.slice.call(e);else for (i = 0; i < e.length; ++i) {this._controlPoints[i] = e[i];}this._isDirtyControlPoint.length !== a && (this._isDirtyControlPoint = new Array(a)), this._isDirtyControlPoint.fill(!1);}, m.prototype.dirtyCurveRepresentation = function () {this._isPlanarXY = void 0, this._isRational = void 0, this._isClosed = void 0, this._isPeriodic = void 0, this._discretizationCache = void 0, this._hasDirtySegments = !0, this._tessellationCache.setDirty(!0);}, m.prototype.hasDirtyTessellation = function () {return this._tessellationCache.isDirty();}, m.prototype.getTessellationCacheTolerance = function () {return this._tessellationCache.getTolerance();}, m.prototype.weightedControlPoints = function () {for (var e = [], t = 0; t < this._controlPoints.length / 3; ++t) {var r = this._weights[t];e.push(this._controlPoints[3 * t] * r, this._controlPoints[3 * t + 1] * r, this._controlPoints[3 * t + 2] * r, r);}return e;}, m.prototype.getControlPoints = function () {return this._controlPoints;}, m.prototype._findChangedControlPoints = function (e) {var t = e.length === this._controlPoints.length;t || (this._isDirtyControlPoint = new Array(e.length / 3), this._isDirtyControlPoint.fill(!0));for (var r = 0; r < e.length / 3; ++r) {if (t) {var n = e[3 * r] - this._controlPoints[3 * r],o = e[3 * r + 1] - this._controlPoints[3 * r + 1],i = e[3 * r + 2] - this._controlPoints[3 * r + 2];n * n + o * o + i * i > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (this._isDirtyControlPoint[r] = !0);} else this._isDirtyControlPoint[r] = !0;}}, m.prototype.setControlPoints = function (e) {this._findChangedControlPoints(e), this._controlPoints = e, this.dirtyCurveRepresentation();}, m.prototype.copyControlPoints = function (e) {if (this._findChangedControlPoints(e), e !== this._controlPoints) {this._controlPoints.length = e.length;for (var t = 0; t < e.length; ++t) {this._controlPoints[t] = e[t];}}this.dirtyCurveRepresentation();}, m.prototype.transform = function (e) {for (var t = [], r = n.Vector3.createFloat64(), o = 0; o < this._controlPoints.length; o += 3) {n.Vector3.set(r, this._controlPoints[o], this._controlPoints[o + 1], this._controlPoints[o + 2]), n.Vector3.transformMatrix44(r, r, e), t.push(r[0], r[1], r[2]);}this.setControlPoints(t);}, m.prototype.getControlPointPosition = function (e) {return n.Vector3.createFloat64FromValues(this._controlPoints[3 * e], this._controlPoints[3 * e + 1], this._controlPoints[3 * e + 2]);}, m.prototype.extendBBoxFromControlPoints = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), e.includePoint(t);}}, m.prototype.setControlPointPosition = function (e, t, r, n) {this._controlPoints[3 * e] = t, this._controlPoints[3 * e + 1] = r, this._controlPoints[3 * e + 2] = n, this._isDirtyControlPoint[e] = !0, this.dirtyCurveRepresentation();}, m.prototype.getWeights = function () {return this._weights;}, m.prototype.setWeights = function (e) {this._weights = e, this.dirtyCurveRepresentation();}, m.prototype.getKnotVector = function () {return this._knots;}, m.prototype.setKnotVector = function (e) {this._knots = e, this.dirtyCurveRepresentation();}, m.prototype.getDegree = function () {return this._degree;}, m.prototype.isRational = function () {if (void 0 === this._isRational && (this._isRational = !1, this._weights)) for (var e = this._weights[0], t = 0; t < this._weights.length; ++t) {if (Math.abs(this._weights[t] - e) > n.FLOAT64_TOLERANCE) return this._isRational = !0, !0;}return this._isRational;}, m.prototype.isSimpleBezier = function () {return this._knots.length === 2 * this._degree + 2;}, m.prototype.getNumControlPoints = function () {return this._controlPoints.length / 3;}, m.prototype.getTessellationCache = function () {return this._tessellationCache.getCache();}, m.prototype.getEvaluationCache = function () {return void 0 === this._discretizationCache && this.evaluate(), this._discretizationCache;}, m.prototype.getRangeUnlimited = function () {return [this._knots[0], this._knots[this._knots.length - 1]];}, m.prototype.isPeriodicUnlimited = function () {return this._checkClosure(), this._isPeriodic;}, m.prototype.isClosedUnlimited = function () {return this._checkClosure(), this._isClosed;}, m.prototype._checkClosure = function () {if (void 0 === this._isClosed || void 0 === this._isPeriodic) {this._isClosed = this._isPeriodic = !1;var e = this.getRangeUnlimited(),t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);if (n.Vector3.equals(t, r, s.KERNEL_TOLERANCE)) {this._isClosed = !0;var o = this.evaluateDt(e[0]),i = this.evaluateDt(e[1]);n.Vector3.isParallel(o, i, 1, s.KERNEL_ANGULAR_TOLERANCE) && (this._isPeriodic = !0);}}}, m.prototype.getBezierSegments = function () {return this._decomposeCurve(), this.isSimpleBezier() ? [this] : this._segments;}, m.prototype.isPlanarXY = function () {if (void 0 === this._isPlanarXY) {var e = s.SPLINE_DISTANCE_TOLERANCE;this._isPlanarXY = !0;for (var t = 1 / 0, r = -1 / 0, n = 2; n < this._controlPoints.length; n += 3) {t = Math.min(t, this._controlPoints[n]), r = Math.max(r, this._controlPoints[n]);}Math.abs(r - t) > 2 * e && (this._isPlanarXY = !1);}return this._isPlanarXY;}, m.prototype.getBezierSegmentsInRange = function (e, t) {for (var r = this.getBezierSegments(), n = e || this._knots[0], o = t || this._knots[this._knots.length - 1], i = [], s = 0; s < r.length; ++s) {var a = r[s].getKnotVector();n <= a[a.length - 1] && a[0] >= o && i.push(r[s]);}return i;}, m.prototype.getApproxParameterSpaceTolerance = function () {if (12 === this.getControlPoints().length) return p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this.getBoundingBox(), s.KERNEL_TOLERANCE);this._decomposeCurve();for (var e = 0, t = 0; t < this._segments.size(); ++t) {e += p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this._segments[t].getBoundingBox(), s.KERNEL_TOLERANCE);}return e;}, m.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = this._restrictRangeToUnlimited(e), r = 0, o = this.getBezierSegments(), i = 0; i < o.length; ++i) {for (var a = o[i], c = a.getRangeUnlimited(), u = 0; u < t.length; ++u) {var h = [Math.max(c[0], t[u][0]), Math.min(c[1], t[u][1])];h[1] - h[0] > s.PARAMETER_SPACE_TOLERANCE && (r += (0, l.integrateFunction1D)(function (e) {return n.Vector3.length(a.evaluateDt(e));}, h));}}return r;}, m.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = this;return (0, l.invertIntegral1D)(function (e) {return n.Vector3.length(r.evaluateDt(e));}, e, t);}, m.prototype._decomposeCurve = function () {if (this._hasDirtySegments) if (this._hasDirtySegments = !1, this.isSimpleBezier()) this._segments = void 0;else {var e;this._isDirtyControlPoint.length === this.getNumControlPoints() ? e = (0, _.decomposeBCurveFlags)(this.getKnotVector(), this._isDirtyControlPoint) : (this._isDirtyControlPoint = new Array(this.getNumControlPoints()), (e = new Array(this.getNumControlPoints())).fill(!0)), this._isDirtyControlPoint.fill(!1);var t = (0, _.decomposeBCurveToBezier)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0);this._segments && this._segments.length === t.P.length || (this._segments = []);for (var r = 0; r < t.P.length; ++r) {void 0 === this._segments[r] && (this._segments[r] = new m(), e[r] = !0), e[r] && this._segments[r].set(t.P[r], t.w ? t.w[r] : new Array(2 * this._degree + 2).fill(1), this._degree, t.U[r]);}}}, m.prototype.evaluatePosition = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurvePoint)(e, this._degree, this._knots, this._controlPoints, t);}, m.prototype.evaluateDt = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurveDerivs)(e, 1, this._degree, this._knots, this._controlPoints, t)[1];}, m.prototype.closestToRayParam = function (e, t, r, o) {if (!(this._controlPoints.length < 9)) {if (this.isPlanarXY()) {var i = t[2],a = n.Vector3.createFloat64();if (Math.abs(i) < s.KERNEL_ANGULAR_TOLERANCE) n.Vector3.copy(a, e);else {var c = (this._controlPoints[2] - e[2]) / i;n.Vector3.add(a, n.Vector3.scale(a, t, c), e);}return this.closestToPointParam(a);}d.DebugUtils.warn("BCurve.closestToRayParam() only defined for planar curves");}}, m.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());for (var r = this._restrictRangeToUnlimited(t), o = n.FLOAT64_TOLERANCE, i = this.getBezierSegments(), s = (0, y.closestBCurveSegments)(e, i, void 0, r), a = Number.POSITIVE_INFINITY, c = void 0, l = 0; l < s.length; ++l) {if (!(s[l].minDistSqr > a)) for (var h = i[s[l].index], d = h.getRangeUnlimited(), g = 0; g < r.length; ++g) {var p = [Math.max(d[0], r[g][0]), Math.min(d[1], r[g][1])];if (!(p[1] - p[0] <= n.FLOAT64_TOLERANCE)) {var f = h.getEvaluationCache(),v = (0, u.closestPointToPolyline)(e, f.points, f.offset, p),_ = (0, y.relaxBCurveToPerpendicular)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0, e, v, p, o, 32),m = h.evaluatePosition(_),E = n.Vector3.squaredDistance(m, e);E < a && (a = E, c = _);var x = h.evaluatePosition(p[0]),R = n.Vector3.squaredDistance(x, e);R < a && (a = R, c = p[0]);var A = h.evaluatePosition(p[1]),P = n.Vector3.squaredDistance(A, e);P < a && (a = P, c = p[1]);}}}return this.isPeriodicUnlimited() && (c = (0, u.foldNearTo)(c, .5 * (t[0] + t[1]), this.getPeriodUnlimited())), c;}, m.prototype.evaluate = function () {var e = this.getBezierSegments();if (e[0] === this) void 0 === this._discretizationCache && (this._discretizationCache = p.SplineCurveHelper.evaluateCurve(this.getDegree(), this.getKnotVector(), this.getControlPoints(), this.getWeights(), !0));else for (var t = 0; t < e.length; ++t) {var r = e[t];void 0 === r._discretizationCache && (r._discretizationCache = p.SplineCurveHelper.evaluateCurve(r.getDegree(), r.getKnotVector(), r.getControlPoints(), r.getWeights(), !0));}}, m.prototype._getFullTessellation = function (e) {var t,r,o = this.getBezierSegments(),i = 0,s = !1;if (o[0] === this) {s = !0;var a = g.CurveTessellator.getAdaptiveRenderPoints(this, e, this.getRangeUnlimited());t = a.positions, r = a.params, i = Math.max(i, a.tolerance);} else {t = [], r = [];for (var c = 0; c < o.length; ++c) {var u = o[c];if (u.hasDirtyTessellation() || u.getTessellationCacheTolerance() > e + n.FLOAT64_TOLERANCE) {s = !0;var l = g.CurveTessellator.getAdaptiveRenderPoints(u, e, u.getRangeUnlimited());u._tessellationCache.setCache(l), i = Math.max(i, l.tolerance);}u._tessellationCache && (0 === c ? (t.push.apply(t, u._tessellationCache.getCache().positions), r.push.apply(r, u._tessellationCache.getCache().params)) : (t.push.apply(t, u._tessellationCache.getCache().positions.slice(1)), r.push.apply(r, u._tessellationCache.getCache().params.slice(1))));}}return { positions: t, params: r, didRetessellate: s, tolerance: i };}, m.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, m.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this._restrictRangeToUnlimited(e),r = new o.BoundingBox(),n = this.getRangeUnlimited();if (t[0][0] < n[0] + s.PARAMETER_SPACE_TOLERANCE && t[0][1] > n[1] - s.PARAMETER_SPACE_TOLERANCE) this.extendBBoxFromControlPoints(r);else for (var i = this.getBezierSegments(), a = 0; a < t.length; a++) {for (var c = 0; c < i.length; c++) {var u = i[c];(u = u._getSubset(t[a][0], t[a][1])) && u.extendBBoxFromControlPoints(r);}}return r;}, m.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);n.Vector3.sub(r, r, t), n.Vector3.squaredLength(r) < .01 * s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (r = this.evaluateDt(.5 * (e[0] + e[1]))), n.Vector3.normalize(r, r);for (var o = new i.TangentCone(r, 0), a = this._restrictRangeToUnlimited(e), c = n.Vector3.createFloat64FromValues(0, 0, 0), u = this.getBezierSegments(), l = 0; l < a.length; l++) {for (var h = 0; h < u.length; h++) {var d = u[h];if (d = d._getSubset(a[l][0], a[l][1])) for (var g = d._controlPoints, p = 0; p < g.length - 3; p += 3) {c[0] = g[p + 3] - g[p], c[1] = g[p + 4] - g[p + 1], c[2] = g[p + 5] - g[p + 2], n.Vector3.dot(c, r) >= 0 ? o.includeVector(c) : o.angle = Math.PI;}}}return o;}, m.prototype._getSubset = function (e, t) {var r;if (this.isPeriodicUnlimited()) return t - e > this.getPeriodUnlimited() - s.PARAMETER_SPACE_TOLERANCE ? this : ((r = this.clone())._periodicTrimToParams(e, t), r);var n = this.getRangeUnlimited();return e > n[1] - s.PARAMETER_SPACE_TOLERANCE || t < n[0] + s.PARAMETER_SPACE_TOLERANCE ? void 0 : e < n[0] + s.PARAMETER_SPACE_TOLERANCE && t > n[1] - s.PARAMETER_SPACE_TOLERANCE ? this : (r = this.clone(), e > n[0] + s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!0, e), t < n[1] - s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!1, t), r);}, m.prototype._periodicTrimToParams = function (e, t) {h.ConsoleUtils.assert(this._isPeriodic);var r = this.getRangeUnlimited(),n = (0, u.normalizeParametricRangeToShiftedRange)([e, t], r);if (n[1] > r[1]) this._isClosed = this._isPeriodic = !1, this.trimToParam(!0, n[1] - (r[1] - r[0]), void 0), this.trimToParam(!1, n[0], void 0);else {var o,i,s = this.getControlPoints(),a = this.getKnotVector(),c = this.getWeights(),l = this.getDegree(),d = this.getPeriodUnlimited(),g = [],f = a.slice(),v = a.slice(),_ = [];for (i = 0; i < s.length / 3; ++i) {g[4 * i + 0] = s[3 * i + 0] * c[i], g[4 * i + 1] = s[3 * i + 1] * c[i], g[4 * i + 2] = s[3 * i + 2] * c[i], g[4 * i + 3] = c[i];}for (o = g.slice(), p.SplineCurveHelper.extractCurveSegment(l, n[1], r[1], f, g), p.SplineCurveHelper.extractCurveSegment(l, r[0], n[0], v, o), i = 0; i < v.length; ++i) {v[i] = v[i] + d;}p.SplineCurveHelper.joinCurves(l, f, g, v, o);var y = g.length / 4,m = [];for (_.length = y, m.length = 3 * y, i = 0; i < y; ++i) {var E = g[4 * i + 3];m[3 * i] = g[4 * i] / E, m[3 * i + 1] = g[4 * i + 1] / E, m[3 * i + 2] = g[4 * i + 2] / E, _[i] = E;}this.set(m, _, l, f), this._isClosed = this._isPeriodic = !1;}}, m.prototype.trimToParam = function (e, t, r) {if (this.isPeriodicUnlimited()) return h.ConsoleUtils.assert(void 0 !== r), void this._periodicTrimToParams(t, r);var n,o,i = this.getControlPoints(),s = this.getKnotVector(),a = this.getWeights(),c = this.getDegree(),u = [];for (n = 0; n < i.length / 3; ++n) {u[4 * n + 0] = i[3 * n + 0] * a[n], u[4 * n + 1] = i[3 * n + 1] * a[n], u[4 * n + 2] = i[3 * n + 2] * a[n], u[4 * n + 3] = a[n];}var l = [],d = 0,g = p.SplineCurveHelper.insertKnot(c, s, u, t, c),v = (0, f.findKnotSpan)(t, g.U);for (e ? (g.U.splice(0, v - c + 1, t), o = g.U.length - c - 1, d = 4 * (g.Pw.length / 4 - o)) : (g.U.splice(v + 1, g.U.length, t), o = g.U.length - c - 1), u.length = 3 * o, l.length = o, n = 0; n < o; ++n) {var _ = g.Pw[4 * n + 3 + d];u[3 * n] = g.Pw[4 * n + 0 + d] / _, u[3 * n + 1] = g.Pw[4 * n + 1 + d] / _, u[3 * n + 2] = g.Pw[4 * n + 2 + d] / _, l[n] = _;}this.set(u, l, c, g.U);}, m.prototype.addControlPoint = function (e, t) {var r = this.getControlPoints(),o = this.getNumControlPoints(),i = this.getKnotVector(),a = this.getWeights(),u = this.getDegree(),l = this.getControlPointPosition(e),h = this.getControlPointPosition(e + 1),d = new c.Line();d.setFromEndpoints(l, h);var g = d.closestToPointParam(t),f = d.evaluatePosition(g),v = n.Vector3.distance(f, l),_ = n.Vector3.distance(f, h),y = a[e] * v + a[e + 1] * _;if (Math.abs(y) < s.KERNEL_TOLERANCE) console.warn("numerical error in addControlPoints -- coincident control points / negative weights?");else {for (var m = a[e] * v / y, E = i[e + 1] + m * (i[e + u + 1] - i[e + 1]), x = [], R = 0; R < r.length / 3; ++R) {x[4 * R] = r[3 * R] * a[R], x[4 * R + 1] = r[3 * R + 1] * a[R], x[4 * R + 2] = r[3 * R + 2] * a[R], x[4 * R + 3] = a[R];}var A = p.SplineCurveHelper.findKnotMultiplicity(E, i),P = p.SplineCurveHelper.insertKnot(u, i, x, E, A + 1),V = [];for (x.length = 3 * (o + 1), V.length = o + 1, R = 0; R <= o; ++R) {var T = P.Pw[4 * R + 3];x[3 * R] = P.Pw[4 * R] / T, x[3 * R + 1] = P.Pw[4 * R + 1] / T, x[3 * R + 2] = P.Pw[4 * R + 2] / T, V[R] = T;}this.set(x, V, u, P.U);}}, m.prototype.addControlPointOnCurve = function (e) {for (var t = this.getNumControlPoints(), r = Number.MAX_VALUE, o = -1, i = n.Vector3.createFloat64FromValues(0, 0, 0), s = n.Vector3.createFloat64FromValues(0, 0, 0), a = 0; a < t - 1; ++a) {i[0] = this._controlPoints[3 * a + 0], i[1] = this._controlPoints[3 * a + 1], s[0] = this._controlPoints[3 * a + 3], s[1] = this._controlPoints[3 * a + 4];var c = (0, u.distancePointToLineSegment)(i, s, e);c < r && (r = c, o = a);}-1 !== o && this.addControlPoint(o, e);}, m.prototype.makePeriodic = function () {if (!this.isPeriodicUnlimited()) {for (var e = this.getControlPoints(), t = this.getKnotVector(), r = this.getWeights(), n = this.getDegree(), o = [], i = 0; i < e.length / 3; ++i) {o[4 * i] = e[3 * i] * r[i], o[4 * i + 1] = e[3 * i + 1] * r[i], o[4 * i + 2] = e[3 * i + 2] * r[i], o[4 * i + 3] = r[i];}var s = t.slice();p.SplineCurveHelper.makePeriodic(n, s, o);var a = [],c = [],u = o.length / 4;for (a.length = u, c.length = 3 * u, i = 0; i < u; ++i) {var l = o[4 * i + 3];c[3 * i] = o[4 * i] / l, c[3 * i + 1] = o[4 * i + 1] / l, c[3 * i + 2] = o[4 * i + 2] / l, a[i] = l;}this.set(c, a, n, s), this._isClosed = this._isPeriodic = !0;}}, m.prototype.suggestSplittingParam = function (e) {var t,r = this.getKnotVector(),n = .5 * (e[0] + e[1]),o = (0, u.sortedIndex)(r, n);if (0 === o) t = r[o];else if (o === r.length) t = r[o - 1];else {var i = r[o - 1],s = r[o];t = n - i < s - n ? i : s;}return t >= e[0] && t <= e[1] ? t : void 0;}, m.prototype.toObject = function () {return { degree: this._degree, knots: this._knots, controlPoints: this._controlPoints, weights: this._weights, range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.BCurve = m;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TangentCone = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this.set(e, t);};s.prototype.set = function (e, t) {void 0 === e || void 0 === t ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e), this.angle = t);}, s.prototype.toString = function () {return this.isDegenerate() ? "degenerate" : "(x:" + this.axis[0] + ", y:" + this.axis[1] + ", z:" + this.axis[2] + ", radians:" + this.angle + ")";}, s.prototype.copy = function (e) {return e.isDegenerate() ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e.axis), this.angle = e.angle), this;}, s.prototype.clone = function () {return new s(this.axis, this.angle);}, s.prototype.isDegenerate = function () {return void 0 === this.axis || void 0 === this.angle;}, s.prototype.includeVector = function (e) {if (n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return this;if (this.isDegenerate()) return this.axis || (this.axis = n.Vector3.createFloat64()), n.Vector3.normalize(this.axis, e), this.angle = 0, this;var t = n.Vector3.dot(this.axis, e) / n.Vector3.length(e);t = (0, i.clamp)(t, -1, 1);var r = Math.acos(t);return this.angle = Math.max(this.angle, r), this;}, s.prototype.includeCone = function (e) {if (e.isDegenerate()) return this;if (this.isDegenerate()) return this.copy(e);var t = n.Vector3.dot(this.axis, e.axis),r = Math.acos((0, i.clamp)(t, -1, 1));if (this.angle >= e.angle + r) return this;if (e.angle >= this.angle + r) return this.copy(e);if (r > Math.PI - o.KERNEL_ANGULAR_TOLERANCE) return this.angle = Math.PI, this;var s = (this.angle + e.angle + r) / 2;if (s >= Math.PI) return this.angle = Math.PI, this;var a = Math.sin(s - e.angle),c = Math.sin(s - this.angle);return n.Vector3.scale(this.axis, this.axis, a), n.Vector3.scaleAndAdd(this.axis, this.axis, e.axis, c), n.Vector3.normalize(this.axis, this.axis), this.angle = s, this;}, s.prototype.contains = function (e, t) {if (t = "number" == typeof t ? t : o.KERNEL_ANGULAR_TOLERANCE, !this.isDegenerate()) return n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE || n.Vector3.angle(this.axis, e) < this.angle + t;}, t.TangentCone = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.invertIntegral1D = t.integrateFunction1D = t.newtonRaphson1D = void 0;var n = r(0),o = r(3),i = r(8),s = function () {var e = [.9914553711208126, .9491079123427585, .8648644233597691, .7415311855993945, .5860872354676911, .4058451513773972, .20778495500789848, 0],t = [.022935322010529224, .06309209262997856, .10479001032225019, .14065325971552592, .1690047266392679, .19035057806478542, .20443294007529889, .20948214108472782],r = [.1294849661688697, .27970539148927664, .3818300505051189, .4179591836734694];return function (o, a, c) {var u = function (n, o, i) {for (var s = .5 * (o + i), a = .5 * (i - o), c = n(s), u = c * t[7], l = c * r[3], h = 0; h < 7; ++h) {var d = a * e[h],g = n(s - d) + n(s + d);u += g * t[h], h % 2 == 1 && (l += g * r[Math.floor(h / 2)]);}var p = 200 * Math.abs(u - l) * a;return { length: u * a, error: p *= Math.sqrt(p) };}(o, a[0], a[1]);if (void 0 === c) c = 0;else if (c > 8) return i.DebugUtils.warn("Max depth reached in integrateFunction1D!"), u.length;if (u.error > n.KERNEL_TOLERANCE) {var l = .5 * (a[0] + a[1]);return s(o, [a[0], l], c + 1) + s(o, [l, a[1]], c + 1);}return u.length;};}();t.newtonRaphson1D = function (e, t, r, n, s) {var a,c = r;t && (c = (0, o.clamp)(c, t[0], t[1]));var u = 0;do {++u;var l = e(c),h = c - l.val / l.deriv;t && (h = (0, o.clamp)(h, t[0], t[1])), a = Math.abs(h - c), c = h;} while (a > n && u < s);return u >= s && i.DebugUtils.warn("Maximum number of iterations reached. Something wrong is going on here !!!"), c;}, t.integrateFunction1D = s, t.invertIntegral1D = function (e, t, r) {var i = n.KERNEL_TOLERANCE,a = s(e, r);if (t < i) return r[0];if (t > a - i) return r[1];for (var c = r[0], u = r[1], l = t; u - c > n.PARAMETER_SPACE_TOLERANCE;) {var h = l / a,d = c + (h = (0, o.clamp)(h, .01, .99)) * (u - c),g = s(e, [c, d]),p = a - (g = (0, o.clamp)(g, 0, a));if (Math.abs(l - g) < i) return d;g > l ? (u = d, a = g) : (c = d, l -= g, a = p);}return .5 * (c + u);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SplineCurveHelper = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = r(17),c = r(37),u = r(72),l = function l() {};l.getApproxBezierParameterSpaceTolerance = function (e, t) {var r = e.getDiagonal(),i = 2 * t / n.Vector3.length(r);return i < .01 * o.PARAMETER_SPACE_TOLERANCE ? .01 * o.PARAMETER_SPACE_TOLERANCE : i;}, l.solve_cubic_uniqueRoots = function (e, t) {var r = e[2] * e[2] - 3 * e[1],n = e[2] * (2 * e[2] * e[2] - 9 * e[1]) + 27 * e[0];if (0 === n && 0 === r) return t[0] = -e[2] / 3, 1;if (n * n / 4 < r * r * r) {var o = -2 * Math.sqrt(r),i = Math.acos(-n / (r * o));return t[0] = (o * Math.cos(i / 3) - e[2]) / 3, t[1] = (o * Math.cos((i + 2 * Math.PI) / 3) - e[2]) / 3, t[2] = (o * Math.cos((i - 2 * Math.PI) / 3) - e[2]) / 3, 3;}var s = Math.pow(Math.abs(n) / 2 + Math.sqrt(n * n / 4 - r * r * r), 1 / 3) / 3;return n > 0 && (s = -s), t[0] = s + r / (9 * s) - e[2] / 3, 1;};var h = function h(e, t, r) {return 6 * ((1 - r) * (e[6 + t] - 2 * e[3 + t] + e[t]) + r * (e[9 + t] - 2 * e[6 + t] + e[3 + t]));},d = function d(e, t) {return 6 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));},g = function g(e, t) {var r = new Array(3);!function (e, t, r) {r[0] = 3 * (e[3 + t] - e[t]), r[1] = 6 * (e[t] + e[6 + t] - 2 * e[3 + t]), r[2] = 3 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));}(e, t, r);var n,o = new Array(2),i = function (e, t) {var r = e[1] * e[1] - 4 * e[2] * e[0];if (r < 0) return 0;if (0 === r) return t[0] = -.5 * e[1] / e[2], 1;var n = e[1] > 0 ? -.5 * (e[1] + Math.sqrt(r)) : -.5 * (e[1] - Math.sqrt(r));return t[0] = n / e[2], t[1] = e[0] / n, 2;}(r, o);2 === i && o[0] > o[1] && (n = o[0], o[0] = o[1], o[1] = n);for (var s = [], a = 0; a < i; a++) {o[a] > 0 && o[a] < 1 && ((n = Math.abs(h(e, t, o[a])) < 1e-12) ? (n = Math.abs(d(e, t)) < 1e-12) && s.push(o[a]) : s.push(o[a]));}return s;},p = function p(e, t, r) {return e + t[0] + t[1] * r + t[2] * r * r + t[3] * r * r * r;};l.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D = function (e, t, r, n) {var i = new Float64Array(4),s = new Float64Array(4);i[0] = t[0] - e[0], i[1] = 3 * (t[3] - t[0]), i[2] = 3 * (t[0] + t[6] - 2 * t[3]), i[3] = t[9] - t[0] + 3 * (t[3] - t[6]), s[0] = t[1] - e[1], s[1] = 3 * (t[4] - t[1]), s[2] = 3 * (t[1] + t[7] - 2 * t[4]), s[3] = t[10] - t[1] + 3 * (t[4] - t[7]);var a,c = s;if (Math.abs(c[3]) > 1e-4) c[0] /= c[3], c[1] /= c[3], c[2] /= c[3], c[3] = 1, a = this.solve_cubic_uniqueRoots(c, r);else {var l = [].slice.call(c).reverse();0 === l[0] && (l = l.slice(1));var h = (0, u.getRealPolynomialRoots)(l);a = h.length;for (var d = 0; d < a; d++) {r[d] = h[d];}}if (1 === a) return (f = r[0]) < 0 || f > 1 ? 0 : (r[0] = p(e[0], i, f), 1);d = 0;for (var g = 0; g < a; ++g) {(f = r[g]) >= 0 && f <= 1 && (r[d] = p(e[0], i, f), ++d);}if (void 0 !== n) {var f, v;if (Math.abs(s[3]) < 1e-12) Math.abs(s[2]) < 1e-12 ? v = -1 : (f = -s[1] / (2 * s[2]), v = 0);else {var _ = 2 / 3 * s[2] / s[3];v = _ * _ / 4 - 1 / 3 * s[1] / s[3], f = -_ / 2;}if (0 === v) {if (f < 0 || f > 1) {var y = p(e[0], s, 0),m = p(e[0], s, 1);Math.abs(y) > Math.abs(m) ? n.push([p(e[0], i, 0), y]) : n.push([p(e[0], i, 1), m]);} else n.push([p(e[0], i, f), p(e[0], s, f)]);} else if (v > 0) {for (g = 0; g < 2; g++) {(f = -_ / 2 + (0 === g ? -1 : 1) * Math.sqrt(v)) < -o.PARAMETER_SPACE_TOLERANCE || f > 1 + o.PARAMETER_SPACE_TOLERANCE || (f = Math.max(Math.min(1, f), 0), n.push([p(e[0], i, f), p(e[0], s, f)]));}if (n.length > 1 && n[0][0] > n[1][0]) {var E = n[0];n[0] = n[1], n[1] = E;}}}return d;}, l.isPointInsideSplineRegionXYPlanar3D = function (e, t, r) {var o,s,a = new Float64Array(3),c = t.getBezierSegments();if (t.isRational() || !c || 3 !== t.getDegree()) {for (var u = t.tessellate().positions, l = new Float64Array(2 * u.length), h = 0; h < u.length; ++h) {l[2 * h] = u[h].x, l[2 * h + 1] = u[h].y;}return (0, i.isPointInsidePolygon2D)(e, l);}var d,g = 0,p = n.Vector3.createFloat64();for (h = 0; h < c.length; ++h) {s = c[h].getControlPoints(), o = this.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D(e, s, a);for (var f = 0; f < o; ++f) {n.Vector3.set(p, a[f], e[1], 0), (d = t.closestToPointParam(p)) >= r[0] && d <= r[1] && a[f] > e[0] && ++g;}}var v = t.evaluatePosition(r[0]),_ = t.evaluatePosition(r[1]),y = n.Vector3.createFloat64();n.Vector3.normalize(y, n.Vector3.sub(y, _, v)), y[1] < 0 && n.Vector3.negate(y, y);var m = n.Vector2.createFloat64FromValues(e[0], e[1]);return (0, i.signedDistanceTo2DLine)(v, y, m) <= 0 && e[1] >= Math.min(v[1], _[1]) && e[1] <= Math.max(v[1], _[1]) && ++g, 1 & g;}, l.insertKnot = function (e, t, r, n, o) {var i,s,c,u = [],l = [],h = [],d = r.length / 4,g = d + e + 1,p = (0, a.findKnotSpanAndMultiplicity)(n, t),f = o - p.multiplicity;if (f < 1) return { U: u = t.slice(), Pw: l = r.slice() };for (i = 0; i <= p.span; ++i) {u[i] = t[i];}for (i = 1; i <= f; ++i) {u[p.span + i] = n;}for (i = p.span + 1; i < g; ++i) {u[i + f] = t[i];}for (i = 0; i <= p.span - e; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = r[4 * i + s];}}for (i = p.span - p.multiplicity; i < d; ++i) {for (s = 0; s < 4; ++s) {l[4 * (i + f) + s] = r[4 * i + s];}}for (i = 0; i <= e - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {h[4 * i + s] = r[4 * (p.span - e + i) + s];}}for (var v = 1; v <= f; ++v) {for (c = p.span - e + v, i = 0; i <= e - v - p.multiplicity; ++i) {var _ = (n - t[c + i]) / (t[i + p.span + 1] - t[c + i]);for (s = 0; s < 4; ++s) {h[4 * i + s] = h[4 * (i + 1) + s] * _ + h[4 * i + s] * (1 - _);}}for (s = 0; s < 4; ++s) {l[4 * c + s] = h[s], l[4 * (p.span + f - v - p.multiplicity) + s] = h[4 * (e - v - p.multiplicity) + s];}}for (i = c + 1; i < p.span - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = h[4 * (i - c) + s];}}return { U: u, Pw: l };}, l.refineKnotVector = function (e, t, r, n) {var i,s,c = [],u = [],l = r.length / 4 - 1,h = n.length - 1,d = l + e + 1,g = (0, a.findKnotSpan)(n[0], t),p = (0, a.findKnotSpan)(n[h], t) + 1;for (i = 0; i <= g - e; ++i) {for (s = 0; s < 4; ++s) {u[4 * i + s] = r[4 * i + s];}}for (i = p - 1; i <= l; ++i) {for (s = 0; s < 4; ++s) {u[4 * (i + h + 1) + s] = r[4 * i + s];}}for (i = 0; i <= g; ++i) {c[i] = t[i];}for (i = p + e; i <= d; ++i) {c[i + h + 1] = t[i];}var f = p + e - 1,v = p + e + h;for (i = h; i >= 0; --i) {for (; n[i] <= t[f] && f > g;) {for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + s] = r[4 * (f - e - 1) + s];}c[v] = t[f], --v, --f;}for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + 1] = u[4 * (v - e) + s];}for (var _ = 1; _ <= e; ++_) {var y = v - e + _,m = c[v + _] - n[i];if (Math.abs(m) < o.KERNEL_TOLERANCE) for (s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * y + s];} else for (m /= c[v + _] - t[f - e + _], s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * (y - 1) + s] * m + u[4 * y + s] * (1 - m);}}c[v] = n[i], --v;}return { U: c, Pw: u };};var f = function f(e, t, r, o) {var s = (0, i.projectPointToLineSegment)(t, r, e);return o && (s = (0, i.clamp)(s, 0, 1)), n.Vector3.lerp(n.Vector3.createFloat64(), t, r, s);};l.validControlPolygon = function (e) {for (var t = e.length / 3, r = e.length, o = n.Vector3.createFloat64(), i = n.Vector3.createFloat64(), s = n.Vector3.createFloat64(), a = 3, c = 1; c < t - 1; ++c) {n.Vector3.set(o, e[a], e[a + 1], e[a + 2]), n.Vector3.set(i, e[a - 3], e[a - 2], e[a - 1]), n.Vector3.set(s, e[a + 3], e[a + 4], e[a + 5]);var u = f(o, i, s, !1);if (n.Vector3.sub(o, o, u), c < t / 2 ? n.Vector3.sub(i, [e[r - 3], e[r - 2], e[r - 1]], u) : n.Vector3.sub(i, [e[0], e[1], e[2]], u), n.Vector3.dot(o, i) > 0) return !1;a += 3;}return !0;};var v = function v(e) {if (e) for (var t = 0; t < e.length; ++t) {if (Math.abs(e[t] - 1) > n.FLOAT64_TOLERANCE) return !0;}return !1;},_ = function () {var e = new Float64Array(4),t = new Float64Array(4),r = new Float64Array(4),n = new Float64Array(16);return function (o, i, s, a, c) {var u,l,h,d,g,p,f = 1 - s;if (e[0] = f * f * f, e[1] = 3 * s * f * f, e[2] = 3 * s * s * f, e[3] = s * s * s, t[0] = -3 * f * f, t[1] = 3 * (s - 1) * (3 * s - 1), t[2] = 3 * s * (2 - 3 * s), t[3] = 3 * s * s, r[0] = 6 * f, r[1] = 6 * (3 * s - 2), r[2] = 6 * (1 - 3 * s), r[3] = 6 * s, void 0 === c ? v(i) : c) {for (var _ = 0; _ < 4; ++_) {n[4 * _ + a] = o[3 * _ + a] * i[_], n[4 * _ + 3] = i[_];}for (u = n[a] * e[0], l = n[a] * t[0], h = n[a] * r[0], _ = 1; _ < 4; ++_) {u += n[4 * _ + a] * e[_], l += n[4 * _ + a] * t[_], h += n[4 * _ + a] * r[_];}for (d = n[3] * e[0], g = n[3] * t[0], p = n[3] * r[0], _ = 1; _ < 4; ++_) {d += n[4 * _ + 3] * e[_], g += n[4 * _ + 3] * t[_], p += n[4 * _ + 3] * r[_];}u /= d, l /= g, h /= p;} else for (u = o[a] * e[0], l = o[a] * t[0], h = o[a] * r[0], _ = 1; _ < 4; ++_) {u += o[3 * _ + a] * e[_], l += o[3 * _ + a] * t[_], h += o[3 * _ + a] * r[_];}return [u, l, h];};}(),y = function y(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1];var i = o[0] * o[0] + o[1] * o[1],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = a;}},m = function m(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1], o[2] = r[2] - t[2];var i = o[0] * o[0] + o[1] * o[1] + o[2] * o[2],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1] + (e[2] - t[2]) * o[2];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[2] = t[2] + a * o[2] - e[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[2] * n[2], n[0] = a;}};l.closestStartPoint = function () {var e,t,r,n,o = new Float64Array(3),i = new Float64Array(3),s = new Float64Array(3),a = new Float64Array(2);return function (c, u, l, h) {if (l) for (a[0] = 0, a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], i[0] = u.points[n + 3], i[1] = u.points[n + 4], y(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));} else for (a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], o[2] = u.points[n + 2], i[0] = u.points[n + 3], i[1] = u.points[n + 4], i[2] = u.points[n + 5], m(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));}return a[0];};}(), l.extremalParams = function (e, t) {if (3 !== e.getDegree()) return s.DebugUtils.warn("SplineCurveHelper.extremalParams called with non-degree 3 curve"), [];var r,i,a = e.getBezierSegments(),c = [];for (r = 0; r < a.length; ++r) {var u = a[r].getControlPoints(),h = a[r].getWeights(),d = a[r].getKnotVector(),g = l.extremalParamsXYPlanarBezierCurve(u, h, t),p = [];for (i = 0; i < g.length; i++) {p.push(d[0] * (1 - g[i]) + d[d.length - 1] * g[i]);}c.push(p);}var f = [];for (r = 0; r < a.length; ++r) {if (f = f.concat(c[r]), r < a.length - 1 || e.isPeriodicUnlimited()) {var v = a[r],_ = a[(r + 1) % a.length],y = c[r],m = c[(r + 1) % a.length],E = v.getRangeUnlimited()[1],x = _.getRangeUnlimited()[0],R = 0 === y.length || E - y[y.length - 1] > o.PARAMETER_SPACE_TOLERANCE,A = 0 === m.length || m[0] - x > o.PARAMETER_SPACE_TOLERANCE;if (R && A) {var P = v.evaluateDt(E)[t],V = _.evaluateDt(x)[t];(Math.abs(P) < n.FLOAT64_TOLERANCE || Math.abs(V) < n.FLOAT64_TOLERANCE || Math.sign(P) !== Math.sign(V)) && f.push(E);}}}return f;}, l.extremalParamsXYPlanarBezierCurve = function (e, t, r, n, o) {var i = v(t);if (!i) return g(e, r);for (var s, a, c = n || 16, u = o || 1e-12, l = [], h = void 0, d = 0; d < 8; d++) {if (a = _(e, t, d / 7, r, i), void 0 !== h && Math.sign(a[1]) !== h) {var p = (d - 1 + Math.abs(s) / (Math.abs(a[1]) + Math.abs(s))) / 7;l.push(p);}h = Math.sign(a[1]), s = a[1];}0 === l.length && (l[0] = 0 + u, l[1] = 1 - u), l.length > 2 && console.error("More than two roots in the second derivative of a cubic polynomial. This should not happen.");var f,y,m,E = [],x = [];for (d = 0; d < l.length; d++) {var R = 0;do {++R, m = 0 !== (a = _(e, t, l[d], r, i))[2] ? l[d] - a[1] / a[2] : l[d], f = Math.abs(a[1]), y = Math.abs(l[d] - m), l[d] = m;} while ((f > u || y > 1e-6) && R < c);E[d] = f, x[d] = a[2];}for (d = 0; d < l.length; d++) {if (l[d] < 0 || l[d] > 1 || E[d] > u) l.splice(d, 1), d--;else if (Math.abs(x[d]) < 1e-6) {var A = (_(e, t, l[d] + 5e-7, r, i)[2] - _(e, t, l[d] - 5e-7, r, i)[2]) / 1e-6;Math.abs(A) > 1e-6 && (l.splice(d, 1), d--);}}if (2 === l.length) {if (Math.abs(l[0] - l[1]) < 1e-6) {var P = E[0] / (E[0] + E[1]);return [l[0] * (1 - P) + l[1] * P];}return l;}return l;}, l.evaluateNURBSCurvePointWithFactors = function (e, t, r, n, o, i) {var s,u,l,h = (0, a.findKnotSpan)(o, t),d = (0, c.evaluateBasisFunctions)(h, o, e, t),g = new Float64Array(3),p = 0,f = 3 * (h - e);for (i.rangeMin = h - e, i.rangeMax = h, u = 0; u <= e; ++u) {for (s = n[h - e + u] * d[u], i.factors[u] = s, l = 0; l < 3; ++l) {g[l] += r[f + l] * s;}p += s, f += 3;}for (u = 0; u < 3; ++u) {g[u] /= p;}for (u = 0; u <= e; ++u) {i.factors[u] /= p;}return g;};var E = function E(e, t, r, o, i, s, a, u, h, d, g, p, v) {var _ = .5 * (r + i),y = (0, c.evaluateBCurvePoint)(_, e, t, a, h ? u : void 0);if (p > v) g.push({ offset: _, point: y });else {var m = f(y, o, s, !1),x = n.Vector3.squaredDistance(s, o),R = n.Vector3.squaredDistance(m, y);l.validControlPolygon(a) && R < d * x ? g.push({ offset: _, point: y }) : (E(e, t, r, o, _, y, a, u, h, d, g, p + 1, v), E(e, t, _, y, i, s, a, u, h, d, g, p + 1, v));}};l.renderNURBSCurve = function (e, t, r, i, s, a, u, l) {var h = a || o.DEFAULT_CURVE_RESOLUTION,d = u || [t[0], t[t.length - 1]];l = void 0 === l || l;var g,p = v(i);if (s) {var f,_,y = [];f = (0, c.evaluateBCurvePoint)(d[0], e, t, r, p ? i : void 0), _ = (0, c.evaluateBCurvePoint)(d[1], e, t, r, p ? i : void 0), y.push({ offset: d[0], point: f }), E(e, t, d[0], f, d[1], _, r, i, p, o.SPLINE_DISTANCE_TOLERANCE, y, 0, 4), y.push({ offset: d[1], point: _ }), g = new Array(4 * y.length);for (var m = l ? 0 : 1, x = l ? 0 : 1; x < y.length; x++) {g[m] = y[x].point[0], g[m + 1] = y[x].point[1], g[m + 2] = y[x].point[2], g[m + 3] = y[x].offset, m += 4;}} else {for (var R = 0, A = 3; A < r.length; A += 3) {R += n.Vector3.distance([r[A - 3], r[A - 2], r[A - 1]], [r[A], r[A + 1], r[A + 2]]);}for (h = 10 * Math.round(R), l ? (A = 0, g = new Float32Array(3 * h)) : (A = 1, g = new Float32Array(3 * (h - 1))); A < h; ++A) {var P,V = d[0] + (d[1] - d[0]) * A / (h - 1);P = (0, c.evaluateBCurvePoint)(V, e, t, r, p ? i : void 0);for (var T = 3 * A, C = 0; C < 3; ++C) {g[T + C] = P[C];}}}return g;}, l.evaluateCurve = function (e, t, r, n, i, s) {if (i) {var a = (0, c.evaluateBCurvePoint)(t[0], e, t, r, n),u = (0, c.evaluateBCurvePoint)(t[t.length - 1], e, t, r, n),l = [];l.push({ offset: t[0], point: a }), E(e, t, t[0], a, t[t.length - 1], u, r, n, !0, o.SPLINE_DISTANCE_TOLERANCE, l, 0, 3), l.push({ offset: t[t.length - 1], point: u });for (var h = [], d = [], g = 0; g < l.length; ++g) {h.push(l[g].offset), d.push(l[g].point[0], l[g].point[1], l[g].point[2]);}} else {var p = s || .01,f = t[0],v = 0;h = [], d = [];do {var _ = (0, c.evaluateBCurvePoint)(f, e, t, r, n);for (h[v] = f, g = 0; g < 3; ++g) {d[3 * v + g] = _[g];}++v, f += p;} while (f <= t[t.length - 1]);}return { offset: h, points: d };};var x = function x(e, t, r) {var n = new Float64Array(2);n[0] = r[0] - t[0], n[1] = r[1] - t[1];var o = n[0] * n[0] + n[1] * n[1];if (0 === o) return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[0] * n[0] + n[1] * n[1];var i = (e[0] - t[0]) * n[0] + (e[1] - t[1]) * n[1];return i < 0 ? (n[0] = e[0] - t[0], n[1] = e[1] - t[1]) : i > o ? (n[0] = e[0] - r[0], n[1] = e[1] - r[1]) : (i /= o, n[0] = t[0] + i * n[0] - e[0], n[1] = t[1] + i * n[1] - e[1]), n[0] * n[0] + n[1] * n[1];},R = function R(e, t) {var r,n = !1,o = t.length;r = 0;for (var i = o - 3; r < o; r += 3) {t[r + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[r]) * (e[1] - t[r + 1]) / (t[i + 1] - t[r + 1]) + t[r] && (n = !n), i = r;}return n;},A = function A(e, t) {for (var r, n = new Float64Array(2), o = Number.NEGATIVE_INFINITY, i = 0; i < t.length; i += 3) {n[0] = t[i] - e[0], n[1] = t[i + 1] - e[1], (r = n[0] * n[0] + n[1] * n[1]) > o && (o = r);}return o;},P = function P(e, t, r) {for (var n, o = t.length, i = new Float64Array(2), s = new Float64Array(2), a = Number.POSITIVE_INFINITY, c = 0; c < o - 3; c += 3) {i[0] = t[c], i[1] = t[c + 1], s[0] = t[c + 3], s[1] = t[c + 4], (n = x(e, i, s)) < a && (a = n);}return void 0 !== r && r && (i[0] = t[o - 3], i[1] = t[o - 2], s[0] = t[0], s[1] = t[1], (n = x(e, i, s)) < a && (a = n)), a;};l.closestSegmentsXYPlanar = function (e, t, r, n) {for (var o = Number.POSITIVE_INFINITY, i = [], s = 0; s < t.length; ++s) {var a,c = t[s],u = c.getRangeUnlimited();if (n) {a = !1;for (var l = 0; l < n.length; ++l) {if (u[1] >= n[l][0] && u[0] <= n[l][1]) {a = !0;break;}}} else a = !0;if (a) {var h,d,g = r ? r[s] : 0,p = c.getControlPoints();R(e, p) ? h = 0 : (h = P(e, p, !0), h = Math.max(0, h - g)), h <= o && (d = A(e, p) + g, i.push({ index: s, minDistSqr: h, maxDistSqr: d }), d < o && (o = d));}}var f = [];for (s = 0; s < i.length; ++s) {i[s].minDistSqr <= o && f.push(i[s]);}return f.sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), f;}, l.findKnotMultiplicity = function (e, t) {for (var r = 0, n = 0; n < t.length; ++n) {if (t[n] > e + 1e-8) return r;Math.abs(t[n] - e) < 1e-8 && r++;}return r;}, l.unclampCurve = function (e, t, r, n) {var o,i,s,a,c,u = r.length / 4 - 1,l = n || 1;for (o = 0; o < e - 1; ++o) {for (t[e - o - 1] = t[e - o] - (t[u - o + 1] - t[u - o]) * l, s = e - 1, i = o; i >= 0; --i) {for (a = (t[e] - t[s]) / (t[e + i + 1] - t[s]), c = 0; c < 4; ++c) {r[4 * i + c] = (r[4 * i + c] - a * r[4 * (i + 1) + c]) / (1 - a);}s -= 1;}}for (t[0] = t[1] - (t[u - e + 2] - t[u - e + 1]) * l, o = 0; o < e - 1; ++o) {for (t[u + o + 2] = t[u + o + 1] + (t[e + o + 1] - t[e + o]) * l, i = o; i >= 0; --i) {for (a = (t[u + 1] - t[u - i]) / (t[u - i + o + 2] - t[u - i]), c = 0; c < 4; ++c) {r[4 * (u - i) + c] = (r[4 * (u - i) + c] - (1 - a) * r[4 * (u - i - 1) + c]) / a;}}}t[u + e + 1] = t[u + e] + (t[2 * e] - t[2 * e - 1]) * l;}, l.extractCurveSegment = function (e, t, r, n, o) {var i = this.insertKnot(e, n, o, t, e);i = this.insertKnot(e, i.U, i.Pw, r, e);var s,c = (0, a.findKnotSpan)(t, i.U);for (n.length = i.U.length - (c - e), n[0] = t, s = 1; s < n.length; ++s) {n[s] = i.U[s + c - e];}var u = n.length - e - 1,l = 4 * (i.Pw.length / 4 - u);for (o.length = i.Pw.length - l, s = 0; s < o.length; ++s) {o[s] = i.Pw[s + l];}c = (0, a.findKnotSpan)(r, n), n.length = c + 1, n.push(r), o.length = 4 * (n.length - e - 1);};var V = function V(e, t, r, n) {for (var o = 0, i = 0; i < 4; ++i) {o += (e[t + i] - r[n + i]) * (e[t + i] - r[n + i]);}return Math.sqrt(o);};l.removeKnot = function (e, t, r, n, i) {if (t <= n[0] || t >= n[n.length - 1]) return 0;var s,c,u,l,h,d = [],g = e + 1,p = (0, a.findKnotSpanAndMultiplicity)(t, n);if (p.multiplicity < 1) return 0;for (var f, v, _, y, m = (2 * p.span - p.multiplicity - e) / 2, E = o.KERNEL_TOLERANCE, x = p.span - p.multiplicity, R = p.span - e, A = !1, P = [0, 0, 0, 0], T = 0; T < r; ++T) {for (f = R - 1, h = 0; h < 4; ++h) {d[0 + h] = i[4 * f + h], d[4 * (x + 1 - f) + h] = i[4 * (x + 1) + h];}for (s = R, c = x, u = 1, l = x - f, A = !1; c - s > T;) {for (v = (t - n[s]) / (n[s + g + T] - n[s]), _ = (t - n[c - T]) / (n[c + g] - n[c - T]), h = 0; h < 4; ++h) {d[4 * u + h] = (i[4 * s + h] - (1 - v) * d[4 * (u - 1) + h]) / v, d[4 * l + h] = (i[4 * c + h] - _ * d[4 * (l + 1) + h]) / (1 - _);}++s, ++u, --c, --l;}if (c - s < T) V(d, 4 * (u - 1), d, 4 * (l + 1)) <= E && (A = !0);else {for (v = (t - n[s]) / (n[s + g + T] - n[s]), h = 0; h < 4; ++h) {P[h] = v * d[4 * (u + T + 1) + h] + (1 - v) * d[4 * (u - 1) + h];}V(i, 4 * s, P, 0) <= E && (A = !0);}if (!A) break;for (s = R, c = x; c - s > T;) {for (h = 0; h < 4; ++h) {i[4 * s + h] = d[4 * (s - f) + h], i[4 * c + h] = d[4 * (c - f) + h];}++s, --c;}--R, ++x;}if (0 === T) return 0;for (y = p.span + 1; y < n.length; ++y) {n[y - T] = n[y];}for (n.length = n.length - T, s = c = m, y = 1; y < T; ++y) {y % 2 == 1 ? s += 1 : c -= 1;}for (y = s + 1; y < i.length / 4; ++y) {for (h = 0; h < 4; ++h) {i[4 * c + h] = i[4 * y + h];}c += 1;}return i.length = i.length - 4 * T, T;}, l.joinCurves = function (e, t, r, n, o) {var i,s = t[t.length - 1];for (t.length = t.length - 1, i = e + 1; i < n.length; ++i) {t.push(n[i]);}for (i = 4; i < o.length; ++i) {r.push(o[i]);}var a = this.removeKnot(e, s, e - 1, t, r);a !== e - 1 && console.warn("Failed knot removal, only removed seam knot " + a + " times.");}, l.clampCurve = function (e, t, r) {var n = t[e],o = t[t.length - e - 1];this.extractCurveSegment(e, n, o, t, r);}, l.makePeriodic = function (e, t, r) {var n,o,i = function (e, t, r) {var n,o,i,s = 0;for (n = 1; n < r.length / 4; ++n) {for (i = 0, o = 0; o < 3; ++o) {i += (r[4 * n + o] - r[4 * (n - 1) + o]) * (r[4 * n + o] - r[4 * (n - 1) + o]);}s += Math.sqrt(i);}for (i = 0, o = 0; o < 3; ++o) {i += (r[o] - r[r.length - 4 + o]) * (r[o] - r[r.length - 4 + o]);}var a = Math.sqrt(i),c = (t[t.length - 1] - t[0]) / s,u = r.length / 4 - 1,l = t.slice();for (n = 0; n < e - 1; ++n) {l[e - n - 1] = l[e - n] - (l[u - n + 1] - l[u - n]), l[u + n + 2] = l[u + n + 1] + (l[e + n + 1] - l[e + n]);}var h = l[1] - (l[u - e + 2] - l[u - e + 1]),d = l[u + e] + (l[2 * e] - l[2 * e - 1]);return c / ((t[0] - h + d - t[t.length - 1]) / a);}(e, t, r);this.unclampCurve(e, t, r, i);var s = t.length;for (n = e - 1; n >= 0; --n) {t[s - n] = t[s - n - 1] + (t[e - (n - 1)] - t[e - n]);}var a = r.length / 4;for (r.length = 4 * a + 4 * e, t.length = s + e, n = 0; n < e; ++n) {for (o = 0; o < 4; ++o) {r[4 * (a + n) + o] = r[4 * n + o];}t[s + n] = t[s + n - 1] + (t[e + n + 1] - t[e + n]);}this.clampCurve(e, t, r);}, t.SplineCurveHelper = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBCurveDerivs = t.evaluateBCurvePoint = t.evaluateBasisDerivatives = t.evaluateBasisFunctions = void 0;var n = r(1),o = r(3),i = r(17),s = function () {var e = null,t = null;return function (r, n, o, i) {(null === e || e.length < o + 1) && (e = new Float64Array(o + 1), t = new Float64Array(o + 1));var s = new Float64Array(o + 1);s[0] = 1;for (var a = 1; a <= o; ++a) {e[a] = n - i[r + 1 - a], t[a] = i[r + a] - n;for (var c = 0, u = 0; u < a; ++u) {var l = s[u] / (t[u + 1] + e[a - u]);s[u] = c + t[u + 1] * l, c = e[a - u] * l;}s[a] = c;}return s;};}(),a = function () {var e = null,t = null,r = null,n = null;return function (o, i, s, a, c, u) {var l, h, d;if (null === t || t.length < s + 1) {for (e = [new Float64Array(s + 1), new Float64Array(s + 1)], t = new Array(s + 1), l = 0; l < s + 1; ++l) {t[l] = new Float64Array(s + 1);}r = new Float64Array(s + 1), n = new Float64Array(s + 1);}if (!u) for (u = new Array(a + 1), l = 0; l <= a; ++l) {u[l] = new Float64Array(s + 1);}for (t[0][0] = 1, l = 1; l <= s; ++l) {r[l] = i - c[o + 1 - l], n[l] = c[o + l] - i;var g = 0;for (d = 0; d < l; ++d) {t[l][d] = n[d + 1] + r[l - d];var p = t[d][l - 1] / t[l][d];t[d][l] = g + n[d + 1] * p, g = r[l - d] * p;}t[l][l] = g;}for (l = 0; l <= s; ++l) {u[0][l] = t[l][s];}for (d = 0; d <= s; ++d) {var f = 0,v = 1;for (e[0][0] = 1, h = 1; h <= a; ++h) {var _,y = 0,m = d - h,E = s - h;for (d >= h && (e[v][0] = e[f][0] / t[E + 1][m], y = e[v][0] * t[m][E]), _ = d - 1 <= E ? h - 1 : s - d, l = m >= -1 ? 1 : -m; l <= _; ++l) {e[v][l] = (e[f][l] - e[f][l - 1]) / t[E + 1][m + l], y += e[v][l] * t[m + l][E];}d <= E && (e[v][h] = -e[f][h - 1] / t[E + 1][d], y += e[v][h] * t[d][E]), u[h][d] = y, l = f, f = v, v = l;}}for (d = s, h = 1; h <= a; ++h) {for (l = 0; l <= s; ++l) {u[h][l] *= d;}d *= s - h;}return u;};}(),c = function () {var e = null,t = null;return function (r, s, c, u, l, h) {var d, g, p;if (null === e || e.length < c + 1) {for (e = new Array(c + 1), d = 0; d <= c; ++d) {e[d] = new Float64Array(c + 1);}t = new Float64Array(c + 1);}var f = Math.min(s, c),v = h && h.length > 0,_ = (0, i.findKnotSpan)(r, u);a(_, r, c, f, u, e);var y = new Array(s + 1);for (d = 0; d <= s; ++d) {y[d] = n.Vector3.createFloat64();}for (g = 0; g <= f; ++g) {var m = 3 * (_ - c);if (v) for (t[g] = 0, d = 0; d <= c; ++d) {p = h[_ - c + d] * e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, t[g] += p, m += 3;} else for (d = 0; d <= c; ++d) {p = e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, m += 3;}}if (v) for (g = 0; g <= f; ++g) {var E = y[g];for (d = 1; d <= g; ++d) {p = -o.binomialCoefficients[g][d] * t[d], n.Vector3.scaleAndAdd(E, E, y[g - d], p);}n.Vector3.scale(E, E, 1 / t[0]);}return y;};}();t.evaluateBasisFunctions = s, t.evaluateBasisDerivatives = a, t.evaluateBCurvePoint = function (e, t, r, o, a) {var c,u,l = (0, i.findKnotSpan)(e, r),h = s(l, e, t, r),d = a && a.length > 0,g = n.Vector3.createFloat64(),p = 0,f = 3 * (l - t);if (d) {for (c = 0; c <= t; ++c) {u = a[l - t + c] * h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, p += u, f += 3;}n.Vector3.scale(g, g, 1 / p);} else for (c = 0; c <= t; ++c) {u = h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, f += 3;}return g;}, t.evaluateBCurveDerivs = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), void 0 !== o && n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._radius * Math.cos(t),o = this._radius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.cos(t),o = Math.sin(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._radius * Math.sin(t),o = this._radius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis) / this._uScale,a = 0;return r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE && (a = Math.atan2(o, r)), { u: s, v: a };}, l.prototype.vParamLine = function (e) {var t = new c.Circle(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._radius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(23),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), u.ConsoleUtils.assert(this._majorRadius > i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), u.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, u.ConsoleUtils.assert(this._minorRadius > i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getMajorAxis = function () {return this._xAxis;}, l.prototype.setMajorAxis = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._majorRadius * Math.cos(t),o = this._minorRadius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = this._minorRadius * Math.cos(t),o = this._majorRadius * Math.sin(t),i = Math.sqrt(r * r + o * o),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, r / i), n.Vector3.scaleAndAdd(s, s, this._yAxis, o / i), s;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._majorRadius * Math.sin(t),o = this._minorRadius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._zAxis) / this._uScale;return { u: r, v: this.vParamLine(r).closestToPointParam(e) };}, l.prototype.vParamLine = function (e) {var t = new c.Ellipse(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._majorRadius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i, this._minorRadius / this._majorRadius), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Wire = void 0;var n = r(9),o = r(4),i = r(0),s = function s() {n.BaseTopology.call(this), this._wireBody = void 0, this._edges = [];};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.WIRE;}, s.prototype.getWireBody = function () {return this._wireBody;}, s.prototype.setWireBody = function (e) {this._wireBody = e;}, s.prototype.getEdges = function () {return this._edges;}, s.prototype.setEdges = function (e) {this._edges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._edges[t] = e[t];}}, s.prototype.addEdge = function (e) {this._edges ? this._edges.push(e) : this._edges = [e], e.setWire(this), e.setCoedge(void 0);}, s.prototype.addEdges = function (e) {this._edges || (this._edges = []);for (var t = 0; t < e.length; ++t) {e[t].setWire(this), e[t].setCoedge(void 0);}this._edges = this._edges.concat(e);}, s.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t > -1 && (this._edges.splice(t, 1), e.getWire() === this && e.setWire(void 0), !0);}, s.prototype.getBody = function () {return this._wireBody;}, s.prototype.collectFaces = function (e) {return e || new Set();}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectVertices(e);}return e;}, s.prototype.isBranched = function () {for (var e = 0; e < this._edges.length; ++e) {var t = this._edges[e],r = t.getStartVertex(),n = t.getEndVertex();if (r === n && r.getOtherEdge(t)) return !0;if (r.getEdges().length > 2 || n.getEdges().length > 2) return !0;}return !1;}, s.prototype.getOrderedEdges = function () {if (0 === this._edges.length) return { edges: [], start: void 0, end: void 0 };var e = [];e.push(this._edges[0]);for (var t = new Set(this._edges.slice(1)), r = e[0].getStartVertex(), n = e[0].getEndVertex(); t.size > 0;) {var o = t.size;if (t.forEach(function (o) {o.getEndVertex() === r ? (e.unshift(o), r = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === r ? (e.unshift(o), r = o.getEndVertex(), t.delete(o)) : o.getEndVertex() === n ? (e.push(o), n = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === n && (e.push(o), n = o.getEndVertex(), t.delete(o));}), o === t.size) {console.warn("Wire is disconnected or branching.");break;}}return { edges: e, start: r, end: n };}, s.prototype.isClosed = function () {if (1 === this._edges.length) return this._edges[0].getStartVertex() === this._edges[0].getEndVertex();for (var e = this._edges[0], t = void 0, r = 0; r < this._edges.length; ++r) {var n,o = e.getStartVertex(),i = e.getEndVertex();if (o === i || 2 !== o.getEdges().length || 2 !== i.getEdges().length) return !1;if (t && o.getOtherEdge(e) !== t) {if (i.getOtherEdge(e) !== t) return !1;n = o.getOtherEdge(e);} else n = i.getOtherEdge(e);t = e, e = n;}return e === this._edges[0];}, s.prototype.getBoundingBox = function () {for (var e = new o.BoundingBox(), t = 0; t < this._edges.length; ++t) {e.include(this._edges[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Wire";}, s.prototype.toObject = function () {return { edges: this.refsToStrings(this._edges), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edges, this._attributes]);}, t.Wire = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.ProgenitorMap = void 0;var n = r(0),o = r(2),i = function i() {this._newToOldMap = new Map(), this._oldToNewMap = new Map(), this._labelMap = new Map();};i.prototype.addEntry = function (e, t, r) {t = Array.from(new Set(t)), o.ConsoleUtils.assert(!this._newToOldMap.has(e)), this._newToOldMap.set(e, t), r && this._labelMap.set(e, r);for (var n = 0; n < t.length; n++) {var i = t[n],s = this._oldToNewMap.get(i);s ? s.indexOf(e) < 0 && s.push(e) : this._oldToNewMap.set(i, [e]);}}, i.prototype.hasEntry = function (e) {return this._newToOldMap.has(e);}, i.prototype.removeEntry = function (e) {var t = this._newToOldMap.get(e);if (t) {this._newToOldMap.delete(e), this._labelMap.delete(e);for (var r = 0; r < t.length; r++) {var n = this._oldToNewMap.get(t[r]),i = n.indexOf(e);o.ConsoleUtils.assert(i >= 0), n.splice(i, 1), 0 === n.length && this._oldToNewMap.delete(t[r]);}}}, i.prototype.size = function () {return this._newToOldMap.size;}, i.prototype.getProgenitors = function (e) {return this._newToOldMap.get(e);}, i.prototype.getDescendants = function (e) {return this._oldToNewMap.get(e) || [];}, i.prototype.getLabel = function (e) {return this._labelMap.get(e) || "";}, i.prototype.getAllNewTopology = function () {return Array.from(this._newToOldMap.keys());}, i.prototype.getAllOldTopology = function () {return Array.from(this._oldToNewMap.keys());}, i.prototype.clear = function () {this._newToOldMap.clear(), this._oldToNewMap.clear(), this._labelMap.clear();}, i.prototype.mergeMaps = function (e) {var t = new i(),r = new Set(this._newToOldMap.keys());return e._newToOldMap.keys().forEach(function (e) {r.add(e);}), r.forEach(function (r) {var n = this.getProgenitors(r) || [],o = e.getProgenitors(r) || [],i = this.getLabel(r) || e.getLabel(r);t.addEntry(r, n.concat(o), i);}), t;}, i.prototype.collapseMaps = function (e, t) {var r = !1,n = !1;t && (void 0 !== t.keepIntermediates && (r = t.keepIntermediates), void 0 !== t.keepAllDescendants && (n = t.keepAllDescendants));var o = new i(),s = void 0;return n && (s = new Set(e._newToOldMap.keys())), this._newToOldMap.forEach(function (t, i) {for (var a = new Set(), c = 0; c < t.length; c++) {var u = t[c],l = e.getProgenitors(u);l && l.length > 0 ? (l.forEach(function (e) {a.add(e);}), r && a.add(u)) : a.add(u), n && s.delete(u);}o.addEntry(i, Array.from(a));}), n && s.forEach(function (t) {var r = e.getProgenitors(t);o.hasEntry(t) && (r = r.concat(o.getProgenitors(t)), o.removeEntry(t)), o.addEntry(t, r);}), o;}, i.prototype.toString = function () {for (var e = "ProgenitorMap:\n", t = this.getAllNewTopology(), r = 0; r < t.length; r++) {var o = t[r];e += n.TOPOLOGY_TYPES.toString(o.getTopologyType()) + ":" + o.getGuid();var i = this.getLabel(o);i && (e += " '" + i + "'"), e += " -> [ ";for (var s = this.getProgenitors(o), a = 0; a < s.length; a++) {a > 0 && (e += ", "), e += n.TOPOLOGY_TYPES.toString(s[a].getTopologyType()) + ":" + s[a].getGuid();}e += " ]\n";}return e;}, t.ProgenitorMap = i;}, function (e, t, r) {"use strict";r.r(t), r.d(t, "default", function () {return i;}), r.d(t, "VERSION", function () {return n.VERSION;}), r.d(t, "iteratee", function () {return n.iteratee;}), r.d(t, "restArguments", function () {return n.restArguments;}), r.d(t, "each", function () {return n.each;}), r.d(t, "forEach", function () {return n.forEach;}), r.d(t, "map", function () {return n.map;}), r.d(t, "collect", function () {return n.collect;}), r.d(t, "reduce", function () {return n.reduce;}), r.d(t, "foldl", function () {return n.foldl;}), r.d(t, "inject", function () {return n.inject;}), r.d(t, "reduceRight", function () {return n.reduceRight;}), r.d(t, "foldr", function () {return n.foldr;}), r.d(t, "find", function () {return n.find;}), r.d(t, "detect", function () {return n.detect;}), r.d(t, "filter", function () {return n.filter;}), r.d(t, "select", function () {return n.select;}), r.d(t, "reject", function () {return n.reject;}), r.d(t, "every", function () {return n.every;}), r.d(t, "all", function () {return n.all;}), r.d(t, "some", function () {return n.some;}), r.d(t, "any", function () {return n.any;}), r.d(t, "contains", function () {return n.contains;}), r.d(t, "includes", function () {return n.includes;}), r.d(t, "include", function () {return n.include;}), r.d(t, "invoke", function () {return n.invoke;}), r.d(t, "pluck", function () {return n.pluck;}), r.d(t, "where", function () {return n.where;}), r.d(t, "findWhere", function () {return n.findWhere;}), r.d(t, "max", function () {return n.max;}), r.d(t, "min", function () {return n.min;}), r.d(t, "shuffle", function () {return n.shuffle;}), r.d(t, "sample", function () {return n.sample;}), r.d(t, "sortBy", function () {return n.sortBy;}), r.d(t, "groupBy", function () {return n.groupBy;}), r.d(t, "indexBy", function () {return n.indexBy;}), r.d(t, "countBy", function () {return n.countBy;}), r.d(t, "toArray", function () {return n.toArray;}), r.d(t, "size", function () {return n.size;}), r.d(t, "partition", function () {return n.partition;}), r.d(t, "first", function () {return n.first;}), r.d(t, "head", function () {return n.head;}), r.d(t, "take", function () {return n.take;}), r.d(t, "initial", function () {return n.initial;}), r.d(t, "last", function () {return n.last;}), r.d(t, "rest", function () {return n.rest;}), r.d(t, "tail", function () {return n.tail;}), r.d(t, "drop", function () {return n.drop;}), r.d(t, "compact", function () {return n.compact;}), r.d(t, "flatten", function () {return n.flatten;}), r.d(t, "without", function () {return n.without;}), r.d(t, "uniq", function () {return n.uniq;}), r.d(t, "unique", function () {return n.unique;}), r.d(t, "union", function () {return n.union;}), r.d(t, "intersection", function () {return n.intersection;}), r.d(t, "difference", function () {return n.difference;}), r.d(t, "unzip", function () {return n.unzip;}), r.d(t, "zip", function () {return n.zip;}), r.d(t, "object", function () {return n.object;}), r.d(t, "findIndex", function () {return n.findIndex;}), r.d(t, "findLastIndex", function () {return n.findLastIndex;}), r.d(t, "sortedIndex", function () {return n.sortedIndex;}), r.d(t, "indexOf", function () {return n.indexOf;}), r.d(t, "lastIndexOf", function () {return n.lastIndexOf;}), r.d(t, "range", function () {return n.range;}), r.d(t, "chunk", function () {return n.chunk;}), r.d(t, "bind", function () {return n.bind;}), r.d(t, "partial", function () {return n.partial;}), r.d(t, "bindAll", function () {return n.bindAll;}), r.d(t, "memoize", function () {return n.memoize;}), r.d(t, "delay", function () {return n.delay;}), r.d(t, "defer", function () {return n.defer;}), r.d(t, "throttle", function () {return n.throttle;}), r.d(t, "debounce", function () {return n.debounce;}), r.d(t, "wrap", function () {return n.wrap;}), r.d(t, "negate", function () {return n.negate;}), r.d(t, "compose", function () {return n.compose;}), r.d(t, "after", function () {return n.after;}), r.d(t, "before", function () {return n.before;}), r.d(t, "once", function () {return n.once;}), r.d(t, "keys", function () {return n.keys;}), r.d(t, "allKeys", function () {return n.allKeys;}), r.d(t, "values", function () {return n.values;}), r.d(t, "mapObject", function () {return n.mapObject;}), r.d(t, "pairs", function () {return n.pairs;}), r.d(t, "invert", function () {return n.invert;}), r.d(t, "functions", function () {return n.functions;}), r.d(t, "methods", function () {return n.methods;}), r.d(t, "extend", function () {return n.extend;}), r.d(t, "extendOwn", function () {return n.extendOwn;}), r.d(t, "assign", function () {return n.assign;}), r.d(t, "findKey", function () {return n.findKey;}), r.d(t, "pick", function () {return n.pick;}), r.d(t, "omit", function () {return n.omit;}), r.d(t, "defaults", function () {return n.defaults;}), r.d(t, "create", function () {return n.create;}), r.d(t, "clone", function () {return n.clone;}), r.d(t, "tap", function () {return n.tap;}), r.d(t, "isMatch", function () {return n.isMatch;}), r.d(t, "isEqual", function () {return n.isEqual;}), r.d(t, "isEmpty", function () {return n.isEmpty;}), r.d(t, "isElement", function () {return n.isElement;}), r.d(t, "isArray", function () {return n.isArray;}), r.d(t, "isObject", function () {return n.isObject;}), r.d(t, "isArguments", function () {return n.isArguments;}), r.d(t, "isFunction", function () {return n.isFunction;}), r.d(t, "isString", function () {return n.isString;}), r.d(t, "isNumber", function () {return n.isNumber;}), r.d(t, "isDate", function () {return n.isDate;}), r.d(t, "isRegExp", function () {return n.isRegExp;}), r.d(t, "isError", function () {return n.isError;}), r.d(t, "isSymbol", function () {return n.isSymbol;}), r.d(t, "isMap", function () {return n.isMap;}), r.d(t, "isWeakMap", function () {return n.isWeakMap;}), r.d(t, "isSet", function () {return n.isSet;}), r.d(t, "isWeakSet", function () {return n.isWeakSet;}), r.d(t, "isFinite", function () {return n.isFinite;}), r.d(t, "isNaN", function () {return n.isNaN;}), r.d(t, "isBoolean", function () {return n.isBoolean;}), r.d(t, "isNull", function () {return n.isNull;}), r.d(t, "isUndefined", function () {return n.isUndefined;}), r.d(t, "has", function () {return n.has;}), r.d(t, "identity", function () {return n.identity;}), r.d(t, "constant", function () {return n.constant;}), r.d(t, "noop", function () {return n.noop;}), r.d(t, "property", function () {return n.property;}), r.d(t, "propertyOf", function () {return n.propertyOf;}), r.d(t, "matcher", function () {return n.matcher;}), r.d(t, "matches", function () {return n.matches;}), r.d(t, "times", function () {return n.times;}), r.d(t, "random", function () {return n.random;}), r.d(t, "now", function () {return n.now;}), r.d(t, "escape", function () {return n.escape;}), r.d(t, "unescape", function () {return n.unescape;}), r.d(t, "result", function () {return n.result;}), r.d(t, "uniqueId", function () {return n.uniqueId;}), r.d(t, "templateSettings", function () {return n.templateSettings;}), r.d(t, "template", function () {return n.template;}), r.d(t, "chain", function () {return n.chain;}), r.d(t, "mixin", function () {return n.mixin;});var n = r(29),o = Object(n.mixin)(n);o._ = o;var i = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseGeometry = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this);};(i.prototype = Object.create(n.Base.prototype)).getGeometryType = function () {console.warn("BaseGeometry.getGeometryType : abstract method invoked!");}, i.prototype.clone = function () {console.warn("BaseGeometry.clone : abstract method invoked");}, i.prototype.copy = function (e) {this._guid = "";}, i.prototype.addToModelObject = function (e) {if (!e.geometries[this.getGuid()]) {var _t4 = {};_t4[o.GEOMETRY_TYPES.toString(this.getGeometryType()).toLowerCase()] = this.toObject(), e.geometries[this.getGuid()] = _t4;}}, t.BaseGeometry = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Base = void 0;var n = r(56);var o = r(45).Autodesk.lookup("SolidDef.paramrange_1_0_0.typeEnum");var i = function i() {this._guid = "";};i.prototype.setGuid = function (e) {this._guid = e;}, i.prototype.getGuid = function () {return this._guid || (this._guid = (0, n.generateGUID)()), this._guid;}, i.prototype.refsToStrings = function (e) {if (e) {var _t5 = new Array(e.length);for (var _r3 = 0; _r3 < e.length; ++_r3) {_t5[_r3] = e[_r3].getGuid();}return _t5;}return [];}, i.prototype.refToString = function (e) {return e ? e.getGuid() : "";}, i.prototype.toObject = function () {return console.warn("Base.toObject : abstract method invoked!"), {};}, i.prototype.vectorToObject = function (e) {return { x: e[0], y: e[1], z: e[2] };}, i.prototype.rangeToObject = function (e, t) {var r = 1,n = 0;t && void 0 !== e && 2 === e.length && isFinite(e[0]) && isFinite(e[1]) && (r = e[0], n = e[1]);var i = r <= n ? "finite" : "infinite";return { low: r, high: n, type: o.values[i] };}, i.prototype.addToModelObject = function (e) {console.warn("Base.addToModelObject : abstract method invoked!");}, t.Base = i;}, function (e, t, r) {"use strict";var n = r(87),o = (n.roots.default || (n.roots.default = new n.Root())).addJSON({ Autodesk: { nested: { SolidDef: { nested: { SolidDef_grpc: { methods: {} }, point3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, vector3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, geometry_1_0_0: { fields: {} }, geometry_1_0_0_Type: { oneofs: { geometry: { oneof: ["point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line"] } }, fields: { point: { type: "point_1_0_0", id: 1 }, bsurface: { type: "bsurface_1_0_0", id: 2 }, cone: { type: "cone_1_0_0", id: 3 }, cylinder: { type: "cylinder_1_0_0", id: 4 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 5 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 6 }, plane: { type: "plane_1_0_0", id: 7 }, sphere: { type: "sphere_1_0_0", id: 8 }, surface: { type: "surface_1_0_0", id: 9 }, torus: { type: "torus_1_0_0", id: 10 }, bcurve: { type: "bcurve_1_0_0", id: 11 }, circle: { type: "circle_1_0_0", id: 12 }, curve: { type: "curve_1_0_0", id: 13 }, ellipse: { type: "ellipse_1_0_0", id: 14 }, line: { type: "line_1_0_0", id: 15 } } }, paramrange_1_0_0: { fields: { low: { type: "double", id: 1 }, high: { type: "double", id: 2 }, type: { type: "typeEnum", id: 3 } }, nested: { typeEnum: { values: { infinite: 0, finite: 1, boundBelow: 2, boundAbove: 3 } } } }, point_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 } } }, bsurface_1_0_0: { fields: { uDegree: { type: "uint32", id: 1 }, vDegree: { type: "uint32", id: 2 }, uKnots: { rule: "repeated", type: "double", id: 3 }, vKnots: { rule: "repeated", type: "double", id: 4 }, controlPoints: { rule: "repeated", type: "double", id: 5 }, weights: { rule: "repeated", type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, cone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, angle: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, cylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, uCoordScale: { type: "double", id: 4 }, uRange: { type: "paramrange_1_0_0", id: 5 }, vRange: { type: "paramrange_1_0_0", id: 6 } } }, ellipticalcone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, angle: { type: "double", id: 5 }, uCoordScale: { type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, ellipticalcylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, plane_1_0_0: { fields: { origin: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, uAxis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, sphere_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, radius: { type: "vector3d_1_0_0", id: 2 }, axis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, surface_1_0_0: { fields: { uRange: { type: "paramrange_1_0_0", id: 1 }, vRange: { type: "paramrange_1_0_0", id: 2 } } }, surface_1_0_0_Type: { oneofs: { surface: { oneof: ["bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "torus"] } }, fields: { bsurface: { type: "bsurface_1_0_0", id: 1 }, cone: { type: "cone_1_0_0", id: 2 }, cylinder: { type: "cylinder_1_0_0", id: 3 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 4 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 5 }, plane: { type: "plane_1_0_0", id: 6 }, sphere: { type: "sphere_1_0_0", id: 7 }, torus: { type: "torus_1_0_0", id: 8 } } }, torus_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "double", id: 3 }, minorRadius: { type: "double", id: 4 }, coordAxis: { type: "vector3d_1_0_0", id: 5 }, lemon: { type: "bool", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, bcurve_1_0_0: { fields: { degree: { type: "uint32", id: 1 }, knots: { rule: "repeated", type: "double", id: 2 }, controlPoints: { rule: "repeated", type: "double", id: 3 }, weights: { rule: "repeated", type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, circle_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 } } }, curve_1_0_0: { fields: { range: { type: "paramrange_1_0_0", id: 1 } } }, curve_1_0_0_Type: { oneofs: { curve: { oneof: ["bcurve", "circle", "ellipse", "line"] } }, fields: { bcurve: { type: "bcurve_1_0_0", id: 1 }, circle: { type: "circle_1_0_0", id: 2 }, ellipse: { type: "ellipse_1_0_0", id: 3 }, line: { type: "line_1_0_0", id: 4 } } }, ellipse_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, line_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 }, direction: { type: "vector3d_1_0_0", id: 2 }, range: { type: "paramrange_1_0_0", id: 3 } } }, attribute_1_0_0: { fields: {} }, attribute_1_0_0_Type: { oneofs: { attribute: { oneof: ["nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { nmiattribute: { type: "nmiattribute_1_0_0", id: 1 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 4 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 2 }, textattribute: { type: "textattribute_1_0_0", id: 3 } } }, body_1_0_0: { fields: { lumps: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, coedge_1_0_0: { fields: { edge: { type: "string", id: 1 }, partner: { type: "string", id: 2 }, reversed: { type: "bool", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, edge_1_0_0: { fields: { vertex0: { type: "string", id: 1 }, vertex1: { type: "string", id: 2 }, precision: { type: "double", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 }, reversed: { type: "bool", id: 5 }, geometry: { type: "string", id: 6 }, attributes: { rule: "repeated", type: "string", id: 7 } } }, face_1_0_0: { fields: { loops: { rule: "repeated", type: "string", id: 1 }, reversed: { type: "bool", id: 2 }, geometry: { type: "string", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, loop_1_0_0: { fields: { coedges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, lump_1_0_0: { fields: { shells: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, model_1_0_0: { fields: { geometries: { keyType: "string", type: "geometry_1_0_0_Type", id: 1 }, topologies: { keyType: "string", type: "topology_1_0_0_Type", id: 2 }, attributes: { keyType: "string", type: "attribute_1_0_0_Type", id: 3 } } }, shell_1_0_0: { fields: { faces: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, topology_1_0_0: { fields: { attributes: { rule: "repeated", type: "string", id: 1 } } }, topology_1_0_0_Type: { oneofs: { topology: { oneof: ["body", "coedge", "edge", "face", "loop", "lump", "shell", "vertex", "wire", "wirebody"] } }, fields: { body: { type: "body_1_0_0", id: 1 }, coedge: { type: "coedge_1_0_0", id: 2 }, edge: { type: "edge_1_0_0", id: 3 }, face: { type: "face_1_0_0", id: 4 }, loop: { type: "loop_1_0_0", id: 5 }, lump: { type: "lump_1_0_0", id: 6 }, shell: { type: "shell_1_0_0", id: 7 }, vertex: { type: "vertex_1_0_0", id: 8 }, wire: { type: "wire_1_0_0", id: 9 }, wirebody: { type: "wirebody_1_0_0", id: 10 } } }, vertex_1_0_0: { fields: { precision: { type: "double", id: 1 }, geometry: { type: "string", id: 2 }, attributes: { rule: "repeated", type: "string", id: 3 } } }, wire_1_0_0: { fields: { edges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, wirebody_1_0_0: { fields: { wires: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, nmiattribute_1_0_0: { fields: { primaryId: { type: "uint64", id: 1 }, secondaryId: { type: "int64", id: 2 }, approachId: { type: "int64", id: 3 }, operationIds: { rule: "repeated", type: "int64", id: 4 } } }, nmiattributearr_1_0_0: { fields: { tagInfo: { rule: "repeated", type: "nmiattributestr_1_0_0", id: 1 } } }, nmiattributestr_1_0_0: { fields: { primaryId: { type: "string", id: 1 }, secondaryId: { type: "string", id: 2 }, approachId: { type: "string", id: 3 }, operationIds: { rule: "repeated", type: "string", id: 4 } } }, textattribute_1_0_0: { fields: { text: { type: "string", id: 1 } } }, entity: { oneofs: { entity: { oneof: ["point3d", "vector3d", "geometry", "paramrange", "point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line", "attribute", "body", "coedge", "edge", "face", "loop", "lump", "model", "shell", "topology", "vertex", "wire", "wirebody", "nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { id: { type: "string", id: 1 }, point3d: { type: "point3d_1_0_0", id: 2 }, vector3d: { type: "vector3d_1_0_0", id: 3 }, geometry: { type: "geometry_1_0_0", id: 4 }, paramrange: { type: "paramrange_1_0_0", id: 5 }, point: { type: "point_1_0_0", id: 6 }, bsurface: { type: "bsurface_1_0_0", id: 7 }, cone: { type: "cone_1_0_0", id: 8 }, cylinder: { type: "cylinder_1_0_0", id: 9 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 10 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 11 }, plane: { type: "plane_1_0_0", id: 12 }, sphere: { type: "sphere_1_0_0", id: 13 }, surface: { type: "surface_1_0_0", id: 14 }, torus: { type: "torus_1_0_0", id: 15 }, bcurve: { type: "bcurve_1_0_0", id: 16 }, circle: { type: "circle_1_0_0", id: 17 }, curve: { type: "curve_1_0_0", id: 18 }, ellipse: { type: "ellipse_1_0_0", id: 19 }, line: { type: "line_1_0_0", id: 20 }, attribute: { type: "attribute_1_0_0", id: 21 }, body: { type: "body_1_0_0", id: 22 }, coedge: { type: "coedge_1_0_0", id: 23 }, edge: { type: "edge_1_0_0", id: 24 }, face: { type: "face_1_0_0", id: 25 }, loop: { type: "loop_1_0_0", id: 26 }, lump: { type: "lump_1_0_0", id: 27 }, model: { type: "model_1_0_0", id: 28 }, shell: { type: "shell_1_0_0", id: 29 }, topology: { type: "topology_1_0_0", id: 30 }, vertex: { type: "vertex_1_0_0", id: 31 }, wire: { type: "wire_1_0_0", id: 32 }, wirebody: { type: "wirebody_1_0_0", id: 33 }, nmiattribute: { type: "nmiattribute_1_0_0", id: 34 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 37 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 35 }, textattribute: { type: "textattribute_1_0_0", id: 36 } } } } } } } });e.exports = o;}, function (e, t, r) {"use strict";e.exports = l;var n,o = r(10),i = o.LongBits,s = o.base64,a = o.utf8;function c(e, t, r) {this.fn = e, this.len = t, this.next = void 0, this.val = r;}function u() {}function l() {this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null;}function h(e, t, r) {t[r] = 255 & e;}function d(e, t) {this.len = e, this.next = void 0, this.val = t;}function g(e, t, r) {for (; e.hi;) {t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;}for (; e.lo > 127;) {t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;}t[r++] = e.lo;}function p(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}l.create = o.Buffer ? function () {return (l.create = function () {return new n();})();} : function () {return new l();}, l.alloc = function (e) {return new o.Array(e);}, o.Array !== Array && (l.alloc = o.pool(l.alloc, o.Array.prototype.subarray)), l.prototype._push = function (e, t, r) {return this.tail = this.tail.next = new c(e, t, r), this.len += t, this;}, d.prototype = Object.create(c.prototype), d.prototype.fn = function (e, t, r) {for (; e > 127;) {t[r++] = 127 & e | 128, e >>>= 7;}t[r] = e;}, l.prototype.uint32 = function (e) {return this.len += (this.tail = this.tail.next = new d((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;}, l.prototype.int32 = function (e) {return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);}, l.prototype.sint32 = function (e) {return this.uint32((e << 1 ^ e >> 31) >>> 0);}, l.prototype.uint64 = function (e) {var t = i.from(e);return this._push(g, t.length(), t);}, l.prototype.int64 = l.prototype.uint64, l.prototype.sint64 = function (e) {var t = i.from(e).zzEncode();return this._push(g, t.length(), t);}, l.prototype.bool = function (e) {return this._push(h, 1, e ? 1 : 0);}, l.prototype.fixed32 = function (e) {return this._push(p, 4, e >>> 0);}, l.prototype.sfixed32 = l.prototype.fixed32, l.prototype.fixed64 = function (e) {var t = i.from(e);return this._push(p, 4, t.lo)._push(p, 4, t.hi);}, l.prototype.sfixed64 = l.prototype.fixed64, l.prototype.float = function (e) {return this._push(o.float.writeFloatLE, 4, e);}, l.prototype.double = function (e) {return this._push(o.float.writeDoubleLE, 8, e);};var f = o.Array.prototype.set ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {for (var n = 0; n < e.length; ++n) {t[r + n] = e[n];}};l.prototype.bytes = function (e) {var t = e.length >>> 0;if (!t) return this._push(h, 1, 0);if (o.isString(e)) {var r = l.alloc(t = s.length(e));s.decode(e, r, 0), e = r;}return this.uint32(t)._push(f, t, e);}, l.prototype.string = function (e) {var t = a.length(e);return t ? this.uint32(t)._push(a.write, t, e) : this._push(h, 1, 0);}, l.prototype.fork = function () {return this.states = new function (e) {this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;}(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this;}, l.prototype.reset = function () {return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this;}, l.prototype.ldelim = function () {var e = this.head,t = this.tail,r = this.len;return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;}, l.prototype.finish = function () {for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) {e.fn(e.val, t, r), r += e.len, e = e.next;}return t;}, l._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = c;var n,o = r(10),i = o.LongBits,s = o.utf8;function a(e, t) {return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len);}function c(e) {this.buf = e, this.pos = 0, this.len = e.length;}var u = "undefined" != typeof Uint8Array ? function (e) {if (e instanceof Uint8Array || Array.isArray(e)) return new c(e);throw Error("illegal buffer");} : function (e) {if (Array.isArray(e)) return new c(e);throw Error("illegal buffer");};function l() {var e = new i(0, 0),t = 0;if (!(this.len - this.pos > 4)) {for (; t < 3; ++t) {if (this.pos >= this.len) throw a(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;}for (; t < 4; ++t) {if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {for (; t < 5; ++t) {if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}} else for (; t < 5; ++t) {if (this.pos >= this.len) throw a(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}throw Error("invalid varint encoding");}function h(e, t) {return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;}function d() {if (this.pos + 8 > this.len) throw a(this, 8);return new i(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4));}c.create = o.Buffer ? function (e) {return (c.create = function (e) {return o.Buffer.isBuffer(e) ? new n(e) : u(e);})(e);} : u, c.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, c.prototype.uint32 = function () {var e = 4294967295;return function () {if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);return e;};}(), c.prototype.int32 = function () {return 0 | this.uint32();}, c.prototype.sint32 = function () {var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;}, c.prototype.bool = function () {return 0 !== this.uint32();}, c.prototype.fixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return h(this.buf, this.pos += 4);}, c.prototype.sfixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return 0 | h(this.buf, this.pos += 4);}, c.prototype.float = function () {if (this.pos + 4 > this.len) throw a(this, 4);var e = o.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;}, c.prototype.double = function () {if (this.pos + 8 > this.len) throw a(this, 4);var e = o.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;}, c.prototype.bytes = function () {var e = this.uint32(),t = this.pos,r = this.pos + e;if (r > this.len) throw a(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);}, c.prototype.string = function () {var e = this.bytes();return s.read(e, 0, e.length);}, c.prototype.skip = function (e) {if ("number" == typeof e) {if (this.pos + e > this.len) throw a(this, e);this.pos += e;} else do {if (this.pos >= this.len) throw a(this);} while (128 & this.buf[this.pos++]);return this;}, c.prototype.skipType = function (e) {switch (e) {case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for (; 4 != (e = 7 & this.uint32());) {this.skipType(e);}break;case 5:this.skip(4);break;default:throw Error("invalid wire type " + e + " at offset " + this.pos);}return this;}, c._configure = function (e) {n = e;var t = o.Long ? "toLong" : "toNumber";o.merge(c.prototype, { int64: function int64() {return l.call(this)[t](!1);}, uint64: function uint64() {return l.call(this)[t](!0);}, sint64: function sint64() {return l.call(this).zzDecode()[t](!1);}, fixed64: function fixed64() {return d.call(this)[t](!0);}, sfixed64: function sfixed64() {return d.call(this)[t](!1);} });};}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "OneOf";var o = r(22),i = r(5);function s(e, t, r, o) {if (Array.isArray(t) || (r = t, t = void 0), n.call(this, e, r), void 0 !== t && !Array.isArray(t)) throw TypeError("fieldNames must be an Array");this.oneof = t || [], this.fieldsArray = [], this.comment = o;}function a(e) {if (e.parent) for (var t = 0; t < e.fieldsArray.length; ++t) {e.fieldsArray[t].parent || e.parent.add(e.fieldsArray[t]);}}s.fromJSON = function (e, t) {return new s(e, t.oneof, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "oneof", this.oneof, "comment", t ? this.comment : void 0]);}, s.prototype.add = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = this, a(this), this;}, s.prototype.remove = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");var t = this.fieldsArray.indexOf(e);if (t < 0) throw Error(e + " is not a member of " + this);return this.fieldsArray.splice(t, 1), (t = this.oneof.indexOf(e.name)) > -1 && this.oneof.splice(t, 1), e.partOf = null, this;}, s.prototype.onAdd = function (e) {n.prototype.onAdd.call(this, e);for (var t = 0; t < this.oneof.length; ++t) {var r = e.get(this.oneof[t]);r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));}a(this);}, s.prototype.onRemove = function (e) {for (var t, r = 0; r < this.fieldsArray.length; ++r) {(t = this.fieldsArray[r]).parent && t.parent.remove(t);}n.prototype.onRemove.call(this, e);}, s.d = function () {for (var e = new Array(arguments.length), t = 0; t < arguments.length;) {e[t] = arguments[t++];}return function (t, r) {i.decorateType(t.constructor).add(new s(r, e)), Object.defineProperty(t, r, { get: i.oneOfGetter(e), set: i.oneOfSetter(e) });};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e) {if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) {this[t[r]] = e[t[r]];}}o.create = function (e) {return this.$type.create(e);}, o.encode = function (e, t) {return this.$type.encode(e, t);}, o.encodeDelimited = function (e, t) {return this.$type.encodeDelimited(e, t);}, o.decode = function (e) {return this.$type.decode(e);}, o.decodeDelimited = function (e) {return this.$type.decodeDelimited(e);}, o.verify = function (e) {return this.$type.verify(e);}, o.fromObject = function (e) {return this.$type.fromObject(e);}, o.toObject = function (e, t) {return this.$type.toObject(e, t);}, o.prototype.toJSON = function () {return this.$type.toObject(this, n.toJSONOptions);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TessellationCache = t.CurveTessellator = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = { getCircularArcRenderPoints: function getCircularArcRenderPoints(e, t, r, n, o) {var i = e.getRadius(),s = 2 * Math.acos((i - r) / i),a = t[1] - t[0],c = Math.ceil(a / s),u = 0;for (!1 === n && u++; u <= c; ++u) {var l = u / c,h = t[0] * (1 - l) + t[1] * l;o.push(e.evaluatePosition(h));}return i * (1 - Math.cos(a / c * .5));}, getAdaptiveRenderPoints: function getAdaptiveRenderPoints(e, t, r, i) {for (var a = t || .001, c = a * a, u = [], l = [], h = n.Vector3.createFloat64(), d = 0, g = function g(t, r, i, a, p) {var f = i - t,v = .5 * (t + i),_ = e.evaluatePosition(v);n.Vector3.scaleAndAdd(h, [0, 0, 0], r, .5), n.Vector3.scaleAndAdd(h, h, a, .5);var y = n.Vector3.squaredDistance(h, _);if (p > 64) s.DebugUtils.warn("Max recursion depth reach in getAdaptiveRenderPoints");else if (f > 10 * o.PARAMETER_SPACE_TOLERANCE && y > c) return g(t, r, v, _, p + 1), void g(v, _, i, a, p + 1);d = Math.max(d, y), u.push(r), l.push(t);}, p = i || function (e, t, r) {for (var n = new Array(7), o = t, i = (r - t) / 6, s = 0; s < 7; s++) {var a = o;s > 0 && s < 6 && (a += Math.sin(s) * i * .1), n[s] = a, o += i;}return n;}(0, r[0], r[1]), f = 0; f < p.length - 1; ++f) {var v = p[f],_ = p[f + 1],y = e.evaluatePosition(v),m = e.evaluatePosition(_);g(v, y, _, m, 0), f === p.length - 2 && (u.push(m), l.push(_));}return { positions: u, params: l, tolerance: Math.sqrt(d) };} },c = function c() {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };};c.prototype.setDirty = function (e) {this._hasDirtyTessellation = e;}, c.prototype.isDirty = function () {return this._hasDirtyTessellation;}, c.prototype.reset = function () {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };}, c.prototype.setCache = function (e) {this._tessellationCache = e, this._hasDirtyTessellation = !1;}, c.prototype.getCache = function () {return this._tessellationCache;}, c.prototype.getTolerance = function () {if (this._tessellationCache) return this._tessellationCache.tolerance;}, c.prototype.getTessellation = function (e, t, r, s) {var a = !1;if (!1 === this._hasDirtyTessellation && this._tessellationCache.tolerance > r + n.FLOAT64_TOLERANCE && (this._hasDirtyTessellation = !0), this._hasDirtyTessellation) {this._hasDirtyTessellation = !1;var c = s(r);this._tessellationCache = { positions: c.positions, params: c.params, tolerance: c.tolerance }, a = c.didRetessellate;}var u = [e[0], e[e.length - 1]],l = 0,h = t.getRangeUnlimited();t.isPeriodicUnlimited() && (l = (u = (0, i.normalizeParametricRangeToShiftedRange)(u, h))[0] - e[0]);var d = this._trimmedTessellationCache,g = d.transitions[0] - u[0],p = d.transitions[d.transitions.length - 1] - u[1],f = g * g + p * p < n.FLOAT64_TOLERANCE;if (f && e.length > 2) {f = d.transitions.length === e.length;for (var v = 1; f && v < e.length - 1; ++v) {f = d.transitions[v - 1] === e[v - 1] + l;}}if (!f || a) {var _;for (d.transitions.length = e.length, _ = 0; _ < e.length; ++_) {d.transitions[_] = e[_] + l;}d.positions = [t.evaluatePosition(e[0])], d.offsets = [0];var y,m,E = 1,x = u[0];for (_ = 1; _ < e.length; _++) {var R = e[_] + l;for (m = 0; m < this._tessellationCache.positions.length; m++) {if ((y = this._tessellationCache.params[m]) > x + o.PARAMETER_SPACE_TOLERANCE) {if (y >= R - o.PARAMETER_SPACE_TOLERANCE) break;n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}}if (t.isPeriodicUnlimited() && R > h[1]) for (m = 1; m < this._tessellationCache.positions.length && (y = this._tessellationCache.params[m]) < R - (h[1] - h[0]) - o.PARAMETER_SPACE_TOLERANCE; m++) {n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}var A = t.evaluatePosition(R);n.Vector3.sqrDist(d.positions[E - 1], A) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && E > d.offsets[d.offsets.length - 1] + 1 && E--, d.positions[E++] = A, d.offsets.push(d.positions.length - 1), x = R;}}return { positions: d.positions, offsets: d.offsets, tolerance: this._tessellationCache.tolerance };}, t.CurveTessellator = a, t.TessellationCache = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cone = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(6),c = r(7),u = r(14),l = r(2),h = function h() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(h.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CONE;}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, h.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), l.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), l.ConsoleUtils.assert(Math.abs(o) < Math.PI / 2), this._angle = o, void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (l.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = a || 1, l.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {l.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.getAxisDir = function () {return this._zAxis;}, h.prototype.setAxisDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, h.prototype.getUvOriginDir = function () {return this._xAxis;}, h.prototype.setUvOriginDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.getUScale = function () {return this._uScale;}, h.prototype.setUScale = function (e) {l.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, h.prototype.getAngle = function () {return this._angle;}, h.prototype.setAngle = function (e) {l.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - i.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, h.prototype.isCylinder = function () {return Math.abs(this._angle) < i.KERNEL_ANGULAR_TOLERANCE;}, h.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._radius / (this._uScale * Math.sin(this._angle));}, h.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._radius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, h.prototype.evaluatePosition = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateNormal = function (e, t) {var r = Math.sin(this._angle),o = Math.cos(this._angle),i = o * Math.cos(t),s = o * Math.sin(t),a = -r,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, i), n.Vector3.scaleAndAdd(c, c, this._yAxis, s), n.Vector3.scaleAndAdd(c, c, this._zAxis, a), c;}, h.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateDv = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, h.prototype.closestParam = function (e) {var t = Math.sin(this._angle),r = Math.cos(this._angle),o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var s = n.Vector3.dot(o, this._xAxis),a = n.Vector3.dot(o, this._yAxis),c = n.Vector3.dot(o, this._zAxis),u = Math.sqrt(s * s + a * a),l = this.getApexParam();if (void 0 !== l) {var h = l * this._uScale * r;(h > 0 && c > h || h < 0 && c < h) && (s = -s, a = -a, u = -u);}return { u: ((u - this._radius) * t + c * r) / this._uScale, v: Math.abs(u) > i.KERNEL_TOLERANCE ? Math.atan2(a, s) : 0 };}, h.prototype.vParamLine = function (e) {var t = this._radius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var r = new u.Circle(),o = n.Vector3.clone(this._center),s = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, s);var c = n.Vector3.clone(this._xAxis);n.Vector3.scale(c, c, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), r.set(o, l, c), r;}return new a.Point(this.getApexPosition());}, h.prototype.uParamLine = function (e) {var t = new c.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, h.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, h.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, h.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimitedU = function () {return !1;}, h.prototype.isPeriodicUnlimitedV = function () {return !0;}, h.prototype.isClosedUnlimitedU = function () {return !1;}, h.prototype.isClosedUnlimitedV = function () {return !0;}, h.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cone = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCone = void 0;var n = r(1),o = r(4),i = r(35),s = r(0),a = r(12),c = r(6),u = r(7),l = r(23),h = r(2),d = function d() {a.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(d.prototype = Object.create(a.Surface.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPTICAL_CONE;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, d.prototype.set = function (e, t, r, o, i, a) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), h.ConsoleUtils.assert(this._majorRadius > s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), h.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, h.ConsoleUtils.assert(this._minorRadius > s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.squaredLength(o) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), h.ConsoleUtils.assert(Math.abs(i) < Math.PI / 2), this._angle = i, this._uScale = a || 1, h.ConsoleUtils.assert(this._uScale > s.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.setMajorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMinorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e;}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.setMajorAxis = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, d.prototype.getCenter = function () {return this._center;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, d.prototype.getAxisDir = function () {return this._zAxis;}, d.prototype.setAxisDir = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, d.prototype.getUScale = function () {return this._uScale;}, d.prototype.setUScale = function (e) {h.ConsoleUtils.assert(e > s.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, d.prototype.getAngle = function () {return this._angle;}, d.prototype.setAngle = function (e) {h.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - s.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, d.prototype.isCylinder = function () {return Math.abs(this._angle) < s.KERNEL_ANGULAR_TOLERANCE;}, d.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._majorRadius / (this._uScale * Math.sin(this._angle));}, d.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._majorRadius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, d.prototype.evaluatePosition = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateNormal = function (e, t) {var r = Math.cos(this._angle),o = r * this._minorRadius * Math.cos(t),i = r * this._majorRadius * Math.sin(t),s = -Math.sin(this._angle) * this._minorRadius,a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), n.Vector3.normalize(a, a), a;}, d.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateDv = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = -r * this._majorRadius * Math.sin(t),i = r * this._minorRadius * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, d.prototype.closestParam = function (e) {var t, r;if (this.isCylinder()) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center), t = n.Vector3.dot(o, this._zAxis) / this._uScale, r = this.vParamLine(t).closestToPointParam(e);} else {var a = n.Vector3.createFloat64();n.Vector3.sub(a, e, this.getApexPosition());var c = n.Vector3.dot(a, this._xAxis),u = n.Vector3.dot(a, this._yAxis),l = n.Vector3.dot(a, this._zAxis),h = this._uScale * Math.sin(this._angle),d = h * this._minorRadius / this._majorRadius,g = this._uScale * Math.cos(this._angle),p = this._majorRadius / h,f = function (e, t, r, o, a, c) {if (o * o + a * a + c * c < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) return { u: 0, v: 0 };var u = n.FLOAT64_TOLERANCE,l = c * e >= 0 ? 1 : -1,h = (o * l >= 0 ? .25 : .75) * (a * l >= 0 ? 1 : -1),d = h * Math.PI,g = [(h - .25) * Math.PI, (h + .25) * Math.PI],p = (0, i.newtonRaphson1D)(function (n) {var i = Math.sin(n),s = Math.cos(n),u = e * (t * t + r * r) * o,l = t * (e * e + r * r) * a,h = r * (e * e - t * t) * c;return { val: u * i - l * s - h * i * s, deriv: u * s + l * i - h * (s * s - i * i) };}, g, d, u, 32),f = e * Math.cos(p),v = t * Math.sin(p);return { u: (f * o + v * a + r * c) / (f * f + v * v + r * r), v: p };}(h, d, g, c, u, l);t = f.u - p, r = f.v;}return { u: t, v: r };}, d.prototype.vParamLine = function (e) {var t = this._majorRadius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > s.KERNEL_TOLERANCE) {var r = new l.Ellipse(),o = n.Vector3.clone(this._center),i = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, i);var a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, t);var u = n.Vector3.clone(this._zAxis);return n.Vector3.negate(u, u), r.set(o, u, a, this._minorRadius / this._majorRadius), r;}return new c.Point(this.getApexPosition());}, d.prototype.uParamLine = function (e) {var t = new u.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, d.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, d.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, d.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimitedU = function () {return !1;}, d.prototype.isPeriodicUnlimitedV = function () {return !0;}, d.prototype.isClosedUnlimitedU = function () {return !1;}, d.prototype.isClosedUnlimitedV = function () {return !0;}, d.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCone = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BSurface = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(33),c = r(3),u = r(76),l = r(103),h = r(104),d = r(105),g = r(77),p = r(2),f = function f() {s.Surface.call(this), this._uDegree = 0, this._vDegree = 0, this._uKnots = [], this._vKnots = [], this._controlPoints = [], this._weights = [], this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;};(f.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.BSURFACE;}, f.prototype.clone = function () {var e = new f();return e.copy(this), e;}, f.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._uDegree = e._uDegree, this._vDegree = e._vDegree, this._uKnots = e._uKnots.slice(0), this._vKnots = e._vKnots.slice(0), this._controlPoints = e._controlPoints.slice(0), this._weights = e._weights.slice(0), this._clearCaches();}, f.prototype.set = function (e, t, r, n, o, i) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, p.ConsoleUtils.assert(t >= 1), this._vDegree = t, p.ConsoleUtils.assert(r.length >= 2 * (e + 1)), this._uKnots = Array.prototype.slice.call(r), p.ConsoleUtils.assert(n.length >= 2 * (t + 1)), this._vKnots = Array.prototype.slice.call(n);var s = r.length - e - 1,a = n.length - t - 1;p.ConsoleUtils.assert(o.length === 3 * s * a), this._controlPoints = Array.prototype.slice.call(o), i && i.length > 0 ? (p.ConsoleUtils.assert(i.length === s * a), this._weights = Array.prototype.slice.call(i)) : this._weights = [], this._clearCaches();}, f.prototype.getDegreeU = function () {return this._uDegree;}, f.prototype.getDegreeV = function () {return this._vDegree;}, f.prototype.setDegreeU = function (e) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, this._clearCaches();}, f.prototype.setDegreeV = function (e) {p.ConsoleUtils.assert(e >= 1), this._vDegree = e, this._clearCaches();}, f.prototype.getNumKnotsU = function () {return this._uKnots.length;}, f.prototype.getNumKnotsV = function () {return this._vKnots.length;}, f.prototype.getKnotsU = function () {return this._uKnots;}, f.prototype.getKnotsV = function () {return this._vKnots;}, f.prototype.setKnotsU = function (e) {this._uKnots = e, this._clearCaches();}, f.prototype.setKnotsV = function (e) {this._vKnots = e, this._clearCaches();}, f.prototype.getNumControlPointsU = function () {return this._uKnots.length - this._uDegree - 1;}, f.prototype.getNumControlPointsV = function () {return this._vKnots.length - this._vDegree - 1;}, f.prototype.getControlPoints = function () {return this._controlPoints;}, f.prototype.setControlPoints = function (e) {this._controlPoints = e, this._clearCaches();}, f.prototype.getWeights = function () {return this._weights;}, f.prototype.setWeights = function (e) {e && e.length > 0 ? this._weights = e : this._weights = [], this._clearCaches();}, f.prototype.isRational = function () {return this._weights.length > 0;}, f.prototype.evaluate = function (e, t, r, n, o) {p.ConsoleUtils.assert(r >= 0), this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV()));var i = (0, u.evaluateBSurfaceDerivs)(e, t, Math.min(r, 3), this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),s = { pos: i[0][0] };return r >= 1 && (s.du = i[1][0], s.dv = i[0][1]), r >= 2 && (s.duu = i[2][0], s.duv = i[1][1], s.dvv = i[0][2]), r >= 3 && (s.duuu = i[3][0], s.duuv = i[2][1], s.duvv = i[1][2], s.dvvv = i[0][3]), s;}, f.prototype.evaluatePosition = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfacePoint)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);}, f.prototype.evaluateNormal = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), s.Surface.prototype.evaluateNormal.call(this, e, t);}, f.prototype.evaluateDu = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[1][0];}, f.prototype.evaluateDv = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[0][1];}, f.prototype.insertKnotU = function (e, t) {var r = (0, l.insertBSurfaceKnotU)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._uKnots = r.uknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.insertKnotV = function (e, t) {var r = (0, l.insertBSurfaceKnotV)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._vKnots = r.vknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.relaxToPerpendicular = function (e, t, r, o, i, s, a) {var c = this;o && 0 !== o.length || (o = this.getRangeU()), i && 0 !== i.length || (i = this.getRangeV());var u = (0, g.newtonRaphson2D)(function (t) {var r = c.evaluate(t[0], t[1], 2);n.Vector3.sub(r.pos, r.pos, e);var o = n.Vector3.dot(r.du, r.pos),i = n.Vector3.dot(r.dv, r.pos),s = n.Vector3.dot(r.duu, r.pos) + n.Vector3.dot(r.du, r.du),a = n.Vector3.dot(r.duv, r.pos) + n.Vector3.dot(r.du, r.dv);return { val: [o, i], deriv1: [s, a], deriv2: [a, n.Vector3.dot(r.dvv, r.pos) + n.Vector3.dot(r.dv, r.dv)] };}, [t, r], [o, i]);return { u: u.param[0], v: u.param[1], status: u.status };}, f.prototype.closestParam = function (e) {for (var t = n.FLOAT64_TOLERANCE, r = [[this.getRangeU(), this.getRangeV()]], o = this.getBezierPatches(), i = (0, d.closestBSurfacePatches)(e, o, r), s = Number.POSITIVE_INFINITY, a = { u: void 0, v: void 0 }, u = 0; u < i.length; ++u) {if (!(i[u].minDistSqr > s)) for (var l = i[u].index, h = o[l[0]][l[1]], g = h.getRangeUnlimitedU(), p = h.getRangeUnlimitedV(), f = 0; f < r.length; ++f) {var v = [Math.max(g[0], r[f][0][0]), Math.min(g[1], r[f][0][1])],_ = [Math.max(p[0], r[f][1][0]), Math.min(p[1], r[f][1][1])];if (!(v[1] - v[0] <= n.FLOAT64_TOLERANCE || _[1] - _[0] <= n.FLOAT64_TOLERANCE)) {var y = (0, d.closestBSurfacePointApprox)(e, h.getDegreeU(), h.getDegreeV(), h.getKnotsU(), h.getKnotsV(), h.getControlPoints(), h.isRational() ? h.getWeights() : void 0, v, _),m = this.relaxToPerpendicular(e, y.u, y.v, v, _, t, 64),E = h.evaluatePosition(m.u, m.v),x = n.Vector3.squaredDistance(E, e);x < s && (s = x, a.u = m.u, a.v = m.v);}}}return this.isPeriodicUnlimitedU() && (a.u = (0, c.foldNearTo)(a.u, .5 * (this.getRangeU()[0] + this.getRangeU()[1]), this.getPeriodUnlimitedU())), this.isPeriodicUnlimitedV() && (a.v = (0, c.foldNearTo)(a.v, .5 * (this.getRangeV()[0] + this.getRangeV()[1]), this.getPeriodUnlimitedV())), a;}, f.prototype.vParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineV)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._vDegree, this._vKnots), n;}, f.prototype.uParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineU)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._uDegree, this._uKnots), n;}, f.prototype.getBoundingBox = function (e, t) {for (var r = new o.BoundingBox(), i = n.Vector3.createFloat64(), s = 0; s < this._controlPoints.length; s += 3) {n.Vector3.set(i, this._controlPoints[s], this._controlPoints[s + 1], this._controlPoints[s + 2]), r.includePoint(i);}return r;}, f.prototype.transform = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), n.Vector3.transformMatrix44(t, t, e), this._controlPoints[r] = t[0], this._controlPoints[r + 1] = t[1], this._controlPoints[r + 2] = t[2];}this._clearCaches();}, f.prototype.getRangeUnlimitedU = function () {return [this._uKnots[0], this._uKnots[this._uKnots.length - 1]];}, f.prototype.getRangeUnlimitedV = function () {return [this._vKnots[0], this._vKnots[this._vKnots.length - 1]];}, f.prototype.isPeriodicUnlimitedU = function () {return this._checkClosure(), this._isPeriodicU;}, f.prototype.isPeriodicUnlimitedV = function () {return this._checkClosure(), this._isPeriodicV;}, f.prototype.isClosedUnlimitedU = function () {return this._checkClosure(), this._isClosedU;}, f.prototype.isClosedUnlimitedV = function () {return this._checkClosure(), this._isClosedV;}, f.prototype._checkClosure = function () {void 0 !== this._isClosedU && void 0 !== this._isPeriodicU || (this._isClosedU = this._isPeriodicU = !1), void 0 !== this._isClosedV && void 0 !== this._isPeriodicV || (this._isClosedV = this._isPeriodicV = !1);}, f.prototype.isSimpleBezier = function () {return this._uKnots.length === 2 * this._uDegree + 2 && this._vKnots.length === 2 * this._vDegree + 2;}, f.prototype.getBezierPatches = function () {if (this.isSimpleBezier()) return this._patches = void 0, [[this]];if (!this._patches) {var e = (0, h.decomposeBSurfaceToBezier)(this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._patches = [];for (var t = 0; t < e.U.length; ++t) {this._patches[t] = [];for (var r = 0; r < e.V.length; ++r) {var n = new f();n.set(this._uDegree, this._vDegree, e.U[t], e.V[r], e.P[t][r], e.w ? e.w[t][r] : void 0), this._patches[t][r] = n;}}}return this._patches;}, f.prototype._clearCaches = function () {this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;}, f.prototype.toObject = function () {return { uDegree: this._uDegree, vDegree: this._vDegree, uKnots: this._uKnots, vKnots: this._vKnots, controlPoints: this._controlPoints, weights: this._weights, uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.BSurface = f;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.WireBody = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._wires = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.WIREBODY;}, a.prototype.getWires = function () {return this._wires;}, a.prototype.setWires = function (e) {this._wires = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._wires[t] = e[t];}}, a.prototype.addWire = function (e) {this._wires ? this._wires.push(e) : this._wires = [e], e.setWireBody(this);}, a.prototype.addWires = function (e) {this._wires || (this._wires = []);for (var t = 0; t < e.length; ++t) {e[t].setWireBody(this);}this._wires = this._wires.concat(e);}, a.prototype.removeWire = function (e) {var t = this._wires.indexOf(e);return t > -1 && (this._wires.splice(t, 1), e.getWireBody() === this && e.setWireBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {return e || new Set();}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._wires.length; ++t) {e.include(this._wires[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toString = function () {return "WireBody";}, a.prototype.toObject = function () {return { wires: this.refsToStrings(this._wires), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._wires, this._attributes]);}, t.WireBody = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyCloner = void 0;var n = r(16),o = r(20),i = r(27),s = r(13),a = r(15),c = r(26),u = r(25),l = r(24),h = r(41),d = function d() {this._edgeMap = {}, this._vertexMap = {}, this._coedgeMap = {}, this._progenitorMap = new h.ProgenitorMap();};d.prototype.cloneVertex = function (e) {var t = this._vertexMap[e.getGuid()];return t || (t = new n.Vertex(e.getPoint().clone()), this._vertexMap[e.getGuid()] = t, t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneEdge = function (e) {var t = this._edgeMap[e.getGuid()];return t || (t = new o.Edge(e.getCurve().clone()), this._edgeMap[e.getGuid()] = t, t.setReversed(e.isReversed()), t.setRange(e.getRange()), t.setStartVertex(this.cloneVertex(e.getStartVertex())), t.setEndVertex(this.cloneVertex(e.getEndVertex())), t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneCoedge = function (e) {var t,r,n = new i.Coedge();this._coedgeMap[e.getGuid()] = n, n.setReversed(e.isReversed()), n.setEdge(this.cloneEdge(e.getEdge())), n.getEdge().setCoedge(n);for (var o = e.getPartner(); o;) {var s = this._coedgeMap[o.getGuid()];s && (t || (t = s), r = s, e.getEdge().getCoedge() === o && n.getEdge().setCoedge(s)), (o = o.getPartner()) === e && (o = void 0);}return t && r && (n.setPartner(t), r.setPartner(n)), this._progenitorMap.addEntry(n, [e]), n;}, d.prototype.cloneLoop = function (e) {for (var t = new s.Loop(), r = e.getCoedges(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneCoedge(r[o]);}return t.addCoedges(n), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFace = function (e) {for (var t = new a.Face(), r = e.getLoops(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneLoop(r[o]);}return t.addLoops(n), t.setSurface(e.getSurface().clone()), t.setReversed(e.isReversed()), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFaces = function (e) {for (var t = new Array(e.length), r = 0; r < e.length; ++r) {t[r] = this.cloneFace(e[r]);}return t;}, d.prototype.cloneShell = function (e) {var t = new c.Shell();return t.addFaces(this.cloneFaces(e.getFaces())), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneLump = function (e) {for (var t = new u.Lump(), r = e.getShells(), n = 0; n < r.length; ++n) {t.addShell(this.cloneShell(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneBody = function (e) {for (var t = new l.Body(), r = e.getLumps(), n = 0; n < r.length; ++n) {t.addLump(this.cloneLump(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.getProgenitorMap = function () {return this._progenitorMap;}, t.TopologyCloner = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {if (t < 1) return "";for (var r = ""; t > 1;) {1 & t && (r += e), t >>= 1, e += e;}return r + e;},o = { isInitialized: !1, rngA: 4027999010, rngB: 3993266363, rngC: 3605298456, rotl32: function rotl32(e, t) {return (e << t >>> 0 | e >>> 32 - t) >>> 0;}, initialize: function initialize(e, t) {return o.isInitialized && !t ? 0 : (o.isInitialized && (o.rngA = 4027999010, o.rngB = 3993266363, o.rngC = 3605298456), o.isInitialized = !0, void 0 !== e ? r = e : (r = new Date().getTime(), r ^= Math.floor(2147483647 * Math.random() + 1)), o.rngA += 2097151 & r, o.rngB += r >> 7 & 524287, o.rngC += r >> 13, r);var r;}, genRandUInt32: function genRandUInt32() {return o.rngA = ~(2911329625 * o.rngA), o.rngA = o.rotl32(o.rngA, 17), o.rngB = 4031235431 * o.rngB, o.rngB = o.rotl32(o.rngB, 15), o.rngC = 3286325185 - o.rotl32(o.rngC, 19), o.rngA + o.rngB ^ o.rngC;} },i = function i(e) {for (var t = "", r = 0; r < 4; r++) {var o = e[r].toString(16);t += n("0", 8 - o.length) + o;}return t.substr(0, 8) + "-" + t.substr(8, 4) + "-" + t.substr(12, 4) + "-" + t.substr(16, 4) + "-" + t.substr(20, 12);},s = function s(e, t) {var r = t;return void 0 === r && (r = new Uint32Array(4)), r[0] = parseInt("0x" + e.substr(0, 8), 16), r[1] = parseInt("0x" + e.substr(9, 4) + e.substr(14, 4), 16), r[2] = parseInt("0x" + e.substr(19, 4) + e.substr(24, 4), 16), r[3] = parseInt("0x" + e.substr(28, 8), 16), r;},a = function a(e, t) {var r = new Uint32Array(t);return r[0] += 2654435769, r[1] += 104395303, r[2] += 452930477, r[3] += 982451653, r[0] += e[3] << 6, r[1] += e[0] << 6, r[2] += e[1] << 6, r[3] += e[2] << 6, r[0] += e[2] >> 2, r[1] += e[3] >> 2, r[2] += e[0] >> 2, r[3] += e[1] >> 2, r[0] = 16777619 * (r[0] ^ e[1]) >>> 0, r[1] = 16777619 * (r[1] ^ e[2]) >>> 0, r[2] = 16777619 * (r[2] ^ e[3]) >>> 0, r[3] = 16777619 * (r[3] ^ e[0]) >>> 0, r;};o.initialize(), t.uint32x4ToGUID = i, t.guidToUint32x4 = s, t.generateGUID = function () {var e = new Uint32Array(4);return e[0] = o.genRandUInt32(), e[1] = o.genRandUInt32(), e[2] = o.genRandUInt32(), e[3] = o.genRandUInt32(), i(e);}, t.isGUID = function (e) {return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(e);}, t.combineGuids = function (e, t) {var r = s(e),n = s(t),o = a(r, n);return i(o);}, t.hashCombine4xUint32 = a;}, function (e, t) {var r;r = function () {return this;}();try {r = r || new Function("return this")();} catch (e) {"object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (r = window);}e.exports = r;}, function (e, t, r) {"use strict";e.exports = function (e, t) {for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) {r[n++] = arguments[o++];}return new Promise(function (o, s) {r[n] = function (e) {if (i) if (i = !1, e) s(e);else {for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) {t[r++] = arguments[r];}o.apply(null, t);}};try {e.apply(t || null, r);} catch (e) {i && (i = !1, s(e));}});};}, function (module, exports, __webpack_require__) {"use strict";function inquire(moduleName) {try {var mod = eval("quire".replace(/^/, "re"))(moduleName);if (mod && (mod.length || Object.keys(mod).length)) return mod;} catch (e) {}return null;}module.exports = inquire;}, function (e, t, r) {"use strict";t.Service = r(98);}, function (e, t, r) {"use strict";e.exports = {};}, function (e, t, r) {"use strict";e.exports = function (e) {for (var t, r = i.codegen(["m", "w"], e.name + "$encode")("if(!w)")("w=Writer.create()"), a = e.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < a.length; ++c) {var u = a[c].resolve(),l = e._fieldsArray.indexOf(u),h = u.resolvedType instanceof n ? "int32" : u.type,d = o.basic[h];t = "m" + i.safeProp(u.name), u.map ? (r("if(%s!=null&&m.hasOwnProperty(%j)){", t, u.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", t)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (u.id << 3 | 2) >>> 0, 8 | o.mapKey[u.keyType], u.keyType), void 0 === d ? r("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", l, t) : r(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | d, h, t), r("}")("}")) : u.repeated ? (r("if(%s!=null&&%s.length){", t, t), u.packed && void 0 !== o.packed[h] ? r("w.uint32(%i).fork()", (u.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", t)("w.%s(%s[i])", h, t)("w.ldelim()") : (r("for(var i=0;i<%s.length;++i)", t), void 0 === d ? s(r, u, l, t + "[i]") : r("w.uint32(%i).%s(%s[i])", (u.id << 3 | d) >>> 0, h, t)), r("}")) : (u.optional && r("if(%s!=null&&m.hasOwnProperty(%j))", t, u.name), void 0 === d ? s(r, u, l, t) : r("w.uint32(%i).%s(%s)", (u.id << 3 | d) >>> 0, h, t));}return r("return w");};var n = r(11),o = r(31),i = r(5);function s(e, t, r, n) {return t.resolvedType.group ? e("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", r, n, (t.id << 3 | 3) >>> 0, (t.id << 3 | 4) >>> 0) : e("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", r, n, (t.id << 3 | 2) >>> 0);}}, function (e, t, r) {"use strict";e.exports = y;var n = r(30);((y.prototype = Object.create(n.prototype)).constructor = y).className = "Type";var o = r(11),i = r(48),s = r(22),a = r(64),c = r(65),u = r(49),l = r(47),h = r(46),d = r(5),g = r(62),p = r(67),f = r(68),v = r(69),_ = r(70);function y(e, t) {n.call(this, e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;}function m(e) {return e._fieldsById = e._fieldsArray = e._oneofsArray = null, delete e.encode, delete e.decode, delete e.verify, e;}Object.defineProperties(y.prototype, { fieldsById: { get: function get() {if (this._fieldsById) return this._fieldsById;this._fieldsById = {};for (var e = Object.keys(this.fields), t = 0; t < e.length; ++t) {var r = this.fields[e[t]],n = r.id;if (this._fieldsById[n]) throw Error("duplicate id " + n + " in " + this);this._fieldsById[n] = r;}return this._fieldsById;} }, fieldsArray: { get: function get() {return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields));} }, oneofsArray: { get: function get() {return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs));} }, ctor: { get: function get() {return this._ctor || (this.ctor = y.generateConstructor(this)());}, set: function set(e) {var t = e.prototype;t instanceof u || ((e.prototype = new u()).constructor = e, d.merge(e.prototype, t)), e.$type = e.prototype.$type = this, d.merge(e, u, !0), this._ctor = e;for (var r = 0; r < this.fieldsArray.length; ++r) {this._fieldsArray[r].resolve();}var n = {};for (r = 0; r < this.oneofsArray.length; ++r) {n[this._oneofsArray[r].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[r].oneof), set: d.oneOfSetter(this._oneofsArray[r].oneof) };}r && Object.defineProperties(e.prototype, n);} } }), y.generateConstructor = function (e) {for (var t, r = d.codegen(["p"], e.name), n = 0; n < e.fieldsArray.length; ++n) {(t = e._fieldsArray[n]).map ? r("this%s={}", d.safeProp(t.name)) : t.repeated && r("this%s=[]", d.safeProp(t.name));}return r("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");}, y.fromJSON = function (e, t) {var r = new y(e, t.options);r.extensions = t.extensions, r.reserved = t.reserved;for (var u = Object.keys(t.fields), l = 0; l < u.length; ++l) {r.add((void 0 !== t.fields[u[l]].keyType ? a.fromJSON : s.fromJSON)(u[l], t.fields[u[l]]));}if (t.oneofs) for (u = Object.keys(t.oneofs), l = 0; l < u.length; ++l) {r.add(i.fromJSON(u[l], t.oneofs[u[l]]));}if (t.nested) for (u = Object.keys(t.nested), l = 0; l < u.length; ++l) {var h = t.nested[u[l]];r.add((void 0 !== h.id ? s.fromJSON : void 0 !== h.fields ? y.fromJSON : void 0 !== h.values ? o.fromJSON : void 0 !== h.methods ? c.fromJSON : n.fromJSON)(u[l], h));}return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = !0), t.comment && (r.comment = t.comment), r;}, y.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return d.toObject(["options", t && t.options || void 0, "oneofs", n.arrayToJSON(this.oneofsArray, e), "fields", n.arrayToJSON(this.fieldsArray.filter(function (e) {return !e.declaringField;}), e) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, y.prototype.resolveAll = function () {for (var e = this.fieldsArray, t = 0; t < e.length;) {e[t++].resolve();}var r = this.oneofsArray;for (t = 0; t < r.length;) {r[t++].resolve();}return n.prototype.resolveAll.call(this);}, y.prototype.get = function (e) {return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;}, y.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);if (e instanceof s && void 0 === e.extend) {if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error("duplicate id " + e.id + " in " + this);if (this.isReservedId(e.id)) throw Error("id " + e.id + " is reserved in " + this);if (this.isReservedName(e.name)) throw Error("name '" + e.name + "' is reserved in " + this);return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = this, e.onAdd(this), m(this);}return e instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(this), m(this)) : n.prototype.add.call(this, e);}, y.prototype.remove = function (e) {if (e instanceof s && void 0 === e.extend) {if (!this.fields || this.fields[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.fields[e.name], e.parent = null, e.onRemove(this), m(this);}if (e instanceof i) {if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.oneofs[e.name], e.parent = null, e.onRemove(this), m(this);}return n.prototype.remove.call(this, e);}, y.prototype.isReservedId = function (e) {return n.isReservedId(this.reserved, e);}, y.prototype.isReservedName = function (e) {return n.isReservedName(this.reserved, e);}, y.prototype.create = function (e) {return new this.ctor(e);}, y.prototype.setup = function () {for (var e = this.fullName, t = [], r = 0; r < this.fieldsArray.length; ++r) {t.push(this._fieldsArray[r].resolve().resolvedType);}this.encode = g(this)({ Writer: h, types: t, util: d }), this.decode = p(this)({ Reader: l, types: t, util: d }), this.verify = f(this)({ types: t, util: d }), this.fromObject = v.fromObject(this)({ types: t, util: d }), this.toObject = v.toObject(this)({ types: t, util: d });var n = _[e];if (n) {var o = Object.create(this);o.fromObject = this.fromObject, this.fromObject = n.fromObject.bind(o), o.toObject = this.toObject, this.toObject = n.toObject.bind(o);}return this;}, y.prototype.encode = function (e, t) {return this.setup().encode(e, t);}, y.prototype.encodeDelimited = function (e, t) {return this.encode(e, t && t.len ? t.fork() : t).ldelim();}, y.prototype.decode = function (e, t) {return this.setup().decode(e, t);}, y.prototype.decodeDelimited = function (e) {return e instanceof l || (e = l.create(e)), this.decode(e, e.uint32());}, y.prototype.verify = function (e) {return this.setup().verify(e);}, y.prototype.fromObject = function (e) {return this.setup().fromObject(e);}, y.prototype.toObject = function (e, t) {return this.setup().toObject(e, t);}, y.d = function (e) {return function (t) {d.decorateType(t, e);};};}, function (e, t, r) {"use strict";e.exports = s;var n = r(22);((s.prototype = Object.create(n.prototype)).constructor = s).className = "MapField";var o = r(31),i = r(5);function s(e, t, r, o, s, a) {if (n.call(this, e, t, o, void 0, void 0, s, a), !i.isString(r)) throw TypeError("keyType must be a string");this.keyType = r, this.resolvedKeyType = null, this.map = !0;}s.fromJSON = function (e, t) {return new s(e, t.id, t.keyType, t.type, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, s.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === o.mapKey[this.keyType]) throw Error("invalid key type: " + this.keyType);return n.prototype.resolve.call(this);}, s.d = function (e, t, r) {return "function" == typeof r ? r = i.decorateType(r).name : r && "object" == _typeof(r) && (r = i.decorateEnum(r).name), function (n, o) {i.decorateType(n.constructor).add(new s(o, e, t, r));};};}, function (e, t, r) {"use strict";e.exports = a;var n = r(30);((a.prototype = Object.create(n.prototype)).constructor = a).className = "Service";var o = r(66),i = r(5),s = r(60);function a(e, t) {n.call(this, e, t), this.methods = {}, this._methodsArray = null;}function c(e) {return e._methodsArray = null, e;}a.fromJSON = function (e, t) {var r = new a(e, t.options);if (t.methods) for (var n = Object.keys(t.methods), i = 0; i < n.length; ++i) {r.add(o.fromJSON(n[i], t.methods[n[i]]));}return t.nested && r.addJSON(t.nested), r.comment = t.comment, r;}, a.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return i.toObject(["options", t && t.options || void 0, "methods", n.arrayToJSON(this.methodsArray, e) || {}, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, Object.defineProperty(a.prototype, "methodsArray", { get: function get() {return this._methodsArray || (this._methodsArray = i.toArray(this.methods));} }), a.prototype.get = function (e) {return this.methods[e] || n.prototype.get.call(this, e);}, a.prototype.resolveAll = function () {for (var e = this.methodsArray, t = 0; t < e.length; ++t) {e[t].resolve();}return n.prototype.resolve.call(this);}, a.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);return e instanceof o ? (this.methods[e.name] = e, e.parent = this, c(this)) : n.prototype.add.call(this, e);}, a.prototype.remove = function (e) {if (e instanceof o) {if (this.methods[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.methods[e.name], e.parent = null, c(this);}return n.prototype.remove.call(this, e);}, a.prototype.create = function (e, t, r) {for (var n, o = new s.Service(e, t, r), a = 0; a < this.methodsArray.length; ++a) {var c = i.lcFirst((n = this._methodsArray[a]).resolve().name).replace(/[^$\w_]/g, "");o[c] = i.codegen(["r", "c"], i.isReserved(c) ? c + "_" : c)("return this.rpcCall(m,q,s,r,c)")({ m: n, q: n.resolvedRequestType.ctor, s: n.resolvedResponseType.ctor });}return o;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(21);((i.prototype = Object.create(n.prototype)).constructor = i).className = "Method";var o = r(5);function i(e, t, r, i, s, a, c, u) {if (o.isObject(s) ? (c = s, s = a = void 0) : o.isObject(a) && (c = a, a = void 0), void 0 !== t && !o.isString(t)) throw TypeError("type must be a string");if (!o.isString(r)) throw TypeError("requestType must be a string");if (!o.isString(i)) throw TypeError("responseType must be a string");n.call(this, e, c), this.type = t || "rpc", this.requestType = r, this.requestStream = !!s || void 0, this.responseType = i, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;}i.fromJSON = function (e, t) {return new i(e, t.type, t.requestType, t.responseType, t.requestStream, t.responseStream, t.options, t.comment);}, i.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return o.toObject(["type", "rpc" !== this.type && this.type || void 0, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", t ? this.comment : void 0]);}, i.prototype.resolve = function () {return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));};}, function (e, t, r) {"use strict";e.exports = function (e) {var t = i.codegen(["r", "l"], e.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (e.fieldsArray.filter(function (e) {return e.map;}).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");e.group && t("if((t&7)===4)")("break"), t("switch(t>>>3){");for (var r = 0; r < e.fieldsArray.length; ++r) {var a = e._fieldsArray[r].resolve(),c = a.resolvedType instanceof n ? "int32" : a.type,u = "m" + i.safeProp(a.name);t("case %i:", a.id), a.map ? (t("r.skip().pos++")("if(%s===util.emptyObject)", u)("%s={}", u)("k=r.%s()", a.keyType)("r.pos++"), void 0 !== o.long[a.keyType] ? void 0 === o.basic[c] ? t('%s[typeof k==="object"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', u, r) : t('%s[typeof k==="object"?util.longToHash(k):k]=r.%s()', u, c) : void 0 === o.basic[c] ? t("%s[k]=types[%i].decode(r,r.uint32())", u, r) : t("%s[k]=r.%s()", u, c)) : a.repeated ? (t("if(!(%s&&%s.length))", u, u)("%s=[]", u), void 0 !== o.packed[c] && t("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", u, c)("}else"), void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", u, r) : t("%s.push(r.%s())", u, c)) : void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", u, r) : t("%s=r.%s()", u, c), t("break");}for (t("default:")("r.skipType(t&7)")("break")("}")("}"), r = 0; r < e._fieldsArray.length; ++r) {var l = e._fieldsArray[r];l.required && t("if(!m.hasOwnProperty(%j))", l.name)("throw util.ProtocolError(%j,{instance:m})", s(l));}return t("return m");};var n = r(11),o = r(31),i = r(5);function s(e) {return "missing required '" + e.name + "'";}}, function (e, t, r) {"use strict";e.exports = function (e) {var t = o.codegen(["m"], e.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"),r = {};e.oneofsArray.length && t("var p={}");for (var n = 0; n < e.fieldsArray.length; ++n) {var c = e._fieldsArray[n].resolve(),u = "m" + o.safeProp(c.name);if (c.optional && t("if(%s!=null&&m.hasOwnProperty(%j)){", u, c.name), c.map) t("if(!util.isObject(%s))", u)("return%j", i(c, "object"))("var k=Object.keys(%s)", u)("for(var i=0;i<k.length;++i){"), a(t, c, "k[i]"), s(t, c, n, u + "[k[i]]")("}");else if (c.repeated) t("if(!Array.isArray(%s))", u)("return%j", i(c, "array"))("for(var i=0;i<%s.length;++i){", u), s(t, c, n, u + "[i]")("}");else {if (c.partOf) {var l = o.safeProp(c.partOf.name);1 === r[c.partOf.name] && t("if(p%s===1)", l)("return%j", c.partOf.name + ": multiple values"), r[c.partOf.name] = 1, t("p%s=1", l);}s(t, c, n, u);}c.optional && t("}");}return t("return null");};var n = r(11),o = r(5);function i(e, t) {return e.name + ": " + t + (e.repeated && "array" !== t ? "[]" : e.map && "object" !== t ? "{k:" + e.keyType + "}" : "") + " expected";}function s(e, t, r, o) {if (t.resolvedType) {if (t.resolvedType instanceof n) {e("switch(%s){", o)("default:")("return%j", i(t, "enum value"));for (var s = Object.keys(t.resolvedType.values), a = 0; a < s.length; ++a) {e("case %i:", t.resolvedType.values[s[a]]);}e("break")("}");} else e("{")("var e=types[%i].verify(%s);", r, o)("if(e)")("return%j+e", t.name + ".")("}");} else switch (t.type) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.isInteger(%s))", o)("return%j", i(t, "integer"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", o, o, o, o)("return%j", i(t, "integer|Long"));break;case "float":case "double":e('if(typeof %s!=="number")', o)("return%j", i(t, "number"));break;case "bool":e('if(typeof %s!=="boolean")', o)("return%j", i(t, "boolean"));break;case "string":e("if(!util.isString(%s))", o)("return%j", i(t, "string"));break;case "bytes":e('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', o, o, o)("return%j", i(t, "buffer"));}return e;}function a(e, t, r) {switch (t.keyType) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.key32Re.test(%s))", r)("return%j", i(t, "integer key"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.key64Re.test(%s))", r)("return%j", i(t, "integer|Long key"));break;case "bool":e("if(!util.key2Re.test(%s))", r)("return%j", i(t, "boolean key"));}return e;}}, function (e, t, r) {"use strict";var n = t,o = r(11),i = r(5);function s(e, t, r, n) {if (t.resolvedType) {if (t.resolvedType instanceof o) {e("switch(d%s){", n);for (var i = t.resolvedType.values, s = Object.keys(i), a = 0; a < s.length; ++a) {t.repeated && i[s[a]] === t.typeDefault && e("default:"), e("case%j:", s[a])("case %i:", i[s[a]])("m%s=%j", n, i[s[a]])("break");}e("}");} else e('if(typeof d%s!=="object")', n)("throw TypeError(%j)", t.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", n, r, n);} else {var c = !1;switch (t.type) {case "double":case "float":e("m%s=Number(d%s)", n, n);break;case "uint32":case "fixed32":e("m%s=d%s>>>0", n, n);break;case "int32":case "sint32":case "sfixed32":e("m%s=d%s|0", n, n);break;case "uint64":c = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", n, n, c)('else if(typeof d%s==="string")', n)("m%s=parseInt(d%s,10)", n, n)('else if(typeof d%s==="number")', n)("m%s=d%s", n, n)('else if(typeof d%s==="object")', n)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", n, n, n, c ? "true" : "");break;case "bytes":e('if(typeof d%s==="string")', n)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", n, n, n)("else if(d%s.length)", n)("m%s=d%s", n, n);break;case "string":e("m%s=String(d%s)", n, n);break;case "bool":e("m%s=Boolean(d%s)", n, n);}}return e;}function a(e, t, r, n) {if (t.resolvedType) t.resolvedType instanceof o ? e("d%s=o.enums===String?types[%i].values[m%s]:m%s", n, r, n, n) : e("d%s=types[%i].toObject(m%s,o)", n, r, n);else {var i = !1;switch (t.type) {case "double":case "float":e("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", n, n, n, n);break;case "uint64":i = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e('if(typeof m%s==="number")', n)("d%s=o.longs===String?String(m%s):m%s", n, n, n)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", n, n, n, n, i ? "true" : "", n);break;case "bytes":e("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", n, n, n, n, n);break;default:e("d%s=m%s", n, n);}}return e;}n.fromObject = function (e) {var t = e.fieldsArray,r = i.codegen(["d"], e.name + "$fromObject")("if(d instanceof this.ctor)")("return d");if (!t.length) return r("return new this.ctor");r("var m=new this.ctor");for (var n = 0; n < t.length; ++n) {var a = t[n].resolve(),c = i.safeProp(a.name);a.map ? (r("if(d%s){", c)('if(typeof d%s!=="object")', c)("throw TypeError(%j)", a.fullName + ": object expected")("m%s={}", c)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", c), s(r, a, n, c + "[ks[i]]")("}")("}")) : a.repeated ? (r("if(d%s){", c)("if(!Array.isArray(d%s))", c)("throw TypeError(%j)", a.fullName + ": array expected")("m%s=[]", c)("for(var i=0;i<d%s.length;++i){", c), s(r, a, n, c + "[i]")("}")("}")) : (a.resolvedType instanceof o || r("if(d%s!=null){", c), s(r, a, n, c), a.resolvedType instanceof o || r("}"));}return r("return m");}, n.toObject = function (e) {var t = e.fieldsArray.slice().sort(i.compareFieldsById);if (!t.length) return i.codegen()("return {}");for (var r = i.codegen(["m", "o"], e.name + "$toObject")("if(!o)")("o={}")("var d={}"), n = [], s = [], c = [], u = 0; u < t.length; ++u) {t[u].partOf || (t[u].resolve().repeated ? n : t[u].map ? s : c).push(t[u]);}if (n.length) {for (r("if(o.arrays||o.defaults){"), u = 0; u < n.length; ++u) {r("d%s=[]", i.safeProp(n[u].name));}r("}");}if (s.length) {for (r("if(o.objects||o.defaults){"), u = 0; u < s.length; ++u) {r("d%s={}", i.safeProp(s[u].name));}r("}");}if (c.length) {for (r("if(o.defaults){"), u = 0; u < c.length; ++u) {var l = c[u],h = i.safeProp(l.name);if (l.resolvedType instanceof o) r("d%s=o.enums===String?%j:%j", h, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);else if (l.long) r("if(util.Long){")("var n=new util.Long(%i,%i,%j)", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", h)("}else")("d%s=o.longs===String?%j:%i", h, l.typeDefault.toString(), l.typeDefault.toNumber());else if (l.bytes) {var d = "[" + Array.prototype.slice.call(l.typeDefault).join(",") + "]";r("if(o.bytes===String)d%s=%j", h, String.fromCharCode.apply(String, l.typeDefault))("else{")("d%s=%s", h, d)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", h, h)("}");} else r("d%s=%j", h, l.typeDefault);}r("}");}var g = !1;for (u = 0; u < t.length; ++u) {l = t[u];var p = e._fieldsArray.indexOf(l);h = i.safeProp(l.name), l.map ? (g || (g = !0, r("var ks2")), r("if(m%s&&(ks2=Object.keys(m%s)).length){", h, h)("d%s={}", h)("for(var j=0;j<ks2.length;++j){"), a(r, l, p, h + "[ks2[j]]")("}")) : l.repeated ? (r("if(m%s&&m%s.length){", h, h)("d%s=[]", h)("for(var j=0;j<m%s.length;++j){", h), a(r, l, p, h + "[j]")("}")) : (r("if(m%s!=null&&m.hasOwnProperty(%j)){", h, l.name), a(r, l, p, h), l.partOf && r("if(o.oneofs)")("d%s=%j", i.safeProp(l.partOf.name), l.name)), r("}");}return r("return d");};}, function (e, t, r) {"use strict";var n = t,o = r(49);n[".google.protobuf.Any"] = { fromObject: function fromObject(e) {if (e && e["@type"]) {var t = this.lookup(e["@type"]);if (t) {var r = "." === e["@type"].charAt(0) ? e["@type"].substr(1) : e["@type"];return this.create({ type_url: "/" + r, value: t.encode(t.fromObject(e)).finish() });}}return this.fromObject(e);}, toObject: function toObject(e, t) {if (t && t.json && e.type_url && e.value) {var r = e.type_url.substring(e.type_url.lastIndexOf("/") + 1),n = this.lookup(r);n && (e = n.decode(e.value));}if (!(e instanceof this.ctor) && e instanceof o) {var i = e.$type.toObject(e, t);return i["@type"] = e.$type.fullName, i;}return this.toObject(e, t);} };}, function (e, t, r) {"use strict";e.exports = h;var n = r(30);((h.prototype = Object.create(n.prototype)).constructor = h).className = "Root";var o,i,s,a = r(22),c = r(11),u = r(48),l = r(5);function h(e) {n.call(this, "", e), this.deferred = [], this.files = [];}function d() {}h.fromJSON = function (e, t) {return t || (t = new h()), e.options && t.setOptions(e.options), t.addJSON(e.nested);}, h.prototype.resolvePath = l.path.resolve, h.prototype.load = function e(t, r, n) {"function" == typeof r && (n = r, r = void 0);var o = this;if (!n) return l.asPromise(e, o, t, r);var a = n === d;function c(e, t) {if (n) {var r = n;if (n = null, a) throw e;r(e, t);}}function u(e, t) {try {if (l.isString(t) && "{" === t.charAt(0) && (t = JSON.parse(t)), l.isString(t)) {i.filename = e;var n,s = i(t, o, r),u = 0;if (s.imports) for (; u < s.imports.length; ++u) {(n = o.resolvePath(e, s.imports[u])) && h(n);}if (s.weakImports) for (u = 0; u < s.weakImports.length; ++u) {(n = o.resolvePath(e, s.weakImports[u])) && h(n, !0);}} else o.setOptions(t.options).addJSON(t.nested);} catch (e) {c(e);}a || g || c(null, o);}function h(e, t) {var r = e.lastIndexOf("google/protobuf/");if (r > -1) {var i = e.substring(r);i in s && (e = i);}if (!(o.files.indexOf(e) > -1)) if (o.files.push(e), e in s) a ? u(e, s[e]) : (++g, setTimeout(function () {--g, u(e, s[e]);}));else if (a) {var h;try {h = l.fs.readFileSync(e).toString("utf8");} catch (e) {return void (t || c(e));}u(e, h);} else ++g, l.fetch(e, function (r, i) {--g, n && (r ? t ? g || c(null, o) : c(r) : u(e, i));});}var g = 0;l.isString(t) && (t = [t]);for (var p, f = 0; f < t.length; ++f) {(p = o.resolvePath("", t[f])) && h(p);}if (a) return o;g || c(null, o);}, h.prototype.loadSync = function (e, t) {if (!l.isNode) throw Error("not supported");return this.load(e, t, d);}, h.prototype.resolveAll = function () {if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (e) {return "'extend " + e.extend + "' in " + e.parent.fullName;}).join(", "));return n.prototype.resolveAll.call(this);};var g = /^[A-Z]/;function p(e, t) {var r = t.parent.lookup(t.extend);if (r) {var n = new a(t.fullName, t.id, t.type, t.rule, void 0, t.options);return n.declaringField = t, t.extensionField = n, r.add(n), !0;}return !1;}h.prototype._handleAdd = function (e) {if (e instanceof a) void 0 === e.extend || e.extensionField || p(0, e) || this.deferred.push(e);else if (e instanceof c) g.test(e.name) && (e.parent[e.name] = e.values);else if (!(e instanceof u)) {if (e instanceof o) for (var t = 0; t < this.deferred.length;) {p(0, this.deferred[t]) ? this.deferred.splice(t, 1) : ++t;}for (var r = 0; r < e.nestedArray.length; ++r) {this._handleAdd(e._nestedArray[r]);}g.test(e.name) && (e.parent[e.name] = e);}}, h.prototype._handleRemove = function (e) {if (e instanceof a) {if (void 0 !== e.extend) if (e.extensionField) e.extensionField.parent.remove(e.extensionField), e.extensionField = null;else {var t = this.deferred.indexOf(e);t > -1 && this.deferred.splice(t, 1);}} else if (e instanceof c) g.test(e.name) && delete e.parent[e.name];else if (e instanceof n) {for (var r = 0; r < e.nestedArray.length; ++r) {this._handleRemove(e._nestedArray[r]);}g.test(e.name) && delete e.parent[e.name];}}, h._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";function n(e, t, r, n, o, i) {o[0] = i.b = n[0], o[1] = i.a = -t * i.b + n[1];for (var s = 2; s < e; s++) {o[s] = -(t * i.a + r * i.b) + n[s], i.b = i.a, i.a = o[s];}}function o(e, t, r, o, i, s, a, c, u) {var l = new Object(),h = 3;return l.b = l.a = 0, n(t, a, c, s, u, l), i.c = l.a, i.d = l.b, Math.abs(i.c) <= 100 * e * Math.abs(s[t - 1]) && Math.abs(i.d) <= 100 * e * Math.abs(s[t - 2]) || (i.h = c * o, Math.abs(i.d) >= Math.abs(i.c) ? (h = 2, i.e = r / i.d, i.f = i.c / i.d, i.g = a * o, i.a3 = i.e * (i.g + r) + i.h * (o / i.d), i.a1 = -r + i.f * o, i.a7 = i.h + (i.f + a) * r) : (h = 1, i.e = r / i.c, i.f = i.d / i.c, i.g = i.e * a, i.a3 = i.e * r + (i.g + i.h / i.c) * o, i.a1 = -r * (i.d / i.c) + o, i.a7 = i.g * i.d + i.h * i.f + r)), h;}function i(e, t, r, n, o, i, s, a, c) {var u;if (3 != r) {if (u = 1 == r ? o : n, Math.abs(i.a1) > 10 * e * Math.abs(u)) for (i.a7 /= i.a1, i.a3 /= i.a1, s[0] = c[0], s[1] = -c[0] * i.a7 + c[1], l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3 + c[l];} else for (s[0] = 0, s[1] = -c[0] * i.a7, l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3;}} else {s[1] = s[0] = 0;for (var l = 2; l < t; l++) {s[l] = a[l - 2];}}}function s(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {var _, y, m, E, x, R, A, P;t.b = t.a = 0, 3 != e && (2 != e ? (_ = r + d * s + h * u, y = a + (d + g * u) * c) : (_ = (r + l) * u + h, y = (u + d) * a + g * c), 0 != (P = -(A = -((x = (m = -p[f - 1] / v[f]) * i) + (R = m * m * o)) + g * (E = -(p[f - 2] + m * v[f - 1]) / v[f]) * n) + y + m * _) && (t.a = -(d * (R + x) + g * (m * n + E * i)) / P + d, t.b = g * (1 + A / P)));}function a(e, t, r, n) {var o, i, s;n.sr = n.si = n.lr = n.li = 0, 0 != e ? 0 != r ? (o = t / 2, Math.abs(o) < Math.abs(r) ? (s = -(s = r >= 0 ? e : -e) + o * (o / Math.abs(r)), i = Math.sqrt(Math.abs(s)) * Math.sqrt(Math.abs(r))) : (s = -e / o * (r / o) + 1, i = Math.sqrt(Math.abs(s)) * Math.abs(o)), s >= 0 ? (i = o >= 0 ? -i : i, n.lr = (-o + i) / e, n.sr = 0 != n.lr ? r / n.lr / e : n.sr) : (n.lr = n.sr = -o / e, n.si = Math.abs(i / e), n.li = -n.si)) : n.lr = -t / e : n.sr = 0 != t ? -r / t : n.sr;}function c(e, t, r, c, u, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b = new Object(),L = 0,O = 0;r.NZ = 0, R = c, P = u;do {if (b.li = b.lr = b.si = b.sr = 0, a(1, R, P, b), r.szr = b.sr, r.szi = b.si, r.lzr = b.lr, r.lzi = b.li, Math.abs(Math.abs(r.szr) - Math.abs(r.lzr)) > .01 * Math.abs(r.lzr)) break;for (n(h, R, P, g, l, d), y = Math.abs(-r.szr * d.b + d.a) + Math.abs(r.szi * d.b), T = Math.sqrt(Math.abs(P)), _ = 2 * Math.abs(l[0]), x = -r.szr * d.b, C = 1; C < t; C++) {_ = _ * T + Math.abs(l[C]);}if (y <= 20 * (_ = (9 * (_ = _ * T + Math.abs(x + d.a)) + 2 * Math.abs(x) - 7 * (Math.abs(d.a + x) + T * Math.abs(d.b))) * e)) {r.NZ = 2;break;}if (++L > 20) break;if (L >= 2 && E <= .01 && y >= m && !O) {for (n(h, R -= R * (E = E < e ? Math.sqrt(e) : Math.sqrt(E)), P += P * E, g, l, d), C = 0; C < 5; C++) {i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l);}O = 1, L = 0;}m = y, i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l), s(o(e, t, d.a, d.b, f, v, R, P, p), d, d.a, f.a1, f.a3, f.a7, d.b, f.c, f.d, f.f, f.g, f.h, R, P, v, t, g), A = d.a, 0 != (V = d.b) && (E = Math.abs((-P + V) / V), R = A, P = V);} while (0 != V);}function u(e, t, r, n, o, i, s, a, c) {var u,l,h,d,g,p,f,v,_,y,m,E = n - 1;for (t.NZ = m = _ = 0, f = r.a;;) {for (s[0] = p = o[0], y = 1; y < i; y++) {s[y] = p = p * f + o[y];}for (h = Math.abs(p), d = Math.abs(f), u = .5 * Math.abs(s[0]), y = 1; y < i; y++) {u = u * d + Math.abs(s[y]);}if (h <= 20 * e * (2 * u - h)) {t.NZ = 1, t.szr = f, t.szi = 0;break;}if (++m > 10) break;if (m >= 2 && Math.abs(v) <= .001 * Math.abs(-v + f) && h > g) {_ = 1, t.a = f;break;}for (g = h, c[0] = l = a[0], y = 1; y < n; y++) {c[y] = l = l * f + a[y];}if (Math.abs(l) > 10 * Math.abs(a[E]) * e) for (v = -p / l, a[0] = s[0], y = 1; y < n; y++) {a[y] = v * c[y - 1] + s[y];} else for (a[0] = 0, y = 1; y < n; y++) {a[y] = c[y - 1];}for (l = a[0], y = 1; y < n; y++) {l = l * f + a[y];}f += v = Math.abs(l) > 10 * Math.abs(a[E]) * e ? -p / l : 0;}return _;}function l(e, t, r, a, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b,L,O,S,M,w,N,F,I,D,j,B,U,k,G,z,Y,K = new Object(),q = new Object(),W = new Array(t),H = new Array(t);for (v.NZ = 0, E = m = .25, S = -2 * a, x = a, P = w = l, q.h = q.g = q.f = q.e = q.d = q.c = q.a7 = q.a3 = q.a1 = K.b = K.a = 0, n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W), B = 0; B < r; B++) {if (i(e, d, G, _, y, q, h, W, f), s(G = o(e, d, _, y, q, h, S, w, W), K, _, q.a1, q.a3, q.a7, y, q.c, q.d, q.f, q.g, q.h, S, w, h, d, g), M = K.a, F = N = K.b, T = 0 != h[d - 1] ? -g[d] / h[d - 1] : 0, C = L = 1, 0 != B && 3 != G && (z = (O = (L = 0 != F ? Math.abs((F - P) / F) : L) < A ? L * A : 1) < E ? 1 : 0, (U = (b = (C = 0 != T ? Math.abs((T - x) / T) : C) < R ? C * R : 1) < m ? 1 : 0) || z)) {for (D = 0; D < d; D++) {H[D] = h[D];}V = T, k = Y = 0, I = 1;do {if (j = 1, I && 0 == (I = 0) && U && (!z || b < O)) ;else {if (c(e, d, v, M, N, f, p, K, g, W, q, h), _ = K.a, y = K.b, v.NZ > 0) return;if (Y = 1, E *= .25, k || !U) j = 0;else for (D = 0; D < d; D++) {h[D] = H[D];}}if (0 != j) {if (K.a = V, j = u(e, v, K, d, g, p, f, h, W), V = K.a, v.NZ > 0) return;if (k = 1, m *= .25, 0 != j) {M = -(V + V), N = V * V;continue;}}for (D = 0; D < d; D++) {h[D] = H[D];}} while (z && !Y);n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W);}P = F, x = T, A = L, R = C;}}Object.defineProperty(t, "__esModule", { value: !0 }), t.getRealPolynomialRoots = function (e) {var t = { Degree: e.length - 1 },r = new Array(e.length),n = new Array(e.length);!function (e, t, r, n) {var o,i,s,c,u,h,d,g,p,f,v,_,y,m,E,x,R,A,P,V,T,C,b = e.Degree,L = Math.LN2,O = e.Degree + 1,S = new Array(O),M = new Array(O),w = new Array(O),N = new Array(O),F = new Object(),I = new Object();_ = 1;do {i = _, y = 1 + (_ /= 2);} while (y > 1);var D = 117549435082229e-52 / i,j = Math.cos(1.6406094968746698),B = Math.sin(1.6406094968746698),U = Math.sqrt(.5),k = -U;for (I.NZ = R = 0, I.szr = I.szi = I.lzr = I.lzi = 0; 0 == t[b];) {r[R] = n[R] = 0, b--, R++;}for (T = b + 1; b >= 1;) {if (b <= 2) {b < 2 ? (r[e.Degree - 1] = -t[1] / t[0], n[e.Degree - 1] = 0) : (F.li = F.lr = F.si = F.sr = 0, a(t[0], t[1], t[2], F), r[e.Degree - 2] = F.sr, n[e.Degree - 2] = F.si, r[e.Degree - 1] = F.lr, n[e.Degree - 1] = F.li);break;}for (d = 0, g = 340282346638529e24, G = 0; G < T; G++) {(f = Math.abs(t[G])) > d && (d = f), 0 != f && f < g && (g = f);}if (((p = D / g) <= 1 && d >= 10 || p > 1 && 340282346638529e24 / p >= d) && (p = 0 == p ? 117549435082229e-52 : p, P = Math.floor(Math.log(p) / L + .5), 1 != (u = Math.pow(2, P)))) for (G = 0; G < T; G++) {t[G] *= u;}for (var G = 0; G < T; G++) {M[G] = Math.abs(t[G]);}M[b] = -M[b], V = b - 1, f = Math.exp((Math.log(-M[b]) - Math.log(M[0])) / b), 0 != M[V] && (f = (v = -M[b] / M[V]) < f ? v : f), v = f;do {for (v = .1 * (f = v), h = M[0], G = 1; G < T; G++) {h = h * v + M[G];}} while (h > 0);for (c = f; Math.abs(c / f) > .005;) {for (s = h = M[0], G = 1; G < b; G++) {s = f * s + (h = f * h + M[G]);}f -= c = (h = f * h + M[b]) / s;}for (o = f, G = 1; G < b; G++) {S[G] = (b - G) * t[G] / b;}for (S[0] = t[0], _ = t[b], y = t[V], C = 0 == S[V] ? 1 : 0, A = 0; A < 5; A++) {if (m = S[V], C) {for (G = 0; G < V; G++) {S[R = V - G] = S[R - 1];}S[0] = 0, C = 0 == S[V] ? 1 : 0;} else {for (E = -_ / m, G = 0; G < V; G++) {S[R = V - G] = E * S[R - 1] + t[R];}S[0] = t[0], C = Math.abs(S[V]) <= Math.abs(y) * i * 10 ? 1 : 0;}}for (G = 0; G < b; G++) {N[G] = S[G];}for (A = 1; A <= 20; A++) {if (x = -B * k + j * U, k = B * U + j * k, l(i, O, 20 * A, o * (U = x), o, S, b, t, T, w, I), 0 != I.NZ) {for (r[R = e.Degree - b] = I.szr, n[R] = I.szi, b = (T -= I.NZ) - 1, G = 0; G < T; G++) {t[G] = w[G];}1 != I.NZ && (r[R + 1] = I.lzr, n[R + 1] = I.lzi);break;}for (G = 0; G < b; G++) {S[G] = N[G];}}if (A > 20) {e.Degree -= b;break;}}}(t, e, r, n);for (var o = [], i = e.length - t.Degree - 1; i < e.length; i++) {Math.abs(n[i]) < 1e-8 && o.push(r[i]);}return o;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.relaxBCurveToPerpendicular = t.closestBCurveSegments = t.maxDistanceSqrToHull = t.minDistanceSqrToHull = void 0;var n = r(1),o = r(0),i = r(37),s = r(35),a = function a(e, t) {var r,i = t.length / 3,s = n.Vector3.asFloat64(0, 0, 0);for (r = 0; r < i; ++r) {s[0] += t[3 * r], s[1] += t[3 * r + 1], s[2] += t[3 * r + 2];}n.Vector3.scale(s, s, 1 / i), n.Vector3.sub(s, s, e);var a = n.Vector3.squaredLength(s);if (a < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var c = Number.POSITIVE_INFINITY;for (r = 0; r < i; ++r) {var u = s[0] * (t[3 * r] - e[0]) + s[1] * (t[3 * r + 1] - e[1]) + s[2] * (t[3 * r + 2] - e[2]);u < c && (c = u);}return c <= 0 ? 0 : c * c / a;},c = function c(e, t) {for (var r = t.length / 3, n = 0, o = 0; o < r; ++o) {var i = t[3 * o] - e[0],s = t[3 * o + 1] - e[1],a = t[3 * o + 2] - e[2],c = i * i + s * s + a * a;c > n && (n = c);}return n;};t.minDistanceSqrToHull = a, t.maxDistanceSqrToHull = c, t.closestBCurveSegments = function (e, t, r, o) {for (var i = Number.POSITIVE_INFINITY, s = [], u = 0; u < t.length; ++u) {var l,h = t[u],d = h.getRangeUnlimited();if (o) {l = !1;for (var g = 0; g < o.length; ++g) {if (d[1] >= o[g][0] + n.FLOAT64_TOLERANCE && d[0] <= o[g][1] - n.FLOAT64_TOLERANCE) {l = !0;break;}}} else l = !0;if (l) {var p = r ? r[u] : 0,f = h.getControlPoints(),v = a(e, f);if ((v = Math.max(0, v - p)) <= i) {var _ = c(e, f) + p;s.push({ index: u, minDistSqr: v, maxDistSqr: _ }), _ < i && (i = _);}}}return (s = s.filter(function (e) {return e.minDistSqr <= i;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.relaxBCurveToPerpendicular = function (e, t, r, o, a, c, u, l) {var h = u || n.FLOAT64_TOLERANCE,d = l || 32,g = t.length / 3,p = e.length - g - 1;return (0, s.newtonRaphson1D)(function (n) {var s = (0, i.evaluateBCurveDerivs)(n, 2, p, e, t, r),a = s[0],c = s[1],u = s[2],l = [a[0] - o[0], a[1] - o[1], a[2] - o[2]];return { val: 2 * (l[0] * c[0] + l[1] * c[1] + l[2] * c[2]), deriv: 2 * (l[0] * u[0] + l[1] * u[1] + l[2] * u[2] + (c[0] * c[0] + c[1] * c[1] + c[2] * c[2])) };}, c, a, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Sphere = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.SPHERE;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t;var s = void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE,a = void 0 === o || n.Vector3.squaredLength(o) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE;s && a ? (n.Vector3.set(this._xAxis, 1, 0, 0), n.Vector3.set(this._zAxis, 0, 0, 1)) : s ? (n.Vector3.normalize(this._xAxis, o), n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)) : a ? (n.Vector3.normalize(this._zAxis, r), n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)) : (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o), n.Vector3.normalize(this._zAxis, r)), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), (n.Vector3.squaredLength(this._zAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)), this._computeYAxis();}, l.prototype.evaluatePosition = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = this._radius * o * s,c = this._radius * o * i,u = this._radius * r,l = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(l, l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = -this._radius * r * s,c = -this._radius * r * i,u = this._radius * o,l = n.Vector3.createFloat64();return n.Vector3.scale(l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateDv = function (e, t) {var r = Math.cos(e),o = Math.sin(t),i = Math.cos(t),s = -this._radius * r * o,a = this._radius * r * i,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, s), n.Vector3.scaleAndAdd(c, c, this._yAxis, a), c;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.length(t);if (r < i.KERNEL_TOLERANCE) return { u: 0, v: 0 };var s = n.Vector3.dot(t, this._xAxis),a = n.Vector3.dot(t, this._yAxis),c = n.Vector3.dot(t, this._zAxis);return { u: Math.asin((0, o.clamp)(c / r, -1, 1)), v: Math.atan2(a, s) };}, l.prototype.vParamLine = function (e) {var t = Math.cos(e),r = Math.sin(e),o = this._radius * t,s = this._radius * r;if (Math.abs(o) > i.KERNEL_TOLERANCE) {var u = new c.Circle(),l = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(l, l, this._zAxis, s);var h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, o);var d = n.Vector3.clone(this._zAxis);return n.Vector3.negate(d, d), u.set(l, d, h), u;}var g = n.Vector3.clone(this._center);return s = s < 0 ? -this._radius : this._radius, n.Vector3.scaleAndAdd(g, g, this._zAxis, s), new a.Point(g);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._radius * o,s = this._radius * r,a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, -s), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.normalize(a, a);var u = n.Vector3.clone(this._xAxis);return n.Vector3.scale(u, u, i), n.Vector3.scaleAndAdd(u, u, this._yAxis, s), t.set(this._center, a, u), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || [-Math.PI / 2, Math.PI / 2], t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = 0; l < 3; ++l) {for (var h = 0; h < 2; ++h) {var d = 0 === h ? 1 : -1,g = Math.atan2(d * this._yAxis[l], d * this._xAxis[l]),p = Math.asin(d * this._zAxis[l]);g = (0, o.adjustParameterToPeriodicRange)(g, t, o.PI2), p > r && p < i && g > s && g < a && (n.Vector3.set(u, 0, 0, 0), u[l] = d * this._radius, c.includePoint(n.Vector3.add(u, this._center, u)));}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-Math.PI / 2, Math.PI / 2];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Sphere = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Torus = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._lemon = !1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.TORUS;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._lemon = e._lemon, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._majorRadius = t, u.ConsoleUtils.assert(r > i.KERNEL_TOLERANCE), this._minorRadius = r, u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, o), void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._lemon = !0 === a, this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.isDoughnut = function () {return this._majorRadius > this._minorRadius + i.KERNEL_TOLERANCE;}, l.prototype.isVortex = function () {return Math.abs(this._majorRadius - this._minorRadius) <= i.KERNEL_TOLERANCE;}, l.prototype.isApple = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && !this._lemon;}, l.prototype.isLemon = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && this._lemon;}, l.prototype.setLemon = function (e) {this._lemon = e;}, l.prototype.getSingularUParams = function () {var e, t, r;return this.isDoughnut() ? [] : this.isApple() ? (e = -this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : this.isLemon() ? (e = this._minorRadius - this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : [-Math.PI, Math.PI];}, l.prototype.evaluatePosition = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.sin(e),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = -this._minorRadius * Math.sin(e),o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.cos(e),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateDv = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis),a = Math.sqrt(r * r + o * o);return this.isLemon() ? a += this._majorRadius : a -= this._majorRadius, { u: s * s + a * a > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(s, a) : 0, v: r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(o, r) : 0 };}, l.prototype.vParamLine = function (e) {var t = this._minorRadius * Math.cos(e);this.isLemon() ? t -= this._majorRadius : t += this._majorRadius;var r = this._minorRadius * Math.sin(e);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var o = new c.Circle(),s = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(s, s, this._zAxis, r);var u = n.Vector3.clone(this._xAxis);n.Vector3.scale(u, u, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), o.set(s, l, u), o;}var h = n.Vector3.clone(this._center),d = this.getSingularUParams();return d[0] && r < 0 ? r = this._minorRadius * Math.sin(d[0]) : d[1] && r > 0 && (r = this._minorRadius * Math.sin(d[1])), n.Vector3.scaleAndAdd(h, h, this._zAxis, r), new a.Point(h);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._majorRadius * o,s = this._majorRadius * r;this.isLemon() && (i = -i, s = -s);var a = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(a, a, this._xAxis, i), n.Vector3.scaleAndAdd(a, a, this._yAxis, s);var u = this._minorRadius * o,l = this._minorRadius * r,h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, -l), n.Vector3.scaleAndAdd(h, h, this._yAxis, u), n.Vector3.normalize(h, h);var d = n.Vector3.clone(this._xAxis);return n.Vector3.scale(d, d, u), n.Vector3.scaleAndAdd(d, d, this._yAxis, l), t.set(a, h, d), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || (this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams()), t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = n.Vector3.createFloat64(), h = 0; h < 3; ++h) {for (var d = 0; d < 2; ++d) {var g = 0 === d ? -1 : 1,p = Math.atan2(g * this._yAxis[h], g * this._xAxis[h]);if ((p = (0, o.adjustParameterToPeriodicRange)(p, t, o.PI2)) > s && p < a) {var f = this.uParamLine(p);u = f.evaluatePosition(0), n.Vector3.sub(u, u, f.getCenter()), l = f.evaluatePosition(Math.PI / 2), n.Vector3.sub(l, l, f.getCenter());var v = (0, o.minMaxCosSinFunc)(u[h], l[h], f.getCenter()[h], e);0 === h ? c.includeX(v[d]) : 1 === h ? c.includeY(v[d]) : c.includeZ(v[d]);}}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams();}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return this.isDoughnut();}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return this.isDoughnut() || this.isVortex();}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), coordAxis: this.vectorToObject(this.getUvOriginDir()), axis: this.vectorToObject(this.getAxisDir()), majorRadius: this.getMajorRadius(), minorRadius: this.getMinorRadius(), lemon: this.isLemon(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Torus = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBSurfaceDerivs = t.evaluateBSurfacePoint = void 0;var n = r(1),o = r(3),i = r(17),s = r(37);t.evaluateBSurfacePoint = function (e, t, r, o, a, c, u, l) {return l && l.length > 0 ? function (e, t, r, o, a, c, u, l) {for (var h, d = c.length - o - 1, g = (0, i.findKnotSpan)(e, a), p = (0, s.evaluateBasisFunctions)(g, e, r, a), f = (0, i.findKnotSpan)(t, c), v = (0, s.evaluateBasisFunctions)(f, t, o, c), _ = g - r, y = n.Vector4.createFloat64(), m = n.Vector4.createFloat64(), E = 0; E <= o; E++) {n.Vector4.set(m, 0, 0, 0, 0), h = f - o + E;for (var x = 0; x <= r; x++) {var R = (_ + x) * d + h,A = p[x] * l[R];m[0] += A * u[3 * R], m[1] += A * u[3 * R + 1], m[2] += A * u[3 * R + 2], m[3] += A;}y[0] += v[E] * m[0], y[1] += v[E] * m[1], y[2] += v[E] * m[2], y[3] += v[E] * m[3];}return n.Vector3.createFloat64FromValues(y[0] / y[3], y[1] / y[3], y[2] / y[3]);}(e, t, r, o, a, c, u, l) : function (e, t, r, o, a, c, u) {for (var l, h = c.length - o - 1, d = (0, i.findKnotSpan)(e, a), g = (0, s.evaluateBasisFunctions)(d, e, r, a), p = (0, i.findKnotSpan)(t, c), f = (0, s.evaluateBasisFunctions)(p, t, o, c), v = d - r, _ = n.Vector3.createFloat64(), y = n.Vector3.createFloat64(), m = 0; m <= o; m++) {n.Vector3.set(y, 0, 0, 0), l = p - o + m;for (var E = 0; E <= r; E++) {var x = (v + E) * h + l;y[0] += g[E] * u[3 * x], y[1] += g[E] * u[3 * x + 1], y[2] += g[E] * u[3 * x + 2];}_[0] += f[m] * y[0], _[1] += f[m] * y[1], _[2] += f[m] * y[2];}return _;}(e, t, r, o, a, c, u);}, t.evaluateBSurfaceDerivs = function (e, t, r, a, c, u, l, h, d) {return function (e, t, r, a, c, u, l, h, d) {var g,p,f,v,_,y,m = new Array(r + 1),E = new Array(r + 1),x = new Array(r + 1),R = new Array(r + 1);for (g = 0; g <= r; g++) {for (m[g] = new Array(r + 1 - g), E[g] = new Array(r + 1 - g), p = 0; p <= r - g; p++) {m[g][p] = n.Vector3.createFloat64(), E[g][p] = 0;}x[g] = new Array(a + 1), R[g] = new Array(c + 1);}var A = Math.min(r, a),P = (0, i.findKnotSpan)(e, u);(0, s.evaluateBasisDerivatives)(P, e, a, A, u, x);var V = Math.min(r, c),T = (0, i.findKnotSpan)(t, l);(0, s.evaluateBasisDerivatives)(T, t, c, V, l, R);var C = d && d.length > 0,b = l.length - c - 1,L = new Array(c + 1);for (g = 0; g <= A; g++) {for (f = 0; f <= c; f++) {for (L[f] = [0, 0, 0, 0], v = 0; v <= a; v++) {var O = (P - a + v) * b + (T - c + f),S = x[g][v];C && (S *= d[O], L[f][3] += S), L[f][0] += S * h[3 * O], L[f][1] += S * h[3 * O + 1], L[f][2] += S * h[3 * O + 2];}}var M = Math.min(r - g, V);for (p = 0; p <= M; p++) {for (f = 0; f <= c; f++) {m[g][p][0] += R[p][f] * L[f][0], m[g][p][1] += R[p][f] * L[f][1], m[g][p][2] += R[p][f] * L[f][2], C && (E[g][p] += R[p][f] * L[f][3]);}}}if (C) {var w = o.binomialCoefficients,N = n.Vector3.createFloat64();for (g = 0; g <= r; g++) {for (p = 0; p <= r - g; p++) {var F = m[g][p];for (y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(F, F, m[g][p - y], -w[p][y] * E[0][y]);}for (_ = 1; _ <= g; _++) {for (n.Vector3.scaleAndAdd(F, F, m[g - _][p], -w[g][_] * E[_][0]), n.Vector3.set(N, 0, 0, 0), y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(N, N, m[g - _][p - y], w[p][y] * E[_][y]);}n.Vector3.scaleAndAdd(F, F, N, -w[g][_]);}n.Vector3.scale(F, F, 1 / E[0][0]);}}}return m;}(e, t, r, a, c, u, l, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.newtonRaphson2D = t.RelaxResult = void 0;var n = r(1),o = {};o[o.Success = 0] = "Success", o[o.OutOfRange = 1] = "OutOfRange", o[o.DegenerateStep = 2] = "DegenerateStep", o[o.TooManySteps = 3] = "TooManySteps", o[o.RootNotFound = 4] = "RootNotFound", t.RelaxResult = o, t.newtonRaphson2D = function (e, t, r, i, s) {i = i || 1e-12, s = s || 100;var a = [void 0, void 0];r && 2 === r.length && (r[0] && 2 === r[0].length && (a[0] = r[0]), r[1] && 2 === r[1].length && (a[1] = r[1])), a[0] && (a[0][0], a[0][1]), a[1] && (a[1][0], a[1][1]);for (var c = [0, 0], u = 1 / 0, l = 1 / 0, h = !1, d = n.Matrix22.createFloat64(), g = n.Matrix22.createFloat64(), p = n.Vector2.clone(t), f = o.Success, v = 0; v <= s; v++) {var _ = e(p);if (u = n.Vector2.squaredLength(_.val), p[0], p[1], u < n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {f = o.Success;break;}if (v > 0) {var y = Math.max(Math.abs(c[0]), Math.abs(c[1]));if (y < i) {u >= l && (n.Vector2.sub(p, p, c), u = l, _ = e(p));var m = 10 * i * (n.Vector2.len(_.deriv1) + n.Vector2.len(_.deriv2)),E = m * m;f = u > E ? h ? o.OutOfRange : o.RootNotFound : o.Success;break;}}if (v === s) {u >= l && (n.Vector2.sub(p, p, c), u = l), f = o.TooManySteps;break;}if (v > 0 && u >= l) {var x = l / (l + u);x = Math.max(x, .1), n.Vector2.sub(p, p, c), n.Vector2.scale(c, c, x), n.Vector2.add(p, p, c), u = l;} else {if (l = u, n.Matrix22.set(d, -_.deriv1[0], -_.deriv1[1], -_.deriv2[0], -_.deriv2[1]), Math.abs(n.Matrix22.determinant(d)) < n.FLOAT64_TOLERANCE) {f = o.DegenerateStep;break;}n.Matrix22.invert(g, d), n.Vector2.transformMatrix22(c, _.val, g), c[0], c[1], n.Vector2.add(p, p, c), h = !1;for (var R = 0; R < 3; R++) {var A = R >= 2,P = R % 2;if (a[P]) {var V = 0;if (p[P] < a[P][0] ? (V = p[P] - a[P][0], p[P] = a[P][0]) : p[P] > a[P][1] && (V = p[P] - a[P][1], p[P] = a[P][1]), 0 !== V) {p[P];var T = c[P];if (c[P] -= V, A) ;else {var C = 1 - P;if (p[C] -= c[C], Math.abs(c[P]) > i) {var b = c[P] / T;c[C] *= b;} else {h = !0;var L = 0 === C ? _.deriv1 : _.deriv2;c[C] = -n.Vector2.dot(_.val, L) / Math.max(n.Vector2.dot(L, L), n.FLOAT64_TOLERANCE);}p[C] += c[C], c[0], c[1];}}}}}}return o[f], p[0], p[1], { param: p, status: f };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getOrderedFacesOnVertex = function (e) {var t = e.getEdges(),r = new n(e),o = [];return t.forEach(function (t) {var n = t.getCoedges();for (var _t6 = 0; _t6 < n.length; ++_t6) {if (n[_t6].getStartVertex() === e) {var _e3 = r.marchFan(n[_t6]);_e3.faces.length > 0 && o.push(_e3);break;}}}), o;};var n = /*#__PURE__*/function () {function n(e) {_classCallCheck(this, n);this._vertex = e, this._visitedCoeds = new Set(), this._unvisitedCoeds = new Set(), this._faces = [], this._type = "unset";}_createClass(n, [{ key: "addVisitedCoedge", value: function addVisitedCoedge(e) {this._visitedCoeds.add(e), this._unvisitedCoeds.delete(e);} }, { key: "getNextFace", value: function getNextFace(e) {var t = e.getFace();t && this._faces.push(t), this.addVisitedCoedge(e);} }, { key: "getPrevFace", value: function getPrevFace(e) {var t = e.getFace();t && this._faces.unshift(t), this.addVisitedCoedge(e);} }, { key: "collectUnvisitedCoeds", value: function collectUnvisitedCoeds(e) {var _this = this;e.getEdge().getCoedges().forEach(function (e) {_this._visitedCoeds.has(e) || e.getStartVertex() !== _this._vertex || _this._unvisitedCoeds.add(e);});} }, { key: "nextFace", value: function nextFace(e) {var t = e.getPartner();if (!t) return void ("unset" === this._type && (this._type = "chain"));if (this._visitedCoeds.has(t)) return;if (t.getPartner() !== e && (this._type = "unordered", this.collectUnvisitedCoeds(e)), t.getEndVertex() !== this._vertex) return this._type = "unordered", void this.collectUnvisitedCoeds(t);this.addVisitedCoedge(t);var r = t.getNext();if (!this._visitedCoeds.has(r)) return this.getNextFace(r), r;"unset" === this._type && (this._type = "cycle");} }, { key: "prevFace", value: function prevFace(e) {var t = e.getPrevious();if (this._visitedCoeds.has(t)) return;var r = t.getPartner();return r && !this._visitedCoeds.has(r) ? (r.getPartner() !== t && (this._type = "unordered", this.collectUnvisitedCoeds(t)), r.getStartVertex() !== this._vertex ? (this._type = "unordered", void this.collectUnvisitedCoeds(r.getNext())) : (this.addVisitedCoedge(t), this.getPrevFace(r), r)) : void 0;} }, { key: "collectFanFaces", value: function collectFanFaces(e) {if (this._visitedCoeds.has(e)) return;var t = e;this.getNextFace(t);var r = t;for (; r;) {r = this.nextFace(r);}for (r = t; r;) {r = this.prevFace(r);}} }, { key: "marchFan", value: function marchFan(e) {for (this._faces = [], this._type = "unset", this.collectFanFaces(e); this._unvisitedCoeds.size > 0;) {var _e4 = this._unvisitedCoeds.values();this.collectFanFaces(_e4.next().value);}return { faces: this._faces, type: this._type };} }]);return n;}();}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Attribute = void 0;var n = r(44);var o = { "autodesk.brep:nmiattributestr-1.0.0": "nmiattributestr", "autodesk.brep:nmiattributearr-1.0.0": "nmiattributearr", "autodesk.brep:textattribute-1.0.0": "textattribute" };var i = function i(e, t) {n.Base.call(this), this._topologies = [], this.typeid = e, this.values = t || {};};(i.prototype = Object.create(n.Base.prototype)).getValues = function () {return this.values;}, i.prototype.getTypeid = function () {return this.typeid;}, i.prototype.getTopologies = function () {return this._topologies;}, i.prototype.addTopology = function (e) {this._topologies ? this._topologies.push(e) : this._topologies = [e];}, i.prototype.removeTopology = function (e) {var t = this._topologies.indexOf(e);return t > -1 && (this._topologies.splice(t, 1), !0);}, i.prototype.toObject = function () {return this.values;}, i.prototype.addToModelObject = function (e) {if (!e.attributes[this.getGuid()]) {var _t7 = o[this.typeid];if (_t7) {var _r4 = {};_r4[_t7] = this.toObject(), e.attributes[this.getGuid()] = _r4;} else console.warn("Attribute.addToModelObject : Unknown attribute type for proto object!");}}, t.Attribute = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SketchRegionSolver = void 0;var n = r(1),o = r(3),i = r(0),s = r(18),a = r(7),c = r(14),u = r(33),l = r(23),h = r(6),d = r(13),g = r(27),p = r(81),f = r(82),v = r(56),_ = r(36),y = r(55),m = r(41),E = r(112),x = r(113),R = r(2),A = r(8),P = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),V = function V() {this.SIDE = { LEFT: 0, RIGHT: 1 }, this._sketch = void 0, this._intersectionVertices = [], this._edgeSegments = [], this._cells = [], this._faces = [], this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, edgesPerCell: void 0 }, this._sketchRegionTopologies = {}, this._planeGeometry = new s.Plane(), this._planeGeometry.set([0, 0, 0], [0, 0, 1], [1, 0, 0]), this._sketchSummary = {}, this._internalToFinalMap = null, this._finalFaces = [], this._progenitorMap = null;};V.prototype.compute = function (e) {this._sketchEdges = e, this._initializeWorkspace(), this._findIntersections(), this._addGraphEdges(), this._mergeCoincidentSegments(), this._sortEdgesAroundVertex(), this._assignAdjacentEdges(), this._sweepRegions(), this._assignleftmostEdges(), this._removeGrazingIntersectionVertices(), this._updateVertexGuidLists(), this._removeTemporaryVertices(), this._assignLoops(), this._updateSketchRegionTopology(), this._clearWorkspace(), this._prepareResult();}, V.prototype._initializeWorkspace = function () {var e = this._workspace;e.edges = {};for (var t = 0; t < this._sketchEdges.length; ++t) {e.edges[this._sketchEdges[t].getGuid()] = this._sketchEdges[t];}for (e.edgeIDs = Object.getOwnPropertyNames(e.edges).sort(), e.edgeIntersections = {}, e.edgeOverlapRegions = {}, e.segmentBlackList = {}, t = 0; t < e.edgeIDs.length; t++) {e.edgeIntersections[e.edgeIDs[t]] = [], e.edgeOverlapRegions[e.edgeIDs[t]] = [], e.segmentBlackList[e.edgeIDs[t]] = [];}e.sweepLineIntersections = void 0, e.sweepLineRegions = void 0, e.edgesPerCell = [], this._faces = [];}, V.prototype._clearWorkspace = function () {this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, sweepLinePosition: void 0, edgesPerCell: [] };}, V.prototype._findIntersections = function () {for (var e = this._workspace, t = 0; t < e.edgeIDs.length; t++) {for (var r = e.edges[e.edgeIDs[t]], s = t; s < e.edgeIDs.length; s++) {var a = e.edges[e.edgeIDs[s]];if (s > t || r.getCurveType() === i.GEOMETRY_TYPES.BCURVE) for (var c = (0, p.computeCurveCurveIntersections)(r, a, !0, !1, i.KERNEL_TOLERANCE), u = 0; u < c.length; u++) {var l = c[u];if (l.rangeInfo) e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[1], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[1], { temporary: !1 })), e.edgeOverlapRegions[e.edgeIDs[t]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[s], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE) }), e.edgeOverlapRegions[e.edgeIDs[s]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[t], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE) });else {if (l.cutInfo.param < r.t0() || l.cutInfo.param > r.t1()) {A.DebugUtils.warn("Intersection outside the bounds of the edge, ignoring");continue;}e.edgeIntersections[e.edgeIDs[t]].push(P.default.defaults(l.cutInfo, { temporary: !1, virtualIntersection: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.defaults(l.cutByInfo, { temporary: !1, virtualIntersection: !1 }));}}}var h = r.getStartVertex(),d = r.getEndVertex(),g = r.t0();h && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: g, atVertex: h }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: g, atVertex: h, temporary: !1, virtualIntersection: void 0 });var f = r.t1();d && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: f, atVertex: d }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: f, atVertex: d, temporary: !1, virtualIntersection: void 0 }), this._makeEdgeXMonotone(r, e.edgeIntersections[e.edgeIDs[t]]);}var v = [];for (t = 0; t < e.edgeIDs.length; t++) {for (s = 0; s < e.edgeIntersections[e.edgeIDs[t]].length; s++) {v.push({ position: e.edges[e.edgeIDs[t]].evaluatePosition(e.edgeIntersections[e.edgeIDs[t]][s].param), virtualIntersection: e.edgeIntersections[e.edgeIDs[t]][s].virtualIntersection });}}for (t = 0; t < e.edgeIDs.length; t++) {var _ = e.edges[e.edgeIDs[t]];for (s = 0; s < v.length; s++) {var y = v[s];if (_.getBoundingBox().isPointInsideWithTolerance(y.position, i.KERNEL_TOLERANCE)) {var m = _.closestToPointParam(y.position);n.Vector3.distance(y.position, _.evaluatePosition(m)) < i.KERNEL_TOLERANCE && m > _.t0() + i.PARAMETER_SPACE_TOLERANCE && m < _.t1() - i.PARAMETER_SPACE_TOLERANCE && e.edgeIntersections[e.edgeIDs[t]].push({ param: m, atVertex: null, temporary: !0, virtualIntersection: y.virtualIntersection });}}}}, V.prototype._addGraphEdges = function () {var e = this._workspace;this._intersectionVertices = [], this._edgeSegments = [];for (var t = function t(_t8, r) {var n = e.segmentBlackList[_t8],s = e.edges[_t8].getCurve(),a = s.getPeriod(),c = e.edges[_t8].isReversed() ? -1 : 1,u = i.KERNEL_TOLERANCE / s.tangentLength(c * r[0]),l = i.KERNEL_TOLERANCE / s.tangentLength(c * r[1]);if (e.edges[_t8].getCurve().isPeriodic()) {for (var h = 0; h < n.length; h++) {if ((0, o.periodicDifference)(n[h].range[0], r[0], a) < u && (0, o.periodicDifference)(n[h].range[1], r[1], a) < l) return n[h].edge;}} else for (h = 0; h < n.length; h++) {if (Math.abs(n[h].range[0] - r[0]) < u && Math.abs(n[h].range[1] - r[1]) < l) return n[h].edge;}}, r = 0; r < e.edgeIDs.length; r++) {var s = e.edges[e.edgeIDs[r]],a = 1,c = this._createGUIDfromEdgeAndLocalID(s, a);e.edgeIntersections[e.edgeIDs[r]] = e.edgeIntersections[e.edgeIDs[r]].sort(function (e, t) {return e.param - t.param;});for (var u = e.edgeIntersections[e.edgeIDs[r]], l = void 0, h = 0; h < u.length; h++) {var d = s.evaluatePosition(u[h].param),g = this._findVertexIndex(d);void 0 === g ? (g = this._intersectionVertices.length, this._intersectionVertices.push({ position: d, adjacentEdges: [], vertices: [], index: g, guidList: [], mergedPositions: [], topologyVertex: void 0, temporary: u[h].temporary, virtualIntersection: u[h].virtualIntersection })) : (this._intersectionVertices[g].temporary = this._intersectionVertices[g].temporary && u[h].temporary, void 0 !== u[h].virtualIntersection && (void 0 === this._intersectionVertices[g].virtualIntersection ? this._intersectionVertices[g].virtualIntersection = u[h].virtualIntersection : this._intersectionVertices[g].virtualIntersection = this._intersectionVertices[g].virtualIntersection && u[h].virtualIntersection), this._intersectionVertices[g].mergedPositions.push(d));var p = this._intersectionVertices[g];if (u[h].atVertex && -1 === p.vertices.indexOf(u[h].atVertex) && p.vertices.push(u[h].atVertex), h > 0 && l !== g) {c = this._createGUIDfromEdgeAndLocalID(s, a), a++;var f = [u[h - 1].param, u[h].param],v = t(s.getGuid(), f);if (void 0 === v) {var _ = { originalEdge: s, parameterRange: f, startVertex: this._intersectionVertices[l], endVertex: this._intersectionVertices[g], coincidentRanges: [], adjacent: [{ prevEdge: void 0, nextEdge: void 0, face: void 0 }, { prevEdge: void 0, nextEdge: void 0, face: void 0 }], index: this._edgeSegments.length, localGuid: c, topologyEdge: void 0 };this._edgeSegments.push(_), this._intersectionVertices[l].adjacentEdges.push(_), this._intersectionVertices[g].adjacentEdges.push(_);for (var y = 0; y < e.edgeOverlapRegions[e.edgeIDs[r]].length; y++) {var m = e.edgeOverlapRegions[e.edgeIDs[r]][y],E = f,x = i.KERNEL_TOLERANCE;if (s.getCurve().isPeriodic() && (s.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && (x /= s.getCurve().getRadius()), E = (0, o.convertToOtherPeriodicRange)(E, s.getRange(), s.getCurve().getPeriod(), x)), E[0] >= m.overlapRange[0] - i.KERNEL_TOLERANCE && E[1] <= m.overlapRange[1] + i.KERNEL_TOLERANCE) {var R = m.otherEdge,A = [e.edges[R].getCurve().closestToPointParam(_.startVertex.position), e.edges[R].getCurve().closestToPointParam(_.endVertex.position)];if (e.edges[R].getCurve().isPeriodic()) {var P = _.originalEdge.getCurve().evaluateDt(_.parameterRange[0]),V = e.edges[R].getCurve().evaluateDt(A[0]);for (n.Vector3.dot(P, V) < 0 && (T = A[0], A[0] = A[1], A[1] = T); A[1] < A[0];) {A[1] += e.edges[R].getCurve().getPeriod();}} else if (A[0] > A[1]) {var T = A[0];A[0] = A[1], A[1] = T;}e.segmentBlackList[m.otherEdge].push({ range: A, edge: _ });}}} else {var C,b = n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[0])) > n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[1]));if (v.coincidentRanges.push({ originalEdge: s, parameterRange: f, localGuid: c, flipped: b }), 0 === p.adjacentEdges.length && ((C = n.Vector3.distance(d, v.startVertex.position) < n.Vector3.distance(d, v.endVertex.position) ? v.startVertex : v.endVertex).mergedPositions.push(d), d = C.position, g = C.index, u[h].atVertex && -1 === C.vertices.indexOf(u[h].atVertex) && C.vertices.push(u[h].atVertex), this._intersectionVertices.pop()), v.startVertex.index !== l && v.endVertex.index !== l) {var L = v.startVertex.index === g ? v.endVertex : v.startVertex,O = this._intersectionVertices[l];for (y = 0; y < O.adjacentEdges.length; y++) {var S = O.adjacentEdges[y];S.startVertex === O && (S.startVertex = L), S.endVertex === O && (S.endVertex = L), L.adjacentEdges.push(S);}for (L.mergedPositions.push(O.position), y = 0; y < O.mergedPositions.length; y++) {L.mergedPositions.push(O.mergedPositions[y]);}for (u[h].atVertex && -1 === L.vertices.indexOf(u[h].atVertex) && L.vertices.push(u[h].atVertex), this._intersectionVertices.splice(l, 1), y = l; y < this._intersectionVertices.length; y++) {this._intersectionVertices[y].index = y;}}}}l = g;}}}, V.prototype._mergeCoincidentSegments = function () {for (var e, t = {}, r = 0; r < this._intersectionVertices.length; r++) {for (var n = this._intersectionVertices[r], o = {}, s = 0; s < n.adjacentEdges.length; s++) {var a = (e = n.adjacentEdges[s]).startVertex === n ? e.endVertex : e.startVertex;t[String(n.index) + "_" + String(a.index)] || (o[String(a.index)] = o[String(a.index)] || [], o[String(a.index)].push(e));}var c = P.default.keys(o);for (s = 0; s < c.length; s++) {if (t[c[s] + "_" + String(n.index)] = !0, o[c[s]].length > 1) for (var u = o[c[s]], l = 0; l < u.length; l++) {for (var h = [], d = l + 1; d < u.length; d++) {(0, f.curvesAreCoincident)(u[l].originalEdge.getCurve(), u[d].originalEdge.getCurve(), u[l].parameterRange, u[d].parameterRange, i.KERNEL_TOLERANCE) && (h.push(u[d]), u.splice(d, 1), d--);}for (d = 0; d < h.length; d++) {var g = h[d];u[l].coincidentRanges.push({ originalEdge: g.originalEdge, parameterRange: g.parameterRange, localGuid: g.localGuid, flipped: g.startVertex !== u[l].startVertex }), g.startVertex.adjacentEdges.splice(g.startVertex.adjacentEdges.indexOf(g), 1), g.endVertex.adjacentEdges.splice(g.endVertex.adjacentEdges.indexOf(g), 1);var p = this._edgeSegments.indexOf(g);this._edgeSegments.splice(p, 1);for (var v = p; v < this._edgeSegments.length; v++) {this._edgeSegments[v].index = v;}}}}}}, V.prototype._sortEdgesAroundVertex = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {for (var t = this._intersectionVertices[e], r = [], s = 0; s < t.adjacentEdges.length; s++) {var a = this._computeAngleAndPositionForEdge(s, t);r.push({ index: s, originalAngle: a.angle, angle: a.angle, position: a.position, derivative: void 0 });}for (var c = 0, u = !1; !u;) {u = !0;var l = -Math.PI + c;for (s = 0; s < r.length; s++) {if ((0, o.angleDifference)(l, r[s].angle) < 1e-5) {u = !1;break;}}if (u) break;c += 2e-5;}for (s = 0; s < t.adjacentEdges.length; s++) {r[s].angle = (0, o.normalizeParameterToShiftedRange)(r[s].angle - c, [-Math.PI, Math.PI]);}var h = this;r = r.sort(function (e, r) {if ((0, o.angleDifference)(e.angle, r.angle) > 1e-5) return e.angle - r.angle;var s = t.adjacentEdges[e.index],a = t.adjacentEdges[r.index],c = s.startVertex === t ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = s.originalEdge.evaluatePosition(c),d = a.originalEdge.evaluatePosition(u),g = n.Vector3.distance(l, d),p = n.Vector3.createFloat64(),f = n.Vector3.createFloat64(),v = s.originalEdge.evaluateCurvature(c, p),_ = a.originalEdge.evaluateCurvature(u, f);if (0 === v && 0 === _) return e.angle - r.angle;if (0 === v || 0 === _) {var y = 1 / Math.max(v, _);g += 1.5 * Math.sqrt(Math.pow(y, 2) - Math.pow(y - g, 2)) + i.KERNEL_TOLERANCE;} else {var m = 1 / v,E = 1 / _;if (m < E) {var x = m;m = E, E = x;}n.Vector3.dot(p, f) < 0 ? g += -Math.sqrt(-.25 * Math.pow(g, 4) + Math.pow(g, 3) * m - g * g * m * m - (g * g - 2 * g * m) * E * E + (g * g * g - 3 * g * g * m + 2 * g * m * m) * E) / (g - m - E) * 1.5 : g += Math.sqrt(-.25 * Math.pow(g, 4) - Math.pow(g, 3) * m - g * g * m * m - (g * g + 2 * g * m) * E * E + (g * g * g + 3 * g * g * m + 2 * g * m * m) * E) / (g + m - E) * 1.5;}var R = Math.min(n.Vector3.distance(s.endVertex.position, s.startVertex.position), n.Vector3.distance(a.endVertex.position, a.startVertex.position));g = Math.max(i.KERNEL_TOLERANCE, g), g = Math.min(.9 * R, g);var A = !1;do {var P = h._computeEdgeDirectionAtVertex(e, t, g),V = h._computeEdgeDirectionAtVertex(r, t, g);A = (0, o.angleDifference)(P, V) > 1e-8, g *= 5;} while (!A && g < R);var T = P - V;return T > Math.PI ? T -= o.PI2 : T < -Math.PI && (T += o.PI2), T;}), t.adjacentEdges = P.default.map(r, function (e) {return t.adjacentEdges[e.index];});}}, V.prototype._assignAdjacentEdges = function () {for (var e = 0; e < this._edgeSegments.length; e++) {var t = this._edgeSegments[e];this._assignAdjacentEdgesToSegment(t);}}, V.prototype._assignAdjacentEdgesToSegment = function (e) {var t = e.startVertex.adjacentEdges,r = t.indexOf(e);R.ConsoleUtils.assert(-1 !== r, "Error in topology");for (var n = 0, i = e.endVertex.adjacentEdges; n < i.length && i[n] !== e;) {n++;}R.ConsoleUtils.assert(n < i.length, "Error in topology"), e.adjacent[this.SIDE.LEFT].nextEdge = i[(0, o.modulus)(n - 1, i.length)], e.adjacent[this.SIDE.LEFT].prevEdge = t[(0, o.modulus)(r + 1, t.length)], e.adjacent[this.SIDE.RIGHT].nextEdge = i[(0, o.modulus)(n + 1, i.length)], e.adjacent[this.SIDE.RIGHT].prevEdge = t[(0, o.modulus)(r - 1, t.length)];}, V.prototype._sweepRegions = function () {var e = this._workspace,t = P.default.clone(this._intersectionVertices).sort(function (e, t) {if (Math.abs(e.position[0] - t.position[0]) < 1e-9) {for (var r = 0; r < e.adjacentEdges.length; r++) {for (var o = 0; o < t.adjacentEdges.length; o++) {if (e.adjacentEdges[r].originalEdge === t.adjacentEdges[o].originalEdge) {var s = e.adjacentEdges[r],a = t.adjacentEdges[o],c = s.startVertex === e ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = !0,h = n.Vector3.createFloat64();n.Vector3.normalize(h, s.originalEdge.evaluateDt(c));var d = n.Vector3.createFloat64();if (n.Vector3.normalize(d, a.originalEdge.evaluateDt(u)), Math.sign(h[0]) !== Math.sign(d[0])) continue;if (Math.abs(h[0]) > i.KERNEL_TOLERANCE && Math.abs(d[0]) > i.KERNEL_TOLERANCE) l = h[0] > 0;else {if (Math.abs(e.position[1] - t.position[1]) < i.KERNEL_TOLERANCE) continue;l = h[1] > 0;}return (c - u) * (l ? 1 : -1);}}}return e.position[1] - t.position[1];}return e.position[0] - t.position[0];});this._cells = [];var r = { index: -1, loops: [], loopOrientations: [], dangling: [], leftmostVertex: void 0 };e.sweepLineIntersections = [-1 / 0, 1 / 0], e.sweepLineRegions = e.sweepLineRegions = [r];for (var o = [], s = 0; s < t.length; s++) {e.sweepLineRegions.length !== e.sweepLineIntersections.length - 1 && console.error("Error during sweep computation");var a = t[s],c = P.default.clone(a.adjacentEdges),u = void 0;if (o[a.index]) {for (var l = o[a.index], h = [], d = 0; d < e.sweepLineIntersections.length - 1; d++) {P.default.contains(l, e.sweepLineIntersections[d]) && (void 0 === u && (u = d - 1), P.default.contains(l, e.sweepLineIntersections[d + 1]) && h.push(d));}for (d = 0; d < l.length; d++) {for (var g = l[d], p = 0; p < e.sweepLineIntersections.length; p++) {e.sweepLineIntersections[p] === g && e.sweepLineIntersections.splice(p, 1);}for (p = 0; p < c.length; p++) {c[p] === g && c.splice(p, 1);}}for (d = h.length - 1; d >= 0; d--) {e.sweepLineRegions.splice(h[d], 1);}} else u = this._findVertexOnSweepLine(a), e.sweepLineRegions.splice(u + 1, 0, e.sweepLineRegions[u]);if (c.length > 0) {var f = u + 1;for (d = 0; d < c.length; d++) {var v = c[d];e.sweepLineIntersections.splice(f, 0, v);var _ = v.startVertex === a ? v.endVertex : v.startVertex;if (void 0 === o[_.index] && (o[_.index] = []), o[_.index].push(v), d > 0) {var y = { index: this._cells.length, loops: [], loopOrientations: [], dangling: [], leftmostVertex: a };this._cells.push(y), e.sweepLineRegions.splice(f - 1, 0, y);}f++;}for (f = u, d = 0; d < c.length; d++) {var m = (v = c[d]).startVertex !== a;v.adjacent[m ? this.SIDE.RIGHT : this.SIDE.LEFT].face = e.sweepLineRegions[f + 1], v.adjacent[m ? this.SIDE.LEFT : this.SIDE.RIGHT].face = e.sweepLineRegions[f], f++;}} else if (e.sweepLineRegions[u] !== e.sweepLineRegions[u + 1]) {var E = e.sweepLineRegions[u + 1],x = e.sweepLineRegions[u];for (x === r ? (x = E, E = r, e.sweepLineRegions.splice(u, 1)) : (void 0 !== x.leftmostVertex && (void 0 === E.leftmostVertex || E.leftmostVertex.position[0] > x.leftmostVertex.position[0]) && (E.leftmostVertex = x.leftmostVertex), e.sweepLineRegions.splice(u + 1, 1)), d = 0; d < this._edgeSegments.length; d++) {this._edgeSegments[d].adjacent[this.SIDE.LEFT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.LEFT].face = E), this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face = E);}for (d = 0; d < e.sweepLineRegions.length; d++) {e.sweepLineRegions[d] === x && (e.sweepLineRegions[d] = E);}this._cells[x.index] = void 0;} else e.sweepLineRegions.splice(u + 1, 1);}for (s = 0; s < this._cells.length; s++) {void 0 === this._cells[s] && (this._cells.splice(s, 1), s--);}for (s = 0; s < this._cells.length; s++) {this._cells[s].index = s;}}, V.prototype._assignleftmostEdges = function () {for (var e = this, t = 0; t < this._cells.length; t++) {var r = this._cells[t],n = r.leftmostVertex,o = P.default.filter(n.adjacentEdges, function (t) {var n = t.adjacent[e.SIDE.LEFT].face,o = t.adjacent[e.SIDE.RIGHT].face;return (n === r || o === r) && n !== o;});if (R.ConsoleUtils.assert(o.length >= 2, "In each loop there should be at least two adjacent edges"), o.length > 2) for (var i = 0; i < o.length; i++) {var s = o[i].adjacent[e.SIDE.LEFT].face === r ? e.SIDE.LEFT : e.SIDE.RIGHT,a = o[i].adjacent[s],c = o[i].startVertex === n ? a.prevEdge : a.nextEdge;if (P.default.contains(o, c)) {o = [o[i], c];break;}}var u = o[0];u.loopsCurveAligned = !!(u.startVertex === n ^ o[0].adjacent[e.SIDE.RIGHT].face === r), r.leftmostEdge = u, r.leftmostVertex = void 0;}}, V.prototype._removeGrazingIntersectionVertices = function () {for (var e = {}, t = 0, r = this._intersectionVertices.slice(); r.length > 0;) {var n = r.pop();if (2 === n.adjacentEdges.length && (1 === n.adjacentEdges[0].coincidentRanges.length || 1 === n.adjacentEdges[1].coincidentRanges.length) && n.virtualIntersection) {var i,s,a = 1 === n.adjacentEdges[0].coincidentRanges.length && 1 === n.adjacentEdges[1].coincidentRanges.length,c = n.adjacentEdges.slice();if (a) {if (i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge], s = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge], !(i[0] === s[0] && i[1] === s[1] || i[0] === s[1] && i[1] === s[0])) continue;e[c[0].originalEdge.getGuid()] = !0, e[c[0].coincidentRanges[0].originalEdge.getGuid()] = !0, e[c[1].originalEdge.getGuid()] = !0, e[c[1].coincidentRanges[0].originalEdge] = !0;var u = [c[0].startVertex === n ? c[0].endVertex : c[0].startVertex, n, c[1].startVertex === n ? c[1].endVertex : c[1].startVertex];} else {var l;c[0].coincidentRanges.length > 0 ? (l = 0, i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge]) : (l = 1, i = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge]), e[i[0].getGuid()] = !0, e[i[1].getGuid()] = !0, u = [c[l].startVertex === n ? c[l].endVertex : c[l].startVertex, n], c = [c[l]];}var h = void 0,d = void 0;if (u[0].vertices.length > 0 ? (h = u[0], d = a ? [u[1], u[2]] : [u[1]]) : a && u[2].vertices.length > 0 ? (h = u[2], d = [u[0], u[1]]) : (h = u[1], d = a ? [u[0], u[2]] : [u[0]]), d[0].vertices.length > 0 || d[1] && (d[1].vertices.length > 0 || d[0] === d[1])) continue;for (var g = !0, p = P.default.without(d, n), f = 0; f < p.length; f++) {var v = p[f].adjacentEdges;if ((v = P.default.difference(v, c)).length > 2) {g = !1;break;}for (var _ = 0; _ < v.length; _++) {if (v[_].coincidentRanges.length > 0 || v[_].originalEdge !== i[0] && v[_].originalEdge !== i[1]) {g = !1;break;}}}if (!g) continue;for (f = 0; f < p.length; f++) {var y = p[f],m = P.default.intersection(c, y.adjacentEdges)[0],E = n !== h && a ? P.default.without(c, m)[0] : m,x = P.default.without(y.adjacentEdges, m);for (y.adjacentEdges[1] === m && (x = x.reverse()), _ = 0; _ < x.length; _++) {var R = x[_],A = E.startVertex === h ? 0 : 1,V = void 0;if (E.originalEdge === R.originalEdge) V = E.parameterRange[A];else {var T = E.coincidentRanges[0].flipped ? 1 - A : A;V = E.coincidentRanges[0].parameterRange[T];}R.startVertex === y ? (R.startVertex = h, R.parameterRange[0] = V) : (R.endVertex = h, R.parameterRange[1] = V);for (var C = 0; C < R.adjacent.length; C++) {var b = R.adjacent[C].face;b.leftmostEdge !== m && b.leftmostEdge !== E || (R.loopsCurveAligned = b.leftmostEdge.loopsCurveAligned, b.leftmostEdge = R), (b.leftmostVertex === d[0] || void 0 !== d[1] && b.leftmostVertex === d[1]) && (b.leftmostVertex = h);}}var L = h.adjacentEdges.indexOf(E);Array.prototype.splice.apply(h.adjacentEdges, [L, 1].concat(x));var O = h.adjacentEdges.length,S = [(0, o.modulus)(L - 1, O), L, L + 1, (L + 2) % O];for (_ = 0; _ < S.length; _++) {var M = h.adjacentEdges[S[_]];this._assignAdjacentEdgesToSegment(M);}}this._intersectionVertices = P.default.difference(this._intersectionVertices, d), r = P.default.difference(r, d), this._edgeSegments = P.default.difference(this._edgeSegments, c), t++;}}if (t > 0) {for (var w = 0; w < this._intersectionVertices.length; w++) {this._intersectionVertices[w].index = w;}for (w = 0; w < this._edgeSegments.length; w++) {this._edgeSegments[w].index = w;}}var N = P.default.keys(e);for (w = 0; w < N.length; w++) {var F = N[w],I = [];for (f = 0; f < this._edgeSegments.length; f++) {for ((D = this._edgeSegments[f]).originalEdge.getGuid() === F && I.push([D, D.parameterRange[0]]), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && I.push([D, D.coincidentRanges[_].parameterRange[0]]);}}for (I.sort(function (e, t) {return e[1] - t[1];}), f = 0; f < I.length; f++) {var D;for ((D = I[f][0]).originalEdge.getGuid() === F && (D.localGuid = this._createGUIDfromEdgeAndLocalID(D.originalEdge, f + 1)), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && (D.coincidentRanges[_].localGuid = this._createGUIDfromEdgeAndLocalID(D.coincidentRanges[_].originalEdge, f + 1));}}}}, V.prototype._removeTemporaryVertices = function () {for (var e = 0, t = 0; t < this._intersectionVertices.length; t++) {var r = this._intersectionVertices[t];if (r.temporary && 2 === r.adjacentEdges.length && r.adjacentEdges[0].originalEdge === r.adjacentEdges[1].originalEdge && r.adjacentEdges[0] !== r.adjacentEdges[1]) {var n, o;r.adjacentEdges[0].endVertex === r ? (n = r.adjacentEdges[0], o = r.adjacentEdges[1]) : (n = r.adjacentEdges[1], o = r.adjacentEdges[0]), R.ConsoleUtils.assert(n.adjacent[this.SIDE.LEFT].face === o.adjacent[this.SIDE.LEFT].face), R.ConsoleUtils.assert(n.adjacent[this.SIDE.RIGHT].face === o.adjacent[this.SIDE.RIGHT].face);var s = n.parameterRange[1] - o.parameterRange[0],a = (n.originalEdge.isReversed() ? -1 : 1) * n.parameterRange[0],c = i.KERNEL_TOLERANCE / n.originalEdge.getCurve().tangentLength(a);if (n.originalEdge.getCurve().isPeriodic() && Math.abs(s - n.originalEdge.getCurve().getPeriod()) < c) n.parameterRange[1] = o.parameterRange[1] + s;else {if (Math.abs(s) > c) continue;n.parameterRange[1] = o.parameterRange[1];}n.endVertex = o.endVertex, n.adjacent[this.SIDE.LEFT].nextEdge = o.adjacent[this.SIDE.LEFT].nextEdge, n.adjacent[this.SIDE.RIGHT].nextEdge = o.adjacent[this.SIDE.RIGHT].nextEdge, n.adjacent[this.SIDE.LEFT].prevEdge === o && (n.adjacent[this.SIDE.LEFT].prevEdge = n), n.adjacent[this.SIDE.RIGHT].prevEdge === o && (n.adjacent[this.SIDE.RIGHT].prevEdge = n);var u = n.adjacent[this.SIDE.LEFT].nextEdge;u.adjacent[this.SIDE.LEFT].prevEdge === o && (u.adjacent[this.SIDE.LEFT].prevEdge = n), u.adjacent[this.SIDE.LEFT].nextEdge === o && (u.adjacent[this.SIDE.LEFT].nextEdge = n), u.adjacent[this.SIDE.RIGHT].prevEdge === o && (u.adjacent[this.SIDE.RIGHT].prevEdge = n), u.adjacent[this.SIDE.RIGHT].nextEdge === o && (u.adjacent[this.SIDE.RIGHT].nextEdge = n);var l = n.adjacent[this.SIDE.RIGHT].nextEdge;l.adjacent[this.SIDE.LEFT].prevEdge === o && (l.adjacent[this.SIDE.LEFT].prevEdge = n), l.adjacent[this.SIDE.LEFT].nextEdge === o && (l.adjacent[this.SIDE.LEFT].nextEdge = n), l.adjacent[this.SIDE.RIGHT].prevEdge === o && (l.adjacent[this.SIDE.RIGHT].prevEdge = n), l.adjacent[this.SIDE.RIGHT].nextEdge === o && (l.adjacent[this.SIDE.RIGHT].nextEdge = n), o.adjacent[this.SIDE.LEFT].face.leftmostEdge === o && (o.adjacent[this.SIDE.LEFT].face.leftmostEdge = n), o.adjacent[this.SIDE.RIGHT].face.leftmostEdge === o && (o.adjacent[this.SIDE.RIGHT].face.leftmostEdge = n), void 0 === n.loopsCurveAligned && (n.loopsCurveAligned = o.loopsCurveAligned), (0, v.hashCombine4xUint32)(n.localGuid, o.localGuid, n.localGuid);var h = n.endVertex.adjacentEdges.indexOf(o);n.endVertex.adjacentEdges[h] = n, this._intersectionVertices.splice(t, 1), this._edgeSegments.splice(o.index - e, 1), t--, e++;} else this._intersectionVertices[t].index -= e;}for (t = 0; t < this._edgeSegments.length; t++) {this._edgeSegments[t].index = t;}}, V.prototype._updateVertexGuidLists = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {var t = this._intersectionVertices[e];if (t.vertices.length > 0) for (var r = 0; r < t.vertices.length; r++) {t.guidList.push((0, v.guidToUint32x4)(t.vertices[r].getGuid()));} else {var n = {};for (r = 0; r < t.adjacentEdges.length; r++) {var o = t.adjacentEdges[r];if (!n[o.index]) {n[o.index] = !0, t.guidList.push(o.localGuid);for (var i = 0; i < o.coincidentRanges.length; i++) {t.guidList.push(o.coincidentRanges[i].localGuid);}}}}}}, V.prototype._assignLoops = function () {var e = this._workspace;e.edgesPerCell = [];for (var t = 0; t < this._cells.length; t++) {e.edgesPerCell[t] = [];}for (t = 0; t < this._edgeSegments.length; t++) {var r = this._edgeSegments[t],n = r.adjacent[this.SIDE.LEFT].face.index;n >= 0 && e.edgesPerCell[n].push(r);var o = r.adjacent[this.SIDE.RIGHT].face.index;o >= 0 && n !== o && e.edgesPerCell[o].push(r);}var i = [];for (t = 0; t < this._cells.length; t++) {var s = [];i[t] = s;for (var a = this._followLoopFromEdge(this._cells[t].leftmostEdge, this._cells[t], !1, !0), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}for (t = 0; t < this._cells.length; t++) {s = i[t];for (var u = 0; u < e.edgesPerCell[t].length; u++) {var l = e.edgesPerCell[t][u];if (l.adjacent[this.SIDE.LEFT].face !== l.adjacent[this.SIDE.RIGHT].face) {if (!0 !== s[l.index]) {for (a = this._followLoopFromEdge(l, this._cells[t], !0, !1), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}} else this._cells[t].dangling.push(l);}}}, V.prototype._updateSketchRegionTopology = function () {for (var e = this._workspace, t = P.default.keys(this._sketchRegionTopologies), r = 0; r < t.length; r++) {var n = t[r];this._sketchRegionTopologies[n].updated = !1, "FaceID" === this._sketchRegionTopologies[n].topology.tuid && this._sketchRegionTopologies[n].topology.removeAllEdges();}var o = {},s = {};for (r = 0; r < this._intersectionVertices.length; r++) {var a = this._addOrFindTopologySubcomponent("VertexID", i.GEOMETRY_TYPES.POINT, this._intersectionVertices[r].guidList, s);a.setPoint(new h.Point(this._intersectionVertices[r].position)), a.setAssociatedEntities(P.default.clone(this._intersectionVertices[r].vertices));for (var c = 0; c < this._intersectionVertices[r].vertices.length; ++c) {var u = this._intersectionVertices[r].vertices[c].getGuid();R.ConsoleUtils.assert(!o[u], "vertex should only map to one topology vertex"), o[u] = a;}this._intersectionVertices[r].topologyVertex = a;}for (r = 0; r < this._edgeSegments.length; r++) {var l = this._edgeSegments[r],p = [l.localGuid];for (c = 0; c < l.coincidentRanges.length; c++) {p.push(l.coincidentRanges[c].localGuid);}(V = this._addOrFindTopologySubcomponent("EdgeID", l.originalEdge.getCurveType(), p, s)).setToEdgeSegment(l.originalEdge, l.parameterRange), V.setStartVertex(l.startVertex.topologyVertex), V.setEndVertex(l.endVertex.topologyVertex);var f = [{ edge: l.originalEdge, range: P.default.clone(l.parameterRange), flipped: !1 }];for (c = 0; c < l.coincidentRanges.length; c++) {f.push({ edge: l.coincidentRanges[c].originalEdge, range: P.default.clone(l.coincidentRanges[c].parameterRange), flipped: l.coincidentRanges[c].flipped });}V.setAssociatedEdges(f), l.topologyEdge = V;}for (r = 0; r < this._cells.length; r++) {var _ = this._cells[r];for (p = [], c = 0; c < e.edgesPerCell[r].length; c++) {p.push((0, v.guidToUint32x4)(e.edgesPerCell[r][c].topologyEdge.getGuid()));}var y = this._addOrFindTopologySubcomponent("FaceID", i.GEOMETRY_TYPES.PLANE, p, s);y.setSurface(this._planeGeometry);var m = [];for (c = 0; c < _.loops.length; c++) {var E = new d.Loop();E.setFace(y), m.push(E);for (var x = [], A = 0; A < _.loops[c].length; A++) {var V = _.loops[c][A].topologyEdge,T = new g.Coedge();T.setLoop(E), x.push(T), T.setEdge(V), T.setReversed(!_.loopOrientations[c][A]), V.getCoedge() ? V.getCoedge().getPartner() || (V.getCoedge().setPartner(T), T.setPartner(V.getCoedge())) : V.setCoedge(T), _.loops[c][A].topologyEdge.setIsDangling(!1);}E.setCoedges(x);}for (y.setLoops(m), this._faces.push(y), c = 0; c < _.dangling.length; c++) {y.addDanglingEdge(_.dangling[c].topologyEdge), _.dangling[c].topologyEdge.setIsDangling(!0);}}for (r = 0; r < t.length; r++) {this._sketchRegionTopologies[t[r]].updated || delete this._sketchRegionTopologies[t[r]];}}, V.prototype._followLoopFromEdge = function (e, t, r, n) {var o = [],i = [],s = e,a = [],c = e.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT,u = !!(s.loopsCurveAligned ^ c !== this.SIDE.LEFT),l = u ? e.startVertex : e.endVertex;do {if (s.adjacent[c].face !== t) {console.error("REGION: Adjacent edge face does not match cell! FIXME!");break;}if (a[s.index]) {console.error("REGION: Malformed edges; walking edge lead us to despair");break;}a[s.index] = !0, o.push(s), i.push(u);do {u ? (l = s.endVertex, s = s.adjacent[c].nextEdge) : (l = s.startVertex, s = s.adjacent[c].prevEdge), s.startVertex === s.endVertex ? c = s.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT : (c = s.startVertex === l ? this.SIDE.LEFT : this.SIDE.RIGHT, s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face && (c = 1 - c, l = s.startVertex === l ? s.endVertex : s.startVertex)), u = c === this.SIDE.LEFT;} while (s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face);n && void 0 === s.loopsCurveAligned && (s.loopsCurveAligned = !!(u ^ c !== this.SIDE.LEFT));} while (s !== e);return { loop: o, orientations: i };}, V.prototype._addNewRegionTopology = function (e) {switch (e.tuid) {case "VertexID":var t = new E.RegionTopologyVertex(new h.Point());return t.setGuid(e.guid), t;case "EdgeID":var r = void 0;switch (e.minortype) {case i.GEOMETRY_TYPES.LINE:r = new a.Line();break;case i.GEOMETRY_TYPES.CIRCLE:r = new c.Circle();break;case i.GEOMETRY_TYPES.ELLIPSE:r = new l.Ellipse();break;case i.GEOMETRY_TYPES.BCURVE:r = new u.BCurve();break;default:console.error("Unhandled curve type");}var n = new E.RegionTopologyEdge(r);return n.setGuid(e.guid), n;case "FaceID":switch (r = void 0, e.minortype) {case i.GEOMETRY_TYPES.PLANE:r = new s.Plane();break;default:console.error("Unhandled surface type");}var o = new E.RegionTopologyFace(r);return o.setGuid(e.guid), o;default:console.error("Unhandled topology type");}}, V.prototype._addOrFindTopologySubcomponent = function (e, t, r, n) {var o = this._createNameFromGuidList(e, t, r, n);if (this._sketchRegionTopologies[o]) {var i = this._sketchRegionTopologies[o];return i.updated = !0, i.topology;}var s = this._addNewRegionTopology({ tuid: e, minortype: t, guid: o });return this._sketchRegionTopologies[o] = { topology: s, updated: !0 }, s;};var T = { VertexID: [1168004130, 3764602020, 2270554856, 1368826480], EdgeID: [2942887333, 1472546498, 2159971906, 413489693], FaceID: [2166479754, 2329626594, 2838556660, 1584616933] },C = {};C[i.GEOMETRY_TYPES.POINT] = [2299429810, 2248164535, 3202574069, 2684287321], C[i.GEOMETRY_TYPES.LINE] = [910992607, 3428993096, 3010390753, 2966835859], C[i.GEOMETRY_TYPES.CIRCLE] = [2229232555, 842549819, 2526558959, 4217038233], C[i.GEOMETRY_TYPES.PLANE] = [2122299449, 3667741317, 2812958731, 939246365], C[i.GEOMETRY_TYPES.BCURVE] = [420548527, 2703575863, 2792852189, 2595995847], C[i.GEOMETRY_TYPES.ELLIPSE] = [902753991, 1129557208, 9277753211, 1913737389];var b = function b(e, t) {var r = 2166136261;return t && (r = 16777619 * (r ^ t) >>> 0), 16777619 * (((r = 16777619 * (((r = 16777619 * (((r = 16777619 * ((r ^ 255 & e) >>> 0) >>> 0) ^ e >> 8 & 255) >>> 0) >>> 0) ^ e >> 16 & 255) >>> 0) >>> 0) ^ e >> 24 & 255) >>> 0) >>> 0;},L = function () {var e = new Uint32Array(4);return function (t) {return e[0] = t, e[1] = 16777619, e[2] = t, e[3] = t, (0, v.hashCombine4xUint32)(e, e);};}(),O = function O(e, t) {for (var r = 0; r < e.length; r++) {e[r] = (e[r] ^ t[r]) >>> 0;}};V.prototype._createNameFromGuidList = function (e, t, r, n) {var o = P.default.clone(T[e]),i = C[t];R.ConsoleUtils.assert(o && i, "Unsupported tuid or minortype!"), O(o, i);for (var s = 0; s < r.length; s++) {O(o, r[s]);}var a = (0, v.uint32x4ToGUID)(o);if (n[a]) {var c = ++n[a];return (r = P.default.clone(r)).push(L(b(c))), this._createNameFromGuidList(e, t, r, n);}return n[a] = 1, a;}, V.prototype._createGUIDfromEdgeAndLocalID = function (e, t) {var r = (0, v.guidToUint32x4)(e.getGuid()),n = L(b(t));return (0, v.hashCombine4xUint32)(r, n);}, V.prototype._findVertexIndex = function (e) {for (var t = 0; t < this._intersectionVertices.length; t++) {if (n.Vector3.distance(this._intersectionVertices[t].position, e) < i.KERNEL_TOLERANCE) return t;for (var r = 0; r < this._intersectionVertices[t].mergedPositions.length; r++) {if (n.Vector3.distance(this._intersectionVertices[t].mergedPositions[r], e) < i.KERNEL_TOLERANCE) return t;}}}, V.prototype._findVertexOnSweepLine = function (e) {for (var t = this._workspace, r = 0, n = t.sweepLineIntersections.length - 1; n >= r;) {if (r + 1 >= n) return r;var o = Math.floor((r + n) / 2);this._isVertexAboveEdgeSegment(t.sweepLineIntersections[o], e) ? r = o : n = o;}console.error("Error in binary search function!");}, V.prototype._isVertexAboveEdgeSegment = function (e, t) {if (e === -1 / 0) return !0;if (e === 1 / 0) return !1;var r = e.originalEdge;switch (r.getCurveType()) {case i.GEOMETRY_TYPES.LINE:var o = r.getStartVertex().getPosition(),s = n.Vector3.createFloat64();n.Vector3.subtract(s, r.getEndVertex().getPosition(), o);var a = n.Vector3.createFloat64();return n.Vector3.subtract(a, t.position, o), (s[0] < 0 || 0 === s[0] && s[1] < 0) && n.Vector3.negate(s, s), a[1] * s[0] - a[0] * s[1] > 0;case i.GEOMETRY_TYPES.CIRCLE:var c = t.position[0] - r.getCurve().getCenter()[0],u = .5 * (e.parameterRange[0] + e.parameterRange[1]),l = r.getCurve().evaluateDtt(u)[1] > 0 ? -1 : 1;return Math.abs(c) > r.getCurve().getRadius() ? r.getCurve().getCenter()[1] < t.position[1] : r.getCurve().getCenter()[1] + l * Math.sqrt(r.getCurve().getRadius() * r.getCurve().getRadius() - c * c) < t.position[1];default:return this.getYvalueForX(e, t.position[0]) < t.position[1];}}, V.prototype._makeEdgeXMonotone = function (e, t) {var r = e.getCurve(),s = [];switch (e.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:var a = r.evaluatePosition(0);n.Vector3.subtract(a, a, r.getCenter());var c = r.getNormal()[2] > 0 ? -1 : 1;s[0] = c * Math.atan2(a[1], a[0]), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.ELLIPSE:var u = r.getMajorAxis()[0] * r.getMajorRadius(),l = r.getMinorAxis()[0] * r.getMinorRadius();s[0] = Math.atan2(l, u), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.BCURVE:s = _.SplineCurveHelper.extremalParams(r, 0);break;default:console.warn("Unsupported edge type in sketch region op");}for (var h = 0; h < s.length; h++) {var d = s[h];e.isReversed() && (d = -d), r.isPeriodicUnlimited() && (d = (0, o.adjustParameterToPeriodicRange)(d, e.getRange(), r.getPeriodUnlimited())), d >= e.t0() && d <= e.t1() && (t.push({ param: d, atVertex: null, temporary: !0 }), A.DebugUtils.level("region3D") > 0 && A.DebugUtils.drawPoint3D(e.evaluatePosition(d), { color: 16711935, label: "x monotonic" }));}}, V.prototype.plotSegments = function (e, t) {var r = this._workspace;Debug.hold("on"), Debug.clearFigure(), Debug.delayUpdates(!0);for (var o = 0; o < this._intersectionVertices.length; o++) {var i = Debug.plotColorForIndex(this._intersectionVertices[o].adjacentEdges.length);if ("sweepLineState" === e && (i = "k", this._intersectionVertices[o] === r.currentVertex && (i = "g"), this._intersectionVertices[o] === r.nextVertex && (i = "b")), Debug.plot([this._intersectionVertices[o].position], i + "o"), "orderColored" === e) for (var s = this._intersectionVertices[o], a = [], c = 0; c < s.adjacentEdges.length; c++) {i = Debug.plotColorForIndex(c);var u = s.adjacentEdges[c],l = P.default.clone(u.parameterRange);u.startVertex !== s || a[u.index] ? l[0] = .5 * (l[0] + l[1]) : l[1] = .5 * (l[0] + l[1]), a[u.index] = !0;var h = u.originalEdge.tessellate(l).positions;Debug.plot(h, i + "-");}}if ("orderColored" !== e) for (o = 0; o < this._edgeSegments.length; o++) {if (u = this._edgeSegments[o], "coincidenceCount" === e) {var d = u.coincidentRanges.length + 1;i = Debug.plotColorForIndex(d);} else i = Debug.plotColorForIndex(o);if ("sweepLineState" === e && (i = r.sweepLineIntersections.indexOf(u) > -1 ? "r" : "k"), t && t.highlightLoop && (i = P.default.contains(t.highlightLoop, u) ? "R" : "k"), h = u.originalEdge.tessellate(u.parameterRange).positions, "regions" === e) {var g = [],p = [];for (c = 0; c < h.length; c++) {if (c < h.length - 1) {var f = n.Vector3.createFloat64();n.Vector3.subtract(f, h[c + 1], h[c]);} else f = n.Vector3.createFloat64(), n.Vector3.subtract(f, h[c], h[c - 1]);n.Vector3.normalize(f, f), n.Vector3.scale(f, f, .05), n.Vector3.cross(f, [0, 0, 1], f);var v = n.Vector3.clone(h[c]);g.push(n.Vector3.add(v, v, f));var _ = n.Vector3.clone(h[c]);p.push(n.Vector3.subtract(_, _, f));}var y = u.adjacent[this.SIDE.LEFT].face.index;i = Debug.plotColorForIndex(y), Debug.plot(g, i + "-");var m = u.adjacent[this.SIDE.RIGHT].face.index;i = Debug.plotColorForIndex(m), Debug.plot(p, i + "-");} else Debug.plot(h, i + "-");}if ("sweepLineState" === e && r.sweepLinePosition) {var E = r.sweepLinePosition,x = void 0;for (o = 0; o < r.sweepLineIntersections.length; o++) {var R,A = r.sweepLineIntersections[o];void 0 !== (R = A === 1 / 0 ? 5 : A === -1 / 0 ? -5 : this.getYvalueForX(A, E)) && (Debug.plot([E], [R], "y."), void 0 !== x && (i = Debug.plotColorForIndex(r.sweepLineRegions[o - 1].index), Debug.plot([E, E], [x, R], i + "-")), x = R);}}if (t && t.showOrientation) {h = [];var V = [],T = [];for (o = 0; o < this._edgeSegments.length; o++) {var C = !(void 0 === (u = this._edgeSegments[o]).loopsCurveAligned || !0 === u.loopsCurveAligned),b = C ? .05 : .95,L = u.parameterRange[0] * (1 - b) + u.parameterRange[1] * b,O = u.originalEdge.evaluatePosition(L);h.push(O);var S = t.arrowSize || .1,M = C ? -S : S;if (u.adjacent[this.SIDE.LEFT].face.index >= 0) {var w = u.originalEdge.evaluateDt(L);n.Vector3.normalize(w, w);var N = [O[0] - S * w[1], O[1] + S * w[0]];V.push(N), T.push([M * w[0], M * w[1]]);}if (u.adjacent[this.SIDE.RIGHT].face.index >= 0) {var F = u.parameterRange[0] * b + u.parameterRange[1] * (1 - b),I = u.originalEdge.evaluatePosition(F),D = u.originalEdge.evaluateDt(F);n.Vector3.normalize(D, D);var j = [I[0] + S * D[1], I[1] - S * D[0]];V.push(j), T.push([-M * D[0], -M * D[1]]);}}Debug.plot(h, "k."), Debug.quiver(V, T, "g", "c");}Debug.delayUpdates(!1), Debug.equalAxis();}, V.prototype.plotEdgeSegment = function (e, t) {Debug.plotEdgeList([e.originalEdge], !1, t + "-", { ranges: [e.parameterRange] });}, V.prototype.plotEdgesAroundVertex = function (e, t) {Debug.plot([e.position], "gx");for (var r = 0; r < e.adjacentEdges.length; r++) {var n,o = e.adjacentEdges[r];console.log(r), n = o.startVertex === e ? [o.parameterRange[0], o.parameterRange[0] + t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0])] : [o.parameterRange[1] - t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0]), o.parameterRange[1]], Debug.plotEdgeList([o.originalEdge], !1, "-" + Debug.plotColorForIndex(r), { ranges: [n], showOrientation: !1, resolution: 1e4 });}}, V.prototype.getYvalueForX = function (e, t) {var r = e.parameterRange[0],n = e.parameterRange[1],o = e.originalEdge.evaluatePosition(r),s = e.originalEdge.evaluatePosition(n),a = o[0],c = s[0];if (a > c) {var u = r;r = n, n = u, u = a, a = c, c = u, u = o, o = s, s = u;}if (t <= a + i.KERNEL_TOLERANCE || t >= c - i.KERNEL_TOLERANCE) return Math.abs(t - a) <= i.KERNEL_TOLERANCE ? o[1] : Math.abs(t - c) <= i.KERNEL_TOLERANCE ? s[1] : void console.warn("Failure in getYvalueForX, in_x oustide segment range, returning undefined");for (; c >= a;) {if (a + i.KERNEL_TOLERANCE >= c) return h[1];var l = (r + n) / 2,h = e.originalEdge.evaluatePosition(l);if (Math.abs(r - n) <= i.PARAMETER_SPACE_TOLERANCE) return R.ConsoleUtils.assert(!1, "Could not converge to a solution for getYvalueForX"), h[1];h[0] < t ? (a = h[0], r = l) : (c = h[0], n = l);}console.warn("Failure in getYvalueForX, returning undefined");}, V.prototype._computeAngleAndPositionForEdge = function (e, t, r) {var o = t.adjacentEdges[e],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1];if (void 0 === r || !((s += (i ? 1 : -1) * r) < o.parameterRange[0] || s > o.parameterRange[1])) {var a = n.Vector3.createFloat64();return n.Vector3.normalize(a, o.originalEdge.evaluateDt(s)), i || n.Vector3.negate(a, a), { angle: Math.atan2(a[1], a[0]), position: o.originalEdge.evaluatePosition(s) };}}, V.prototype._computeEdgeDirectionAtVertex = function (e, t, r) {var o = t.adjacentEdges[e.index],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1],a = s + (i ? 1 : -1) * r / n.Vector3.length(o.originalEdge.evaluateDt(s)),c = o.originalEdge.evaluatePosition(a),u = n.Vector3.subtract(c, c, t.position);return Math.atan2(u[1], u[0]);}, V.prototype._prepareResult = function () {var e = new y.TopologyCloner();this._finalFaces = e.cloneFaces(this._faces), this._internalToFinalMap = e.getProgenitorMap(), this._progenitorMap = new m.ProgenitorMap();for (var t = e.getProgenitorMap().getAllNewTopology(), r = 0; r < t.length; r++) {var n = t[r],o = e.getProgenitorMap().getProgenitors(n)[0],s = void 0;n.getTopologyType() === i.TOPOLOGY_TYPES.FACE ? (s = new Set(), o.collectEdges().forEach(function (e) {e.getAssociatedEntities().forEach(function (e) {s.add(e);});}), s = Array.from(s)) : (n.getTopologyType() === i.TOPOLOGY_TYPES.EDGE || n.getTopologyType() === i.TOPOLOGY_TYPES.VERTEX) && (s = o.getAssociatedEntities()), s && this._progenitorMap.addEntry(n, s);}this._sketchSummary = { regionFaces: [], regionEdges: [], regionVertices: [], sketchEdges: {} };for (var a = P.default.keys(this._sketchRegionTopologies), c = 0; c < a.length; c++) {var u = this._sketchRegionTopologies[a[c]].topology;u instanceof E.RegionTopologyFace ? this._sketchSummary.regionFaces.push(u) : u instanceof E.RegionTopologyEdge ? this._sketchSummary.regionEdges.push(u) : u instanceof E.RegionTopologyVertex ? this._sketchSummary.regionVertices.push(u) : R.ConsoleUtils.assert(!1);}for (var l = 0; l < this._sketchEdges.length; l++) {var h = this._sketchEdges[l];this._sketchSummary.sketchEdges[h.getGuid()] = h;}}, V.prototype.getFaces = function () {return this._finalFaces;}, V.prototype.getRegionTopologyFaces = function () {return this._faces;}, V.prototype.getProgenitorMap = function () {return this._progenitorMap;}, V.prototype.createFaceRecipe = function (e) {var t = this._finalFaces.indexOf(e);if (t < 0) return "";var r = this._faces[t],n = (0, x.createRecipeFromRegionFace)(r, this._sketchSummary);return (0, x.serializeRegionFaceRecipe)(n);}, V.prototype.matchFaceRecipe = function (e) {for (var t = (0, x.deserializeRegionFaceRecipe)(e), r = (0, x.matchRegionFaceRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.regions.length; o++) {var i = this._faces.indexOf(r.regions[o]);R.ConsoleUtils.assert(i >= 0), n.push(this._finalFaces[i]);}return n;}, V.prototype.createEdgeRecipe = function (e) {var t = this._internalToFinalMap.getProgenitors(e);if (!t || 1 !== t.length) return "";var r = (0, x.createRecipeFromRegionEdge)(t[0], this._sketchSummary);return (0, x.serializeRegionEdgeRecipe)(r);}, V.prototype.matchEdgeRecipe = function (e) {for (var t = (0, x.deserializeRegionEdgeRecipe)(e), r = (0, x.matchRegionEdgeRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.edges.length; o++) {var i = this._internalToFinalMap.getDescendants(r.edges[o]);R.ConsoleUtils.assert(1 === i.length), n.push(i[0]);}return n;}, t.SketchRegionSolver = V;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.computeCurveCurveIntersections = void 0;var n = r(1),o = r(0),i = r(6),s = r(7),a = r(20),c = r(16),u = r(72),l = r(36),h = r(3),d = r(110),g = o.KERNEL_TOLERANCE,p = function p(e, t, r, o) {var i = t,s = e.getRange();if (e.getCurve().isPeriodicUnlimited() && (i < s[0] - n.FLOAT64_TOLERANCE || i > s[1] + n.FLOAT64_TOLERANCE)) {var a = e.getCurve().getPeriodUnlimited();i = (0, h.foldNearTo)(i, .5 * (s[0] + s[1]), a);}var c = Math.abs(i - s[0]) < Math.abs(i - s[1]) ? 0 : 1,u = n.Vector3.length(e.evaluateDt(i));return Math.abs(i - s[c]) * u < r ? { param: s[c], atVertex: e.getVertex(c) } : i >= s[0] && i <= s[1] ? { param: i, atVertex: void 0 } : !e.isClosed() && o.distanceToPoint(e.getVertex(c).getPosition()) < r ? { param: s[c], atVertex: e.getVertex(c) } : void 0;},f = function f(e, t, r, o, i) {var s = p(e, t, i, r);if (s) {if (s.atVertex) {var a = r.getRange();e === r && (a = [o - .1 * (l = Math.abs(a[1] - a[0])), o + .1 * l]);var c = r.closestToPointParam(s.atVertex.getPosition(), a);n.Vector3.distance(r.evaluatePosition(c), s.atVertex.getPosition()) < i && (o = c);}var u = p(r, o, i, e);if (u) {var l;if (u.atVertex) a = e.getRange(), e === r && (a = [t - .1 * (l = Math.abs(a[1] - a[0])), t + .1 * l]), c = e.closestToPointParam(u.atVertex.getPosition(), a), n.Vector3.distance(e.evaluatePosition(c), u.atVertex.getPosition()) < i && (s = p(e, t = c, i, r));if (s) return { cutInfo: s, cutByInfo: u };}}},v = function v(e, t, r) {var n = [t - e.getRange()[0], t - e.getRange()[1]];if (n[0] >= r && n[1] <= -r) return { param: t, atVertex: void 0 };var o = Math.abs(n[0]) < Math.abs(n[1]) ? 0 : 1;return Math.abs(n[o]) < r ? { param: e.getRange()[o], atVertex: e.getVertex(o) } : void 0;},_ = function _(e, t, r, i, s, a, c) {var u = e.getCurve().getPeriodUnlimited(),l = t.getCurve().getPeriodUnlimited(),d = [r[0], r[2]],g = [i[0], i[2]],f = [s / n.Vector3.length(e.evaluateDt(d[0])), s / n.Vector3.length(e.evaluateDt(d[1]))],v = [s / n.Vector3.length(t.evaluateDt(g[0])), s / n.Vector3.length(t.evaluateDt(g[1]))];if (((0, h.isParameterWithinPeriodicRange)(d[0], e.getRange(), u, f[0]) || (0, h.isParameterWithinPeriodicRange)(d[1], e.getRange(), u, f[1])) && ((0, h.isParameterWithinPeriodicRange)(g[0], t.getRange(), l, v[0]) || (0, h.isParameterWithinPeriodicRange)(g[1], t.getRange(), l, v[1]))) {for (var _ = 0; _ < 2; _++) {d[_] = (0, h.adjustParameterToPeriodicRange)(d[_], e.getRange(), u, !1, !0), g[_] = (0, h.adjustParameterToPeriodicRange)(g[_], t.getRange(), l, !1, !0);var y = (0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15,m = (0, h.periodicDifference)(g[_], t.getRange()[0], l) < 3e-15 || (0, h.periodicDifference)(g[_], t.getRange()[1], l) < 3e-15;if (d[_] - e.getRange()[0] < f[_] && (d[_] = e.getRange()[0], y = !0), e.getRange()[1] - d[_] < f[_] && (d[_] = e.getRange()[1], y = !0), g[_] - t.getRange()[0] < v[_] && (g[_] = t.getRange()[0], m = !0), t.getRange()[1] - g[_] < v[_] && (g[_] = t.getRange()[1], m = !0), y) {var E = t.closestToPointParam(e.evaluatePosition(d[_]));g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0);}if (m) {var x = e.closestToPointParam(t.evaluatePosition(g[_]));d[_] = (0, h.adjustParameterToPeriodicRange)(x, e.getRange(), u, !1, !0), ((0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15) && (E = t.closestToPointParam(e.evaluatePosition(d[_])), g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0));}}var R, A;if ((0, h.periodicDifference)(d[0], d[1], u) < Math.min(f[0], f[1]) && (0, h.periodicDifference)(g[0], g[1], l) < Math.min(v[0], v[1])) R = p(e, .5 * (d[0] + d[1]), s, e), A = p(t, .5 * (g[0] + g[1]), s, t);else for (R = p(e, r[1], s, e), A = p(t, i[1], s, t), _ = 0; _ < 2; _++) {if (!((0, h.periodicDifference)(d[_], R.param, u) < f[_] && (0, h.periodicDifference)(g[_], A.param, l) < v[_])) {var P,V,T = p(e, d[_], s, e),C = p(t, g[_], s, t);if (isFinite(u)) {var b = (0, h.getShortestParametricRange)(T.param, R.param, u);P = (0, h.periodicDifference)(R.param, b[0], u) <= o.KERNEL_ANGULAR_TOLERANCE;} else P = T.param > R.param;isFinite(l) ? (b = (0, h.getShortestParametricRange)(C.param, A.param, l), V = (0, h.periodicDifference)(A.param, b[0], l) <= o.KERNEL_ANGULAR_TOLERANCE) : V = C.param > A.param, a.push({ rangeInfo: P ? [R, T] : [T, R], rangeByInfo: V ? [A, C] : [C, A] });}}c && c.push({ firstParam: R.param, secondParam: A.param });}},y = function y(e, t, r, o) {var i = e.getRange(),s = e.evaluatePosition(0),a = e.evaluateDt(0),c = n.Vector2.length(a),u = t.getRange(),l = t.evaluatePosition(0),d = t.evaluateDt(0),g = n.Vector2.length(d),p = [a[1] / c, -a[0] / c],_ = t.evaluatePosition(u[0]);n.Vector2.subtract(_, _, s);var y = n.Vector2.dot(_, p),m = t.evaluatePosition(u[1]);n.Vector2.subtract(m, m, s);var E = n.Vector2.dot(m, p);if (Math.abs(y) <= o && Math.abs(E) <= o) {var x = n.Vector2.dot(_, a) / (c * c),R = n.Vector2.dot(m, a) / (c * c),A = [Math.min(x, R), Math.max(x, R)],P = o / c,V = o / g;if (A[1] < i[0] - P || A[0] > i[1] + P) return [];var T = [Math.max(i[0], A[0]), Math.min(i[1], A[1])];if (T[1] - T[0] < P) {var C = .5 * (T[0] + T[1]),b = Math.abs(R - x) > n.FLOAT64_TOLERANCE ? u[0] + (u[1] - u[0]) * (C - x) / (R - x) : .5 * (u[0] + u[1]);return [{ cutInfo: v(e, C, P), cutByInfo: v(t, b, V) }];}if (!r) return [];var L = u[0] + (u[1] - u[0]) * (T[0] - x) / (R - x),O = u[0] + (u[1] - u[0]) * (T[1] - x) / (R - x);return [{ rangeInfo: [v(e, T[0], P), v(e, T[1], P)], rangeByInfo: [v(t, Math.min(L, O), V), v(t, Math.max(L, O), V)] }];}if (y > o && E > o || y < -o && E < -o) return [];var S = [[a[0], -d[0], l[0] - s[0]], [a[1], -d[1], l[1] - s[1]]],M = (0, h.solveTwoEquationsTwoVariables)(S);if (M) {var w = f(e, M[0], t, M[1], o);if (w) return [w];}return [];},m = function m(e, t, r) {var o,i = t.getCenter(),s = e.closestToPointParam(i, []),a = e.evaluatePosition(s),c = n.Vector3.squaredDistance(a, i),u = [],l = t.getRadius(),h = l - Math.sqrt(c);if (h < -r) ;else if (h < r) o = t.closestToPointParam(a, []), u.push({ lineParam: s, circleParam: o });else for (var d = Math.sqrt(l * l - c) / n.Vector3.length(e.evaluateDt(0)), g = 0; g < 2; ++g) {var p = s + (0 === g ? -1 : 1) * d,f = e.evaluatePosition(p);o = t.closestToPointParam(f, []), u.push({ lineParam: p, circleParam: o });}return u;},E = function E(e, t, r, n, o, i) {var s = [r[0] + t * n[0] - e * n[1], r[1] + t * n[1] + e * n[0], 0];return { firstParam: o.closestToPointParam(s, [0, 2 * Math.PI]), secondParam: i.closestToPointParam(s, [0, 2 * Math.PI]) };},x = function x(e, t) {t || (t = o.KERNEL_TOLERANCE);for (var r = [], n = !1, i = [], s = [], a = 0; a < e.length; ++a) {e[a].hasOwnProperty("rangeInfo") ? (!1 === n ? (i = e[a].rangeInfo, s = e[a].rangeByInfo) : Math.abs(i[1].param - e[a].rangeInfo[0].param) < t && Math.abs(s[1].param - e[a].rangeByInfo[0].param) < t ? (i[1] = e[a].rangeInfo[1], s[1] = e[a].rangeByInfo[1]) : (r.push({ rangeInfo: i, rangeByInfo: s }), i = e[a].rangeInfo, s = e[a].rangeByInfo), n = !0) : e[a].hasOwnProperty("cutInfo") ? (n && r.push({ rangeInfo: i, rangeByInfo: s }), r.push(e[a]), n = !1) : console.warn("unknown segment type in intersection code");}return n && r.push({ rangeInfo: i, rangeByInfo: s }), r;},R = function R(e, t, r, o, i) {var s = r.getControlPoints(),a = r.getKnotVector(),c = e.getBoundingBox(),u = [];if (!r.getBoundingBox([a[0], a[a.length - 1]]).intersectsWithTolerance(c, i)) return u;var d = new Float64Array(s.length),g = s.length / 3 - 1,y = n.Vector2.createFloat64FromValues(e.getStartVertex().getPosition()[0], e.getStartVertex().getPosition()[1]),m = n.Vector3.createFloat64();n.Vector3.sub(m, e.getEndVertex().getPosition(), e.getStartVertex().getPosition()), n.Vector3.normalize(m, m);for (var E = n.Vector2.createFloat64FromValues(m[0], m[1]), x = n.Vector2.createFloat64(), R = !0, A = 0; A <= g; ++A) {x[0] = s[3 * A + 0], x[1] = s[3 * A + 1], d[3 * A + 0] = A / g, d[3 * A + 1] = (0, h.signedDistanceTo2DLine)(y, E, x), Math.abs(d[3 * A + 1]) > i && (R = !1), d[3 * A + 2] = 0;}if (R) return o ? u = function (e, t, r, o, i) {var s = o.length / 3 - 1,a = n.Vector3.createFloat64FromValues(o[0], o[1], o[2]),c = e.closestToPointParam(a),u = n.Vector3.createFloat64FromValues(o[3 * s + 0], o[3 * s + 1], o[3 * s + 2]),l = e.closestToPointParam(u),h = [v(e, c, r), v(e, l, r)];if (h[0].param > h[1].param) {var d = h[0];h[0] = h[1], h[1] = d;}var g = i[0],f = i[i.length - 1];if (t.isReversed()) {var _ = g;g = -f, f = -_;}var y = [p(t, g, r, e), p(t, f, r, e)];return h[0] && h[1] && y[0] && y[1] ? [{ rangeInfo: h, rangeByInfo: y }] : (console.warn("Error in intersection computation."), []);}(e, t, i, s, a) : [];var P = new Float64Array(3),V = [];return function (e, t, r, n, o, i, s, a, c) {var u,l = [],h = n.length / 3 - 1;3 === i ? (s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u), s[1] > s[2] && (u = s[1], s[1] = s[2], s[2] = u), s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u)) : 2 === i && s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u);var d = [!1, !1, !1],g = o[o.length - 1] - o[0],v = t.getCurve().tangentLength(o[0]) * g;Math.abs(n[1]) < r && (0 === i || s[0] > r / v) && (i++, s[2] = s[1], s[1] = s[0], s[0] = 0, d[0] = !0);var y = t.getCurve().tangentLength(o[o.length - 1]) * g;Math.abs(n[3 * h + 1]) < r && (0 === i || 1 - s[i - 1] > r / y) && (s[i] = 1, d[i] = !0, i++);for (var m = e.isReversed() ? -1 : 1, E = t.isReversed() ? -1 : 1, x = 0, R = 0; R < i + 1; ++R) {var A = !1;if (R !== i) {var P = s[R];s[R] = o[0] + (o[o.length - 1] - o[0]) * s[R];var V = t.getCurve().evaluatePosition(s[R]),T = e.getCurve().closestToPointParam(V, []),C = f(e, T * m, t, s[R] * E, r);C && (C.cutInfo.virtualIntersection = d[R], C.cutByInfo.virtualIntersection = d[R], l.push(C));} else P = o[o.length - 1], A = Math.abs(n[3 * h + 1]) > r;if (0 === R && P > 0 && Math.abs(n[0]) > r && (A = !0), c) {var b = void 0;if (a.length > 0 && a[0][0] >= x && a[0][0] <= P && (b = a[0]), a.length > 1 && a[1][0] >= x && a[1][0] <= P && (b = a[1]), void 0 !== b && Math.abs(b[1]) < r && !A) {var L = [o[0] + (o[o.length - 1] - o[0]) * x, o[0] + (o[o.length - 1] - o[0]) * P],O = [e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[0]), []), e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[1]), [])];if (Math.abs(O[0] - O[1]) > r) {var S = [p(e, O[0] * m, r, t), p(e, O[1] * m, r, t)],M = [p(t, L[0] * E, r, e), p(t, L[1] * E, r, e)];if (S[0] && S[1] && M[0] && M[1]) {var w = o[0] + (o[o.length - 1] - o[0]) * b[0];w !== L[0] && w !== L[1] || (w = .5 * (L[0] + L[1]));var N = e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(w), []);_(e, t, [O[0] * m, N * m, O[1] * m], [L[0] * E, w * E, L[1] * E], r, l);var F = { cutInfo: p(e, N * m, r, e), cutByInfo: p(t, w * E, r, e) };F.cutInfo.virtualIntersection = !0, F.cutByInfo.virtualIntersection = !0, l.push(F);}}}}x = P;}return l;}(e, t, i, d, a, l.SplineCurveHelper.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D([0, 0, 0], d, P, V), P, V, o);},A = function A(e, t, r, n) {var o = e.getBoundingBox(),i = [];if (!t.getBoundingBox().intersectsWithTolerance(o, n)) return i;for (var s = t.getCurve().getBezierSegments(), a = s.length, c = 0; c < a; c++) {for (var u = R(e, t, s[c], r, n), l = 0; l < u.length; ++l) {i.push(u[l]);}}return x(i);},P = function P(e, t, r, o, i) {var a = r.getControlPoints(),c = r.getKnotVector(),l = e.getBoundingBox(),d = [];if (!r.getBoundingBox([c[0], c[c.length - 1]]).intersectsWithTolerance(l, i)) return d;for (var v = !0, _ = n.Vector2.createFloat64(), y = n.Vector2.createFloat64(), E = n.Vector2.createFloat64(), x = 0; x < a.length / 3 - 2 && v; ++x) {_[0] = a[3 * x + 0], _[1] = a[3 * x + 1], y[0] = a[3 * x + 3], y[1] = a[3 * x + 4], E[0] = a[3 * x + 6], E[1] = a[3 * x + 7], v = Math.abs((0, h.orient2D)(_, y, E)) < g;}if (v) {var R = new s.Line(),A = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),P = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);R.setFromEndpoints(A, P);var V = n.Vector3.distance(P, A),T = m(R, e.getCurve(), i);for (x = 0; x < T.length; ++x) {if (T[x].lineParam >= 0 && T[x].lineParam <= V) {T[x].lineParam = t.getCurve().closestToPointParam(R.evaluatePosition(T[x].lineParam), []);var C = p(e, T[x].circleParam * (e.isReversed() ? -1 : 1), i, t),b = p(t, T[x].lineParam * (t.isReversed() ? -1 : 1), i, e);b && C && d.push({ cutInfo: C, cutByInfo: b });}}return d;}var L = n.Vector2.createFloat64(),O = n.Vector2.createFloat64(),S = n.Vector2.createFloat64(),M = n.Vector2.createFloat64();L[0] = -a[0] + 3 * a[3] - 3 * a[6] + a[9], L[1] = -a[1] + 3 * a[4] - 3 * a[7] + a[10], O[0] = 3 * a[0] - 6 * a[3] + 3 * a[6], O[1] = 3 * a[1] - 6 * a[4] + 3 * a[7], S[0] = -3 * a[0] + 3 * a[3], S[1] = -3 * a[1] + 3 * a[4], M[0] = a[0], M[1] = a[1];var w = e.getCurve().getCenter(),N = e.getCurve().getRadius() * e.getCurve().getRadius(),F = N,I = new Float64Array(7);I[0] = F * L[0] * L[0] + N * L[1] * L[1], I[1] = 2 * F * L[0] * O[0] + 2 * O[1] * N * L[1], I[2] = 2 * S[0] * F * L[0] + O[1] * O[1] * N + F * O[0] * O[0] + 2 * S[1] * N * L[1], I[3] = -2 * w[1] * N * L[1] + 2 * O[1] * S[1] * N + 2 * S[0] * F * O[0] - 2 * F * L[0] * w[0] + 2 * F * L[0] * M[0] + 2 * M[1] * N * L[1], I[4] = -2 * F * w[0] * O[0] + S[1] * S[1] * N - 2 * w[1] * O[1] * N + 2 * F * M[0] * O[0] + S[0] * S[0] * F + 2 * M[1] * O[1] * N, I[5] = -2 * w[1] * S[1] * N - 2 * S[0] * F * w[0] + 2 * S[0] * F * M[0] + 2 * M[1] * S[1] * N, I[6] = F * w[0] * w[0] - 2 * M[1] * w[1] * N - F * N + w[1] * w[1] * N + M[1] * M[1] * N - 2 * F * w[0] * M[0] + F * M[0] * M[0];var D = (0, u.getRealPolynomialRoots)(I);for (x = 0; x < D.length; ++x) {if (D[x] >= 0 && D[x] <= 1) {D[x] = c[0] + (c[c.length - 1] - c[0]) * D[x];var j = t.getCurve().evaluatePosition(D[x]),B = e.getCurve().closestToPointParam(j, []),U = f(e, B * (e.isReversed() ? -1 : 1), t, D[x] * (t.isReversed() ? -1 : 1), i);U && d.push(U);}}return d;},V = function V(e, t, r, n, o) {var i = e.getBoundingBox(),s = [];if (!t.getBoundingBox().intersectsWithTolerance(i, o)) return s;var a = 0;e.isClosed() && n && (a = 1);for (var c = t.getCurve().getBezierSegments(), u = c.length, l = 0; l < u; l++) {for (var h = P(e, t, c[l], 0, o), d = 0; d < h.length; ++d) {for (var g = -a; g <= a; ++g) {s.push({ cutInfo: { atVertex: h[d].cutInfo.atVertex, param: h[d].cutInfo.param + g * Math.PI * 2 }, cutByInfo: h[d].cutByInfo });}}}return x(s);},T = function T(e, t, r, l, d, v, _) {var m = r.getControlPoints(),E = r.getKnotVector(),x = l.getControlPoints(),A = l.getKnotVector(),P = r.getBoundingBox([E[0], E[E.length - 1]]),V = l.getBoundingBox([A[0], A[A.length - 1]]),T = e === t,C = !1,b = !1;T && Math.abs(m[m.length - 3] - x[0]) < v && Math.abs(m[x.length - 2] - x[1]) < v && Math.abs(m[x.length - 1] - x[2]) < v && (C = !0), T && Math.abs(m[0] - x[m.length - 3]) < v && Math.abs(m[1] - x[x.length - 2]) < v && Math.abs(m[2] - x[x.length - 1]) < v && (b = !0);var L = [];if (!P.intersectsWithTolerance(V, v)) return L;var O = !0,S = !0,M = n.Vector2.createFloat64(),w = n.Vector2.createFloat64(),N = n.Vector2.createFloat64();for (we = 0; we < m.length / 3 - 2 && O; ++we) {M[0] = m[3 * we + 0], M[1] = m[3 * we + 1], w[0] = m[3 * we + 3], w[1] = m[3 * we + 4], N[0] = m[3 * we + 6], N[1] = m[3 * we + 7], O = Math.abs((0, h.orient2D)(M, w, N)) < g;}for (we = 0; we < x.length / 3 - 2 && S; ++we) {M[0] = x[3 * we + 0], M[1] = x[3 * we + 1], w[0] = x[3 * we + 3], w[1] = x[3 * we + 4], N[0] = x[3 * we + 6], N[1] = x[3 * we + 7], S = Math.abs((0, h.orient2D)(M, w, N)) < g;}if (O || S) return function (e, t, r, u, l, h, d, g, v) {var _ = l.getControlPoints(),m = h.getControlPoints(),E = [];if (e && !t || !e && t) {var x,A,P = new s.Line();e ? (x = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]), A = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1])) : (x = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]), A = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1])), P.setFromEndpoints(x, A);var V = new a.Edge(P),T = n.Vector3.distance(A, x);V.setRange([0, T]);var C = new i.Point();C.setPosition(x[0], x[1], x[2]);var b = new i.Point();b.setPosition(A[0], A[1], A[2]);var L,O = new c.Vertex(C),S = new c.Vertex(b);V.setStartVertex(O), V.setEndVertex(S), ee = e ? R(V, u, h, d, g) : R(V, r, l, d, g);for (var M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) {if (ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= T && (e ? (ee[M].cutInfo.param = r.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) : (ee[M].cutInfo.param = u.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutByInfo.param, u, ee[M].cutInfo.param, g)), L)) if (v) {var w = L.cutInfo.param,N = L.cutByInfo.param;(F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w))) > o.KERNEL_TOLERANCE && !ee[M].cutInfo.virtualIntersection && E.push(L);} else E.push(L);} else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= T && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= T) if (e ? (ee[M].rangeInfo[0].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))) : (ee[M].rangeInfo[0].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))), e ? (te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)], re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)]) : (te = [p(r, ee[M].rangeByInfo[0].param, g, u), p(r, ee[M].rangeByInfo[1].param, g, u)], re = [p(u, ee[M].rangeInfo[0].param, g, r), p(u, ee[M].rangeInfo[1].param, g, r)]), te[0] && te[1] && re[0] && re[1]) {var F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1]));(!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re });} else console.warn("Error in intersection computation.");}} else {var I = new s.Line(),D = new s.Line(),j = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]),B = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1]),U = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]),k = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1]);I.setFromEndpoints(j, B), D.setFromEndpoints(U, k);var G = new a.Edge(I),z = n.Vector3.distance(B, j),Y = new a.Edge(D),K = n.Vector3.distance(k, U);G.setRange([0, z]), Y.setRange([0, K]);var q = new i.Point();q.setPosition(j[0], j[1], j[2]);var W = new i.Point();W.setPosition(B[0], B[1], B[2]);var H = new i.Point();H.setPosition(U[0], U[1], U[2]);var X = new i.Point();X.setPosition(k[0], k[1], k[2]);var J = new c.Vertex(q),$ = new c.Vertex(W),Z = new c.Vertex(H),Q = new c.Vertex(X);G.setStartVertex(J), G.setEndVertex($), Y.setStartVertex(Z), Y.setEndVertex(Q);var ee = y(G, Y, d, g);for (M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= z && ee[M].cutByInfo.param >= 0 && ee[M].cutByInfo.param <= K && (ee[M].cutInfo.param = r.closestToPointParam(I.evaluatePosition(ee[M].cutInfo.param)), ee[M].cutByInfo.param = u.closestToPointParam(D.evaluatePosition(ee[M].cutByInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) && (w = L.cutInfo.param, N = L.cutByInfo.param, F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w)), (!v || v && F > o.KERNEL_TOLERANCE) && E.push(L));else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= z && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= z && ee[M].rangeByInfo[0].param >= 0 && ee[M].rangeByInfo[0].param <= K && ee[M].rangeByInfo[1].param >= 0 && ee[M].rangeByInfo[1].param <= K) {ee[M].rangeInfo[0].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[1].param)), ee[M].rangeByInfo[0].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[0].param)), ee[M].rangeByInfo[1].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[1].param));var te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)],re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)];te[0] && te[1] && re[0] && re[1] ? (F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1])), (!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re })) : console.warn("Error in intersection computation.");}}}return E;}(O, S, e, t, r, l, d, v, _);var F = -m[0] + 3 * m[3] - 3 * m[6] + m[9],I = 3 * m[0] - 6 * m[3] + 3 * m[6],D = -3 * m[0] + 3 * m[3],j = m[0],B = -m[1] + 3 * m[4] - 3 * m[7] + m[10],U = 3 * m[1] - 6 * m[4] + 3 * m[7],k = -3 * m[1] + 3 * m[4],G = m[1],z = j * j,Y = D * D,K = I * I,q = F * F,W = j * j * j,H = D * D * D,X = I * I * I,J = F * F * F,$ = G * G,Z = k * k,Q = U * U,ee = B * B,te = G * G * G,re = k * k * k,ne = U * U * U,oe = B * B * B,ie = -x[0] + 3 * x[3] - 3 * x[6] + x[9],se = 3 * x[0] - 6 * x[3] + 3 * x[6],ae = -3 * x[0] + 3 * x[3],ce = x[0],ue = -x[1] + 3 * x[4] - 3 * x[7] + x[10],le = 3 * x[1] - 6 * x[4] + 3 * x[7],he = -3 * x[1] + 3 * x[4],de = x[1],ge = ce * ce,pe = ce * ce * ce,fe = de * de,ve = de * de * de,_e = ae * ae,ye = ae * ae * ae,me = he * he,Ee = he * he * he,xe = se * se,Re = se * se * se,Ae = le * le,Pe = le * le * le,Ve = ie * ie,Te = ue * ue,Ce = new Float64Array(10),be = F * ue - B * ie;Ce[0] = be * be * be, Ce[1] = 3 * (F * le - B * se) * be * be, Ce[2] = 3 * (F * ue - B * ie) * (q * he * ue + q * Ae - F * B * ae * ue - 2 * F * B * se * le - F * B * ie * he + ee * ae * ie + ee * xe), Ce[3] = 3 * j * q * B * Te - 6 * j * F * ee * ie * ue + 3 * j * oe * Ve - 3 * D * I * F * B * Te + 3 * D * I * ee * ie * ue + 2 * D * q * U * Te - D * F * U * B * ie * ue - D * U * ee * Ve + X * B * Te - K * F * U * Te - 2 * K * U * B * ie * ue + I * q * k * Te + I * F * k * B * ie * ue + 2 * I * F * Q * ie * ue - 2 * I * k * ee * Ve + I * Q * B * Ve - 3 * J * G * Te + 3 * J * de * Te + 6 * J * he * le * ue + J * Pe + 6 * q * G * B * ie * ue - 3 * q * k * U * ie * ue - 3 * q * B * ce * Te - 6 * q * B * ae * le * ue - 6 * q * B * se * he * ue - 3 * q * B * se * Ae - 6 * q * B * ie * de * ue - 6 * q * B * ie * he * le - 3 * F * G * ee * Ve + 3 * F * k * U * B * Ve - F * ne * Ve + 6 * F * ee * ce * ie * ue + 6 * F * ee * ae * se * ue + 6 * F * ee * ae * ie * le + 3 * F * ee * xe * le + 6 * F * ee * se * ie * he + 3 * F * ee * Ve * de - 3 * oe * ce * Ve - 6 * oe * ae * se * ie - oe * Re, Ce[4] = 6 * j * q * B * le * ue - 6 * j * F * ee * se * ue - 6 * j * F * ee * ie * le + 6 * j * oe * se * ie - 6 * D * I * F * B * le * ue + 3 * D * I * ee * se * ue + 3 * D * I * ee * ie * le + 4 * D * q * U * le * ue - D * F * U * B * se * ue - D * F * U * B * ie * le - 2 * D * U * ee * se * ie + 2 * X * B * le * ue - 2 * K * F * U * le * ue - 2 * K * U * B * se * ue - 2 * K * U * B * ie * le + 2 * I * q * k * le * ue + I * F * k * B * se * ue + I * F * k * B * ie * le + 2 * I * F * Q * se * ue + 2 * I * F * Q * ie * le - 4 * I * k * ee * se * ie + 2 * I * Q * B * se * ie - 6 * J * G * le * ue + 6 * J * de * le * ue + 3 * J * me * ue + 3 * J * he * Ae + 6 * q * G * B * se * ue + 6 * q * G * B * ie * le - 3 * q * k * U * se * ue - 3 * q * k * U * ie * le - 6 * q * B * ce * le * ue - 6 * q * B * ae * he * ue - 3 * q * B * ae * Ae - 6 * q * B * se * de * ue - 6 * q * B * se * he * le - 6 * q * B * ie * de * le - 3 * q * B * ie * me - 6 * F * G * ee * se * ie + 6 * F * k * U * B * se * ie - 2 * F * ne * se * ie + 6 * F * ee * ce * se * ue + 6 * F * ee * ce * ie * le + 3 * F * ee * _e * ue + 6 * F * ee * ae * se * le + 6 * F * ee * ae * ie * he + 3 * F * ee * xe * he + 6 * F * ee * se * ie * de - 6 * oe * ce * se * ie - 3 * oe * _e * ie - 3 * oe * ae * xe, Ce[5] = 6 * j * q * B * he * ue + 3 * j * q * B * Ae - 6 * j * F * ee * ae * ue - 6 * j * F * ee * se * le - 6 * j * F * ee * ie * he + 6 * j * oe * ae * ie + 3 * j * oe * xe - 6 * D * I * F * B * he * ue - 3 * D * I * F * B * Ae + 3 * D * I * ee * ae * ue + 3 * D * I * ee * se * le + 3 * D * I * ee * ie * he + 4 * D * q * U * he * ue + 2 * D * q * U * Ae - D * F * U * B * ae * ue - D * F * U * B * se * le - D * F * U * B * ie * he - 2 * D * U * ee * ae * ie - D * U * ee * xe + 2 * X * B * he * ue + X * B * Ae - 2 * K * F * U * he * ue - K * F * U * Ae - 2 * K * U * B * ae * ue - 2 * K * U * B * se * le - 2 * K * U * B * ie * he + 2 * I * q * k * he * ue + I * q * k * Ae + I * F * k * B * ae * ue + I * F * k * B * se * le + I * F * k * B * ie * he + 2 * I * F * Q * ae * ue + 2 * I * F * Q * se * le + 2 * I * F * Q * ie * he - 4 * I * k * ee * ae * ie - 2 * I * k * ee * xe + 2 * I * Q * B * ae * ie + I * Q * B * xe - 6 * J * G * he * ue - 3 * J * G * Ae + 6 * J * de * he * ue + 3 * J * de * Ae + 3 * J * me * le + 6 * q * G * B * ae * ue + 6 * q * G * B * se * le + 6 * q * G * B * ie * he - 3 * q * k * U * ae * ue - 3 * q * k * U * se * le - 3 * q * k * U * ie * he - 6 * q * B * ce * he * ue - 3 * q * B * ce * Ae - 6 * q * B * ae * de * ue - 6 * q * B * ae * he * le - 6 * q * B * se * de * le - 3 * q * B * se * me - 6 * q * B * ie * de * he - 6 * F * G * ee * ae * ie - 3 * F * G * ee * xe + 6 * F * k * U * B * ae * ie + 3 * F * k * U * B * xe - 2 * F * ne * ae * ie - F * ne * xe + 6 * F * ee * ce * ae * ue + 6 * F * ee * ce * se * le + 6 * F * ee * ce * ie * he + 3 * F * ee * _e * le + 6 * F * ee * ae * se * he + 6 * F * ee * ae * ie * de + 3 * F * ee * xe * de - 6 * oe * ce * ae * ie - 3 * oe * ce * xe - 3 * oe * _e * se, Ce[6] = 3 * z * F * ee * ue - 3 * z * oe * ie - 3 * j * D * I * ee * ue + j * D * F * U * B * ue + 2 * j * D * U * ee * ie + 2 * j * K * U * B * ue - j * I * F * k * B * ue - 2 * j * I * F * Q * ue + 4 * j * I * k * ee * ie - 2 * j * I * Q * B * ie - 6 * j * q * G * B * ue + 3 * j * q * k * U * ue + 6 * j * q * B * de * ue + 6 * j * q * B * he * le + 6 * j * F * G * ee * ie - 6 * j * F * k * U * B * ie + 2 * j * F * ne * ie - 6 * j * F * ee * ce * ue - 6 * j * F * ee * ae * le - 6 * j * F * ee * se * he - 6 * j * F * ee * ie * de + 6 * j * oe * ce * ie + 6 * j * oe * ae * se + H * ee * ue - Y * I * U * B * ue - 2 * Y * F * k * B * ue + Y * F * Q * ue - Y * k * ee * ie + D * K * k * B * ue + 6 * D * I * F * G * B * ue - D * I * F * k * U * ue - 6 * D * I * F * B * de * ue - 6 * D * I * F * B * he * le - 3 * D * I * G * ee * ie + D * I * k * U * B * ie + 3 * D * I * ee * ce * ue + 3 * D * I * ee * ae * le + 3 * D * I * ee * se * he + 3 * D * I * ee * ie * de - 4 * D * q * G * U * ue + D * q * Z * ue + 4 * D * q * U * de * ue + 4 * D * q * U * he * le + D * F * G * U * B * ie + 2 * D * F * Z * B * ie - D * F * k * Q * ie - D * F * U * B * ce * ue - D * F * U * B * ae * le - D * F * U * B * se * he - D * F * U * B * ie * de - 2 * D * U * ee * ce * ie - 2 * D * U * ee * ae * se - 2 * X * G * B * ue + 2 * X * B * de * ue + 2 * X * B * he * le + 2 * K * F * G * U * ue - 2 * K * F * U * de * ue - 2 * K * F * U * he * le + 2 * K * G * U * B * ie - K * Z * B * ie - 2 * K * U * B * ce * ue - 2 * K * U * B * ae * le - 2 * K * U * B * se * he - 2 * K * U * B * ie * de - 2 * I * q * G * k * ue + 2 * I * q * k * de * ue + 2 * I * q * k * he * le - I * F * G * k * B * ie - 2 * I * F * G * Q * ie + I * F * Z * U * ie + I * F * k * B * ce * ue + I * F * k * B * ae * le + I * F * k * B * se * he + I * F * k * B * ie * de + 2 * I * F * Q * ce * ue + 2 * I * F * Q * ae * le + 2 * I * F * Q * se * he + 2 * I * F * Q * ie * de - 4 * I * k * ee * ce * ie - 4 * I * k * ee * ae * se + 2 * I * Q * B * ce * ie + 2 * I * Q * B * ae * se + 3 * J * $ * ue - 6 * J * G * de * ue - 6 * J * G * he * le + 3 * J * fe * ue + 6 * J * de * he * le + J * Ee - 3 * q * $ * B * ie + 3 * q * G * k * U * ie + 6 * q * G * B * ce * ue + 6 * q * G * B * ae * le + 6 * q * G * B * se * he + 6 * q * G * B * ie * de - q * re * ie - 3 * q * k * U * ce * ue - 3 * q * k * U * ae * le - 3 * q * k * U * se * he - 3 * q * k * U * ie * de - 6 * q * B * ce * de * ue - 6 * q * B * ce * he * le - 6 * q * B * ae * de * le - 3 * q * B * ae * me - 6 * q * B * se * de * he - 3 * q * B * ie * fe - 6 * F * G * ee * ce * ie - 6 * F * G * ee * ae * se + 6 * F * k * U * B * ce * ie + 6 * F * k * U * B * ae * se - 2 * F * ne * ce * ie - 2 * F * ne * ae * se + 3 * F * ee * ge * ue + 6 * F * ee * ce * ae * le + 6 * F * ee * ce * se * he + 6 * F * ee * ce * ie * de + 3 * F * ee * _e * he + 6 * F * ee * ae * se * de - 3 * oe * ge * ie - 6 * oe * ce * ae * se - oe * ye, Ce[7] = 3 * z * F * ee * le - 3 * z * oe * se - 3 * j * D * I * ee * le + j * D * F * U * B * le + 2 * j * D * U * ee * se + 2 * j * K * U * B * le - j * I * F * k * B * le - 2 * j * I * F * Q * le + 4 * j * I * k * ee * se - 2 * j * I * Q * B * se - 6 * j * q * G * B * le + 3 * j * q * k * U * le + 6 * j * q * B * de * le + 3 * j * q * B * me + 6 * j * F * G * ee * se - 6 * j * F * k * U * B * se + 2 * j * F * ne * se - 6 * j * F * ee * ce * le - 6 * j * F * ee * ae * he - 6 * j * F * ee * se * de + 6 * j * oe * ce * se + 3 * j * oe * _e + H * ee * le - Y * I * U * B * le - 2 * Y * F * k * B * le + Y * F * Q * le - Y * k * ee * se + D * K * k * B * le + 6 * D * I * F * G * B * le - D * I * F * k * U * le - 6 * D * I * F * B * de * le - 3 * D * I * F * B * me - 3 * D * I * G * ee * se + D * I * k * U * B * se + 3 * D * I * ee * ce * le + 3 * D * I * ee * ae * he + 3 * D * I * ee * se * de - 4 * D * q * G * U * le + D * q * Z * le + 4 * D * q * U * de * le + 2 * D * q * U * me + D * F * G * U * B * se + 2 * D * F * Z * B * se - D * F * k * Q * se - D * F * U * B * ce * le - D * F * U * B * ae * he - D * F * U * B * se * de - 2 * D * U * ee * ce * se - D * U * ee * _e - 2 * X * G * B * le + 2 * X * B * de * le + X * B * me + 2 * K * F * G * U * le - 2 * K * F * U * de * le - K * F * U * me + 2 * K * G * U * B * se - K * Z * B * se - 2 * K * U * B * ce * le - 2 * K * U * B * ae * he - 2 * K * U * B * se * de - 2 * I * q * G * k * le + 2 * I * q * k * de * le + I * q * k * me - I * F * G * k * B * se - 2 * I * F * G * Q * se + I * F * Z * U * se + I * F * k * B * ce * le + I * F * k * B * ae * he + I * F * k * B * se * de + 2 * I * F * Q * ce * le + 2 * I * F * Q * ae * he + 2 * I * F * Q * se * de - 4 * I * k * ee * ce * se - 2 * I * k * ee * _e + 2 * I * Q * B * ce * se + I * Q * B * _e + 3 * J * $ * le - 6 * J * G * de * le - 3 * J * G * me + 3 * J * fe * le + 3 * J * de * me - 3 * q * $ * B * se + 3 * q * G * k * U * se + 6 * q * G * B * ce * le + 6 * q * G * B * ae * he + 6 * q * G * B * se * de - q * re * se - 3 * q * k * U * ce * le - 3 * q * k * U * ae * he - 3 * q * k * U * se * de - 6 * q * B * ce * de * le - 3 * q * B * ce * me - 6 * q * B * ae * de * he - 3 * q * B * se * fe - 6 * F * G * ee * ce * se - 3 * F * G * ee * _e + 6 * F * k * U * B * ce * se + 3 * F * k * U * B * _e - 2 * F * ne * ce * se - F * ne * _e + 3 * F * ee * ge * le + 6 * F * ee * ce * ae * he + 6 * F * ee * ce * se * de + 3 * F * ee * _e * de - 3 * oe * ge * se - 3 * oe * ce * _e, Ce[8] = 3 * z * F * ee * he - 3 * z * oe * ae - 3 * j * D * I * ee * he + j * D * F * U * B * he + 2 * j * D * U * ee * ae + 2 * j * K * U * B * he - j * I * F * k * B * he - 2 * j * I * F * Q * he + 4 * j * I * k * ee * ae - 2 * j * I * Q * B * ae - 6 * j * q * G * B * he + 3 * j * q * k * U * he + 6 * j * q * B * de * he + 6 * j * F * G * ee * ae - 6 * j * F * k * U * B * ae + 2 * j * F * ne * ae - 6 * j * F * ee * ce * he - 6 * j * F * ee * ae * de + 6 * j * oe * ce * ae + H * ee * he - Y * I * U * B * he - 2 * Y * F * k * B * he + Y * F * Q * he - Y * k * ee * ae + D * K * k * B * he + 6 * D * I * F * G * B * he - D * I * F * k * U * he - 6 * D * I * F * B * de * he - 3 * D * I * G * ee * ae + D * I * k * U * B * ae + 3 * D * I * ee * ce * he + 3 * D * I * ee * ae * de - 4 * D * q * G * U * he + D * q * Z * he + 4 * D * q * U * de * he + D * F * G * U * B * ae + 2 * D * F * Z * B * ae - D * F * k * Q * ae - D * F * U * B * ce * he - D * F * U * B * ae * de - 2 * D * U * ee * ce * ae - 2 * X * G * B * he + 2 * X * B * de * he + 2 * K * F * G * U * he - 2 * K * F * U * de * he + 2 * K * G * U * B * ae - K * Z * B * ae - 2 * K * U * B * ce * he - 2 * K * U * B * ae * de - 2 * I * q * G * k * he + 2 * I * q * k * de * he - I * F * G * k * B * ae - 2 * I * F * G * Q * ae + I * F * Z * U * ae + I * F * k * B * ce * he + I * F * k * B * ae * de + 2 * I * F * Q * ce * he + 2 * I * F * Q * ae * de - 4 * I * k * ee * ce * ae + 2 * I * Q * B * ce * ae + 3 * J * $ * he - 6 * J * G * de * he + 3 * J * fe * he - 3 * q * $ * B * ae + 3 * q * G * k * U * ae + 6 * q * G * B * ce * he + 6 * q * G * B * ae * de - q * re * ae - 3 * q * k * U * ce * he - 3 * q * k * U * ae * de - 6 * q * B * ce * de * he - 3 * q * B * ae * fe - 6 * F * G * ee * ce * ae + 6 * F * k * U * B * ce * ae - 2 * F * ne * ce * ae + 3 * F * ee * ge * he + 6 * F * ee * ce * ae * de - 3 * oe * ge * ae, Ce[9] = W * oe - z * D * U * ee - 2 * z * I * k * ee + z * I * Q * B - 3 * z * F * G * ee + 3 * z * F * k * U * B - z * F * ne + 3 * z * F * ee * de - 3 * z * oe * ce + j * Y * k * ee + 3 * j * D * I * G * ee - j * D * I * k * U * B - 3 * j * D * I * ee * de - j * D * F * G * U * B - 2 * j * D * F * Z * B + j * D * F * k * Q + j * D * F * U * B * de + 2 * j * D * U * ee * ce - 2 * j * K * G * U * B + j * K * Z * B + 2 * j * K * U * B * de + j * I * F * G * k * B + 2 * j * I * F * G * Q - j * I * F * Z * U - j * I * F * k * B * de - 2 * j * I * F * Q * de + 4 * j * I * k * ee * ce - 2 * j * I * Q * B * ce + 3 * j * q * $ * B - 3 * j * q * G * k * U - 6 * j * q * G * B * de + j * q * re + 3 * j * q * k * U * de + 3 * j * q * B * fe + 6 * j * F * G * ee * ce - 6 * j * F * k * U * B * ce + 2 * j * F * ne * ce - 6 * j * F * ee * ce * de + 3 * j * oe * ge - H * G * ee + H * ee * de + Y * I * G * U * B - Y * I * U * B * de + 2 * Y * F * G * k * B - Y * F * G * Q - 2 * Y * F * k * B * de + Y * F * Q * de - Y * k * ee * ce - D * K * G * k * B + D * K * k * B * de - 3 * D * I * F * $ * B + D * I * F * G * k * U + 6 * D * I * F * G * B * de - D * I * F * k * U * de - 3 * D * I * F * B * fe - 3 * D * I * G * ee * ce + D * I * k * U * B * ce + 3 * D * I * ee * ce * de + 2 * D * q * $ * U - D * q * G * Z - 4 * D * q * G * U * de + D * q * Z * de + 2 * D * q * U * fe + D * F * G * U * B * ce + 2 * D * F * Z * B * ce - D * F * k * Q * ce - D * F * U * B * ce * de - D * U * ee * ge + X * $ * B - 2 * X * G * B * de + X * B * fe - K * F * $ * U + 2 * K * F * G * U * de - K * F * U * fe + 2 * K * G * U * B * ce - K * Z * B * ce - 2 * K * U * B * ce * de + I * q * $ * k - 2 * I * q * G * k * de + I * q * k * fe - I * F * G * k * B * ce - 2 * I * F * G * Q * ce + I * F * Z * U * ce + I * F * k * B * ce * de + 2 * I * F * Q * ce * de - 2 * I * k * ee * ge + I * Q * B * ge - J * te + 3 * J * $ * de - 3 * J * G * fe + J * ve - 3 * q * $ * B * ce + 3 * q * G * k * U * ce + 6 * q * G * B * ce * de - q * re * ce - 3 * q * k * U * ce * de - 3 * q * B * ce * fe - 3 * F * G * ee * ge + 3 * F * k * U * B * ge - F * ne * ge + 3 * F * ee * ge * de - oe * pe;var Le = (0, u.getRealPolynomialRoots)(Ce),Oe = l.getApproxParameterSpaceTolerance(),Se = -Oe,Me = 1 + Oe;C && (Se = Oe), b && (Me = 1 - Oe);for (var we = 0; we < Le.length; ++we) {if (Le[we] >= Se && Le[we] <= Me) {Le[we] < 0 ? Le[we] = 0 : Le[we] > 1 && (Le[we] = 1), Le[we] = A[0] + (A[A.length - 1] - A[0]) * Le[we];var Ne = t.getCurve().evaluatePosition(Le[we]);if (P.isPointInsideWithTolerance(Ne)) {var Fe = r.closestToPointParam(Ne, []);if (Fe >= E[0] && Fe <= E[E.length - 1]) {var Ie = e.getCurve().evaluatePosition(Fe);if (n.Vector3.squaredDistance(Ie, Ne) <= v * v) {var De = f(e, Fe * (e.isReversed() ? -1 : 1), t, Le[we] * (t.isReversed() ? -1 : 1), v);De && L.push(De);}}}}}return L;},C = function C(e, t, r, o) {var i = [],a = t.getControlPoints(),c = e.isReversed() ? -1 : 1,u = new s.Line(),h = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),d = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);u.setFromEndpoints(h, d);var g = n.Vector3.distance(d, h),p = n.Vector3.createFloat64FromValues(a[3], a[4], a[5]),v = n.Vector3.createFloat64FromValues(a[6], a[7], a[8]);if (u.closestToPointParam(p, []) > 0 && u.closestToPointParam(p, []) < g && u.closestToPointParam(v, []) > 0 && u.closestToPointParam(v, []) < g) return i;var _,y = -a[0] + 3 * a[3] - 3 * a[6] + a[9],m = -a[1] + 3 * a[4] - 3 * a[7] + a[10],E = 3 * a[0] - 6 * a[3] + 3 * a[6],x = 3 * a[1] - 6 * a[4] + 3 * a[7],R = -3 * a[0] + 3 * a[3],A = -3 * a[1] + 3 * a[4],P = E / y,V = R / y,T = x / m,C = A / m;if (Math.abs(P - T) < o || Math.abs(C - V) < o) return i;var b = new Float64Array(4);if (Math.abs(y) < o && Math.abs(m) < o) return i;Math.abs(y) < o ? (_ = -R / E, P = T, V = C) : _ = Math.abs(m) < o ? -A / x : (C - V) / (P - T), b[0] = (-_ * _ * _ - P * _ * _ - V * _) / 2, b[1] = (3 * _ * _ + 2 * _ * P + 2 * V) / 2, b[2] = -1.5 * _, b[3] = 1;var L,O = new Float64Array(3);if (3 !== l.SplineCurveHelper.solve_cubic_uniqueRoots(b, O)) return i;if (O[1] < O[0] && (L = O[0], O[0] = O[1], O[1] = L), O[2] < O[0] && (L = O[0], O[0] = O[2], O[2] = L), O[2] < O[1] && (L = O[1], O[1] = O[2], O[2] = L), O[0] >= 0 && O[0] <= 1 && O[2] >= 0 && O[2] <= 1) {var S = t.getKnotVector();O[0] = S[0] + (S[S.length - 1] - S[0]) * O[0], O[2] = S[0] + (S[S.length - 1] - S[0]) * O[2];var M = f(e, O[0] * c, e, O[2] * c, o);M && i.push(M);}return i;};t.computeCurveCurveIntersections = function (e, t, r, i, s) {s = void 0 === s ? o.KERNEL_TOLERANCE : s;var a = e.getCurveType(),c = a === o.GEOMETRY_TYPES.CIRCLE,u = a === o.GEOMETRY_TYPES.LINE,l = a === o.GEOMETRY_TYPES.BCURVE && !e.getCurve().isRational() && 3 === e.getCurve().getDegree(),g = t.getCurveType(),v = g === o.GEOMETRY_TYPES.CIRCLE,R = g === o.GEOMETRY_TYPES.LINE,P = g === o.GEOMETRY_TYPES.BCURVE && !t.getCurve().isRational() && 3 === t.getCurve().getDegree();return u && v ? function (e, t, r) {for (var n = m(e.getCurve(), t.getCurve(), r), o = [], i = 0; i < n.length; ++i) {var s = (e.isReversed() ? -1 : 1) * n[i].lineParam,a = (t.isReversed() ? -1 : 1) * n[i].circleParam,c = f(e, s, t, a, r);c && o.push(c);}return o;}(e, t, s) : c && R ? function (e, t, r, n) {var o = m(t.getCurve(), e.getCurve(), n),i = [],s = 0;e.isClosed() && r && (s = 1);for (var a = 0; a < o.length; ++a) {var c = (e.isReversed() ? -1 : 1) * o[a].circleParam,u = (t.isReversed() ? -1 : 1) * o[a].lineParam,l = f(e, c, t, u, n);if (l) for (var h = -s; h <= s; ++h) {i.push({ cutInfo: { atVertex: l.cutInfo.atVertex, param: l.cutInfo.param + h * Math.PI * 2 }, cutByInfo: l.cutByInfo });}}return i;}(e, t, i, s) : u && R ? y(e, t, r, s) : c && v ? function (e, t, r, o, i) {var s = [],a = e.getCurve().getCenter(),c = e.getCurve().getRadius(),u = t.getCurve().getCenter(),l = t.getCurve().getRadius(),d = 2 * Math.PI,g = n.Vector3.createFloat64();n.Vector3.sub(g, u, a);var v = n.Vector3.length(g),y = Math.abs(c - l);if (v < y - i) return s;if (v + y < i) {var m = i / c;if (e.getRange()[1] - e.getRange()[0] > d - m && t.getRange()[1] - t.getRange()[0] > d - m) return s.push({ rangeInfo: [p(e, e.getRange()[0], i, t), p(e, e.getRange()[1], i, t)], rangeByInfo: [p(t, t.getRange()[0], i, e), p(t, t.getRange()[1], i, e)] }), s;var x = [],R = e.closestToPointParam(t.evaluatePosition(0), [0, d]),A = n.Vector3.dot(e.evaluateDt(R), t.evaluateDt(0)) < 0,P = e.getRange(),V = t.getRange();V = A ? [R - V[1], R - V[0]] : [R + V[0], R + V[1]];var T = (0, h.foldAbove)(V[0], P[0], d) - V[0];if ((V = [V[0] + T, V[1] + T])[0] < P[1] + m && x.push([Math.min(V[0], P[1]), Math.min(P[1], V[1])]), V[1] > P[0] + d - m && x.push([P[0], Math.max(P[0], Math.min(P[1], V[1] - d))]), P[1] - P[0] > d - m || V[1] - V[0] > d - m) for (var C = x.length - 1; C >= 0 && 1 !== x.length; --C) {x[C][1] - x[C][0] < m && x.splice(C, 1);}for (C = 0; C < x.length; ++C) {var b = x[C],L = A ? [R - b[1], R - b[0]] : [b[0] - R, b[1] - R],O = (0, h.foldAbove)(L[0], t.getRange()[0], d) - L[0];if (L = [L[0] + O, L[1] + O], b[1] - b[0] < m) {var S = .5 * (b[0] + b[1]),M = .5 * (L[0] + L[1]),w = p(e, S, i, t),N = p(t, M, i, e);w && N && s.push({ cutInfo: w, cutByInfo: N });} else {var F = [p(e, b[0], i, t), p(e, b[1], i, t)],I = [p(t, L[0], i, e), p(t, L[1], i, e)];F[0] && F[1] && I[0] && I[1] && s.push({ rangeInfo: F, rangeByInfo: I });}}return s;}var D = (c * c - l * l + v * v) / (2 * v),j = c * c - D * D,B = c - Math.abs(D),U = [],k = [];if (B < -i) ;else {var G = Math.sqrt(Math.max(0, j));if (n.Vector3.scale(g, g, 1 / v), G < 2 * i) U.push(E(0, D, a, g, e, t)), k.push(!1);else if (B < i) {if (k.push(!1), r) {k[k.length - 1] = !0;var z = E(0, D, a, g, e, t),Y = [E(G, D, a, g, e, t), E(-G, D, a, g, e, t)];_(e, t, [Y[0].firstParam, z.firstParam, Y[1].firstParam], [Y[0].secondParam, z.secondParam, Y[1].secondParam], i, s, U);} else U.push(E(0, D, a, g, e, t));} else U.push(E(G, D, a, g, e, t)), U.push(E(-G, D, a, g, e, t));}var K = 0;for (e.isClosed() && o && (K = 1), C = 0; C < U.length; ++C) {var q = f(e, U[C].firstParam, t, U[C].secondParam, i);if (q) for (var W = -K; W <= K; ++W) {s.push({ cutInfo: { atVertex: q.cutInfo.atVertex, param: q.cutInfo.param + W * Math.PI * 2 }, cutByInfo: q.cutByInfo }), k[C] && (s[s.length - 1].cutInfo.virtualIntersection = !0, s[s.length - 1].cutByInfo.virtualIntersection = !0);}}return s;}(e, t, r, i, s) : u && P ? A(e, t, r, s) : l && R ? function (e, t, r, n, o) {var i = A(t, e, r, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, r, i, s) : c && P ? V(e, t, 0, i, s) : l && v ? function (e, t, r, n, o) {var i = V(t, e, 0, !1, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, 0, i, s) : l && P ? function (e, t, r, n, o) {var i = e === t,s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, o)) return c;var u,l,h,d,g = e.getCurve().getBezierSegments(),p = g.length,f = t.getCurve().getBezierSegments(),v = f.length,_ = [],y = 0,m = 0,E = 0;for (n && e.getCurve().isPeriodic() && e.isClosed() && (m = 1, E = e.getCurve().getPeriod()), u = 0; u < p; u++) {for (i && (y = u + 1), l = y; l < v; l++) {var R = i && l === u + 1;for (_ = T(e, t, g[u], f[l], r, o, R), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}}if (i) for (u = 0; u < p; ++u) {for (_ = C(e, g[u], 0, o), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}return x(c);}(e, t, r, i, s) : function (e, t, r, n, i) {var s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, i)) return c;var u = e.isReversed(),l = t.isReversed(),h = e.getRange();u && (h = [-h[1], -h[0]]);var g = t.getRange();l && (g = [-g[1], -g[0]]), c = new d.CCI(e.getCurve(), h, t.getCurve(), g, o.KERNEL_TOLERANCE).intersect();for (var p = 0; p < c.length; ++p) {u && (c[p].cutInfo ? c[p].cutInfo.param *= -1 : c[p].rangeInfo && (c[p].rangeInfo = [c[p].rangeInfo[1], c[p].rangeInfo[0]], c[p].rangeInfo[0].param *= -1, c[p].rangeInfo[1].param *= -1)), l && (c[p].cutByInfo ? c[p].cutByInfo.param *= -1 : c[p].rangeByInfo && (c[p].rangeByInfo[0].param *= -1, c[p].rangeByInfo[1].param *= -1));}return c;}(e, t, 0, 0, s);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.edgesAreCoincident = t.curvesAreCoincident = void 0;var n = r(1),o = r(0),i = r(2),s = r(8);function a(e, t, r, o, i) {var s = e.evaluatePosition(t),a = r.closestToPointParam(s, o),c = r.evaluatePosition(a);return n.Vector3.squaredDistance(s, c) < i * i;}function c(e, t, r, o, i, s) {var c = [0, 0, 0];if (n.Vector3.isParallel(e, t.getNormal())) return !0;n.Vector3.add(c, t.getCenter(), e);var u = t.closestToPointParam(c, o);if (u > o[0] && u < o[1] && !a(t, u, r, i, s)) return !1;n.Vector3.sub(c, t.getCenter(), e);var l = t.closestToPointParam(c, o);return !(l > o[0] && l < o[1] && !a(t, l, r, i, s));}function u(e, t, r, n, o) {if (!a(e, .5 * (r[0] + r[1]), t, n, o)) return !1;var i = t.closestToPointParam(e.getCenter(), n);return !(i > n[0] && i < n[1] && !a(t, i, e, r, o));}var l = function l(e, t, r, _l, h) {r ? 0 === r.length && (r = e.getRangeUnlimited()) : r = e.getRange(), _l ? 0 === _l.length && (_l = t.getRangeUnlimited()) : _l = t.getRange(), h || (h = o.KERNEL_TOLERANCE);var d = e.getGeometryType(),g = t.getGeometryType();if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(_l[0]) && isFinite(_l[1]))) {var p = r[0] === Number.NEGATIVE_INFINITY && r[1] === Number.POSITIVE_INFINITY,f = _l[0] === Number.NEGATIVE_INFINITY && _l[1] === Number.POSITIVE_INFINITY;return !(!p || !f) && (i.ConsoleUtils.assert(d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE), function (e, t, r) {if (e === t) return !0;if (!a(e, 0, t, [], r) || !a(t, 0, e, [], r)) return !1;var o = e.evaluateDt(0);n.Vector3.normalize(o, o);var i = t.evaluateDt(0);return n.Vector3.normalize(i, i), n.Vector3.dot(o, i) < 0 && n.Vector3.negate(i, i), n.Vector3.equals(o, i, n.FLOAT64_TOLERANCE);}(e, t, h));}return e === t && Math.abs(r[0] - _l[0]) < n.FLOAT64_TOLERANCE && Math.abs(r[1] - _l[1]) < n.FLOAT64_TOLERANCE || !!(a(e, r[0], t, _l, h) && a(e, r[1], t, _l, h) && a(t, _l[0], e, r, h) && a(t, _l[1], e, r, h)) && (d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE || (d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.CIRCLE ? function (e, t, r, o, i) {var s = .5 * (r[0] + r[1]),u = .5 * (o[0] + o[1]);if (!a(e, s, t, o, i) || !a(t, u, e, r, i)) return !1;var l = n.Vector3.sub([0, 0, 0], t.getCenter(), e.getCenter());if (n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (n.Vector3.dot(e.getNormal(), t.getNormal()) < 0 ? n.Vector3.add(l, e.getNormal(), t.getNormal()) : n.Vector3.sub(l, e.getNormal(), t.getNormal()), n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (r[1] - r[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var h = e.evaluatePosition(s + Math.PI),d = t.closestToPointParam(h, o);if (d > o[0] && d < o[1] && !a(t, d, e, r, i)) return !1;}if (o[1] - o[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var g = t.evaluatePosition(u + Math.PI),p = e.closestToPointParam(g, r);if (p > r[0] && p < r[1] && !a(e, p, t, o, i)) return !1;}return !0;}(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.LINE ? u(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.CIRCLE ? u(t, e, _l, r, h) : function (e, t, r, o, i) {for (var a = [r[0], r[1]], c = [e.evaluatePosition(r[0]), e.evaluatePosition(r[1])], u = 0; u < 100; ++u) {var l = .5 * (a[0] + a[1]),h = e.evaluatePosition(l),d = t.closestToPointParam(h, o),g = t.evaluatePosition(d),p = n.Vector3.sub([0, 0, 0], g, h);if (n.Vector3.squaredLength(p) > i * i) return !1;if (n.Vector3.distance(c[0], h) + n.Vector3.distance(h, c[1]) < i) return !0;var f = e.evaluateDt(l);n.Vector3.dot(f, p) < 0 ? (a[0] = l, c[0] = h) : (a[1] = l, c[1] = h);}return s.DebugUtils.warn("Binary search in coincidence check exceeded maximum iterations"), !0;}(e, t, r, _l, h)));};t.curvesAreCoincident = l, t.edgesAreCoincident = function (e, t) {if (e === t) return !0;var r = Math.max(o.KERNEL_TOLERANCE, e.getPrecision(), t.getPrecision()),i = e.getCurve(),s = t.getCurve();if (!i || !s) {if (i || s) return !1;var a = e.getStartVertex(),c = t.getStartVertex();r = Math.max(r, a.getPrecision(), c.getPrecision());var u = a.getPosition(),h = c.getPosition();return n.Vector3.squaredDistance(u, h) < r * r;}var d = e.getRange();e.isReversed() && (d = [-d[1], -d[0]]);var g = t.getRange();return t.isReversed() && (g = [-g[1], -g[0]]), l(i, s, d, g, r);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extrudeFace = void 0;var n = r(1),o = r(0),i = r(2),s = r(18),a = r(38),c = r(39),u = r(53),l = r(13),h = r(15),d = r(26),g = r(25),p = r(24),f = r(55),v = r(19),_ = r(28);function y(e, t, r) {var i = n.Vector3.length(r),s = n.Vector3.dot(e.getAxisDir(), r) > 0 ? [0, i] : [-i, 0];e.limitRangeU(s), t[1] - t[0] < 2 * Math.PI - o.PARAMETER_SPACE_TOLERANCE && e.limitRangeV(t);}var m = function m(e, t) {var r = e.getEdge().getCurve(),i = e.getRange(),l = !0;e.isReversed() !== e.getEdge().isReversed() && (i = [-i[1], -i[0]], l = !1);var h,d = l ? e.t0() : e.t1(),g = e.evaluateDt(d);if (n.Vector3.cross(g, g, t), n.Vector3.normalize(g, g), n.Vector3.negate(g, g), r.getGeometryType() === o.GEOMETRY_TYPES.LINE) h = function (e, t, r) {var o = new s.Plane(),i = e.evaluateDt(0),a = n.Vector3.createFloat64();n.Vector3.normalize(a, r);var c = n.Vector3.createFloat64();n.Vector3.cross(c, a, i), o.set(e.evaluatePosition(0), c, a);var u = n.Vector3.length(r),l = n.Vector3.dot(a, r) > 0 ? [0, u] : [-u, 0];return o.limitRangeV(t), o.limitRangeU(l), o;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.CIRCLE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new a.Cylinder();return s.set(e.getCenter(), e.getRadius(), i, o, 1), y(s, t, r), s;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.ELLIPSE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new c.EllipticalCylinder();return s.set(e.getCenter(), o, e.getMinorRadius() / e.getMajorRadius(), i, 1), y(s, t, r), s;}(r, i, t);else {if (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE) throw new Error("createSideFaceRuledSurface: Curve type not supported.");h = function (e, t, r) {for (var n = new u.BSurface(), o = e.getDegree(), i = e.getKnotVector().slice(0), s = e.getControlPoints().slice(0), a = (s = s.concat(s)).length / 2; a < s.length; a += 3) {s[a] += r[0], s[a + 1] += r[1], s[a + 2] += r[2];}var c = void 0;return e.isRational() && (c = (c = e.getWeights().slice(0)).concat(c)), n.set(1, o, [0, 0, 1, 1], i, s, c), n.limitRangeU([0, 1]), n.limitRangeV(t), n;}(r, i, t);}var p = h.evaluateNormal(0, i[0]);return { surface: h, isReversed: n.Vector3.dot(p, g) < 0 };};t.extrudeFace = function (e, t) {i.ConsoleUtils.assert(e.getSurfaceType() === o.GEOMETRY_TYPES.PLANE);var r = e.evaluateNormal(0, 0);n.Vector3.scale(r, r, t);var s = new f.TopologyCloner().cloneFace(e),a = n.Matrix44.fromTranslation(n.Matrix44.createFloat64(), r);(0, v.transformTopology)(s, a), t > 0 ? (0, v.reverseFace)(e) : (0, v.reverseFace)(s);var c = function (e, t, r) {for (var n = [], o = e.getLoops(), i = t.getLoops(), s = 0; s < o.length; ++s) {for (var a = o[s].getCoedges(), c = i[s].getCoedges(), u = new Array(a.length), d = 0; d < a.length; ++d) {var g = new Array(4),p = a[d],f = c[a.length - 1 - d],v = p.getStartVertex(),y = p.getEndVertex(),E = f.getStartVertex(),x = f.getEndVertex();g[0] = (0, _.createCoedgeOnEdge)(p.getEdge()), 0 === d && (u[d] = (0, _.createLineEdgeBetweenVertices)(v, x)), g[1] = (0, _.createCoedgeOnEdge)(u[d]), g[2] = (0, _.createCoedgeOnEdge)(f.getEdge()), d !== a.length - 1 && (u[d + 1] = (0, _.createLineEdgeBetweenVertices)(E, y)), g[3] = (0, _.createCoedgeOnEdge)(u[(d + 1) % a.length]);var R = new l.Loop();R.addCoedges(g);var A = m(p, r),P = new h.Face(A.surface);P.setReversed(A.isReversed), P.addLoop(R), n.push(P);}}return n;}(e, s, r),u = e.getShell();u || (u = new d.Shell()).addFace(e), i.ConsoleUtils.assert(1 === u.getFaces().length), u.addFaces(c), u.addFace(s);var y = u.getLump();y || (y = new g.Lump()).addShell(u);var E = y.getBody();return E || (E = new p.Body()).addLump(y), E;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeSketchRegions = void 0;var n = r(0),o = r(19),i = r(80),s = function s(e, t) {var r = e.getProgenitorMap(),o = new Set();return t.forEach(function (e) {r.getDescendants(e).forEach(function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.EDGE && o.add(e);});}), Array.from(o);},a = function a(e, t) {var r = [];return (0, o.findConnectedFaces)(e, { allowVertexConnections: !1, barrierEdges: t }).forEach(function (e) {(function (e, t) {e = new Set(e), t = new Set(t);var r = new Set();e.forEach(function (e) {e.collectEdges(r);}), r = Array.from(r);for (var n = 0; n < r.length; n++) {var o = r[n];if (!t.has(o)) {var i = o.getCoedges();if (i.length < 2) return !1;for (var s = 0; s < i.length; s++) {if (!e.has(i[s].getFace())) return !1;}}}return !0;})(e, t) && (r = r.concat(e));}), r;},c = function c(e, t) {for (var r = 0; r < e.length; r++) {if (t.indexOf(e[r]) < 0) return !1;}return !0;};t.mergeSketchRegions = function (e) {var t,r,n = [];e.forEach(function (e) {n = n.concat(e.getEdges());});var u = new i.SketchRegionSolver();u.compute(n);var l = u.getFaces(),h = [],d = [];for (t = 0; t < e.length; t++) {var g = s(u, e[t].getEdges());if (0 !== g.length) {var p = a(l, g);0 !== p.length && (d.push(g), h.push(p));}}for (var f = [], v = new Set(l), _ = !0; h.length > 0;) {var y = [];for (t = 0; t < h.length; t++) {var m = !1;for (r = 0; r < h.length; r++) {if (t !== r && c(h[t], h[r])) {m = !0;break;}}y.push(m);}var E = new Set();for (t = h.length - 1; t >= 0; t--) {y[t] ? h[t].forEach(function (e) {E.add(e), v.delete(e);}) : (h.splice(t, 1), d.splice(t, 1));}_ && (f = f.concat(Array.from(v))), v = E, _ = !_;}return (0, o.mergeConnectedFaces)(f);}, t.getRegionEdges = s, t.getBoundedRegionFaces = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.propertyToRange = t.GeometrySetters = void 0;var n = r(1),o = function o(e, t, r) {var n = t[r];e[0] = n.x, e[1] = n.y, e[2] = n.z;},i = function i(e, t) {var r = e[t];var n = r.type;return "infinite" === n || 0 === n ? [] : [r.low, r.high];},s = function s(e, t) {var r = i(e, "uRange");t.unlimitRangeU(), r.length > 0 && t.limitRangeU(r);var n = i(e, "vRange");t.unlimitRangeV(), n.length > 0 && t.limitRangeV(n);},a = function a(e, t) {var r = i(e, "range");t.unlimitRange(), r.length > 0 && t.limitRange(r);},c = { setBCurveFromProperty: function setBCurveFromProperty(e, t) {var r,n,o = t.degree,i = t.knots,s = t.controlPoints,c = t.weights,u = s.length / 3;if (0 === c.length) for (n = new Array(u), r = 0; r < u; ++r) {n[r] = 1;} else n = c;e.set(s, n, o, i), a(t, e);}, setBSurfaceFromProperty: function setBSurfaceFromProperty(e, t) {var r,n,o = t.uDegree,i = t.vDegree,a = t.uKnots,c = t.vKnots,u = t.controlPoints,l = t.weights;if (0 === l.length) {var h = u.length / 3;for (n = new Array(h), r = 0; r < h; ++r) {n[r] = 1;}} else n = l;e.set(o, i, a, c, u, n), s(t, e);}, setCircleFromProperty: function setCircleFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "radius"), e.set(r, i, s), a(t, e);}, setConeFromProperty: function setConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.angle,l = t.uCoordScale;e.set(r, c, i, u, a, l), s(t, e);}, setCylinderFromProperty: function setCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.uCoordScale;e.set(r, c, i, a, u), s(t, e);}, setEllipseFromProperty: function setEllipseFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "majorRadius");var c = t.radiusRatio;e.set(r, i, s, c), a(t, e);}, setEllipticalConeFromProperty: function setEllipticalConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.angle,u = t.radiusRatio,l = t.uCoordScale;e.set(r, a, u, i, c, l), s(t, e);}, setEllipticalCylinderFromProperty: function setEllipticalCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.radiusRatio,u = t.uCoordScale;e.set(r, a, c, i, u), s(t, e);}, setLineFromProperty: function setLineFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64();o(r, t, "position"), o(i, t, "direction"), e.set(r, i), a(t, e);}, setPlaneFromProperty: function setPlaneFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "origin"), o(i, t, "normal"), o(a, t, "uAxis"), e.set(r, i, a), s(t, e);}, setPointFromProperty: function setPointFromProperty(e, t) {e.setPosition(t.position.x, t.position.y, t.position.z);}, setSphereFromProperty: function setSphereFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "radius"), o(a, t, "axis");var c = n.Vector3.length(i);n.Vector3.normalize(i, i), e.set(r, c, a, i), s(t, e);}, setTorusFromProperty: function setTorusFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "coordAxis");var c = t.majorRadius,u = t.minorRadius,l = t.lemon;e.set(r, c, u, i, a, l), s(t, e);}, setHapCurveFromProperty: function setHapCurveFromProperty(e, t) {for (var r = t.spans, n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = {}, n[o].polyOrder = r[o].polyOrder, n[o].lowParam = r[o].lowParam, n[o].highParam = r[o].highParam, n[o].coefs = r[o].coefs.slice(0);}var i = {};i.spans = n;var s = t.periodic;void 0 === s && (s = !1), i.periodic = s, i.closed = s, e.setHapDefinition(i), a(t, e);}, setCurveRangeFromProperty: a, setSurfaceRangeFromProperty: s };t.GeometrySetters = c, t.propertyToRange = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeConnectedFaces = t.getOrderedFacesOnVertex = t.saveToProtoMessage = t.saveToProtoBinary = t.SolidDefSaver = t.SolidDefLoader = t.Path2D = t.DebugUtils = t.svgFromWire = t.transformTopology = t.TopologyStitcher = t.TopologyCloner = t.extrudeFace = t.createEdgeFromCurve = t.createFaceFromPolyline = t.createShellsFromFaces = t.createPolyhedron = t.createLineEdgeBetweenVertices = t.createLineEdge = t.createCylinder = t.createCone = t.createBlock = t.computeCurveCurveIntersections = t.SketchRegionSolver = t.facetPlanarFace = t.checkValidity = t.BoundingBox = t.Attribute = t.Wire = t.WireBody = t.Vertex = t.Edge = t.Coedge = t.Loop = t.Face = t.Shell = t.Lump = t.Body = t.BSurface = t.Torus = t.EllipticalCone = t.Cone = t.Sphere = t.EllipticalCylinder = t.Cylinder = t.Plane = t.BCurve = t.Ellipse = t.Circle = t.Line = t.Point = t.TOPOLOGY_TYPES = t.GEOMETRY_TYPES = t.KERNEL_TOLERANCE = void 0;var n = r(0),o = r(4),i = r(6),s = r(7),a = r(14),c = r(23),u = r(33),l = r(18),h = r(38),d = r(39),g = r(74),p = r(51),f = r(52),v = r(75),_ = r(53),y = r(24),m = r(25),E = r(26),x = r(15),R = r(13),A = r(27),P = r(20),V = r(16),T = r(54),C = r(40),b = r(79),L = r(106),O = r(107),S = r(80),M = r(81),w = r(115),N = r(116),F = r(117),I = r(28),D = r(83),j = r(55),B = r(118),U = r(19),k = r(121),G = r(8),z = r(122),Y = r(123),K = r(126),q = r(84),W = r(78);t.KERNEL_TOLERANCE = n.KERNEL_TOLERANCE, t.GEOMETRY_TYPES = n.GEOMETRY_TYPES, t.TOPOLOGY_TYPES = n.TOPOLOGY_TYPES, t.Point = i.Point, t.Line = s.Line, t.Circle = a.Circle, t.Ellipse = c.Ellipse, t.BCurve = u.BCurve, t.Plane = l.Plane, t.Cylinder = h.Cylinder, t.EllipticalCylinder = d.EllipticalCylinder, t.Sphere = g.Sphere, t.Cone = p.Cone, t.EllipticalCone = f.EllipticalCone, t.Torus = v.Torus, t.BSurface = _.BSurface, t.Body = y.Body, t.Lump = m.Lump, t.Shell = E.Shell, t.Face = x.Face, t.Loop = R.Loop, t.Coedge = A.Coedge, t.Edge = P.Edge, t.Vertex = V.Vertex, t.WireBody = T.WireBody, t.Wire = C.Wire, t.Attribute = b.Attribute, t.BoundingBox = o.BoundingBox, t.checkValidity = L.checkValidity, t.facetPlanarFace = O.facetPlanarFace, t.SketchRegionSolver = S.SketchRegionSolver, t.computeCurveCurveIntersections = M.computeCurveCurveIntersections, t.createBlock = w.createBlock, t.createCone = N.createCone, t.createCylinder = N.createCylinder, t.createLineEdge = I.createLineEdge, t.createLineEdgeBetweenVertices = I.createLineEdgeBetweenVertices, t.createPolyhedron = F.createPolyhedron, t.createShellsFromFaces = I.createShellsFromFaces, t.createFaceFromPolyline = I.createFaceFromPolyline, t.createEdgeFromCurve = I.createEdgeFromCurve, t.extrudeFace = D.extrudeFace, t.TopologyCloner = j.TopologyCloner, t.TopologyStitcher = B.TopologyStitcher, t.transformTopology = U.transformTopology, t.svgFromWire = k.svgFromWire, t.DebugUtils = G.DebugUtils, t.Path2D = z.Path2D, t.SolidDefLoader = Y.SolidDefLoader, t.SolidDefSaver = K.SolidDefSaver, t.saveToProtoBinary = K.saveToProtoBinary, t.saveToProtoMessage = K.saveToProtoMessage, t.getOrderedFacesOnVertex = W.getOrderedFacesOnVertex, t.mergeConnectedFaces = U.mergeConnectedFaces, t.getRegionEdges = q.getRegionEdges, t.getBoundedRegionFaces = q.getBoundedRegionFaces;}, function (e, t, r) {"use strict";e.exports = r(88);}, function (e, t, r) {"use strict";var n = e.exports = r(89);n.build = "light", n.load = function (e, t, r) {return "function" == typeof t ? (r = t, t = new n.Root()) : t || (t = new n.Root()), t.load(e, r);}, n.loadSync = function (e, t) {return t || (t = new n.Root()), t.loadSync(e);}, n.encoder = r(62), n.decoder = r(67), n.verifier = r(68), n.converter = r(69), n.ReflectionObject = r(21), n.Namespace = r(30), n.Root = r(71), n.Enum = r(11), n.Type = r(63), n.Field = r(22), n.OneOf = r(48), n.MapField = r(64), n.Service = r(65), n.Method = r(66), n.Message = r(49), n.wrappers = r(70), n.types = r(31), n.util = r(5), n.ReflectionObject._configure(n.Root), n.Namespace._configure(n.Type, n.Service, n.Enum), n.Root._configure(n.Type), n.Field._configure(n.Type);}, function (e, t, r) {"use strict";var n = t;function o() {n.Reader._configure(n.BufferReader), n.util._configure();}n.build = "minimal", n.Writer = r(46), n.BufferWriter = r(96), n.Reader = r(47), n.BufferReader = r(97), n.util = r(10), n.rpc = r(60), n.roots = r(61), n.configure = o, n.Writer._configure(n.BufferWriter), o();}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {var t = e.length;if (!t) return 0;for (var r = 0; --t % 4 > 1 && "=" === e.charAt(t);) {++r;}return Math.ceil(3 * e.length) / 4 - r;};for (var o = new Array(64), i = new Array(123), s = 0; s < 64;) {i[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++;}n.encode = function (e, t, r) {for (var n, i = null, s = [], a = 0, c = 0; t < r;) {var u = e[t++];switch (c) {case 0:s[a++] = o[u >> 2], n = (3 & u) << 4, c = 1;break;case 1:s[a++] = o[n | u >> 4], n = (15 & u) << 2, c = 2;break;case 2:s[a++] = o[n | u >> 6], s[a++] = o[63 & u], c = 0;}a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);}return c && (s[a++] = o[n], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, s.slice(0, a));}, n.decode = function (e, t, r) {for (var n, o = r, s = 0, a = 0; a < e.length;) {var c = e.charCodeAt(a++);if (61 === c && s > 1) break;if (void 0 === (c = i[c])) throw Error("invalid encoding");switch (s) {case 0:n = c, s = 1;break;case 1:t[r++] = n << 2 | (48 & c) >> 4, n = c, s = 2;break;case 2:t[r++] = (15 & n) << 4 | (60 & c) >> 2, n = c, s = 3;break;case 3:t[r++] = (3 & n) << 6 | c, s = 0;}}if (1 === s) throw Error("invalid encoding");return r - o;}, n.test = function (e) {return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);};}, function (e, t, r) {"use strict";function n() {this._listeners = {};}e.exports = n, n.prototype.on = function (e, t, r) {return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;}, n.prototype.off = function (e, t) {if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) {r[n].fn === t ? r.splice(n, 1) : ++n;}return this;}, n.prototype.emit = function (e) {var t = this._listeners[e];if (t) {for (var r = [], n = 1; n < arguments.length;) {r.push(arguments[n++]);}for (n = 0; n < t.length;) {t[n].fn.apply(t[n++].ctx, r);}}return this;};}, function (e, t, r) {"use strict";function n(e) {return "undefined" != typeof Float32Array ? function () {var t = new Float32Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[3];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];}function i(e, n, o) {t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];}function a(e, n) {return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];}e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;}() : function () {function t(e, t, r, n) {var o = t < 0 ? 1 : 0;if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {var i = Math.floor(Math.log(t) / Math.LN2);e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);}}function r(e, t, r) {var n = e(t, r),o = 2 * (n >> 31) + 1,i = n >>> 23 & 255,s = 8388607 & n;return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);}e.writeFloatLE = t.bind(null, o), e.writeFloatBE = t.bind(null, i), e.readFloatLE = r.bind(null, s), e.readFloatBE = r.bind(null, a);}(), "undefined" != typeof Float64Array ? function () {var t = new Float64Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[7];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];}function i(e, n, o) {t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];}function a(e, n) {return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];}e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;}() : function () {function t(e, t, r, n, o, i) {var s = n < 0 ? 1 : 0;if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {var a;if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {var c = Math.floor(Math.log(n) / Math.LN2);1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);}}}function r(e, t, r, n, o) {var i = e(n, o + t),s = e(n, o + r),a = 2 * (s >> 31) + 1,c = s >>> 20 & 2047,u = 4294967296 * (1048575 & s) + i;return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);}e.writeDoubleLE = t.bind(null, o, 0, 4), e.writeDoubleBE = t.bind(null, i, 4, 0), e.readDoubleLE = r.bind(null, s, 0, 4), e.readDoubleBE = r.bind(null, a, 4, 0);}(), e;}function o(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}function i(e, t, r) {t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;}function s(e, t) {return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;}function a(e, t) {return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;}e.exports = n(n);}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {for (var t = 0, r = 0, n = 0; n < e.length; ++n) {(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;}return t;}, n.read = function (e, t, r) {if (r - t < 1) return "";for (var n, o = null, i = [], s = 0; t < r;) {(n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);}return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, s));}, n.write = function (e, t, r) {for (var n, o, i = r, s = 0; s < e.length; ++s) {(n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);}return r - i;};}, function (e, t, r) {"use strict";e.exports = function (e, t, r) {var n = r || 8192,o = n >>> 1,i = null,s = n;return function (r) {if (r < 1 || r > o) return e(r);s + r > n && (i = e(n), s = 0);var a = t.call(i, s, s += r);return 7 & s && (s = 1 + (7 | s)), a;};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t) {this.lo = e >>> 0, this.hi = t >>> 0;}var i = o.zero = new o(0, 0);i.toNumber = function () {return 0;}, i.zzEncode = i.zzDecode = function () {return this;}, i.length = function () {return 1;};var s = o.zeroHash = "\0\0\0\0\0\0\0\0";o.fromNumber = function (e) {if (0 === e) return i;var t = e < 0;t && (e = -e);var r = e >>> 0,n = (e - r) / 4294967296 >>> 0;return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new o(r, n);}, o.from = function (e) {if ("number" == typeof e) return o.fromNumber(e);if (n.isString(e)) {if (!n.Long) return o.fromNumber(parseInt(e, 10));e = n.Long.fromString(e);}return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;}, o.prototype.toNumber = function (e) {if (!e && this.hi >>> 31) {var t = 1 + ~this.lo >>> 0,r = ~this.hi >>> 0;return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);}return this.lo + 4294967296 * this.hi;}, o.prototype.toLong = function (e) {return n.Long ? new n.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };};var a = String.prototype.charCodeAt;o.fromHash = function (e) {return e === s ? i : new o((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);}, o.prototype.toHash = function () {return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);}, o.prototype.zzEncode = function () {var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;}, o.prototype.zzDecode = function () {var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;}, o.prototype.length = function () {var e = this.lo,t = (this.lo >>> 28 | this.hi << 4) >>> 0,r = this.hi >>> 24;return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;};}, function (e, t, r) {"use strict";e.exports = s;var n = r(46);(s.prototype = Object.create(n.prototype)).constructor = s;var o = r(10),i = o.Buffer;function s() {n.call(this);}s.alloc = function (e) {return (s.alloc = o._Buffer_allocUnsafe)(e);};var a = i && i.prototype instanceof Uint8Array && "set" === i.prototype.set.name ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) {t[r++] = e[n++];}};function c(e, t, r) {e.length < 40 ? o.utf8.write(e, t, r) : t.utf8Write(e, r);}s.prototype.bytes = function (e) {o.isString(e) && (e = o._Buffer_from(e, "base64"));var t = e.length >>> 0;return this.uint32(t), t && this._push(a, t, e), this;}, s.prototype.string = function (e) {var t = i.byteLength(e);return this.uint32(t), t && this._push(c, t, e), this;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(47);(i.prototype = Object.create(n.prototype)).constructor = i;var o = r(10);function i(e) {n.call(this, e);}o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t, r) {if ("function" != typeof e) throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);}(o.prototype = Object.create(n.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, r, o, i, s) {if (!i) throw TypeError("request must be specified");var a = this;if (!s) return n.asPromise(e, a, t, r, o, i);if (a.rpcImpl) try {return a.rpcImpl(t, r[a.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function (e, r) {if (e) return a.emit("error", e, t), s(e);if (null !== r) {if (!(r instanceof o)) try {r = o[a.responseDelimited ? "decodeDelimited" : "decode"](r);} catch (e) {return a.emit("error", e, t), s(e);}return a.emit("data", r, t), s(null, r);}a.end(!0);});} catch (e) {return a.emit("error", e, t), void setTimeout(function () {s(e);}, 0);} else setTimeout(function () {s(Error("already ended"));}, 0);}, o.prototype.end = function (e) {return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;};}, function (e, t, r) {"use strict";function n(e, t) {"string" == typeof e && (t = e, e = void 0);var r = [];function o(e) {if ("string" != typeof e) {var t = i();if (n.verbose && console.log("codegen: " + t), t = "return " + t, e) {for (var s = Object.keys(e), a = new Array(s.length + 1), c = new Array(s.length), u = 0; u < s.length;) {a[u] = s[u], c[u] = e[s[u++]];}return a[u] = t, Function.apply(null, a).apply(null, c);}return Function(t)();}for (var l = new Array(arguments.length - 1), h = 0; h < l.length;) {l[h] = arguments[++h];}if (h = 0, e = e.replace(/%([%dfijs])/g, function (e, t) {var r = l[h++];switch (t) {case "d":case "f":return String(Number(r));case "i":return String(Math.floor(r));case "j":return JSON.stringify(r);case "s":return String(r);}return "%";}), h !== l.length) throw Error("parameter count mismatch");return r.push(e), o;}function i(n) {return "function " + (n || t || "") + "(" + (e && e.join(",") || "") + "){\n  " + r.join("\n  ") + "\n}";}return o.toString = i, o;}e.exports = n, n.verbose = !1;}, function (e, t, r) {"use strict";e.exports = i;var n = r(58),o = r(59)("fs");function i(e, t, r) {return "function" == typeof t ? (r = t, t = {}) : t || (t = {}), r ? !t.xhr && o && o.readFile ? o.readFile(e, function (n, o) {return n && "undefined" != typeof XMLHttpRequest ? i.xhr(e, t, r) : n ? r(n) : r(null, t.binary ? o : o.toString("utf8"));}) : i.xhr(e, t, r) : n(i, this, e, t);}i.xhr = function (e, t, r) {var n = new XMLHttpRequest();n.onreadystatechange = function () {if (4 === n.readyState) {if (0 !== n.status && 200 !== n.status) return r(Error("status " + n.status));if (t.binary) {var e = n.response;if (!e) {e = [];for (var o = 0; o < n.responseText.length; ++o) {e.push(255 & n.responseText.charCodeAt(o));}}return r(null, "undefined" != typeof Uint8Array ? new Uint8Array(e) : e);}return r(null, n.responseText);}}, t.binary && ("overrideMimeType" in n && n.overrideMimeType("text/plain; charset=x-user-defined"), n.responseType = "arraybuffer"), n.open("GET", e), n.send();};}, function (e, t, r) {"use strict";var n = t,o = n.isAbsolute = function (e) {return /^(?:\/|\w+:)/.test(e);},i = n.normalize = function (e) {var t = (e = e.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"),r = o(e),n = "";r && (n = t.shift() + "/");for (var i = 0; i < t.length;) {".." === t[i] ? i > 0 && ".." !== t[i - 1] ? t.splice(--i, 2) : r ? t.splice(i, 1) : ++i : "." === t[i] ? t.splice(i, 1) : ++i;}return n + t.join("/");};n.resolve = function (e, t, r) {return r || (t = i(t)), o(t) ? t : (r || (e = i(e)), (e = e.replace(/(?:\/|^)[^/]+$/, "")).length ? i(e + "/" + t) : t);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBCurveFlags = t.decomposeBCurveToBezier = t.decomposeBCurveControlPoints = void 0;var n = r(17),o = r(2),i = function i(e, t, r) {o.ConsoleUtils.assert(t.length % r == 0);var n,i,s,a = e.length - t.length / r - 1;o.ConsoleUtils.assert(a > 0);var c = e.length - 1,u = a,l = a + 1,h = 0,d = [],g = [];for (g[h] = new Array((a + 1) * r), n = 0; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[n * r + s];}}for (; l < c;) {for (var p = 1; l < c && e[l + 1] === e[l];) {++l, ++p;}var f = l === c;if (f || (g[h + 1] = new Array((a + 1) * r)), p < a) {var v = e[l] - e[u];for (i = a; i > p; --i) {d[i - p - 1] = v / (e[u + i] - e[u]);}var _ = a - p;for (i = 1; i <= _; ++i) {for (var y = _ - i, m = p + i, E = a; E >= m; --E) {var x = d[E - m];for (s = 0; s < r; ++s) {g[h][E * r + s] = g[h][E * r + s] * x + g[h][(E - 1) * r + s] * (1 - x);}}if (!f) for (s = 0; s < r; ++s) {g[h + 1][y * r + s] = g[h][a * r + s];}}}if (f) break;for (++h, n = a - p; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[(l - a + n) * r + s];}}u = l, ++l;}return g;};t.decomposeBCurveControlPoints = i, t.decomposeBCurveToBezier = function (e, t, r) {var s,a = r && r.length > 0;o.ConsoleUtils.assert(t.length > 0 && t.length % 3 == 0), o.ConsoleUtils.assert(!a || t.length === 3 * r.length);var c,u,l = e.length - t.length / 3 - 1;if (o.ConsoleUtils.assert(l > 0), a) {var h = (0, n.controlPointsToHomogeneous)(t, r);for (c = i(e, h, 4), u = [], s = 0; s < c.length; ++s) {var d = (0, n.controlPointsFromHomogeneous)(c[s]);c[s] = d.P, u[s] = d.w;}} else c = i(e, t, 3), u = void 0;var g = (0, n.getUniqueKnots)(e);o.ConsoleUtils.assert(g.length === c.length + 1);var p = new Array(g.length - 1);for (s = 0; s < p.length; ++s) {p[s] = new Array(2 * l + 2), p[s].fill(g[s], 0, l + 1), p[s].fill(g[s + 1], l + 1);}return { U: p, P: c, w: u };}, t.decomposeBCurveFlags = function (e, t) {var r,n = e.length - t.length - 1,o = new Array(t.length);o.fill(!1);var i = n - 1;for (r = 0; r < t.length; ++r) {if (t[r]) {var s = Math.max(r - i, 0),a = Math.min(r + i, o.length - 1);o.fill(!0, s, a + 1);}}var c = [],u = e.length - 1,l = n + 1,h = 0;for (c[h] = !1, r = 0; r <= n; ++r) {o[r] && (c[h] = !0);}for (; l < u;) {for (var d = 1; l < u && e[l + 1] === e[l];) {++l, ++d;}if (l === u) break;for (c[++h] = !1, r = n - d; r <= n; ++r) {o[l - n + r] && (c[h] = !0);}++l;}return c;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extractBSurfaceParamLineV = t.extractBSurfaceParamLineU = t.insertBSurfaceKnotV = t.insertBSurfaceKnotU = void 0;var n = r(1),o = r(17),i = r(0),s = function s(e, t, r, o, i, _s, a) {var c,u,l = new Array(o);for (u = 0; u < o; ++u) {l[u] = new Array(i - u - r);var h = t - i + u + 1;for (c = 0; c < i - u - r; ++c) {l[u][c] = (e - _s[h + c]) / (_s[c + t + 1] - _s[h + c]);}}for (var d = a.length, g = new Array(d), p = new Array(i - r + 1), f = 0; f < d; ++f) {for (g[f] = new Array(i - r + o - 1), c = 0; c <= i - r; ++c) {p[c] = n.Vector4.clone(a[f][c]);}for (u = 0; u < o; ++u) {for (c = 0; c < i - u - r; ++c) {n.Vector4.lerp(p[c], p[c], p[c + 1], l[u][c]);}g[f][u] = n.Vector4.clone(p[0]), g[f][i + o - r - u - 2] = n.Vector4.clone(p[i - u - r - 1]);}for (c = o; c < i - r - 1; c++) {g[f][c] = n.Vector4.clone(p[c - o + 1]);}}return g;};t.insertBSurfaceKnotU = function (e, t, r, a, c, u, l, h) {t = Math.min(t, r);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, c);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < c[0] + i.PARAMETER_SPACE_TOLERANCE || e > c[c.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { uknots: c.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(E),R = p - r,A = p - f;for (y = 0; y < E; ++y) {for (x[y] = new Array(A - R + 1), _ = R; _ <= A; ++_) {var P = _ * E + y,V = d ? h[P] : 1;x[y][_ - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, r, c, x),C = c.slice(0, p + 1);for (_ = 0; _ < v; ++_) {C.push(e);}C = C.concat(c.slice(p + 1));var b,L = new Array(3 * (m + v) * E),O = new Array((m + v) * E);for (y = 0; y < E; ++y) {for (_ = 0; _ <= R; ++_) {P = b = _ * E + y, L[3 * b] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (_ = 0; _ < T[y].length; ++_) {b = (_ + R + 1) * E + y;var S = T[y][_];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (_ = A; _ < m; ++_) {P = _ * E + y, L[3 * (b = (_ + v) * E + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { uknots: C, P: L, weights: d ? O : void 0 };}, t.insertBSurfaceKnotV = function (e, t, r, a, c, u, l, h) {t = Math.min(t, a);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, u);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < u[0] + i.PARAMETER_SPACE_TOLERANCE || e > u[u.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { vknots: u.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(m),R = p - a,A = p - f;for (_ = 0; _ < m; ++_) {for (x[_] = new Array(A - R + 1), y = R; y <= A; ++y) {var P = _ * E + y,V = d ? h[P] : 1;x[_][y - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, a, u, x),C = u.slice(0, p + 1);for (y = 0; y < v; ++y) {C.push(e);}C = C.concat(u.slice(p + 1));var b,L = new Array(3 * m * (E + v)),O = new Array(m * (E + v));for (_ = 0; _ < m; ++_) {for (y = 0; y <= R; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (y = 0; y < T[_].length; ++y) {b = _ * (E + v) + (y + R + 1);var S = T[_][y];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (y = A; y < E; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + (y + v))] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { vknots: C, P: L, weights: d ? O : void 0 };}, t.extractBSurfaceParamLineU = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, a);e = h.knot;var d,g,p,f = h.span,v = e === a[a.length - 1],_ = v ? r + 1 : h.multiplicity,y = r - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * m),R = new Array(m);if (_ >= r) for (g = v ? E - 1 : f - r, d = 0; d < m; ++d) {p = d * E + g, x[3 * d] = c[3 * p], x[3 * d + 1] = c[3 * p + 1], x[3 * d + 2] = c[3 * p + 2], R[d] = l ? u[p] : 1;} else {var A = new Array(m),P = f - r,V = f - _;for (d = 0; d < m; ++d) {for (A[d] = new Array(V - P + 1), g = P; g <= V; ++g) {p = d * E + g;var T = l ? u[p] : 1;A[d][g - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, r, a, A);for (g = y - 1, d = 0; d < m; ++d) {var b = C[d][g];x[3 * d] = b[0] / b[3], x[3 * d + 1] = b[1] / b[3], x[3 * d + 2] = b[2] / b[3], R[d] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };}, t.extractBSurfaceParamLineV = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, i);e = h.knot;var d,g,p,f = h.span,v = e === i[i.length - 1],_ = v ? t + 1 : h.multiplicity,y = t - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * E),R = new Array(E);if (_ >= t) for (d = v ? m - 1 : f - t, g = 0; g < E; ++g) {p = d * E + g, x[3 * g] = c[3 * p], x[3 * g + 1] = c[3 * p + 1], x[3 * g + 2] = c[3 * p + 2], R[g] = l ? u[p] : 1;} else {var A = new Array(E),P = f - t,V = f - _;for (g = 0; g < E; ++g) {for (A[g] = new Array(V - P + 1), d = P; d <= V; ++d) {p = d * E + g;var T = l ? u[p] : 1;A[g][d - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, t, i, A);for (d = y - 1, g = 0; g < E; ++g) {var b = C[g][d];x[3 * g] = b[0] / b[3], x[3 * g + 1] = b[1] / b[3], x[3 * g + 2] = b[2] / b[3], R[g] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBSurfaceToBezier = t.decomposeBSurfaceControlPoints = t.decomposeBSurfaceControlPointsV = t.decomposeBSurfaceControlPointsU = void 0;var n = r(17),o = r(2),i = function i(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = e + 1,d = l,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[(s * l + c) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V * d + c) * n + u] = y[v][(V * d + c) * n + u] * T + y[v][((V - 1) * d + c) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A * d + c) * n + u] = y[v][(e * d + c) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[((f - e + s) * l + c) * n + u];}}}p = f, ++f;}return y;},s = function s(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = l,d = e + 1,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(s + c * i) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V + c * d) * n + u] = y[v][(V + c * d) * n + u] * T + y[v][(V - 1 + c * d) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A + c * d) * n + u] = y[v][(e + c * d) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(f - e + s + c * i) * n + u];}}}p = f, ++f;}return y;},a = function a(e, t, r, n, _a, c) {o.ConsoleUtils.assert(_a.length % c == 0), o.ConsoleUtils.assert(_a.length / c == (r.length - e - 1) * (n.length - t - 1));var u,l = r.length > 2 * e + 2,h = n.length > 2 * t + 2;if (!l && !h) return [[_a.slice()]];u = l ? i(e, r, _a, c) : [_a];for (var d = 0; d < u.length; ++d) {u[d] = h ? s(t, n, u[d], c) : [u[d]];}return u;};t.decomposeBSurfaceControlPointsU = i, t.decomposeBSurfaceControlPointsV = s, t.decomposeBSurfaceControlPoints = a, t.decomposeBSurfaceToBezier = function (e, t, r, i, s, c) {var u,l,h,d,g = c && c.length > 0;if (o.ConsoleUtils.assert(s.length > 0 && s.length % 3 == 0), o.ConsoleUtils.assert(!g || s.length === 3 * c.length), g) {var p = (0, n.controlPointsToHomogeneous)(s, c);for (h = a(e, t, r, i, p, 4), d = [], u = 0; u < h.length; ++u) {for (d[u] = [], l = 0; l < h[u].length; ++l) {var f = (0, n.controlPointsFromHomogeneous)(h[u][l]);h[u][l] = f.P, d[u][l] = f.w;}}} else h = a(e, t, r, i, s, 3), d = void 0;var v = (0, n.getUniqueKnots)(r);o.ConsoleUtils.assert(v.length === h.length + 1);var _ = new Array(v.length - 1);for (u = 0; u < _.length; ++u) {_[u] = new Array(2 * e + 2), _[u].fill(v[u], 0, e + 1), _[u].fill(v[u + 1], e + 1);}var y = (0, n.getUniqueKnots)(i);o.ConsoleUtils.assert(y.length === h[0].length + 1);var m = new Array(y.length - 1);for (u = 0; u < m.length; ++u) {m[u] = new Array(2 * t + 2), m[u].fill(y[u], 0, t + 1), m[u].fill(y[u + 1], t + 1);}return { U: _, V: m, P: h, w: d };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.closestBSurfacePointApprox = t.closestBSurfacePatches = void 0;var n = r(1),o = r(3),i = r(73),s = r(76);t.closestBSurfacePatches = function (e, t, r) {for (var o = Number.POSITIVE_INFINITY, s = [], a = 0; a < t.length; ++a) {for (var c = 0; c < t[a].length; ++c) {var u,l = t[a][c],h = l.getRangeUnlimitedU(),d = l.getRangeUnlimitedV();if (r) {u = !1;for (var g = 0; g < r.length; ++g) {if (h[1] >= r[g][0][0] + n.FLOAT64_TOLERANCE && h[0] <= r[g][0][1] - n.FLOAT64_TOLERANCE && d[1] >= r[g][1][0] + n.FLOAT64_TOLERANCE && d[0] <= r[g][1][1] - n.FLOAT64_TOLERANCE) {u = !0;break;}}} else u = !0;if (u) {var p = l.getControlPoints(),f = (0, i.minDistanceSqrToHull)(e, p, !0);if (f <= o) {var v = (0, i.maxDistanceSqrToHull)(e, p);s.push({ index: [a, c], minDistSqr: f, maxDistSqr: v }), v < o && (o = v);}}}}return (s = s.filter(function (e) {return e.minDistSqr <= o;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.closestBSurfacePointApprox = function (e, t, r, i, a, c, u, l, h) {var d = t > 1 ? 2 * t : 1,g = r > 1 ? 2 * r : 1,p = (l[1] - l[0]) / (i[i.length - 1] - i[0]),f = (h[1] - h[0]) / (a[a.length - 1] - a[0]);d = Math.max(1, Math.round(d * p)), g = Math.max(1, Math.round(g * f));for (var v = (l[1] - l[0]) / d, _ = (h[1] - h[0]) / g, y = Number.POSITIVE_INFINITY, m = { u: void 0, v: void 0 }, E = void 0, x = n.Vector3.createFloat64(), R = 0; R <= g; ++R) {for (var A = h[0] + R * _, P = [], V = 0; V <= d; ++V) {var T,C,b = l[0] + V * v;P[V] = (0, s.evaluateBSurfacePoint)(b, A, t, r, i, a, c, u), V > 0 && R > 0 && (T = (0, o.closestPointToTriangle)(e, E[V - 1], E[V], P[V - 1], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b + v * (T.coordA - 1), m.v = A + _ * (T.coordB - 1)), T = (0, o.closestPointToTriangle)(e, P[V], P[V - 1], E[V], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b - v * T.coordA, m.v = A - _ * T.coordB));}E = P;}return m;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.checkValidity = void 0;var n = r(1),o = r(0),i = r(32),s = r(6),a = r(12),c = r(19);function u(e) {var t = [],r = e.getGuid();return r && "string" == typeof r || t.push({ error: "BaseTopology has invalid GUID", source: [e] }), t;}function l(e) {var t = u(e),r = 0,n = 0,i = 0,s = e.getLumps();if (s.length > 0) {for (var a = new Set(), c = 0; c < s.length; ++c) {var l = s[c];a.add(l), l && l.getTopologyType() === o.TOPOLOGY_TYPES.LUMP ? l.getBody() !== e && t.push({ error: "Body is not the parent of child Lump", source: [e, l] }) : t.push({ error: "Body has invalid element in Lump array", source: [e, l] }), r += l.collectFaces().size, n += l.collectEdges().size, i += l.collectVertices().size;}a.size !== s.length && t.push({ error: "Body has non-unique Lumps", source: [e] });}return r !== e.collectFaces().size && t.push({ error: "Body has Lumps which share Faces", source: [e] }), n !== e.collectEdges().size && t.push({ error: "Body has Lumps which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Body has Lumps which share Vertices", source: [e] }), t;}function h(e) {var t = u(e),r = e.getBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.BODY && t.push({ error: "Lump has invalid parent Body", source: [e] });var n = 0,i = 0,s = 0,a = e.getShells();if (a.length > 0) {for (var c = new Set(), l = 0; l < a.length; ++l) {var h = a[l];c.add(h), h && h.getTopologyType() === o.TOPOLOGY_TYPES.SHELL ? h.getLump() !== e && t.push({ error: "Lump is not the parent of child Shell", source: [e, h] }) : t.push({ error: "Lump has invalid element in Shell array", source: [e, h] }), n += h.collectFaces().size, i += h.collectEdges().size, s += h.collectVertices().size;}c.size !== a.length && t.push({ error: "Lump has non-unique Shells", source: [e] });} else t.push({ error: "Lump has no Shells", source: [e] });return n !== e.collectFaces().size && t.push({ error: "Lump has Shells which share Faces", source: [e] }), i !== e.collectEdges().size && t.push({ error: "Lump has Shells which share Edges", source: [e] }), s !== e.collectVertices().size && t.push({ error: "Lump has Shells which share Vertices", source: [e] }), t;}function d(e) {var t = u(e),r = e.getLump();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LUMP && t.push({ error: "Shell has invalid parent Lump", source: [e] });var n = e.getFaces();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.FACE ? a.getShell() !== e && t.push({ error: "Shell is not the parent of child Face", source: [e, a] }) : t.push({ error: "Shell has invalid element in Face array", source: [e, a] });}i.size !== n.length && t.push({ error: "Shell has non-unique Faces", source: [e] });} else t.push({ error: "Shell has no Faces", source: [e] });1 !== (0, c.findConnectedFaces)(e.getFaces()).length && t.push({ error: "Shell is disconnected", source: [e] });var l = e.collectVertices(),h = e.collectEdges(),d = new Set(),g = new Set();return l.forEach(function (e) {e.collectEdges(d), e.collectFaces(g);}), d.size !== h.size && t.push({ error: "Shell has rogue edges", source: [e] }), l.size > 0 && g.size !== e.getFaces().length && t.push({ error: "Shell has rogue faces", source: [e] }), t;}function g(e) {var t = u(e),r = e.getShell();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.SHELL && t.push({ error: "Face has invalid parent Shell", source: [e] });var n = 0,i = 0,s = e.getLoops(),c = e.getSurface();if (s.length > 0) {for (var l = new Set(), h = 0; h < s.length; ++h) {var d = s[h];l.add(d), d && d.getTopologyType() === o.TOPOLOGY_TYPES.LOOP ? d.getFace() !== e && t.push({ error: "Face is not the parent of child Loop", source: [e, d] }) : t.push({ error: "Face has invalid element in Loop array", source: [e, d] }), n += d.collectEdges().size, i += d.collectVertices().size;}l.size !== s.length && t.push({ error: "Face has non-unique Loops", source: [e] });} else {var g = c.getGeometryType() === o.GEOMETRY_TYPES.SPHERE,p = c.getGeometryType() === o.GEOMETRY_TYPES.TORUS && c.isDoughnut();g || p || t.push({ error: "Face has no Loops", source: [e] });}return n !== e.collectEdges().size && t.push({ error: "Face has Loops which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Face has Loops which share Vertices", source: [e] }), c ? c instanceof a.Surface || t.push({ error: "Face has invalid Surface geometry", source: [e, c] }) : t.push({ error: "Face has no Surface geometry", source: [e] }), t;}function p(e) {var t = u(e),r = e.getFace();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.FACE && t.push({ error: "Loop has invalid parent Face", source: [e] });var n = e.getCoedges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];if (i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.COEDGE) {a.getLoop() !== e && t.push({ error: "Loop is not the parent of child Coedge", source: [e, a] });var c = n[(s + 1) % n.length];a.getEndVertex() !== c.getStartVertex() && t.push({ error: "Loop has disconnected Coedges", source: [e, a, c] });} else t.push({ error: "Loop has invalid element in Coedge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Loop has non-unique Coedges", source: [e] });} else t.push({ error: "Loop has no Coedges", source: [e] });return t;}function f(e) {var t = u(e),r = e.getLoop();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LOOP && t.push({ error: "Coedge has invalid parent Loop", source: [e] });var n = e.getBody(),i = new Set(),s = e;do {if (i.has(s)) {t.push({ error: "Coedge partner list does not form a loop", source: [e] });break;}if (i.add(s), !s.getPartner()) {s !== e && t.push({ error: "Coedge has no partner", source: [e, s] });break;}if ((s = s.getPartner()).getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE) {t.push({ error: "Coedge has invalid entry in partner list", source: [e, s] });break;}s.getEdge() !== e.getEdge() && t.push({ error: "Coedge partner refers to a different Edge", source: [e, s] }), s.getBody() !== n && t.push({ error: "Coedge partner is part of a different Body", source: [e, s] });} while (s !== e);var a = e.getEdge();return a ? a.getTopologyType() !== o.TOPOLOGY_TYPES.EDGE ? t.push({ error: "Coedge has invalid Edge", source: [e, a] }) : (s = a.getCoedge()) && i.has(s) || t.push({ error: "Coedge partner list does not include parent of Edge", source: [e, a] }) : t.push({ error: "Coedge has no Edge", source: [e] }), t;}function v(e) {var t = u(e),r = e.getCoedge(),s = e.getWire();s && r ? t.push({ error: "Edge has too many parents, both Wire and Coedge", source: [e] }) : s ? s.getTopologyType() !== o.TOPOLOGY_TYPES.WIRE && t.push({ error: "Edge has invalid parent Wire", source: [e] }) : r && r.getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE && t.push({ error: "Edge has invalid parent Coedge", source: [e] });for (var a = e.getVertices(), c = 0; c < a.length; ++c) {var l = a[c];l && l.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX ? l.isAdjacentEdge(e) || t.push({ error: "Edge is not adjacent to own Vertex", source: [e, l] }) : t.push({ error: "Edge has invalid Vertex", source: [e, l] });}var h = e.getCurve();return h ? h instanceof i.Curve ? t = t.concat(function (e, t) {var r = [],i = e.isReversed(),s = e.getRange();if (void 0 === s || 2 !== s.length || void 0 === s[0] || void 0 === s[1] || s[1] < s[0]) return r.push({ error: "Edge range is not defined", source: [e, s] }), r;var a = e.getStartVertex(),c = i ? -e.t0() : e.t0(),u = t.evaluatePosition(c),l = Math.max(o.KERNEL_TOLERANCE, a.getPrecision());n.Vector3.equals(a.getPosition(), u, l) || r.push({ error: "Edge start position not consistent with Vertex", source: [e, a, u] });var h = e.getEndVertex(),d = i ? -e.t1() : e.t1(),g = t.evaluatePosition(d),p = Math.max(o.KERNEL_TOLERANCE, h.getPrecision());return n.Vector3.equals(h.getPosition(), g, p) || r.push({ error: "Edge end position not consistent with Vertex", source: [e, h, g] }), e.isClosed() ? (a !== h && r.push({ error: "Edge is closed but has different start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) || r.push({ error: "Edge is closed but has different start and end positions", source: [e, u, g] }), t.isClosed() || r.push({ error: "Edge is closed but its curve is not", source: [e] })) : (a === h && r.push({ error: "Edge is open but has same start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) && r.push({ error: "Edge is open but has same start and end positions", source: [e, u, g] })), t.isPeriodic() ? Math.abs(d - c) > t.getPeriod() + o.PARAMETER_SPACE_TOLERANCE && r.push({ error: "Edge parameter range is longer than curve period", source: [e] }) : ((c + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || c - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge start parameter is outside of curve range", source: [e] }), (d + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || d - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge end parameter is outside of curve range", source: [e] })), r;}(e, h)) : t.push({ error: "Edge has invalid Curve geometry", source: [e, h] }) : t = t.concat(function (e) {if (e.getWire()) return [{ error: "Degenerate Edge is part of a Wire", source: [e] }];if (e.getStartVertex() !== e.getEndVertex()) return [{ error: "Degenerate Edge has different start and end vertices", source: [e] }];var t = Array.from(e.collectFaces());if (0 === t.length) return [];if (1 !== t.length) return [{ error: "Degenerate Edge is part of multiple Faces", source: [e] }];var r = e.getStartVertex().getPosition(),i = t[0].getSurface(),s = i.getGeometryType();if (s === o.GEOMETRY_TYPES.PLANE || s === o.GEOMETRY_TYPES.CYLINDER || s === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || s === o.GEOMETRY_TYPES.SPHERE) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (s === o.GEOMETRY_TYPES.CONE || s === o.GEOMETRY_TYPES.ELLIPTICAL_CONE) {if (!(l = i.getApexPosition())) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (!n.Vector3.equals(r, l, o.KERNEL_TOLERANCE)) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];} else {if (s !== o.GEOMETRY_TYPES.TORUS) return [{ error: "Degenerate Edge is not on an analytic surface", source: [e] }];for (var a = !1, c = i.getSingularUParams(), u = 0; u < c.length; ++u) {var l = i.evaluatePosition(c[u], 0);n.Vector3.equals(r, l, o.KERNEL_TOLERANCE) && (a = !0);}if (!a) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];}return [];}(e)), t;}function _(e) {var t = u(e),r = e.getEdges();if (r.length > 0) for (var n = e.getBody(), i = 0; i < r.length; ++i) {var a = r[i];a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getStartVertex() !== e && a.getEndVertex() !== e ? t.push({ error: "Vertex is not an end-point of adjacent Edge", source: [e, a] }) : a.getBody() !== n && t.push({ error: "Vertex has adjacent Edge from a different body", source: [e, a] }) : t.push({ error: "Vertex has invalid entry in Edge list", source: [e, a] });} else t.push({ error: "Vertex has no adjacent Edges", source: [e] });var c = e.getPoint();return c ? c instanceof s.Point || t.push({ error: "Vertex has invalid Point geometry", source: [e, c] }) : t.push({ error: "Vertex has no Point geometry", source: [e] }), t;}function y(e) {var t = u(e),r = 0,n = 0,i = e.getWires();if (i.length > 0) {for (var s = new Set(), a = 0; a < i.length; ++a) {var c = i[a];s.add(c), c && c.getTopologyType() === o.TOPOLOGY_TYPES.WIRE ? c.getWireBody() !== e && t.push({ error: "WireBody is not the parent of child Wire", source: [e, c] }) : t.push({ error: "WireBody has invalid element in Wire array", source: [e, c] }), r += c.collectEdges().size, n += c.collectVertices().size;}s.size !== i.length && t.push({ error: "WireBody has non-unique Wires", source: [e] });} else t.push({ error: "WireBody has no Wires", source: [e] });return r !== e.collectEdges().size && t.push({ error: "WireBody has Wires which share Edges", source: [e] }), n !== e.collectVertices().size && t.push({ error: "WireBody has Wires which share Vertices", source: [e] }), t;}function m(e) {var t = u(e),r = e.getWireBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.WIREBODY && t.push({ error: "Wire has invalid parent WireBody", source: [e] });var n = e.getEdges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getWire() !== e && t.push({ error: "Wire is not the parent of child Edge", source: [e, a] }) : t.push({ error: "Wire has invalid element in Edge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Wire has non-unique Edges", source: [e] });var l = (0, c.findConnectedEdges)(n);1 !== l.length ? t.push({ error: "Wire is not a connected set of Edges", source: [e] }) : l[0].length !== n.length && t.push({ error: "Wire is connected to other unknown Edges", source: [e] });} else t.push({ error: "Wire has no Edges", source: [e] });return t;}t.checkValidity = function (e) {for (var t, r, n, i = [], s = [e], a = new Set(), c = new Map(); s.length > 0;) {a.clear();var u = new Set();for (t = 0; t < s.length; ++t) {switch ((r = s[t]).getTopologyType()) {case o.TOPOLOGY_TYPES.BODY:i = i.concat(l(r)), r.getLumps().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.LUMP:i = i.concat(h(r)), r.getShells().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.SHELL:i = i.concat(d(r)), r.getFaces().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.FACE:i = i.concat(g(r)), r.getLoops().forEach(function (e) {a.add(e);}), r.getSurface() && u.add(r.getSurface());break;case o.TOPOLOGY_TYPES.LOOP:i = i.concat(p(r)), r.getCoedges().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.COEDGE:i = i.concat(f(r)), a.add(r.getEdge());break;case o.TOPOLOGY_TYPES.EDGE:i = i.concat(v(r)), r.getVertices().forEach(function (e) {e && a.add(e);}), r.getCurve() && u.add(r.getCurve());break;case o.TOPOLOGY_TYPES.VERTEX:i = i.concat(_(r)), r.getPoint() && u.add(r.getPoint());break;case o.TOPOLOGY_TYPES.WIREBODY:i = i.concat(y(r)), r.getWires().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.WIRE:i = i.concat(m(r)), r.getEdges().forEach(function (e) {a.add(e);});}n = r.getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}for (u = Array.from(u), t = 0; t < u.length; ++t) {n = (r = u[t]).getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}s = Array.from(a);}return i;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.facetPlanarFace = void 0;var n = r(1),o = r(0),i = r(108),s = r(3),a = r(109),c = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),u = r(8),l = 1e-8,h = o.KERNEL_TOLERANCE,d = function d(e, t, r) {var o,i = e[(0, s.modulus)(t - 1, e.length)],a = e[(0, s.modulus)(t + 1, e.length)],c = e[t],u = c[0] - i[0],l = c[1] - i[1],d = a[0] - c[0],g = a[1] - c[1],p = Math.sqrt(u * u + l * l),f = Math.sqrt(d * d + g * g);u * d + l * g < -.95 * p * f ? (u *= -1, l *= -1) : r ? (o = u, u = -l, l = o, o = d, d = -g, g = o) : (o = u, u = l, l = -o, o = d, d = g, g = -o);var v = .5 * (u / p + d / f),_ = .5 * (l / p + g / f),y = Math.sqrt(v * v + _ * _);e[t] = n.Vector3.clone(c), e[t][0] += h * v / y, e[t][1] += h * _ / y;},g = function g(e) {return String(e[0]) + String(e[1]);},p = function p(e) {for (var t = !1, r = {}, n = 0; n < e.length; n++) {var o = g(e[n]);void 0 === r[o] ? r[o] = [] : t = !0, r[o].push(n);}return { table: r, foundSelfIntersection: t };},f = function f(e) {var t = p(e);if (t.foundSelfIntersection) {for (var r = (0, i.isLoopCCW)(e), n = [], o = 0; o < e.length - 1; o++) {n[o] = !1;}var a = [];for (o = 0; o < e.length - 1; o++) {if (!n[o]) {var c = [],u = o;n[u] = !0, c.push(e[u]);var l = g(c[0]),h = e[(0, s.modulus)(u + 1, e.length)],f = g(h),v = [];for (t.table[l].length > 1 && v.push(0); f !== l;) {if (c.push(h), c.length > e.length) throw new Error("splitHole failure");var _ = t.table[f];if (1 === _.length) u++;else {v.push(c.length - 1);for (var y = [], m = 0; m < _.length; m++) {_[m] !== u && y.push(_[m]);}var E = Math.atan2(e[u + 1][1] - e[u][1], e[u + 1][0] - e[u][0]);E = (0, s.normalizeParameterToShiftedRange)(E - Math.PI, [-Math.PI, Math.PI]);var x = -1,R = 0;for (m = 0; m < y.length; m++) {var A = Math.atan2(e[(0, s.modulus)(y[m] + 1, e.length)][1] - e[y[m]][1], e[(0, s.modulus)(y[m] + 1, e.length)][0] - e[y[m]][0]);A < E && r ? A += s.PI2 : A > E && !r && (A -= s.PI2);var P = Math.abs(A - E);P > R && (R = P, x = y[m]);}u = x;}h = e[(0, s.modulus)(u + 1, e.length)], f = g(h), n[u] = !0;}for (m = 0; m < v.length; m++) {d(c, v[m], r);}a.push(c);}}return a;}return [e];},v = function v(e, t) {for (var r = [], n = 0; n < e.length; n++) {r[n] = { index: void 0, loop: void 0 };for (var o = e[n], i = 0; i < t.length; i++) {for (var s = t[i], a = 0; a < s.length; a++) {if (s[a][0] === o[0] && s[a][1] === o[1]) {r[n].index = a, r[n].loop = s;break;}}}}return r;};function _(e, t) {var r,n = !1,o = t.length,i = o - 1;for (r = 0; r < o; r += 2) {t[r][1] > e[1] != t[i][1] > e[1] && e[0] < (t[i][0] - t[r][0]) * (e[1] - t[r][1]) / (t[i][1] - t[r][1]) + t[r][0] && (n = !n), i = r;}return n;}function y(e, t, r) {for (var o, s, a = v(e, [t].concat(r)), c = [], h = [], d = void 0, g = void 0, p = 0; p < 4; ++p) {a[p] && void 0 !== a[p].index && (d ? g || a[p].loop === d || (g = a[p].loop) : d = a[p].loop, a[p].loop === d ? (o = d, s = c) : (o = g, s = h), (P = [a[p].index - 1, a[p].index])[0] < 0 && (P[0] = o.length - 1), s.push(P), s.push([a[p].index, (a[p].index + 1) % o.length]));}g || (g = d, h = c);var f,y,m = void 0,E = d,x = c;for (p = 0; p < 3; ++p) {for (f = 0; f < c.length; ++f) {for (y = 0; y < h.length && (c === h && y >= f || !(m = (0, i.intersectSegments)(d[c[f][0]], d[c[f][1]], g[h[y][0]], g[h[y][1]], 0)) || !m.intersection); ++y) {;}if (m && m.intersection) break;}if (m && m.intersection || d === g) break;0 === p ? (d = g, c = h) : 1 === p && (d = E, c = x, g = E, h = x);}if (void 0 !== m && m.intersection) {var R = n.Vector3.subtract(n.Vector3.createFloat64(), d[c[f][1]], d[c[f][0]]);n.Vector3.scale(R, R, m.solutions[0]);var A = n.Vector3.add(R, R, d[c[f][0]]);if (c[f][0] > c[f][1]) {var P = c[f][1];c[f][1] = c[f][0], c[f][0] = P;}if (0 === c[f][0] && 1 !== c[f][1] && (c[f][0] = c[f][1], c[f][1] = 0), h[y][0] > h[y][1] && 0 !== h[y][1] && (P = h[y][1], h[y][1] = h[y][0], h[y][0] = P), 0 === h[y][0] && 1 !== h[y][1] && (h[y][0] = h[y][1], h[y][1] = 0), d === g) {if (d.length < 4) return void console.error("REGION: Failed to fix loop tessellation! [loop too short]");console.log("REGION: Fixing self-intersection");var V = new Array(4);c[f][0] < h[y][0] ? (V[0] = c[f][0], V[1] = c[f][1], V[2] = h[y][0], V[3] = h[y][1]) : (V[0] = h[y][0], V[1] = h[y][1], V[2] = c[f][0], V[3] = c[f][1]);var T = [];for (p = 0; p <= V[0]; ++p) {T.push(d[p]);}var C = n.Vector3.subtract(n.Vector3.createFloat64(), d[V[0]], d[V[1]]);n.Vector3.normalize(C, C), n.Vector3.scale(C, C, l);var b = n.Vector3.add(n.Vector3.createFloat64(), A, C);for (T.push(b), p = V[2]; p >= V[1]; --p) {T.push(d[p]);}var L = n.Vector3.subtract(n.Vector3.createFloat64(), A, C);if (T.push(L), V[3] > V[2]) for (p = V[3]; p < d.length; ++p) {T.push(d[p]);}for (d.length = T.length, p = 0; p < T.length; ++p) {d[p] = T[p];}} else {console.log("REGION: Fixing loop-loop intersection");var O = d,S = g,M = h[y][0],w = h[y][1],N = c[f][0],F = c[f][1];(t === S || S.length > O.length && t !== O) && (O = g, S = d, M = c[f][0], w = c[f][1], N = h[y][0], F = h[y][1]);var I = 1;t !== S && t !== O && (I = -1);var D = 1;_(S[w], O) && (D = -1, P = M, M = w, w = P), n.Vector3.subtract(S[w], S[M], S[w]), n.Vector3.normalize(S[w], S[w]), n.Vector3.scale(S[w], S[w], I * l), n.Vector3.add(S[w], A, S[w]);var j,B,U = w;do {(w += D) < 0 ? w = S.length - 1 : w %= S.length;} while (w !== M && !_(S[w], O));(M = w - D) < 0 && (M = S.length - 1), F = N;do {j = O[F], B = O[F = ++F % O.length], m = (0, i.intersectSegments)(j, B, S[M], S[w], 0);} while (N !== F && !m.intersection);m.intersection && (n.Vector3.scale(R, n.Vector3.subtract(R, B, j), m.solutions[0]), n.Vector3.add(A, R, j), n.Vector3.subtract(S[M], S[w], S[M]), n.Vector3.normalize(S[M], S[M]), n.Vector3.scale(S[M], S[M], I * l), n.Vector3.add(S[M], A, S[M])), Math.min(Math.abs(U - M), Math.abs(U - M - S.length)) > 1 && console.warn("REGION: Remove loop segment! FIXME!");}} else u.DebugUtils.warn("REGION: Failed to fix loop tessellation! [no intersected segments]");}var m = function m(e, t) {var r = e;for (r < 0 ? r += t.length : r %= t.length; t[r] !== r;) {r = t[r];}return r;},E = function E(e, t, r, o) {return n.Vector3.distance(r[e], r[t]) < 1e-6 ? (o[0] = e, o[1] = e, 1) : 0;},x = function x(e, t, r, o, i) {var s = new Array(2);if (s[0] = o[e], s[1] = o[r], n.Vector3.length(n.Vector3.subtract(n.Vector3.createFloat64(), s[0], s[1])) < 1e-6) return i[0] = e, i[1] = e, i[2] = e, 2;var a = (s[0][0] - s[1][0]) * (o[t][1] - s[1][1]) - (s[0][1] - s[1][1]) * (o[t][0] - s[1][0]);return a > -l * l && a < l * l ? (i[0] = e, i[1] = e, i[2] = r, 1) : 0;},R = function R(e, t, r, n, o, s) {return (0, i.intersectSegments)(o[e], o[t], o[r], o[n]).intersection ? (s[0] = e, s[1] = t, s[2] = t, s[3] = n, 1) : (s[0] = -1, 0);},A = function A(e) {if (e.length < 4) return e;for (var t, r, n, o, i = e.length, s = new Int32Array(i), a = 0; a < i; ++a) {s[a] = a;}var c,u = new Array(3),l = new Array(3);for (l[0] = 0, l[1] = 0, l[2] = 0, a = 0; a < i; ++a) {t = m(a, s), r = m(a + 1, s), (c = E(t, r, e, u)) && (++l[0], s[t] = u[0], s[r] = u[1], t = m(a += c, s), r = m(a + 1, s)), n = m(a + 2, s), (c = x(t, r, n, e, u)) && (++l[1], s[t] = u[0], s[r] = u[1], s[n] = u[2], t = m(a += c, s), r = m(a + 1, s), n = m(a + 2, s)), o = m(a + 3, s), (c = R(t, r, n, o, e, u)) && (++l[2], s[t] = u[0], s[r] = u[1], s[n] = u[2], s[o] = u[3], a += c);}var h = [];for (a = 0; a < e.length; ++a) {s[a] === a && h.push(e[a]);}return h;},P = function P(e, t, r) {for (var n = v(e, [t].concat(r)), o = 0; o < n.length; o++) {d(n[o].loop, n[o].index, (0, i.isLoopCCW)(n[o].loop));}},V = function V(e, t) {var r = !1;!function (e) {var t = p(e);if (t.foundSelfIntersection) for (var r = (0, i.isLoopCCW)(e), n = c.default.keys(t.table), o = 0; o < n.length; o++) {if (t.table[n[o]].length > 1) for (var s = t.table[n[o]], a = 0; a < s.length; a++) {d(e, s[a], r);}}}(e);for (var n = [], o = 0; o < t.length; o++) {n.push.apply(n, f(t[o]));}var s = A(e),l = [];for (o = 0; o < n.length; o++) {l.push(A(n[o]));}var h = 8;do {r = !0;var g = (0, c.default)(s).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);}),v = new a.poly2tri.SweepContext(g);for (o = 0; o < l.length; o++) {var _ = (0, c.default)(l[o]).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);});v.addHole(_);}try {v.triangulate();} catch (e) {if ("poly2tri Intersecting Constraints" === e.message.substr(0, 33)) r = !1, y(e.points, s, l);else if ("poly2tri EdgeEvent: Collinear not supported" === e.message.substr(0, 43)) r = !1, P(e.points, s, l);else {if (!e.points) throw e;r = !1, y(e.points, s, l);}}} while (!r && h-- > 0);return h <= 0 && u.DebugUtils.warn("Computation of region tessellation failed, due to too many intersections."), v;};t.facetPlanarFace = function (e, t) {var r = e.getSurface(),o = (0, s.getPlaneTransforms)(r),a = new i.LoopCalculator(e, o.threeSpaceToUV).getRank0Loops();if (1 !== a.length) throw new Error("Each region should have exactly one top-loop");var c = a[0],u = (0, i.tessellateLoop)(c._loop, t);if (o.threeSpaceToUV) for (var l = 0; l < u.length; l++) {n.Vector3.transformMatrix44(u[l], u[l], o.threeSpaceToUV);}for (var h = [], d = c.getImmediatelyInsideLoops(), g = 0; g < d.length; g++) {var p = (0, i.tessellateLoop)(d[g]._loop, t);if (h.push(p), o.threeSpaceToUV) for (l = 0; l < p.length; l++) {n.Vector3.transformMatrix44(p[l], p[l], o.threeSpaceToUV);}}var f = V(u, h),v = f.getTriangles(),_ = new Uint32Array(3 * v.length),y = new Float32Array(3 * f.pointCount()),m = n.Vector3.createFloat64();for (l = 0; l < f.pointCount(); l++) {var E = f.getPoint(l);n.Vector3.set(m, E.x, E.y, 0), o.uvToThreeSpace && n.Vector3.transformMatrix44(m, m, o.uvToThreeSpace), y[3 * l] = m[0], y[3 * l + 1] = m[1], y[3 * l + 2] = m[2], E.index = l;}for (l = 0; l < v.length; l++) {var x = v[l].getPoints();for (e.isReversed() && x.reverse(), g = 0; g < x.length; g++) {var R = x[g];_[3 * l + g] = R.index;}}return { indexBuffer: _, vertexBuffer: y };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.LoopCalculator = t.intersectSegments = t.isLoopCCW = t.tessellateLoop = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this._loop = e, this._enclosureRank = 0, this._isOuterLoop = !1, this._insideLoops = [], this._isOpen = !1, this._coedges = this._loop.getCoedges();for (var r = 0; r < this._coedges.length; ++r) {this._coedges[r].generateUVCurve(t);}};s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.uvAngleSubtended = function (e) {if (!this.isClosedLoop()) throw new Error("uvAngleSubtended cannot work with open loops");for (var t = 0, r = 0; r < this._coedges.length; r++) {t += this._coedges[r].uvAngleSubtended(e);}return t;}, s.prototype.getArbitraryPointOnLoop = function () {if (1 === this._coedges.length) {var e = this._coedges[0].t0();return this._coedges[0].evaluatePosition(e);}var t = this._coedges[0].getStartVertex();if (t) return t.getPosition();}, s.prototype.isInside = function (e) {var t = this.getArbitraryPointOnLoop(),r = Math.abs(e.uvAngleSubtended(t)),n = Math.floor(r / (2 * Math.PI)),i = r - 2 * n * Math.PI;return !!(Math.abs(i) < o.KERNEL_TOLERANCE && n || Math.abs(i - 2 * Math.PI) < o.KERNEL_TOLERANCE);}, s.prototype.getEnclosureRank = function () {return this._enclosureRank;}, s.prototype.resetEnclosureRank = function () {this._enclosureRank = 0;}, s.prototype.decreaseEnclosureRank = function () {this._enclosureRank--;}, s.prototype.setIsOuterLoop = function (e) {this._isOuterLoop = e;}, s.prototype.isOuterLoop = function () {return this._isOuterLoop;}, s.prototype.isClosedLoop = function () {return !this._isOpen;}, s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.getImmediatelyInsideLoops = function () {for (var e = [], t = 0; t < this._insideLoops.length; t++) {this._insideLoops[t].getEnclosureRank() === this._enclosureRank - 1 && e.push(this._insideLoops[t]);}return e;};var a = function a(e, t) {this._face = e, this._loops = [];for (var r = 0; r < this._face.getLoops().length; ++r) {this._loops.push(new s(this._face.getLoops()[r], t));}this._calcSenses();};a.prototype._calcSenses = function () {for (var e = this._loops.length, t = 0; t < e; t++) {this._loops[t].resetEnclosureRank();}for (t = 0; t < e; t++) {if (this._loops[t].isClosedLoop()) for (var r = 0; r < e; r++) {this._loops[r].isClosedLoop() && t !== r && this._loops[t].isInside(this._loops[r]) && !this._loops[r].isInside(this._loops[t]) && (this._loops[t].decreaseEnclosureRank(), this._loops[r].addInsideLoop(this._loops[t]));}}for (t = 0; t < e; t++) {var n = 0 - this._loops[t].getEnclosureRank();this._loops[t].setIsOuterLoop(n % 2 == 0);}}, a.prototype.getRank0Loops = function () {var e = [];return this._loops.forEach(function (t) {0 === t.getEnclosureRank() && e.push(t);}), e;}, t.tessellateLoop = function (e, t) {for (var r = [], o = 0, i = e.getCoedges().length; o < i; ++o) {var s = e.getCoedges()[o],a = s.getEdge(),c = a.tessellate(void 0, t).positions;c = c.slice(1, c.length - 1), (c = [n.Vector3.clone(a.getStartVertex().getPosition())].concat(c)).push(n.Vector3.clone(a.getEndVertex().getPosition())), s.isReversed() && c.reverse(), r = r.concat(c.slice(0, c.length - 1));}return r;}, t.isLoopCCW = function (e) {for (var t = 0, r = 0; r < e.length; r++) {var n = (r + 1) % e.length;t += e[r][0] * e[n][1] - e[r][1] * e[n][0];}return t > 0;}, t.intersectSegments = function (e, t, r, o, s) {var a = [[t[0] - e[0], -(o[0] - r[0]), r[0] - e[0]], [t[1] - e[1], -(o[1] - r[1]), r[1] - e[1]]],c = (0, i.solveTwoEquationsTwoVariables)(a);if (void 0 === c) return !1;var u = n.Vector3.distance(e, t),l = n.Vector3.distance(r, o);return { intersection: -s < c[0] * u && (c[0] - 1) * u < s && -s < c[1] * l && (c[1] - 1) * l < s, solutions: c };}, t.LoopCalculator = a;}, function (e, t, r) {"use strict";var n, o;if (Object.defineProperty(t, "__esModule", { value: !0 }), void 0 === i) var i = {},s = { exports: {} };!function (a) {"object" == _typeof(i) ? s.exports = a() : void 0 === (o = "function" == typeof (n = a) ? n.call(t, r, t, e) : n) || (e.exports = o);}(function () {return function e(t, r, n) {function o(s, a) {if (!r[s]) {if (!t[s]) {if (i) return i(s, !0);throw new Error("Cannot find module '" + s + "'");}var c = r[s] = { exports: {} };t[s][0].call(c.exports, function (e) {return o(t[s][1][e] || e);}, c, c.exports, e, t, r, n);}return r[s].exports;}for (var i = !1, s = 0; s < n.length; s++) {o(n[s]);}return o;}({ 1: [function (e, t, r) {t.exports = { version: "1.3.5" };}, {}], 2: [function (e, t, r) {var n = function n(e, t) {this.head_ = e, this.tail_ = t, this.search_node_ = e;};n.prototype.head = function () {return this.head_;}, n.prototype.setHead = function (e) {this.head_ = e;}, n.prototype.tail = function () {return this.tail_;}, n.prototype.setTail = function (e) {this.tail_ = e;}, n.prototype.search = function () {return this.search_node_;}, n.prototype.setSearch = function (e) {this.search_node_ = e;}, n.prototype.findSearchNode = function () {return this.search_node_;}, n.prototype.locateNode = function (e) {var t = this.search_node_;if (e < t.value) {for (; t = t.prev;) {if (e >= t.value) return this.search_node_ = t, t;}} else for (; t = t.next;) {if (e < t.value) return this.search_node_ = t.prev, t.prev;}return null;}, n.prototype.locatePoint = function (e) {var t = e.x,r = this.findSearchNode(t),n = r.point.x;if (t === n) {if (e !== r.point) if (e === r.prev.point) r = r.prev;else {if (e !== r.next.point) throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");r = r.next;}} else if (t < n) for (; (r = r.prev) && e !== r.point;) {;} else for (; (r = r.next) && e !== r.point;) {;}return r && (this.search_node_ = r), r;}, t.exports = n, t.exports.Node = function (e, t) {this.point = e, this.triangle = t || null, this.next = null, this.prev = null, this.value = e.x;};}, {}], 3: [function (e, t, r) {t.exports = function (e, t) {if (!e) throw new Error(t || "Assert Failed");};}, {}], 4: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.x = +e || 0, this.y = +t || 0, this._p2t_edge_list = null;};o.prototype.toString = function () {return n.toStringBase(this);}, o.prototype.toJSON = function () {return { x: this.x, y: this.y };}, o.prototype.clone = function () {return new o(this.x, this.y);}, o.prototype.set_zero = function () {return this.x = 0, this.y = 0, this;}, o.prototype.set = function (e, t) {return this.x = +e || 0, this.y = +t || 0, this;}, o.prototype.negate = function () {return this.x = -this.x, this.y = -this.y, this;}, o.prototype.add = function (e) {return this.x += e.x, this.y += e.y, this;}, o.prototype.sub = function (e) {return this.x -= e.x, this.y -= e.y, this;}, o.prototype.mul = function (e) {return this.x *= e, this.y *= e, this;}, o.prototype.length = function () {return Math.sqrt(this.x * this.x + this.y * this.y);}, o.prototype.normalize = function () {var e = this.length();return this.x /= e, this.y /= e, e;}, o.prototype.equals = function (e) {return this.x === e.x && this.y === e.y;}, o.negate = function (e) {return new o(-e.x, -e.y);}, o.add = function (e, t) {return new o(e.x + t.x, e.y + t.y);}, o.sub = function (e, t) {return new o(e.x - t.x, e.y - t.y);}, o.mul = function (e, t) {return new o(e * t.x, e * t.y);}, o.cross = function (e, t) {return "number" == typeof e ? "number" == typeof t ? e * t : new o(-e * t.y, e * t.x) : "number" == typeof t ? new o(t * e.y, -t * e.x) : e.x * t.y - e.y * t.x;}, o.toString = n.toString, o.compare = n.compare, o.cmp = n.compare, o.equals = n.equals, o.dot = function (e, t) {return e.x * t.x + e.y * t.y;}, t.exports = o;}, { "./xy": 11 }], 5: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.name = "PointError", this.points = t = t || [], this.message = e || "Invalid Points!";for (var r = 0; r < t.length; r++) {this.message += " " + n.toString(t[r]);}};(o.prototype = new Error()).constructor = o, t.exports = o;}, { "./xy": 11 }], 6: [function (e, t, r) {(function (t) {var n = t.poly2tri;r.noConflict = function () {return t.poly2tri = n, r;}, r.VERSION = e("../dist/version.json").version, r.PointError = e("./pointerror"), r.Point = e("./point"), r.Triangle = e("./triangle"), r.SweepContext = e("./sweepcontext");var o = e("./sweep");r.triangulate = o.triangulate, r.sweep = { Triangulate: o.triangulate };}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});}, { "../dist/version.json": 1, "./point": 4, "./pointerror": 5, "./sweep": 7, "./sweepcontext": 8, "./triangle": 9 }], 7: [function (e, t, r) {var n = e("./assert"),o = e("./pointerror"),i = e("./triangle"),s = e("./advancingfront").Node,a = e("./utils"),c = a.EPSILON,u = a.Orientation,l = a.orient2d,h = a.inScanArea,d = a.isAngleObtuse;function g(e, t) {var r = e.locateNode(t),o = function (e, t, r) {var n = new i(t, r.point, r.next.point);n.markNeighbor(r.triangle), e.addToMap(n);var o = new s(t);return o.next = r.next, o.prev = r, r.next.prev = o, r.next = o, y(e, n) || e.mapTriangleToNodes(n), o;}(e, t, r);return t.x <= r.point.x + c && _(e, r), function (e, t) {for (var r = t.next; r.next && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.next;}for (r = t.prev; r.prev && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.prev;}t.next && t.next.next && function (e) {var t = e.point.x - e.next.next.point.x,r = e.point.y - e.next.next.point.y;return n(r >= 0, "unordered y"), t >= 0 || Math.abs(t) < r;}(t) && function (e, t) {for (l(t.point, t.next.point, t.next.next.point) === u.CCW ? e.basin.left_node = t.next.next : e.basin.left_node = t.next, e.basin.bottom_node = e.basin.left_node; e.basin.bottom_node.next && e.basin.bottom_node.point.y >= e.basin.bottom_node.next.point.y;) {e.basin.bottom_node = e.basin.bottom_node.next;}if (e.basin.bottom_node !== e.basin.left_node) {for (e.basin.right_node = e.basin.bottom_node; e.basin.right_node.next && e.basin.right_node.point.y < e.basin.right_node.next.point.y;) {e.basin.right_node = e.basin.right_node.next;}e.basin.right_node !== e.basin.bottom_node && (e.basin.width = e.basin.right_node.point.x - e.basin.left_node.point.x, e.basin.left_highest = e.basin.left_node.point.y > e.basin.right_node.point.y, function e(t, r) {if (!function (e, t) {var r;return r = e.basin.left_highest ? e.basin.left_node.point.y - t.point.y : e.basin.right_node.point.y - t.point.y, e.basin.width > r;}(t, r) && (_(t, r), r.prev !== t.basin.left_node || r.next !== t.basin.right_node)) {if (r.prev === t.basin.left_node) {if (l(r.point, r.next.point, r.next.next.point) === u.CW) return;r = r.next;} else if (r.next === t.basin.right_node) {if (l(r.point, r.prev.point, r.prev.prev.point) === u.CCW) return;r = r.prev;} else r = r.prev.point.y < r.next.point.y ? r.prev : r.next;e(t, r);}}(e, e.basin.bottom_node));}}(e, t);}(e, o), o;}function p(e, t, r) {e.edge_event.constrained_edge = t, e.edge_event.right = t.p.x > t.q.x, v(r.triangle, t.p, t.q) || (function (e, t, r) {e.edge_event.right ? function (e, t, r) {for (; r.next.point.x < t.p.x;) {l(t.q, r.next.point, t.p) === u.CCW ? x(e, t, r) : r = r.next;}}(e, t, r) : function (e, t, r) {for (; r.prev.point.x > t.p.x;) {l(t.q, r.prev.point, t.p) === u.CW ? A(e, t, r) : r = r.prev;}}(e, t, r);}(e, t, r), f(e, t.p, t.q, r.triangle, t.q));}function f(e, t, r, n, i) {if (!v(n, t, r)) {var s = n.pointCCW(i),a = l(r, s, t);if (a === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, s, t]);var c = n.pointCW(i),h = l(r, c, t);if (h === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, c, t]);a === h ? f(e, t, r, n = a === u.CW ? n.neighborCCW(i) : n.neighborCW(i), i) : V(e, t, r, n, i);}}function v(e, t, r) {var n = e.edgeIndex(t, r);if (-1 !== n) {e.markConstrainedEdgeByIndex(n);var o = e.getNeighbor(n);return o && o.markConstrainedEdgeByPoints(t, r), !0;}return !1;}function _(e, t) {var r = new i(t.prev.point, t.point, t.next.point);r.markNeighbor(t.prev.triangle), r.markNeighbor(t.triangle), e.addToMap(r), t.prev.next = t.next, t.next.prev = t.prev, y(e, r) || e.mapTriangleToNodes(r);}function y(e, t) {for (var r = 0; r < 3; ++r) {if (!t.delaunay_edge[r]) {var n = t.getNeighbor(r);if (n) {var o = t.getPoint(r),i = n.oppositePoint(t, o),s = n.index(i);if (n.constrained_edge[s] || n.delaunay_edge[s]) {t.constrained_edge[r] = n.constrained_edge[s];continue;}if (m(o, t.pointCCW(o), t.pointCW(o), i)) {t.delaunay_edge[r] = !0, n.delaunay_edge[s] = !0, E(t, o, n, i);var a = !y(e, t);return a && e.mapTriangleToNodes(t), (a = !y(e, n)) && e.mapTriangleToNodes(n), t.delaunay_edge[r] = !1, n.delaunay_edge[s] = !1, !0;}}}}return !1;}function m(e, t, r, n) {var o = e.x - n.x,i = e.y - n.y,s = t.x - n.x,a = t.y - n.y,c = o * a - s * i;if (c <= 0) return !1;var u = r.x - n.x,l = r.y - n.y,h = u * i - o * l;return !(h <= 0) && (o * o + i * i) * (s * l - u * a) + (s * s + a * a) * h + (u * u + l * l) * c > 0;}function E(e, t, r, n) {var o, i, s, a, c, u, l, h, d, g, p, f;o = e.neighborCCW(t), i = e.neighborCW(t), s = r.neighborCCW(n), a = r.neighborCW(n), c = e.getConstrainedEdgeCCW(t), u = e.getConstrainedEdgeCW(t), l = r.getConstrainedEdgeCCW(n), h = r.getConstrainedEdgeCW(n), d = e.getDelaunayEdgeCCW(t), g = e.getDelaunayEdgeCW(t), p = r.getDelaunayEdgeCCW(n), f = r.getDelaunayEdgeCW(n), e.legalize(t, n), r.legalize(n, t), r.setDelaunayEdgeCCW(t, d), e.setDelaunayEdgeCW(t, g), e.setDelaunayEdgeCCW(n, p), r.setDelaunayEdgeCW(n, f), r.setConstrainedEdgeCCW(t, c), e.setConstrainedEdgeCW(t, u), e.setConstrainedEdgeCCW(n, l), r.setConstrainedEdgeCW(n, h), e.clearNeighbors(), r.clearNeighbors(), o && r.markNeighbor(o), i && e.markNeighbor(i), s && e.markNeighbor(s), a && r.markNeighbor(a), e.markNeighbor(r);}function x(e, t, r) {r.point.x < t.p.x && (l(r.point, r.next.point, r.next.next.point) === u.CCW ? R(e, t, r) : (function e(t, r, n) {l(n.next.point, n.next.next.point, n.next.next.next.point) === u.CCW ? R(t, r, n.next) : l(r.q, n.next.next.point, r.p) === u.CCW && e(t, r, n.next);}(e, t, r), x(e, t, r)));}function R(e, t, r) {_(e, r.next), r.next.point !== t.p && l(t.q, r.next.point, t.p) === u.CCW && l(r.point, r.next.point, r.next.next.point) === u.CCW && R(e, t, r);}function A(e, t, r) {r.point.x > t.p.x && (l(r.point, r.prev.point, r.prev.prev.point) === u.CW ? P(e, t, r) : (function e(t, r, n) {l(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === u.CW ? P(t, r, n.prev) : l(r.q, n.prev.prev.point, r.p) === u.CW && e(t, r, n.prev);}(e, t, r), A(e, t, r)));}function P(e, t, r) {_(e, r.prev), r.prev.point !== t.p && l(t.q, r.prev.point, t.p) === u.CW && l(r.point, r.prev.point, r.prev.prev.point) === u.CW && P(e, t, r);}function V(e, t, r, i, s) {var a = i.neighborAcross(s);n(a, "FLIP failed due to missing triangle!");var c = a.oppositePoint(i, s);if (i.getConstrainedEdgeAcross(s)) {var d = i.index(s);throw new o("poly2tri Intersecting Constraints", [s, c, i.getPoint((d + 1) % 3), i.getPoint((d + 2) % 3)]);}h(s, i.pointCCW(s), i.pointCW(s), c) ? (E(i, s, a, c), e.mapTriangleToNodes(i), e.mapTriangleToNodes(a), s === r && c === t ? r === e.edge_event.constrained_edge.q && t === e.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(t, r), a.markConstrainedEdgeByPoints(t, r), y(e, i), y(e, a)) : V(e, t, r, i = function (e, t, r, n, o, i) {var s;return t === u.CCW ? (s = n.edgeIndex(o, i), n.delaunay_edge[s] = !0, y(e, n), n.clearDelaunayEdges(), r) : (s = r.edgeIndex(o, i), r.delaunay_edge[s] = !0, y(e, r), r.clearDelaunayEdges(), n);}(e, l(r, c, t), i, a, s, c), s)) : (function e(t, r, o, i, s, a) {var c = s.neighborAcross(a);n(c, "FLIP failed due to missing triangle");var u = c.oppositePoint(s, a);h(o, i.pointCCW(o), i.pointCW(o), u) ? V(t, o, u, c, u) : e(t, r, o, i, c, T(r, o, c, u));}(e, t, r, i, a, T(t, r, a, c)), f(e, t, r, i, s));}function T(e, t, r, n) {var i = l(t, n, e);if (i === u.CW) return r.pointCCW(n);if (i === u.CCW) return r.pointCW(n);throw new o("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [t, n, e]);}r.triangulate = function (e) {e.initTriangulation(), e.createAdvancingFront(), function (e) {var t,r = e.pointCount();for (t = 1; t < r; ++t) {for (var n = e.getPoint(t), o = g(e, n), i = n._p2t_edge_list, s = 0; i && s < i.length; ++s) {p(e, i[s], o);}}}(e), function (e) {for (var t = e.front().head().next.triangle, r = e.front().head().next.point; !t.getConstrainedEdgeCW(r);) {t = t.neighborCCW(r);}e.meshClean(t);}(e);};}, { "./advancingfront": 2, "./assert": 3, "./pointerror": 5, "./triangle": 9, "./utils": 10 }], 8: [function (e, t, r) {var n = e("./pointerror"),o = e("./point"),i = e("./triangle"),s = e("./sweep"),a = e("./advancingfront"),c = a.Node,u = function u(e, t) {if (this.p = e, this.q = t, e.y > t.y) this.q = e, this.p = t;else if (e.y === t.y) if (e.x > t.x) this.q = e, this.p = t;else if (e.x === t.x) throw new n("poly2tri Invalid Edge constructor: repeated points!", [e]);this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);},l = function l() {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};l.prototype.clear = function () {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};var h = function h(e, t) {t = t || {}, this.triangles_ = [], this.map_ = [], this.points_ = t.cloneArrays ? e.slice(0) : e, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new l(), this.edge_event = new function () {this.constrained_edge = null, this.right = !1;}(), this.initEdges(this.points_);};h.prototype.addHole = function (e) {this.initEdges(e);var t,r = e.length;for (t = 0; t < r; t++) {this.points_.push(e[t]);}return this;}, h.prototype.AddHole = h.prototype.addHole, h.prototype.addHoles = function (e) {var t,r = e.length;for (t = 0; t < r; t++) {this.initEdges(e[t]);}return this.points_ = this.points_.concat.apply(this.points_, e), this;}, h.prototype.addPoint = function (e) {return this.points_.push(e), this;}, h.prototype.AddPoint = h.prototype.addPoint, h.prototype.addPoints = function (e) {return this.points_ = this.points_.concat(e), this;}, h.prototype.triangulate = function () {return s.triangulate(this), this;}, h.prototype.getBoundingBox = function () {return { min: this.pmin_, max: this.pmax_ };}, h.prototype.getTriangles = function () {return this.triangles_;}, h.prototype.GetTriangles = h.prototype.getTriangles, h.prototype.front = function () {return this.front_;}, h.prototype.pointCount = function () {return this.points_.length;}, h.prototype.head = function () {return this.head_;}, h.prototype.setHead = function (e) {this.head_ = e;}, h.prototype.tail = function () {return this.tail_;}, h.prototype.setTail = function (e) {this.tail_ = e;}, h.prototype.getMap = function () {return this.map_;}, h.prototype.initTriangulation = function () {var e,t = this.points_[0].x,r = this.points_[0].x,n = this.points_[0].y,i = this.points_[0].y,s = this.points_.length;for (e = 1; e < s; e++) {var a = this.points_[e];a.x > t && (t = a.x), a.x < r && (r = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);}this.pmin_ = new o(r, i), this.pmax_ = new o(t, n);var c = .3 * (t - r),u = .3 * (n - i);this.head_ = new o(t + c, i - u), this.tail_ = new o(r - c, i - u), this.points_.sort(o.compare);}, h.prototype.initEdges = function (e, t) {var r,n = e.length,o = t ? e.length - 1 : e.length;for (r = 0; r < o; ++r) {this.edge_list.push(new u(e[r], e[(r + 1) % n]));}}, h.prototype.getPoint = function (e) {return this.points_[e];}, h.prototype.addToMap = function (e) {this.map_.push(e);}, h.prototype.locateNode = function (e) {return this.front_.locateNode(e.x);}, h.prototype.createAdvancingFront = function () {var e,t,r,n = new i(this.points_[0], this.tail_, this.head_);this.map_.push(n), e = new c(n.getPoint(1), n), t = new c(n.getPoint(0), n), r = new c(n.getPoint(2)), this.front_ = new a(e, r), e.next = t, t.next = r, t.prev = e, r.prev = t;}, h.prototype.removeNode = function (e) {}, h.prototype.mapTriangleToNodes = function (e) {for (var t = 0; t < 3; ++t) {if (!e.getNeighbor(t)) {var r = this.front_.locatePoint(e.pointCW(e.getPoint(t)));r && (r.triangle = e);}}}, h.prototype.removeFromMap = function (e) {var t,r = this.map_,n = r.length;for (t = 0; t < n; t++) {if (r[t] === e) {r.splice(t, 1);break;}}}, h.prototype.meshClean = function (e) {for (var t, r, n = [e]; t = n.pop();) {if (!t.isInterior()) for (t.setInterior(!0), this.triangles_.push(t), r = 0; r < 3; r++) {t.constrained_edge[r] || n.push(t.getNeighbor(r));}}}, t.exports = h;}, { "./advancingfront": 2, "./point": 4, "./pointerror": 5, "./sweep": 7, "./triangle": 9 }], 9: [function (e, t, r) {var n = function n(e, t, r) {this.points_ = [e, t, r], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];},o = e("./xy").toString;n.prototype.toString = function () {return "[" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + "]";}, n.prototype.getPoint = function (e) {return this.points_[e];}, n.prototype.GetPoint = n.prototype.getPoint, n.prototype.getPoints = function () {return this.points_;}, n.prototype.getNeighbor = function (e) {return this.neighbors_[e];}, n.prototype.containsPoint = function (e) {var t = this.points_;return e === t[0] || e === t[1] || e === t[2];}, n.prototype.containsEdge = function (e) {return this.containsPoint(e.p) && this.containsPoint(e.q);}, n.prototype.containsPoints = function (e, t) {return this.containsPoint(e) && this.containsPoint(t);}, n.prototype.isInterior = function () {return this.interior_;}, n.prototype.setInterior = function (e) {return this.interior_ = e, this;}, n.prototype.markNeighborPointers = function (e, t, r) {var n = this.points_;if (e === n[2] && t === n[1] || e === n[1] && t === n[2]) this.neighbors_[0] = r;else if (e === n[0] && t === n[2] || e === n[2] && t === n[0]) this.neighbors_[1] = r;else {if (!(e === n[0] && t === n[1] || e === n[1] && t === n[0])) throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2] = r;}}, n.prototype.markNeighbor = function (e) {var t = this.points_;e.containsPoints(t[1], t[2]) ? (this.neighbors_[0] = e, e.markNeighborPointers(t[1], t[2], this)) : e.containsPoints(t[0], t[2]) ? (this.neighbors_[1] = e, e.markNeighborPointers(t[0], t[2], this)) : e.containsPoints(t[0], t[1]) && (this.neighbors_[2] = e, e.markNeighborPointers(t[0], t[1], this));}, n.prototype.clearNeighbors = function () {this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;}, n.prototype.clearDelaunayEdges = function () {this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;}, n.prototype.pointCW = function (e) {var t = this.points_;return e === t[0] ? t[2] : e === t[1] ? t[0] : e === t[2] ? t[1] : null;}, n.prototype.pointCCW = function (e) {var t = this.points_;return e === t[0] ? t[1] : e === t[1] ? t[2] : e === t[2] ? t[0] : null;}, n.prototype.neighborCW = function (e) {return e === this.points_[0] ? this.neighbors_[1] : e === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];}, n.prototype.neighborCCW = function (e) {return e === this.points_[0] ? this.neighbors_[2] : e === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];}, n.prototype.getConstrainedEdgeCW = function (e) {return e === this.points_[0] ? this.constrained_edge[1] : e === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];}, n.prototype.getConstrainedEdgeCCW = function (e) {return e === this.points_[0] ? this.constrained_edge[2] : e === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];}, n.prototype.getConstrainedEdgeAcross = function (e) {return e === this.points_[0] ? this.constrained_edge[0] : e === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];}, n.prototype.setConstrainedEdgeCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[1] = t : e === this.points_[1] ? this.constrained_edge[2] = t : this.constrained_edge[0] = t;}, n.prototype.setConstrainedEdgeCCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[2] = t : e === this.points_[1] ? this.constrained_edge[0] = t : this.constrained_edge[1] = t;}, n.prototype.getDelaunayEdgeCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[1] : e === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];}, n.prototype.getDelaunayEdgeCCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[2] : e === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];}, n.prototype.setDelaunayEdgeCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[1] = t : e === this.points_[1] ? this.delaunay_edge[2] = t : this.delaunay_edge[0] = t;}, n.prototype.setDelaunayEdgeCCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[2] = t : e === this.points_[1] ? this.delaunay_edge[0] = t : this.delaunay_edge[1] = t;}, n.prototype.neighborAcross = function (e) {return e === this.points_[0] ? this.neighbors_[0] : e === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];}, n.prototype.oppositePoint = function (e, t) {var r = e.pointCW(t);return this.pointCW(r);}, n.prototype.legalize = function (e, t) {var r = this.points_;if (e === r[0]) r[1] = r[0], r[0] = r[2], r[2] = t;else if (e === r[1]) r[2] = r[1], r[1] = r[0], r[0] = t;else {if (e !== r[2]) throw new Error("poly2tri Invalid Triangle.legalize() call");r[0] = r[2], r[2] = r[1], r[1] = t;}}, n.prototype.index = function (e) {var t = this.points_;if (e === t[0]) return 0;if (e === t[1]) return 1;if (e === t[2]) return 2;throw new Error("poly2tri Invalid Triangle.index() call");}, n.prototype.edgeIndex = function (e, t) {var r = this.points_;if (e === r[0]) {if (t === r[1]) return 2;if (t === r[2]) return 1;} else if (e === r[1]) {if (t === r[2]) return 0;if (t === r[0]) return 2;} else if (e === r[2]) {if (t === r[0]) return 1;if (t === r[1]) return 0;}return -1;}, n.prototype.markConstrainedEdgeByIndex = function (e) {this.constrained_edge[e] = !0;}, n.prototype.markConstrainedEdgeByEdge = function (e) {this.markConstrainedEdgeByPoints(e.p, e.q);}, n.prototype.markConstrainedEdgeByPoints = function (e, t) {var r = this.points_;t === r[0] && e === r[1] || t === r[1] && e === r[0] ? this.constrained_edge[2] = !0 : t === r[0] && e === r[2] || t === r[2] && e === r[0] ? this.constrained_edge[1] = !0 : (t === r[1] && e === r[2] || t === r[2] && e === r[1]) && (this.constrained_edge[0] = !0);}, t.exports = n;}, { "./xy": 11 }], 10: [function (e, t, r) {var n = 1e-16;r.EPSILON = n;var o = { CW: 1, CCW: -1, COLLINEAR: 0 };r.Orientation = o, r.orient2d = function (e, t, r) {var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);return i > -n && i < n ? o.COLLINEAR : i > 0 ? o.CCW : o.CW;}, r.inScanArea = function (e, t, r, o) {return !((e.x - t.x) * (o.y - t.y) - (o.x - t.x) * (e.y - t.y) >= -n || (e.x - r.x) * (o.y - r.y) - (o.x - r.x) * (e.y - r.y) <= n);}, r.isAngleObtuse = function (e, t, r) {var n = t.x - e.x,o = t.y - e.y;return n * (r.x - e.x) + o * (r.y - e.y) < 0;};}, {}], 11: [function (e, t, r) {function n(e) {return "(" + e.x + ";" + e.y + ")";}t.exports = { toString: function toString(e) {var t = e.toString();return "[object Object]" === t ? n(e) : t;}, toStringBase: n, compare: function compare(e, t) {return e.y === t.y ? e.x - t.x : e.y - t.y;}, equals: function equals(e, t) {return e.x === t.x && e.y === t.y;} };}, {}] }, {}, [6])(6);});var a = s.exports;t.poly2tri = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.CCI = void 0;var n = r(1),o = r(111),i = r(77),s = function s(e, t, r, n, i) {this._cu1 = e, this._range1 = t, this._cu2 = r, this._range2 = n, this._epsilon = i, this._tree = new o.SubCurveTree(e, t, r, n, i);};s.prototype.intersect = function () {var e = [];this._tree.build();for (var t = 0; t < this._tree._overlaps.length; ++t) {var r = this._tree._overlaps[t][0],n = this._tree._overlaps[t][1];e = e.concat(this._solve(r._range, n._range));}return this._merge(e), e;}, s.prototype._distanceSquared = function (e, t) {var r = this._cu1.evaluatePosition(e),o = this._cu2.evaluatePosition(t);return n.Vector3.squaredDistance(r, o);}, s.prototype._solve = function (e, t) {var r = [],n = [.5 * (e[0] + e[1]), .5 * (t[0] + t[1])],o = this._relaxNR(n, [e, t]),s = o === i.RelaxResult.Success;if (o === i.RelaxResult.OutOfRange) {var a = n[0] < e[0] + 1e-12 || n[0] > e[1] - 1e-12,c = n[1] < t[0] + 1e-12 || n[1] > t[1] - 1e-12;(a || c) && this._distanceSquared(n[0], n[1]) < this._epsilon * this._epsilon && (s = !0);}return s && r.push(new function (e, t) {this.cutInfo = e, this.cutByInfo = t;}({ param: n[0], atVertex: void 0 }, { param: n[1], atVertex: void 0 })), r;}, s.prototype._relaxNR = function (e, t) {var r = this,o = (0, i.newtonRaphson2D)(function (e) {var t = r._cu1.evaluatePosition(e[0]),o = r._cu2.evaluatePosition(e[1]),i = [t[0] - o[0], t[1] - o[1]],s = r._cu1.evaluateDt(e[0]),a = r._cu2.evaluateDt(e[1]);return n.Vector3.negate(a, a), { val: i, deriv1: s, deriv2: a };}, e, t);return e[0] = o.param[0], e[1] = o.param[1], o.status;}, s.prototype._merge = function (e) {e.sort(function (e, t) {return e.cutInfo.param - t.cutInfo.param;});for (var t = 0; t < e.length; t++) {if (e[t]) for (var r = e[t].cutInfo.param, n = e[t].cutByInfo.param, o = t + 1; o < e.length; o++) {if (e[o]) {var i = e[o].cutInfo.param,s = e[o].cutByInfo.param;if (i > r + 1e-11) break;if (Math.abs(s - n) <= 1e-11) {e[t] = void 0;break;}}}}for (t = 0; t < e.length; t++) {e[t] || (e.splice(t, 1), t--);}}, t.CCI = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SubCurveTree = void 0;var n = 100 * r(0).KERNEL_TOLERANCE,o = Math.PI / 180 * 10,i = function i(e, t, r) {void 0 === r && (r = 0), this._cu = e, this._range = t, this._bx = e.getBoundingBox(t).clone(), this._simple = void 0, this._split_param = void 0, this._children = [], this._depth = r;};i.prototype.isSimple = function () {if (void 0 === this._simple) {this._simple = !1;var e = [this._range[0] + 1e-8, this._range[1] - 1e-8];if (this._split_param = this._cu.suggestSplittingParam(e), void 0 === this._split_param) {this._split_param = .5 * (this._range[0] + this._range[1]);var t = this._cu.getTangentCone(this._range);(t.isDegenerate() || t.angle < o) && (this._simple = !0);}}return this._simple;}, i.prototype.canDivide = function () {return !(this._depth >= 10 || this._range[1] - this._range[0] < 2e-8 || Math.max(this._bx.getWidth(0), this._bx.getWidth(1), this._bx.getWidth(2)) < n);}, i.prototype.divide = function () {if (0 === this._children.length) {var e = [this._range[0], this._split_param],t = [this._split_param, this._range[1]];this._children = [new i(this._cu, e, this._depth + 1), new i(this._cu, t, this._depth + 1)];}}, i.prototype.fullSubdivision = function () {if (!this.isSimple() && this.canDivide()) {this.divide();for (var e = 0; e < this._children.length; ++e) {this._children[e].fullSubdivision();}}}, i.prototype.toString = function () {if (this._children.length > 0) {for (var e = "", t = 0; t < this._children.length; ++t) {e += this._children[t];}return e;}return "t=[" + this._range[0] + " " + this._range[1] + "] " + this._bx + "\n";};var s = function s(e, t, r, n, o) {this._cu1_root_node = new i(e, t), this._cu2_root_node = new i(r, n), this._epsilon = o, this._overlaps = [];};s.prototype.process = function (e, t) {if (e._bx.intersectsWithTolerance(t._bx, this._epsilon)) {var r = e.canDivide(),n = t.canDivide(),o = e.isSimple() || !r,i = t.isSimple() || !n;if (o && i) this._overlaps.push([e, t]);else if (r && n) {e.divide(), t.divide();for (var s = 0; s < e._children.length; ++s) {for (var a = 0; a < t._children.length; ++a) {this.process(e._children[s], t._children[a]);}}} else if (r) for (e.divide(), s = 0; s < e._children.length; ++s) {this.process(e._children[s], t);} else if (n) for (t.divide(), s = 0; s < t._children.length; ++s) {this.process(e, t._children[s]);}}}, s.prototype.build = function () {this.process(this._cu1_root_node, this._cu2_root_node);}, t.SubCurveTree = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.RegionTopologyFace = t.RegionTopologyEdge = t.RegionTopologyVertex = void 0;var n = r(1),o = r(16),i = r(20),s = r(15),a = r(0),c = r(2),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e) {o.Vertex.call(this, e), this._associatedVertices = [];};(l.prototype = Object.create(o.Vertex.prototype)).setAssociatedEntities = function (e) {this._associatedVertices = u.default.clone(e);}, l.prototype.getAssociatedEntities = function () {return this._associatedVertices;};var h = function h(e) {i.Edge.call(this, e), this._sourceEdge = void 0, this._associatedEdges = [], this._isDangling = !1;};(h.prototype = Object.create(i.Edge.prototype)).setAssociatedEdges = function (e) {this._associatedEdges = e;}, h.prototype.getAssociatedEntities = function () {return u.default.map(this._associatedEdges, function (e) {return e.edge;});}, h.prototype.getAssociatedEdgeInfo = function () {return this._associatedEdges;}, h.prototype.setToEdgeSegment = function (e, t) {this._sourceEdge = e, this._curve = e.getCurve(), this._reversed = e.isReversed(), this.setRange(t);}, h.prototype.setIsDangling = function (e) {this._isDangling = e;}, h.prototype.isDangling = function () {return this._isDangling;}, h.prototype.getSourceEdge = function () {return this._sourceEdge;};var d = function d(e) {s.Face.call(this, e), this._danglingEdges = [];};(d.prototype = Object.create(s.Face.prototype)).addDanglingEdge = function (e) {this._danglingEdges.push(e);}, d.prototype.isPointInsideFace = function (e) {for (var t = 0, r = 0; r < this.getLoops().length; ++r) {for (var n = this.getLoops()[r], o = 0; o < n.getCoedges().length; ++o) {var i = n.getCoedges()[o];i.getEdge().isDangling() || (t += i.uvAngleSubtended(e));}}t = Math.abs(t);var s = Math.floor(t / (2 * Math.PI)),c = t - 2 * s * Math.PI;return !!(Math.abs(c) < a.PARAMETER_SPACE_TOLERANCE && s || Math.abs(c - 2 * Math.PI) < a.PARAMETER_SPACE_TOLERANCE);}, d.prototype.getRepresentativePoint = function () {var e,t,r = n.Vector3.createFloat64(),o = this.getBoundingBox(),i = (o.max[0] - o.min[0]) / 33,s = (o.max[1] - o.min[1]) / 33;for (e = 1; e < 32; ++e) {for (t = 1; t < 32; ++t) {if (r[0] = o.min[0] + i * e, r[1] = o.min[1] + s * t, this.isPointInsideFace(r)) return r;}}return c.ConsoleUtils.assert(!1), o.getCenter();}, d.prototype.getDanglingEdges = function () {return this._danglingEdges;}, t.RegionTopologyVertex = l, t.RegionTopologyEdge = h, t.RegionTopologyFace = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.matchRegionEdgeRecipe = t.deserializeRegionEdgeRecipe = t.serializeRegionEdgeRecipe = t.createRecipeFromRegionEdge = t.matchRegionFaceRecipe = t.deserializeRegionFaceRecipe = t.serializeRegionFaceRecipe = t.createRecipeFromRegionFace = void 0;var n = r(1),o = r(3),i = r(0),s = r(114),a = r(2),c = r(8),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e, t) {var r = u.default.filter(t.regionVertices, function (t) {return u.default.contains(t.getAssociatedEntities(), e.getStartVertex());});a.ConsoleUtils.assert(1 === r.length), r = r[0];var n = [],o = [],i = new Set(),s = r,c = void 0;if (s) do {n.push(s);var l = u.default.filter(s.getEdges(), function (t) {return t !== c && u.default.contains(t.getAssociatedEntities(), e) && !i.has(t);});if (0 === l.length) {a.ConsoleUtils.assert(!e.isClosed()), a.ConsoleUtils.assert(u.default.contains(s.getAssociatedEntities(), e.getEndVertex()));break;}var h = void 0;if (l.length > 1) {l.sort(function (e, t) {return e.t0() - t.t0();});for (var d = 0; d < l.length; d++) {if (l[d].getStartVertex() === s) {h = l[d];break;}}a.ConsoleUtils.assert(h);} else h = l[0];s = h.getOtherVertex(s), a.ConsoleUtils.assert(s), c = h, i.add(c), o.push(c);} while (s !== r);return { edges: o, vertices: n };},h = function h(e, t, r) {var o = [],s = u.default.filter(t, function (t) {return t !== e;});if (0 === s.length) ;else for (var a = r.vertices, c = 0; c < a.length; c++) {for (var l = a[c], h = !1, d = l.getEdges(), g = 0; g < d.length; g++) {if (u.default.intersection(s, d[g].getAssociatedEntities()).length > 0) {h = !0;break;}}h && o.push({ vertex: l, indexInTopology: c });}if (e.isClosed() && 2 === o.length && 1 === s.length) {var p = !1;if (s[0].getCurveType() === i.GEOMETRY_TYPES.LINE) {var f = s[0],v = f.closestToPointParam(o[0].vertex.getPosition());p = f.closestToPointParam(o[1].vertex.getPosition()) < v;} else if (e.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && s[0].getCurveType() === i.GEOMETRY_TYPES.CIRCLE) {var _ = e.getCurve().getCenter(),y = n.Vector3.sub([0, 0, 0], s[0].getCurve().getCenter(), _);if (n.Vector3.length(y) > 0) {n.Vector3.normalize(y, y);var m = n.Vector3.sub([0, 0, 0], o[0].vertex.getPosition(), _),E = n.Vector3.sub([0, 0, 0], o[1].vertex.getPosition(), _),x = m.x * y.y - m.y * y.x,R = E.x * y.y - E.y * y.x;x > 0 && R < 0 && (p = !0);}}if (p) {var A = o[1];o[1] = o[0], o[0] = A;}}return o;},d = function d(e, t, r, n, o) {var i,a = {};a[e.getGuid()] = { dist: 0, prev: null, prevEdge: null, vertex: e, guid: e.getGuid() };var c = new s.BinaryHeap(function (e) {return e.dist;}, function (e) {return e.guid;});for (c.push(a[e.getGuid()]); 0 !== c.size();) {var l = c.pop();if (l === t) break;i = l.vertex.getEdges();for (var h = 0; h < i.length; h++) {var d = i[h].getOtherVertex(l.vertex);if (d && !n[i[h].getGuid()] && (!r[d.getGuid()] || d === t)) {for (var g = i[h].getEndVertex() === d, p = !1, f = i[h].getAssociatedEntities(), v = 0; v < o.length; v++) {if (u.default.contains(f, o[v].edge) && o[v].orientation === g) {p = !0;break;}}var _ = a[l.guid].dist;p || (_ += 1), void 0 === a[d.getGuid()] ? (a[d.getGuid()] = { dist: _, prev: l, prevEdge: i[h], vertex: d, guid: d.getGuid() }, c.push(a[d.getGuid()])) : a[d.getGuid()].dist > _ && (a[d.getGuid()].dist = _, a[d.getGuid()].prev = l, a[d.getGuid()].prevEdge = i[h], c.updated(a[d.getGuid()]));}}}var y = a[t.getGuid()];if (y) {i = [];for (var m = [], E = y, x = t; E.prevEdge;) {var R = E.prevEdge;i.push(R), E = E.prev, m.push(R.getEndVertex() === x), x = R.getOtherVertex(x);}return { dist: y.dist, edges: i.reverse(), orientations: m.reverse(), startVertex: e, endVertex: t };}return { dist: 1 / 0, edges: [] };},g = function g(e, t, r, n, i, s, a) {for (var c = e[i], l = {}, h = 0; h < c.length; h++) {null !== c[h].endVertex && (l[c[h].endVertex.getGuid()] ? l[c[h].endVertex.getGuid()].incomingEdges.push({ edge: c[h].edge, orientation: c[h].edgeOriented }) : l[c[h].endVertex.getGuid()] = { edgeIndex: h, edgeInfo: c[h], vertex: c[h].endVertex, incomingEdges: [{ edge: c[h].edge, orientation: c[h].edgeOriented }] });}if (u.default.values(l).length > 0) {var g = s.vertices,p = s.edges,f = u.default.keys(l),v = { dist: 1 / 0 },_ = n;do {_ = (0, o.modulus)(_ - 1, e.length);for (var y = u.default.keys(a[_]), m = 0; m < y.length; m++) {var E = a[_][y[m]].vertex;if (E) for (var x = 0; x < f.length; x++) {var R = l[f[x]].vertex,A = a[_][y[m]].outgoingEdges.concat(l[f[x]].incomingEdges),P = d(E, R, g, p, A);P.dist < v.dist && ((v = P).startIndex = _);}}} while (_ !== t && v.dist === 1 / 0);if (v.dist < 1 / 0) {var V = a[v.startIndex][v.startVertex.getGuid()],T = a[i][v.endVertex.getGuid()],C = V.cost + v.dist;(!T || C < T.cost || i === t && v.endVertex.getGuid() === r.getGuid() && null === T.previousGuid) && (a[i][v.endVertex.getGuid()] = { previousGuid: v.startVertex.getGuid(), edgeSegment: null, indexRange: [], cost: V.cost + v.dist, vertex: v.endVertex, previousIndex: v.startIndex, connectionEdges: v.edges, connectionOrientation: v.orientations, outgoingEdges: [] });}}},p = function p(e, t, r, n, i) {var s = [],a = e[t][r].endVertex;s[t] = {}, s[t][a.getGuid()] = { previousGuid: null, edgeSegment: null, previousIndex: null, cost: 0, vertex: a, outgoingEdges: [] };var c = t;do {var l = (0, o.modulus)(c + 1, e.length),h = e[l];s[l] = s[l] || {};for (var d = u.default.keys(s[c]), p = 0, f = 0; f < d.length; f++) {for (var v = d[f], _ = 0; _ < h.length; _++) {if (h[_].startVertices[v]) {s[c][v].outgoingEdges.push({ edge: h[_].edge, orientation: h[_].edgeOriented });var y = h[_].endVertex;if (null !== y) {var m = s[c][v].cost;h[_].edge.isClosed() || h[_].endVertexTopologyIndex > h[_].startVertices[v].vertexIndex !== h[_].edgeOriented && (m += 1), (!s[l][y.getGuid()] || s[l][y.getGuid()].cost > m || l === t && y.getGuid() === a.getGuid() && null === s[l][y.getGuid()].previousGuid) && (s[l][y.getGuid()] = { previousGuid: v, edgeSegment: h[_], indexRange: [h[_].startVertices[v].vertexIndex, h[_].endVertexTopologyIndex], cost: m, vertex: y, previousIndex: c, outgoingEdges: [] }, p++);} else m = s[c][v].cost, (!s[l][v] || s[l][v].cost > m) && (s[l][v] = { previousGuid: v, edgeSegment: h[_], indexRange: [], cost: m, previousIndex: c, outgoingEdges: [] });}}}0 === p && g(e, t, a, c, l, n, s), c = l;} while (c !== t);null !== s[t][a.getGuid()].previousGuid && s[t][a.getGuid()].cost < i.cost && (i.cost = s[t][a.getGuid()].cost, i.state = s, i.startGuid = a.getGuid());},f = function f(e, t) {for (var r = function (e, t) {var r = {},n = {},i = {},s = t;do {var a = (0, o.modulus)(s + 1, e.length),c = e[s],u = e[a],l = i;i = {};for (var h = 0; h < u.length; h++) {var d = u[h].topologyAlongEdge.vertices,g = u[h].topologyAlongEdge.edges;u[h].startVertices = {};var p = void 0,f = void 0,v = c.length;void 0 !== l[u[h].edge.getGuid()] && v++;for (var _ = 0; _ < v; _++) {var y = void 0;if (_ === c.length) y = l[u[h].edge.getGuid()];else {if (!c[_].endVertex) continue;y = c[_].endVertex.getGuid();}for (var m = void 0, E = 0; E < d.length; E++) {if (d[E].getGuid() === y) {m = E;break;}}void 0 !== m && (u[h].startVertices[y] = { vertex: d[m], vertexIndex: m }, null !== u[h].endVertex && (u[h].edgeOriented ? (p = void 0 !== p ? Math.min(p, m) : m, f = void 0 !== f ? Math.max(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex) : (p = void 0 !== p ? Math.max(p, m) : m, f = void 0 !== f ? Math.min(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex)), void 0 === i[u[h].edge.getGuid()] && (i[u[h].edge.getGuid()] = y));}if (void 0 !== p && void 0 !== f) {if (p !== f) {var x;x = u[h].edge.isClosed() ? u[h].edgeOriented ? 1 : -1 : p < f ? 1 : -1;var R = p;do {if (r[d[R].getGuid()] = d[R], x > 0) R !== f && (n[g[R].getGuid()] = g[R]);else {var A = (0, o.modulus)(R - 1, g.length);n[g[A].getGuid()] = g[A];}R = (0, o.modulus)(R + x, d.length);} while (R !== f);}r[d[f].getGuid()] = d[f];}}s = a;} while (s !== t);return { vertices: r, edges: n };}(e, t), n = { cost: 1 / 0, state: void 0, startGuid: void 0 }, i = 0; i < e[t].length; i++) {null !== e[t][i].endVertex && p(e, t, i, r, n);}if (n.cost === 1 / 0) return { edges: void 0, edgeOrientedFlags: void 0, score: 1 / 0 };var s = function (e, t) {var r = [],n = e.startGuid,i = t;do {r.push(e.state[i][n]);var s = e.state[i][n].previousIndex;n = e.state[i][n].previousGuid, i = s;} while (i !== t);r = r.reverse();var a = [],c = [];for (i = 0; i < r.length; i++) {if (0 !== r[i].indexRange.length) {var u,l,h,d,g = r[i].edgeSegment.topologyAlongEdge;r[i].indexRange[0] < r[i].indexRange[1] ? (u = r[i].indexRange[0], l = r[i].indexRange[1], r[i].edgeSegment.edge.isClosed() && !r[i].edgeSegment.edgeOriented ? (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1) : (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0)) : r[i].edgeSegment.edge.isClosed() && r[i].edgeSegment.edgeOriented ? (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0) : (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1);var p = u;do {a.push(g.edges[p]), c.push(d), p = (0, o.modulus)(p + h, g.edges.length);} while (p !== l);} else if (r[i].connectionEdges) for (p = 0; p < r[i].connectionEdges.length; p++) {a.push(r[i].connectionEdges[p]), c.push(r[i].connectionOrientation[p]);}}return { topologyEdges: a, edgeOrientedFlags: c };}(n, t);return { edges: s.topologyEdges, edgeOrientedFlags: s.edgeOrientedFlags, score: n.cost };},v = function v(e, t) {var r,n = function (e, t) {for (var r = [], n = 0; n < e.length; n++) {for (var o = e[n], i = [], s = 0; s < o.length; s++) {var a = o[s],c = t.sketchEdges[a.edgeRef];c && i.push({ edgeRef: a.edgeRef, edgeOriented: a.edgeOriented, intersectionNumber: a.intersectionNumber, totalIntersections: a.totalIntersections, edge: c, topologyAlongEdge: l(c, t), endVertex: null, endVertexTopologyIndex: null });}r.push(i);}return r;}(e, t);if (c.DebugUtils.level("region_match") >= 2) {var o = u.default.pluck(u.default.flatten(n), "edge");for (r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}c.DebugUtils.render();}if (function (e) {for (var t = 0; t < e.length; t++) {for (var r = u.default.pluck(e[(t + 1) % e.length], "edge"), n = 0; n < e[t].length; n++) {var o = e[t][n],i = h(o.edge, r, o.topologyAlongEdge);if (0 === o.totalIntersections) o.endVertex = null;else if (i.length === o.totalIntersections) {var s = i[o.intersectionNumber];o.endVertexTopologyIndex = s.indexInTopology, o.endVertex = s.vertex;} else 0 === i.length || c.DebugUtils.warn("Region matching problem! Intersection counts do not match"), o.endVertex = null;}}}(n), c.DebugUtils.level("region_match") >= 2) {var i = u.default.pluck(u.default.flatten(n), "endVertex");for (r = 0; r < i.length; r++) {null !== i[r] && c.DebugUtils.drawVertex3D(i[r], { color: 65280, render: !1 });}c.DebugUtils.render();}var s = function (e) {for (var t = 1 / 0, r = void 0, n = 0; n < e.length; n++) {var o = e[n];if (0 !== o.length) {for (var i = 0, s = 0; s < o.length; s++) {null !== o[s].endVertex && i++;}var a = o.length - i;if (0 === a) return n;i > 0 && a < t && (t = a, r = n);}}return r;}(n);if (void 0 === s) {for (var a = 0; a < n[0].length; a++) {var d = n[0][a].edge;if (d.isClosed() && u.default.all(n, function (e) {for (var t = 0; t < e.length; t++) {if (e[t].edge === d) return !0;}return !1;})) {var g = n[0][a].topologyAlongEdge.edges,p = new Array(g.length);for (r = 0; r < p.length; r++) {p[r] = n[0][a].edgeOriented;}return n[0][a].edgeOriented || g.reverse(), c.DebugUtils.level("region_match") >= 2 && c.DebugUtils.drawEdge3D(d, { color: 16711680 }), { edges: g, edgeOrientedFlags: p, matchStatus: 2 };}}return { edges: void 0, edgeOrientedFlags: void 0, matchStatus: 0 };}var v,_ = f(n, s);if (c.DebugUtils.level("region_match") >= 2 && void 0 !== _.edges) {for (r = 0; r < _.edges.length; r++) {c.DebugUtils.drawEdge3D(_.edges[r], { color: 16711680, render: !1 });}c.DebugUtils.render();}return v = 0 === _.score ? 2 : _.score === 1 / 0 ? 0 : 1, { edges: _.edges, edgeOrientedFlags: _.edgeOrientedFlags, matchStatus: v };},_ = function _(e, t) {if (!e || !e.edges) return new Set();for (var r = new Set(), n = 0; n < e.edges.length; n++) {var o = e.edgeOrientedFlags[n] === t,i = e.edges[n].getCoedges();a.ConsoleUtils.assert(i.length >= 1 && i.length <= 2);for (var s = void 0, c = 0; c < i.length; c++) {if (i[c].isReversed() === o) {s = i[c].getFace();break;}}s && !r.has(s) && r.add(s);}var u = new Set(e.edges);return r.forEach(function (e) {for (var t = Array.from(e.collectEdges()), n = 0; n < t.length; n++) {var o = t[n];if (!u.has(o)) {var i = void 0,s = o.getFaces();a.ConsoleUtils.assert(s.length >= 1 && s.length <= 2), 1 === s.length ? a.ConsoleUtils.assert(s[0] === e) : 2 === s.length && (a.ConsoleUtils.assert(s[0] === e || s[1] === e), i = s[0] === e ? s[1] : s[0]), i && !r.has(i) && r.add(i);}}}), r;};t.createRecipeFromRegionFace = function (e, t) {for (var r = [], n = e.getLoops(), o = 0; o < n.length; o++) {for (var i = n[o].getCoedges(), s = [], a = 0; a < i.length; a++) {for (var c = i[a], d = c.getEdge().getAssociatedEdgeInfo(), g = c.getEndVertex(), p = i[(a + 1) % i.length].getEdge().getAssociatedEdgeInfo(), f = u.default.pluck(p, "edge"), v = [], _ = 0; _ < d.length; _++) {for (var y = l(d[_].edge, t), m = h(d[_].edge, f, y), E = 0, x = 0; x < m.length; x++) {if (m[x].vertex === g) {E = x;break;}}var R = { edgeRef: d[_].edge.getGuid(), edgeOriented: !(c.isReversed() ^ d[_].flipped), intersectionNumber: E, totalIntersections: m.length, edge: d[_].edge };v.push(R);}s.push(v);}r.push(s);}return r;}, t.serializeRegionFaceRecipe = function (e) {for (var t = [], r = 0; r < e.length; r++) {for (var n = [], o = e[r], i = 0; i < o.length; i++) {for (var s = [], a = o[i], c = 0; c < a.length; c++) {var u = a[c];s.push(u.edgeRef + "_" + (u.edgeOriented ? "t" : "f") + "_" + u.intersectionNumber + "_" + u.totalIntersections);}n.push(s.join(";"));}t.push(n.join("+"));}return t.join("/");}, t.deserializeRegionFaceRecipe = function (e) {for (var t = e.split("/"), r = 0; r < t.length; r++) {t[r] = t[r].split("+");for (var n = t[r], o = 0; o < n.length; o++) {n[o] = n[o].split(";");for (var i = n[o], s = 0; s < i.length; s++) {var a = i[s].split("_");i[s] = { edgeRef: a[0], edgeOriented: "t" === a[1], intersectionNumber: parseInt(a[2], 10), totalIntersections: parseInt(a[3], 10) };}}}return t;}, t.matchRegionFaceRecipe = function (e, t) {var r,n,o,i = 2,s = [];for (r = 0; r < e.length; r++) {var a = v(e[r], t);if (0 === a.matchStatus && 0 === r) return { regions: [], matchStatus: 0 };2 !== a.matchStatus && (i = 1), s.push(a);}if (c.DebugUtils.level("region_match") > 0) {for (c.DebugUtils.clearView(), o = u.default.values(t.sketchEdges), r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}for (r = 0; r < s.length; r++) {for (n = 0; n < s[r].edges.length; n++) {var l = 0 === r ? 65280 : 16711680;c.DebugUtils.drawEdge3D(s[r].edges[n], { color: l, render: !1 });}}c.DebugUtils.render();}var h = _(s[0], !1);for (n = 1; n < s.length; n++) {_(s[n], !0).forEach(function (e) {h.delete(e);});}if (h = Array.from(h), c.DebugUtils.level("region_match") > 0) {for (r = 0; r < h.length; r++) {for (o = Array.from(h[r].collectEdges()), n = 0; n < o.length; n++) {c.DebugUtils.drawEdge3D(o[n], { color: 13684736, render: !1 });}}c.DebugUtils.render();}return { regions: h, matchStatus: i };}, t.createRecipeFromRegionEdge = function (e, t) {var r,n,o = { startEdgeRefs: [], endEdgeRefs: [], edgeRef: [], edgeOriented: [], intersectionNumberStart: [], totalIntersectionsStart: [], intersectionNumberEnd: [], totalIntersectionsEnd: [] },i = e.getStartVertex(),s = [];i.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {s.indexOf(t[r]) < 0 && (s.push(t[r]), o.startEdgeRefs.push(t[r].getGuid()));}});var a = e.getEndVertex(),c = [];a.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {c.indexOf(t[r]) < 0 && (c.push(t[r]), o.endEdgeRefs.push(t[r].getGuid()));}});var d = e.getAssociatedEdgeInfo(),g = u.default.pluck(d, "edge");for (r = 0; r < d.length; r++) {var p = g[r],f = !d[r].flipped,v = l(p, t),_ = u.default.unique(s.concat(g)),y = h(p, _, v),m = 0;for (n = 0; n < y.length; n++) {if (y[n].vertex === i) {m = n;break;}}var E = u.default.unique(c.concat(g)),x = h(p, E, v),R = 0;for (n = 0; n < x.length; n++) {if (x[n].vertex === a) {R = n;break;}}o.edgeRef.push(p.getGuid()), o.edgeOriented.push(f), o.intersectionNumberStart.push(m), o.totalIntersectionsStart.push(y.length), o.intersectionNumberEnd.push(R), o.totalIntersectionsEnd.push(x.length);}return o;}, t.serializeRegionEdgeRecipe = function (e) {var t = { edge: e.edgeRef, orient: e.edgeOriented, start: e.startEdgeRefs, end: e.endEdgeRefs, sIdx: e.intersectionNumberStart, sNum: e.totalIntersectionsStart, eIdx: e.intersectionNumberEnd, eNum: e.totalIntersectionsEnd };return JSON.stringify(t);}, t.deserializeRegionEdgeRecipe = function (e) {var t = JSON.parse(e);return { edgeRef: t.edge, edgeOriented: t.orient, startEdgeRefs: t.start, endEdgeRefs: t.end, intersectionNumberStart: t.sIdx, totalIntersectionsStart: t.sNum, intersectionNumberEnd: t.eIdx, totalIntersectionsEnd: t.eNum };}, t.matchRegionEdgeRecipe = function (e, t) {var r = [],n = 0,o = [];e.startEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && o.push(r);});var i = [];e.endEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && i.push(r);}), e.edgeRef.forEach(function (e) {var r = t.sketchEdges[e];r && o.indexOf(r) < 0 && o.push(r), r && i.indexOf(r) < 0 && i.push(r);});for (var s = 0; s < e.edgeRef.length; s++) {var a = t.sketchEdges[e.edgeRef[s]];if (a) {var u = l(a, t),d = void 0,g = void 0,p = h(a, o, u);if (0 === e.totalIntersectionsStart[s]) d = u.vertices[0], g = 0;else if (p.length === e.totalIntersectionsStart[s]) {var f = p[e.intersectionNumberStart[s]];d = f.vertex, g = f.indexInTopology;}var v = void 0,_ = void 0,y = h(a, i, u);if (0 === e.totalIntersectionsEnd[s]) v = u.vertices[0], _ = u.vertices.length;else if (y.length === e.totalIntersectionsEnd[s]) {var m = y[e.intersectionNumberEnd[s]];v = m.vertex, 0 === (_ = m.indexInTopology) && a.isClosed() && (_ = u.vertices.length);}if (!e.edgeOriented[s]) {var E = d;d = v, v = E, E = g, g = _, _ = E;}if (d && v) {if (!(g >= _)) {r = u.edges.slice(g, _), n = 2;break;}c.DebugUtils.warn("Edge recipe match should find start vertex before end vertex");}}}return { edges: r, matchStatus: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {this.content = [], this.scoreFunction = e, this.lookupFunction = t, this.lookupFunction && (this.nodeDict = {});};n.prototype = { push: function push(e) {this.content.push(e), this.lookupFunction && (this.nodeDict[this.lookupFunction(e)] = this.content.length - 1), this.bubbleUp(this.content.length - 1);}, pop: function pop() {var e = this.content[0],t = this.content.pop();return this.content.length > 0 && (this.content[0] = t, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = 0), this.sinkDown(0)), this.lookupFunction && delete this.nodeDict[this.lookupFunction(e)], e;}, peek: function peek() {return this.content[0];}, getNodeIndex: function getNodeIndex(e) {if (this.lookupFunction) return this.nodeDict[this.lookupFunction(e)];for (var t = this.content.length, r = 0; r < t; r++) {if (this.content[r] === e) return r;}throw new Error("Node not found.");}, updated: function updated(e) {var t = this.getNodeIndex(e),r = this.scoreFunction(e),n = Math.floor((t + 1) / 2) - 1,o = this.content[n];if (t > 0 && r < this.scoreFunction(o)) this.bubbleUp(t);else {var i = 2 * (t + 1),s = i - 1,a = this.content[s],c = this.content[i];(a && r > this.scoreFunction(a) || c && r > this.scoreFunction(c)) && this.sinkDown(t);}}, remove: function remove(e) {var t = this.content.length,r = this.getNodeIndex(e),n = this.content.pop();r !== t - 1 && (this.content[r] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.bubbleUp(r) : this.sinkDown(r));}, size: function size() {return this.content.length;}, bubbleUp: function bubbleUp(e) {for (var t = this.content[e]; e > 0;) {var r = Math.floor((e + 1) / 2) - 1,n = this.content[r];if (!(this.scoreFunction(t) < this.scoreFunction(n))) break;this.content[r] = t, this.content[e] = n, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = r, this.nodeDict[this.lookupFunction(n)] = e), e = r;}}, sinkDown: function sinkDown(e) {for (var t = this.content.length, r = this.content[e], n = this.scoreFunction(r);;) {var o = 2 * (e + 1),i = o - 1,s = null;if (i < t) {var a = this.content[i],c = this.scoreFunction(a);c < n && (s = i);}if (o < t) {var u = this.content[o];this.scoreFunction(u) < (null === s ? n : c) && (s = o);}if (null === s) break;this.content[e] = this.content[s], this.content[s] = r, this.lookupFunction && (this.nodeDict[this.lookupFunction(this.content[e])] = e, this.nodeDict[this.lookupFunction(this.content[s])] = s), e = s;}} }, t.BinaryHeap = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createBlock = void 0;var n = r(28),o = r(83),i = r(0),s = r(2);t.createBlock = function (e, t) {var r = [Math.min(e[0], t[0]), Math.min(e[1], t[1]), Math.min(e[2], t[2])],a = [Math.max(e[0], t[0]), Math.max(e[1], t[1]), Math.max(e[2], t[2])];s.ConsoleUtils.assert(a[0] - r[0] > i.KERNEL_TOLERANCE, "block is degenerate in x axis"), s.ConsoleUtils.assert(a[1] - r[1] > i.KERNEL_TOLERANCE, "block is degenerate in y axis"), s.ConsoleUtils.assert(a[2] - r[2] > i.KERNEL_TOLERANCE, "block is degenerate in z axis");var c = [[r[0], r[1], r[2]], [a[0], r[1], r[2]], [a[0], a[1], r[2]], [r[0], a[1], r[2]]],u = (0, n.createFaceFromPolyline)(c),l = a[2] - r[2];return (0, o.extrudeFace)(u, l);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createCylinder = t.createCone = void 0;var n = r(1),o = r(28),i = r(0),s = r(18),a = r(51),c = r(38),u = r(39),l = r(52),h = r(13),d = r(15),g = r(26),p = r(25),f = r(24),v = r(2),_ = function _(e, t, r, _2, y, m) {var E = e,x = t,R = Math.abs(r),A = void 0 === _typeof(_2) ? R : Math.abs(_2);if (R < i.KERNEL_TOLERANCE) {E = t, x = e;var P = R;R = A, A = P;}v.ConsoleUtils.assert(R > i.KERNEL_TOLERANCE);var V = n.Vector3.createFloat64();n.Vector3.subtract(V, x, E);var T = n.Vector3.length(V);v.ConsoleUtils.assert(T > i.KERNEL_TOLERANCE), n.Vector3.scale(V, V, 1 / T);var C = A - R,b = Math.abs(C) > i.KERNEL_TOLERANCE,L = 0;b && (L = Math.atan2(C, T));var O,S = n.Vector3.createFloat64();m && n.Vector3.subtract(S, m, n.Vector3.scale(S, V, n.Vector3.dot(m, V))), (!m || n.Vector3.squaredLength(S) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE) && n.Vector3.computeOrthogonal(S, V), n.Vector3.normalize(S, S), n.Vector3.scale(S, S, R);var M = y || 1;v.ConsoleUtils.assert(M > 0 && M <= 1);var w = Math.max(R, A);Math.abs(w * (1 - M)) < i.KERNEL_TOLERANCE ? b ? (O = new a.Cone()).set(E, R, V, L, S, 1) : (O = new c.Cylinder()).set(E, R, V, S, 1) : b ? (O = new l.EllipticalCone()).set(E, S, M, V, L, 1) : (O = new u.EllipticalCylinder()).set(E, S, M, V, 1);var N = [0, T / Math.cos(L)];O.limitRangeU(N);var F = (0, o.makeConeOrCylinderVParamLoop)(O, N[0]),I = (0, o.makeConeOrCylinderVParamLoop)(O, N[1]);F.getCoedges()[0].setReversed(!0);var D = [];D[0] = new d.Face(), D[0].setSurface(O), D[0].addLoops([F, I]);var j = F.getCoedges()[0].getEdge();if (j.getCurve()) {var B = new h.Loop();B.addCoedge((0, o.createCoedgeOnEdge)(j)), (G = new d.Face()).addLoop(B);var U = new s.Plane();U.set(E, V), G.setSurface(U), G.setReversed(!0), D.push(G), v.ConsoleUtils.assert(B.getCoedges()[0].uvAngleSubtended(E) < -i.KERNEL_TOLERANCE);}var k = I.getCoedges()[0].getEdge();if (k.getCurve()) {var G,z = new h.Loop();z.addCoedge((0, o.createCoedgeOnEdge)(k)), (G = new d.Face()).addLoop(z);var Y = new s.Plane();Y.set(x, V), G.setSurface(Y), D.push(G), v.ConsoleUtils.assert(z.getCoedges()[0].uvAngleSubtended(x) < -i.KERNEL_TOLERANCE);}var K = new g.Shell();K.addFaces(D);var q = new p.Lump();q.addShell(K);var W = new f.Body();return W.addLump(q), W;};t.createCone = _, t.createCylinder = function (e, t, r, n, o) {return _(e, t, r, r, n, o);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createPolyhedron = void 0;var n = r(24),o = r(25),i = r(15),s = r(13),a = r(16),c = r(18),u = r(6),l = r(28),h = r(3),d = r(2),g = r(8);function p(e, t) {var r,n = e.getCommonEdges(t);d.ConsoleUtils.assert(n.length <= 1), r = 0 === n.length ? (0, l.createLineEdgeBetweenVertices)(e, t) : n[0];var o = (0, l.createCoedgeOnEdge)(r);return d.ConsoleUtils.assert(o.getStartVertex() === e), d.ConsoleUtils.assert(o.getEndVertex() === t), o;}function f(e, t) {var r,n = [];for (r = 0; r < t.length; ++r) {n[r] = e[t[r]];}var o = (0, h.definePlaneThroughPoints)(n);if (o) {var i = new c.Plane();return i.set(o.origin, o.normal, o.uAxis), i.limitRangeU(o.uRange), i.limitRangeV(o.vRange), i;}g.DebugUtils.warn("Face is degenerate");}t.createPolyhedron = function (e, t) {var r,c = [];for (r = 0; r < e.length; ++r) {var h = new a.Vertex(new u.Point(e[r]));c.push(h);}var g = [];for (r = 0; r < t.length; ++r) {var v = t[r];d.ConsoleUtils.assert(v.length >= 3);for (var _ = new s.Loop(), y = [], m = 0; m < v.length; ++m) {var E = v[m],x = v[(m + 1) % v.length];d.ConsoleUtils.assert(E >= 0 && E < e.length), d.ConsoleUtils.assert(x >= 0 && x < e.length);var R = p(c[E], c[x]);y.push(R);}_.addCoedges(y);var A = f(e, v),P = new i.Face(A);P.addLoop(_), g.push(P);}var V = (0, l.createShellsFromFaces)(g),T = [];for (r = 0; r < V.length; ++r) {T[r] = new o.Lump(), T[r].addShell(V[r]);}var C = new n.Body();return C.addLumps(T), C;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyStitcher = void 0;var n = r(1),o = r(119),i = r(41),s = r(2),a = function a() {this._shellSet = new Set(), this._lumpSet = new Set(), this._bodySet = new Set(), this._wireSet = new Set(), this._progenitorMap = new i.ProgenitorMap();};a.prototype.initMerge = function () {this._shellSet.clear(), this._lumpSet.clear(), this._bodySet.clear(), this._wireSet.clear();}, a.prototype.getEdgeOwnerToMerge = function (e) {var t = e.getWire();if (t) this._wireSet.add(t);else {var r = function (e) {var t = e.getCoedge();if (t) {var r = t.getFace();if (r) return r.getShell();}}(e);r && this._shellSet.add(r);}}, a.prototype.getVertexOwnerToMerge = function (e) {var t = e.getEdges();t.length > 0 && this.getEdgeOwnerToMerge(t[0]);}, a.prototype.stitchVertices = function (e, t) {var r;this.initMerge();var n = void 0;for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {n = e[r];break;}}s.ConsoleUtils.assert(n);var o = [];for (r = 0; r < e.length; ++r) {if (this.getVertexOwnerToMerge(e[r]), e[r] !== n) {for (var i = e[r], a = i.getEdges().slice(0), c = 0; c < a.length; ++c) {var u = a[c];u.getStartVertex() === i && u.setStartVertex(n), u.getEndVertex() === i && u.setEndVertex(n);}s.ConsoleUtils.assert(0 === i.getEdges().length), t && t.has(i) || o.push(i);}}o.length > 0 && this._progenitorMap.addEntry(n, o), this.mergeTopology();}, a.prototype.stitchEdges = function (e, t) {var r,o = e[0];for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {o = e[r];break;}}var i = [],s = [];for (r = 0; r < e.length; ++r) {var a = e[r],c = !1;if (a.getStartVertex() !== o.getStartVertex() && a.getStartVertex() === o.getEndVertex()) {var u = a.evaluateDt(a.t0()),l = o.evaluateDt(o.t1());n.Vector3.dot(u, l) < 0 && (c = !0);}for (var h = a.getCoedge(); h;) {i.push(h), c && h.setReversed(!h.isReversed()), (h = h.getPartner()) === a.getCoedge() && (h = void 0);}a !== o && (a.setStartVertex(null), a.setEndVertex(null), s.push(a));}for (this.initMerge(), r = 0; r < i.length; ++r) {var d = i[r];this.getEdgeOwnerToMerge(d.getEdge()), d.setEdge(o);var g = (r + 1) % i.length;d.setPartner(i[g]);}this.mergeTopology(), this._progenitorMap.addEntry(o, s);}, a.prototype.mergeTopology = function () {if (this._shellSet.size > 1 && this.mergeShells(), this._wireSet.size > 1) throw new Error("Merging wires in TopologyStitcher is not yet supported.");}, a.prototype.mergeShells = function () {var e = new i.ProgenitorMap();if (this._shellSet.size > 1) {var t = Array.from(this._shellSet),r = t[0],n = r.getLump();n && this._lumpSet.add(n);for (var o = 1; o < t.length; ++o) {var s = t[o];r.addFaces(s.getFaces()), s.setFaces([]), (n = s.getLump()) && (n.removeShell(s), this._lumpSet.add(n));}e.addEntry(r, t.slice(1));}if (this._lumpSet.size > 1) {var a = Array.from(this._lumpSet),c = a[0],u = c.getBody();for (u && this._bodySet.add(u), o = 1; o < a.length; ++o) {var l = a[o];c.addShells(l.getShells()), l.setShells([]), (u = l.getBody()) && (u.removeLump(l), this._bodySet.add(u));}e.addEntry(c, a.slice(1));}if (this._bodySet.size > 1) {var h = Array.from(this._bodySet),d = h[0];for (o = 1; o < h.length; ++o) {for (var g = h[o], p = g.getLumps().slice(0), f = 0; f < p.length; ++f) {p[f].getShells().length > 0 && d.addLump(p[f]);}g.setLumps([]);}e.addEntry(d, h.slice(1));}e.size() > 0 && (this._progenitorMap = e.collapseMaps(this._progenitorMap, { keepIntermediates: !0, keepAllDescendants: !0 }));}, a.prototype.getProgenitorMap = function () {return this._progenitorMap;}, a.prototype.stitchTwoEdgeSets = function (e, t) {var r = new o.MatchFinder();r.setEdges(e, t), r.compute();for (var n = r.getVertexMatches(), i = r.getEdgeMatches(), s = r.getNewVertices(), a = new Set(r.getEdgeProgenitors().getAllNewTopology()), c = 0; c < n.length; ++c) {this.stitchVertices(n[c], s);}for (c = 0; c < i.length; ++c) {this.stitchEdges(i[c], a);}this._progenitorMap = this._progenitorMap.collapseMaps(r.getEdgeProgenitors(), { keepIntermediates: !1, keepAllDescendants: !0 });}, a.prototype.stitchTwoTopology = function (e, t) {s.ConsoleUtils.assert("function" == typeof e.collectEdges), s.ConsoleUtils.assert("function" == typeof t.collectEdges);var r = e.collectEdges(),n = t.collectEdges();this.stitchTwoEdgeSets(r, n);}, a.prototype.stitchEdgeSet = function (e) {this.stitchTwoEdgeSets(e, e);}, t.TopologyStitcher = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.MatchFinder = void 0;var n = r(1),o = r(0),i = r(120),s = r(82),a = r(41),c = r(2),u = function u() {this._edges1 = [], this._edges2 = [], this._verts1 = [], this._verts2 = [], this._vertexMatchMap = new Map(), this._edgeMatchMap = new Map(), this._sameEdgeLists = !1, this._newVertices = new Set(), this._edgeProgenitors = new a.ProgenitorMap();};u.prototype.addMergeToMap = function (e, t, r) {var n = r.get(e),o = r.get(t);if (n && !o) n.push(t), r.set(t, n);else if (!n && o) o.push(e), r.set(e, o);else if (n || o) {if (n && o && n !== o) for (var i = 0; i < o.length; ++i) {n.push(o[i]), r.set(o[i], n);}} else {var s = [e, t];r.set(e, s), r.set(t, s);}}, u.prototype.addVertexMerge = function (e, t) {this.addMergeToMap(e, t, this._vertexMatchMap);}, u.prototype.addEdgeMerge = function (e, t) {this.addMergeToMap(e, t, this._edgeMatchMap);}, u.prototype.verticesMatch = function (e, t) {var r = Math.max(e.getPrecision(), t.getPrecision(), o.KERNEL_TOLERANCE);return n.Vector3.squaredDistance(e.getPosition(), t.getPosition()) < r * r;}, u.prototype.findEdgeSplitParam = function (e, t) {var r = e.getStartVertex();if (r !== t) {var i = e.getEndVertex();if (i !== t) {var s = this._vertexMatchMap.get(r);if (!s || -1 === s.indexOf(t)) {var a = this._vertexMatchMap.get(i);if (!a || -1 === a.indexOf(t)) {var c = t.getPosition(),u = Math.max(t.getPrecision(), o.KERNEL_TOLERANCE),l = e.closestToPointParam(c);if (void 0 !== l) {var h = e.evaluatePosition(l);if (!(n.Vector3.squaredDistance(c, h) > u * u)) return { param: l, position: h };}}}}}}, u.prototype.matchVertices = function () {for (var e = new Set(), t = 0; t < this._edges1.length; ++t) {this._edges1[t].collectVertices(e);}this._verts1 = Array.from(e);var r = new Set();for (t = 0; t < this._edges2.length; ++t) {this._edges2[t].collectVertices(r);}this._verts2 = Array.from(r);var n = this;e.forEach(function (e) {r.forEach(function (t) {e !== t && n.verticesMatch(e, t) && n.addVertexMerge(e, t);});});}, u.prototype.findVertexOnEdgeSplits = function (e, t) {for (var r = t.length, n = 0; n < r; ++n) {for (var o = t[n], i = [], s = 0; s < e.length; ++s) {var a = e[s],c = this.findEdgeSplitParam(o, a);c && i.push({ vertex: a, param: c.param, position: c.position });}if (i.length > 0) {var u = this.splitEdgeAtParams(o, i);if (u.length > 0) {t[n] = u[0];for (var l = 1; l < u.length; ++l) {t.push(u[l]);}}}}}, u.prototype.doEdgeSplits = function () {this.findVertexOnEdgeSplits(this._verts1, this._edges2), this._sameEdgeLists || this.findVertexOnEdgeSplits(this._verts2, this._edges1);}, u.prototype.splitEdgeAtParams = function (e, t) {t.sort(function (e, t) {return e.param - t.param;});for (var r = [], s = e, a = 0; a < t.length; ++a) {var c = t[a].vertex,u = t[a].param,l = t[a].position,h = s.getStartVertex().getPosition();if (n.Vector3.squaredDistance(l, h) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) this.addVertexMerge(c, s.getStartVertex());else {0 === r.length && (s = (0, i.replaceEdge)(s), r.push(s), this._edgeProgenitors.addEntry(s, [e]));var d = (0, i.splitEdge)(s, u, l);r.push(d), this._edgeProgenitors.addEntry(d, [e]);var g = d.getStartVertex();this.addVertexMerge(c, g), this._newVertices.add(g), s = d;}}return r;}, u.prototype.edgesMatch = function (e, t) {return (0, s.edgesAreCoincident)(e, t);}, u.prototype.matchEdges = function () {for (var e = 0; e < this._edges1.length; ++e) {for (var t = this._edges1[e], r = t.getStartVertex(), n = t.getEndVertex(), o = 0; o < this._edges2.length; ++o) {var i = this._edges2[o],s = i.getStartVertex(),a = i.getEndVertex();if (!(this._sameEdgeLists && o <= e) && t !== i) {var c,u = r === s || r === a;if (!u) {var l = this._vertexMatchMap.get(r);l && (u = l === this._vertexMatchMap.get(s) || l === this._vertexMatchMap.get(a));}if (u && !(c = n === s || n === a)) {var h = this._vertexMatchMap.get(n);h && (c = h === this._vertexMatchMap.get(s) || h === this._vertexMatchMap.get(a));}u && c && this.edgesMatch(t, i) && this.addEdgeMerge(t, i);}}}}, u.prototype.setEdges = function (e, t) {e instanceof Set ? this._edges1 = Array.from(e) : e instanceof Array && (this._edges1 = e), t && t !== e ? t instanceof Set ? this._edges2 = Array.from(t) : t instanceof Array && (this._edges2 = t) : this._edges2 = this._edges1, this._sameEdgeLists = this._edges1 === this._edges2, c.ConsoleUtils.assert(this._edges1 && this._edges2);}, u.prototype.compute = function () {this.matchVertices(), this.doEdgeSplits(), this.matchEdges();}, u.prototype.getVertexMatches = function () {var e = new Set();return this._vertexMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getEdgeMatches = function () {var e = new Set();return this._edgeMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getNewVertices = function () {return this._newVertices;}, u.prototype.getEdgeProgenitors = function () {return this._edgeProgenitors;}, t.MatchFinder = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceEdge = t.splitEdge = void 0;var n = r(16),o = r(20),i = r(27),s = r(6),a = function a(e, t) {var r = new i.Coedge();r.setEdge(t), e.getEdge().getCoedge() === e && t.setCoedge(r), r.setReversed(e.isReversed()), r.setLoop(e.getLoop());var n = e.getLoop().getCoedges(),o = n.indexOf(e);return r.isReversed() ? n.splice(o, 0, r) : n.splice((o + 1) % n.length, 0, r), r;};t.splitEdge = function (e, t, r) {var i = new n.Vertex(new s.Point(r)),c = [e.getRange()[0], e.getRange()[1]],u = e.getEndVertex();e.setRange([c[0], t]), e.setEndVertex(i);var l = new o.Edge();l.setCurve(e.getCurve()), l.setReversed(e.isReversed()), l.setRange([t, c[1]]), l.setStartVertex(i), l.setEndVertex(u), l.setPrecision(e.getPrecision()), l.setWire(e.getWire());for (var h = [], d = e.getCoedge(); d;) {h.push(a(d, l)), (d = d.getPartner()) === e.getCoedge() && (d = void 0);}for (var g = 0; g < h.length; ++g) {var p = (g + 1) % h.length;h[g].setPartner(h[p]);}if (l.getWire()) {var f = l.getWire().getEdges().slice(),v = f.indexOf(e);f.splice(v + 1, 0, l), l.getWire().setEdges(f);}return l;}, t.replaceEdge = function (e) {var t = new o.Edge();t.setCurve(e.getCurve()), t.setReversed(e.isReversed()), t.setRange([e.getRange()[0], e.getRange()[1]]), t.setStartVertex(e.getStartVertex()), t.setEndVertex(e.getEndVertex()), t.setPrecision(e.getPrecision()), t.setCoedge(e.getCoedge()), t.setWire(e.getWire()), e.setStartVertex(null), e.setEndVertex(null), e.setCoedge(void 0), e.setWire(void 0);for (var r = t.getCoedge(); r;) {r.setEdge(t), (r = r.getPartner()) === t.getCoedge() && (r = void 0);}if (t.getWire()) {var n = t.getWire().getEdges().slice();n[n.indexOf(e)] = t, t.getWire().setEdges(n);}return t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.svgFromWire = void 0;var n = r(0),o = r(2);t.svgFromWire = function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.WIREBODY && console.warn("svgFromWire: Pass a wire, not a wire body."), o.ConsoleUtils.assert(e.getTopologyType() === n.TOPOLOGY_TYPES.WIRE, "Input topology is not a Wire");var t = e.getOrderedEdges();if (0 === t.edges.length) return "";for (var r = t.start, i = r.getPosition(), s = "M " + i[0] + " " + i[1], a = 0; a < t.edges.length; ++a) {var c = t.edges[a];i = (r = r === c.getStartVertex() ? c.getEndVertex() : c.getStartVertex()).getPosition();var u = c.getCurve();if (u) if (u.getGeometryType() === n.GEOMETRY_TYPES.LINE) s += " L " + i[0] + " " + i[1];else if (u.getGeometryType() !== n.GEOMETRY_TYPES.BCURVE || 3 !== u.getDegree() || u.isRational()) console.warn("Unhandled curve type in svgFromWire");else {for (var l = [], h = u.getBezierSegments(), d = 0; d < h.length; d++) {var g = h[d];if (g) for (var p = g.getControlPoints(), f = 0; f < p.length; f += 3) {l.push([p[f], p[f + 1]]);}}r === c.getStartVertex() !== c.isReversed() && l.reverse(), o.ConsoleUtils.assert(l.length === 4 * h.length, "Unexpected number of control points");for (var v = 0; v < h.length; ++v) {s += " C " + l[4 * v + 1][0] + " " + l[4 * v + 1][1] + " " + l[4 * v + 2][0] + " " + l[4 * v + 2][1] + " ", v === h.length - 1 ? s += i[0] + " " + i[1] : s += l[4 * v + 3][0] + " " + l[4 * v + 3][1];}}}return s;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Path2D = void 0;var n = r(1),o = r(0),i = r(54),s = r(40),a = r(33),c = r(14),u = r(23),l = r(7),h = r(28),d = r(84),g = r(2),p = r(8),f = { assert: function assert(e, t) {if (!e) throw { message: t || "assertion failed" };}, assert_arg: function assert_arg(e, t, r, n) {var o = "Invalid argument '" + t + "': " + r + "\nUsage: " + n;this.assert(e, o);}, assert_number: function assert_number(e, t, r) {this.assert_arg("number" == typeof e, t, "should be a number", r);}, assert_boolean: function assert_boolean(e, t, r) {this.assert_arg("boolean" == typeof e, t, "should be a boolean", r);}, assert_string: function assert_string(e, t, r) {this.assert_arg("string" == typeof e, t, "should be a string", r);} },v = function v() {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0], this._mergeBCurves = !0, this._healPath = !1, this._tangentTol = o.KERNEL_ANGULAR_TOLERANCE;};function _(e, t, r) {var o = 3 * (t - 1),i = [e[o], e[o + 1], e[o + 2]],s = 3 * r,a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, -.1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], a, c, u);e[s - 3 * u] = l[0], e[s - 3 * u + 1] = l[1], e[s - 3 * u + 2] = l[2];}}function y(e, t, r) {var o = 3 * t,i = [e[o], e[o + 1], e[o + 2]],s = 3 * (r + 1),a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, .1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], i, c, u);e[o + 3 * u] = l[0], e[o + 3 * u + 1] = l[1], e[o + 3 * u + 2] = l[2];}}function m(e, t) {for (var r, o, i, s = [], a = e.getControlPoints(), c = [a[0], a[1], a[2]], u = a.length / 3, l = 1; l < u; ++l) {r = [a[3 * l], a[3 * l + 1], a[3 * l + 2]];var h = l === u - 1;n.Vector3.squaredDistance(c, r) < t ? (void 0 === o && (o = l - 1), i = l) : h = !0, h && void 0 !== o && void 0 !== i && (s.push([o, i]), h = !1, o = void 0, i = void 0), c = r;}return s;}function E(e, t) {var r = m(e, t);if (1 === r.length && r[0][1] - r[0][0] == 1) {var n = r[0];0 === n[0] ? e.addControlPointOnCurve(e.evaluatePosition(.1)) : n[1] === e.getNumControlPoints() - 1 ? e.addControlPointOnCurve(e.evaluatePosition(.9)) : (e.addControlPointOnCurve(e.evaluatePosition(.45)), e.addControlPointOnCurve(e.evaluatePosition(.55)));}return r.length > 0;}function x(e, t) {for (var r = m(e, t), n = 0; n < r.length; ++n) {var o = r[n],i = e.getControlPoints().slice();o[0] > 0 ? _(i, o[0], o[1]) : o[1] < i.length / 3 - 1 ? y(i, o[0], o[1]) : p.DebugUtils.warn("Degenerate BCurve!"), e.setControlPoints(i);}}function R(e, t) {var r = e.getControlPoints(),o = [r[0], r[1], r[2]],i = [r[3], r[4], r[5]],s = n.Vector3.distance(o, i);r[3] = o[0] + t[0] * s, r[4] = o[1] + t[1] * s, r[5] = o[2] + t[2] * s, e.setControlPoints(r);}function A(e, t) {var r = e.getControlPoints(),o = e.getControlPoints().length,i = [r[o - 6], r[o - 5], r[o - 4]],s = [r[o - 3], r[o - 2], r[o - 1]],a = n.Vector3.distance(i, s);r[o - 6] = s[0] - t[0] * a, r[o - 5] = s[1] - t[1] * a, r[o - 4] = s[2] - t[2] * a, e.setControlPoints(r);}function P(e) {var t = new a.BCurve(),r = e.getRange(),o = e.evaluatePosition(r[0]),i = e.evaluatePosition(r[1]),s = n.Vector3.lerp([0, 0, 0], o, i, 1 / 3),c = n.Vector3.lerp([0, 0, 0], o, i, 2 / 3),u = [o[0], o[1], 0, s[0], s[1], 0, c[0], c[1], 0, i[0], i[1], 0];return t.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), t;}function V(e, t) {for (var r, o = e.getRange(), i = e.evaluatePosition(o[0]), s = e.evaluatePosition(o[1]), a = n.Vector3.distance(i, s), c = 0, u = t.getControlPoints(), l = [u[0], u[1], u[2]], h = u.length / 3, d = 1; d < h; ++d) {r = [u[3 * d], u[3 * d + 1], u[3 * d + 2]], c += n.Vector3.distance(l, r), l = r;}return a < c;}function T(e, t) {var r = e.getControlPoints().concat(t.getControlPoints().slice(3)),o = e.getWeights().concat(t.getWeights().slice(1)),i = e.getKnotVector().slice(0, -1),s = e.evaluateDt(e.getRange()[1]),a = t.evaluateDt(t.getRange()[0]),c = Math.sqrt(n.Vector3.squaredLength(a) / n.Vector3.squaredLength(s)),u = i[i.length - 1] - t.getKnotVector()[0] * c,l = t.getKnotVector().slice(t.getDegree() + 1);return l = l.map(function (e) {return e * c + u;}), i = i.concat(l), e.set(r, o, 3, i), e;}function C(e, t, r, i, s) {var a = n.Vector2.subtract([], s, e),u = n.Vector2.length(a);if (!(u < o.KERNEL_TOLERANCE)) {u > 2 * t && (t = u / 2);var l = n.Vector2.scaleAndAdd([], e, a, .5);if (u < 2 * t - n.FLOAT64_TOLERANCE) {var h = Math.sqrt(t * t - u * u / 4);!0 === i != (!1 === r) && (h = -h);var d = n.Vector2.normalize([], [-a[1], a[0]]);n.Vector2.scaleAndAdd(l, l, d, h);}var g = [0, 0, i ? 1 : -1],p = new c.Circle();p.set([l[0], l[1], 0], g, [t, 0, 0]);var f = p.closestToPointParam([e[0], e[1], 0]),v = p.closestToPointParam([s[0], s[1], 0]);return v <= f && (v += 2 * Math.PI), p.limitRange([f, v]), p;}}function b(e, t) {var r = e.slice(1);r = r.replace(/([^e])-/g, "$1 -");for (var n = 0; n < 2; ++n) {r = r.replace(/\.[0-9]*\./g, function (e) {return e.slice(0, -1) + " .";});}for (var o = r.split(/[,\s]/), i = [], s = 0; s < o.length; ++s) {if (o[s].length > 0) {var a = Number(o[s]);t(!isNaN(a), "could not parse command"), i.push(a);}}return i;}v.prototype.numWires = function () {var e = this._wireBody.getWires().length;return this._curves.length > 0 && (e += 1), e;}, v.prototype.numClosed = function () {for (var e = 0, t = 0; t < this._wireBody.getWires().length; ++t) {this._wireBody.getWires()[t].isClosed() && (e += 1);}return this._areCurvesClosed() && (e += 1), e;}, v.prototype._fixCoincidentControlPoints = function () {for (var e = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, t = 0; t < this._curves.length; ++t) {var r = this._curves[t];r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && 3 === r.getDegree() && 4 === r.getNumControlPoints() && !1 === r.isRational() && E(r, e) && x(r, e);}}, v.prototype._snapBCurvesTangent = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE ? (n.Vector3.normalize(s, s), R(i, s)) : r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && (n.Vector3.normalize(a, a), A(r, a)));}}, v.prototype._areCurvesClosed = function () {if (0 === this._curves.length) return !1;var e = this._curves[this._curves.length - 1],t = this._curves[0];return n.Vector3.squaredDistance(e.evaluatePosition(e.getRange()[1]), t.evaluatePosition(t.getRange()[0])) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE;}, v.prototype._mergeShortLinesWithBCurves = function () {for (var e = !1, t = 0; t < this._curves.length; ++t) {var r = (t + 1) % this._curves.length;if (0 === r && !this._areCurvesClosed()) break;var i = this._curves[t],s = this._curves[r],a = i.evaluateDt(i.getRange()[1]),c = s.evaluateDt(s.getRange()[0]);n.Vector3.isParallel(a, c, 1, o.KERNEL_ANGULAR_TOLERANCE) && (i.getGeometryType() === o.GEOMETRY_TYPES.LINE && s.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && V(i, s) ? (this._curves.splice(t, 1, T(P(i), s)), this._curves.splice(r, 1), t -= 1, e = !0) : i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && s.getGeometryType() === o.GEOMETRY_TYPES.LINE && V(s, i) && (this._curves.splice(t, 1, T(i, P(s))), this._curves.splice(r, 1), t -= 1, e = !0));}return e;}, v.prototype._mergeAdjacentBCurves = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && (n.Vector3.squaredLength(s) < n.Vector3.squaredLength(a) ? (n.Vector3.normalize(s, s), R(i, s)) : (n.Vector3.normalize(a, a), A(r, a)), r !== i && (T(r, i), this._curves.splice(t, 1), e -= 1));}}, v.prototype.setMergeBCurves = function (e) {this._mergeBCurves = e;}, v.prototype.setHealForASM = function (e, t) {this._healPath = e, this._tangentTol = void 0 !== t ? t : .01745240643728351;}, v.prototype._addWire = function () {if (0 !== this._curves.length) {this._healPath && (this._fixCoincidentControlPoints(), this._snapBCurvesTangent()), (this._mergeBCurves || this._healPath) && this._mergeAdjacentBCurves(), this._healPath && this._mergeShortLinesWithBCurves() && this._mergeAdjacentBCurves();var e = (0, h.createWiresFromEdges)((0, h.createEdgesFromCurves)(this._curves));g.ConsoleUtils.assert(1 === e.length), this._wireBody.addWire(e[0]), this._curves = [];}}, v.prototype._discardIfOpen = function () {if (0 !== this._curves.length) {var e = this._curves[0].evaluatePosition(this._curves[0].getRange()[0]),t = [this._xy[0], this._xy[1], 0];n.Vector3.squaredDistance(e, t) >= o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (this._curves = []);}}, v.prototype.moveTo = function (e, t) {var r = "Path2D.moveTo(x, y)";return f.assert_number(e, "x", r), f.assert_number(t, "y", r), this._addWire(), this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.lineTo = function (e, t) {var r = "Path2D.lineTo(x, y)";f.assert_number(e, "x", r), f.assert_number(t, "y", r);var n = e - this._xy[0],i = t - this._xy[1];if (n * n + i * i > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) {var s = new l.Line();s.set([this._xy[0], this._xy[1], 0], [n, i, 0]), s.limitRange([0, 1]), this._curves.push(s);}return this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.quadraticCurveTo = function (e, t, r, n) {var o = "Path2D.quadraticCurveTo(cpx, cpy, x, y)";f.assert_number(e, "cpx", o), f.assert_number(t, "cpy", o), f.assert_number(r, "x", o), f.assert_number(n, "y", o);var i = new a.BCurve(),s = 1 / 3 * this._xy[0] + 2 / 3 * e,c = 1 / 3 * this._xy[1] + 2 / 3 * t,u = 1 / 3 * r + 2 / 3 * e,l = 1 / 3 * n + 2 / 3 * t,h = [this._xy[0], this._xy[1], 0, s, c, 0, u, l, 0, r, n, 0];return i.set(h, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(i), this._xy[0] = r, this._xy[1] = n, this;}, v.prototype.bezierCurveTo = function (e, t, r, n, o, i) {var s = "Path2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)";f.assert_number(e, "cp1x", s), f.assert_number(t, "cp1y", s), f.assert_number(r, "cp2x", s), f.assert_number(n, "cp2y", s), f.assert_number(o, "x", s), f.assert_number(i, "y", s);var c = new a.BCurve(),u = [this._xy[0], this._xy[1], 0, e, t, 0, r, n, 0, o, i, 0];return c.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(c), this._xy[0] = o, this._xy[1] = i, this;}, v.prototype.circleArcTo = function (e, t, r, n, o) {var i = "Path2D.circleArcTo(radius, longest, anticlockwise, x, y)";f.assert_number(e, "radius", i), f.assert_arg(e > 0, "radius", "must be positive", i), f.assert_boolean(t, "longest", i), f.assert_boolean(r, "anticlockwise", i), f.assert_number(n, "x", i), f.assert_number(o, "y", i);var s = C(this._xy, e, t, r, [n, o]);return s && (this._curves.push(s), this._xy[0] = n, this._xy[1] = o), this;}, v.prototype.ellipseArcTo = function (e, t, r, o, i, s, a) {var c = "Path2D.ellipseArcTo(xRadius, yRadius, rotation, longest, anticlockwise, x, y)";if (f.assert_number(e, "xRadius", c), f.assert_arg(e > 0, "xRadius", "must be positive", c), f.assert_number(t, "yRadius", c), f.assert_arg(t > 0, "yRadius", "must be positive", c), f.assert_number(r, "rotation", c), f.assert_boolean(o, "longest", c), f.assert_boolean(i, "anticlockwise", c), f.assert_number(s, "x", c), f.assert_number(a, "y", c), e < t) {var l = e;e = t, t = l, r += Math.PI / 2;}var h = Math.cos(r),d = Math.sin(r),g = e / t,p = n.Matrix22.multiply([], [1, 0, 0, g], [h, -d, d, h]),v = C(n.Vector2.transformMatrix22([], this._xy, p), e, o, i, n.Vector2.transformMatrix22([], [s, a], p));if (v) {var _ = [v.getCenter()[0], v.getCenter()[1]];n.Matrix22.invert(p, p), n.Vector2.transformMatrix22(_, _, p), _[2] = 0;var y = v.getRadius(),m = [y * h, y * d, 0],E = new u.Ellipse();E.set(_, v.getNormal(), m, 1 / g), E.limitRange(v.getRange()), this._curves.push(E), this._xy[0] = s, this._xy[1] = a;}return this;}, v.prototype.closePath = function () {if (this._curves.length > 0) {var e = this._curves[0],t = e.evaluatePosition(e.getRange()[0]);this.lineTo(t[0], t[1]), this._addWire();}return this;}, v.prototype.addCircle = function (e, t, r) {var n = "Path2D.addCircle(x, y, radius)";f.assert_number(e, "x", n), f.assert_number(t, "y", n), f.assert_number(r, "radius", n), f.assert_arg(r > 0, "radius", "must be positive", n), this._addWire();var o = new c.Circle();return o.set([e, t, 0], [0, 0, 1], [r, 0, 0]), this._curves.push(o), this._addWire(), this;}, v.prototype.addEllipse = function (e, t, r, n, o) {o = void 0 === o ? 0 : o;var i = "Path2D.addEllipse(x, y, xRadius, yRadius, rotation)";if (f.assert_number(e, "x", i), f.assert_number(t, "y", i), f.assert_number(r, "xRadius", i), f.assert_arg(r > 0, "xRadius", "must be positive", i), f.assert_number(n, "yRadius", i), f.assert_arg(n > 0, "yRadius", "must be positive", i), f.assert_number(o, "rotation", i), this._addWire(), r < n) {var s = r;r = n, n = s, o += Math.PI / 2;}var a = new u.Ellipse(),c = Math.cos(o),l = Math.sin(o),h = n / r;return a.set([e, t, 0], [0, 0, 1], [r * c, r * l, 0], h), this._curves.push(a), this._addWire(), this;}, v.prototype.addSVGPath = function (e, t) {t = void 0 !== t && t;var r = "Path2D.addSVGPath(pathString, [includeOpen])";f.assert_string(e, "pathString", r), f.assert_boolean(t, "includeOpen", r), this._addWire(), this._xy[0] = 0, this._xy[1] = 0;var n = function (e) {for (var t = []; e.length > 0;) {var r = e.slice(1).search(/[MmZzLlHhVvCcSsQqTtAa]/) + 1;r <= 0 && (r = e.length);var n = e.slice(0, r).trim();n.length > 0 && t.push(n), e = e.slice(r).trim();}return t;}(e);f.assert_arg(n.length > 0, "pathString", "cannot be empty string", r);for (var i = [this._xy[0], this._xy[1]], s = [this._xy[0], this._xy[1]], a = 0; a < n.length; ++a) {var c,u,l,h,d,g,p,v = function v(e, t) {f.assert_arg(e, "pathString", t + ' "' + n[a] + '"', r);},_ = n[a].charAt(0).toUpperCase(),y = _ !== n[a].charAt(0),m = b(n[a], v),E = y ? this._xy : [0, 0];switch (_) {case "M":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), t || this._discardIfOpen(), this.moveTo(m[0] + E[0], m[1] + E[1]), p = 2; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "Z":v(0 === m.length, "command should not have arguments"), this.closePath();break;case "L":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), p = 0; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "H":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(m[p] + E[0], this._xy[1]);}break;case "V":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(this._xy[0], m[p] + E[1]);}break;case "C":for (v(m.length >= 6, "insufficient arguments in command"), v(m.length % 6 == 0, "command requires sets of 6 arguments"), p = 0; p < m.length; p += 6) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], d = m[p + 4] + E[0], g = m[p + 5] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "S":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = 2 * this._xy[0] - s[0], u = 2 * this._xy[1] - s[1], l = m[p] + E[0], h = m[p + 1] + E[1], d = m[p + 2] + E[0], g = m[p + 3] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "Q":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "T":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of arguments"), p = 0; p < m.length; p += 2) {c = 2 * this._xy[0] - i[0], u = 2 * this._xy[1] - i[1], l = m[p] + E[0], h = m[p + 1] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "A":for (v(m.length >= 7, "insufficient arguments in command"), v(m.length % 7 == 0, "command requires sets of 7 arguments"), p = 0; p < m.length; p += 7) {var x = Math.abs(m[p]),R = Math.abs(m[p + 1]),A = m[p + 2] * Math.PI / 180,P = 0 !== m[p + 3],V = 0 !== m[p + 4],T = m[p + 5] + E[0],C = m[p + 6] + E[1];x < o.KERNEL_TOLERANCE || R < o.KERNEL_TOLERANCE ? this.lineTo(T, C) : this.ellipseArcTo(x, R, A, P, V, T, C);}break;default:v(!1, "unrecognised command");}"Q" !== _ && "T" !== _ && (i = [this._xy[0], this._xy[1]]), "C" !== _ && "S" !== _ && (s = [this._xy[0], this._xy[1]]);}return t || this._discardIfOpen(), this._addWire(), this;}, v.prototype.getWireBody = function () {return this._addWire(), this._wireBody;}, v.prototype.computeRegionizedWireBody = function () {this.getWireBody();for (var e = new i.WireBody(), t = (0, d.mergeSketchRegions)(this._wireBody.getWires()), r = 0; r < t.length; ++r) {for (var n = t[r].getLoops(), o = 0; o < n.length; ++o) {var a = n[o],c = new s.Wire();c.addEdges(Array.from(a.collectEdges())), e.addWire(c);}}return e;}, v.prototype.reset = function () {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0];}, t.Path2D = v;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SolidDefLoader = t.getTopologyRank = void 0;var n = r(6),o = r(7),i = r(14),s = r(23),a = r(33),c = r(18),u = r(38),l = r(39),h = r(74),d = r(51),g = r(52),p = r(75),f = r(53),v = r(24),_ = r(25),y = r(26),m = r(15),E = r(13),x = r(27),R = r(20),A = r(16),P = r(54),V = r(40),T = r(79),C = r(0),b = r(85),L = r(124),O = r(125),S = r(45),M = function () {var e = {};return e[C.TOPOLOGY_TYPES.BODY] = 10, e[C.TOPOLOGY_TYPES.WIREBODY] = 9, e[C.TOPOLOGY_TYPES.LUMP] = 8, e[C.TOPOLOGY_TYPES.SHELL] = 7, e[C.TOPOLOGY_TYPES.FACE] = 6, e[C.TOPOLOGY_TYPES.WIRE] = 5, e[C.TOPOLOGY_TYPES.LOOP] = 4, e[C.TOPOLOGY_TYPES.COEDGE] = 3, e[C.TOPOLOGY_TYPES.EDGE] = 2, e[C.TOPOLOGY_TYPES.VERTEX] = 1, function (t) {var r = void 0;return "function" == typeof t.getTopologyType && (r = e[t.getTopologyType()]), r || 0;};}(),w = function w() {this._runTimeMap = new Map(), this._typeidToFuncMap = {}, this.addLoader("body", L.TopologySetters.setBodyData, v.Body), this.addLoader("wirebody", L.TopologySetters.setWireBodyData, P.WireBody), this.addLoader("wire", L.TopologySetters.setWireData, V.Wire), this.addLoader("lump", L.TopologySetters.setLumpData, _.Lump), this.addLoader("shell", L.TopologySetters.setShellData, y.Shell), this.addLoader("face", L.TopologySetters.setFaceData, m.Face), this.addLoader("loop", L.TopologySetters.setLoopData, E.Loop), this.addLoader("coedge", L.TopologySetters.setCoedgeData, x.Coedge), this.addLoader("edge", L.TopologySetters.setEdgeData, R.Edge), this.addLoader("vertex", L.TopologySetters.setVertexData, A.Vertex), this.addLoader("point", b.GeometrySetters.setPointFromProperty, n.Point), this.addLoader("line", b.GeometrySetters.setLineFromProperty, o.Line), this.addLoader("circle", b.GeometrySetters.setCircleFromProperty, i.Circle), this.addLoader("ellipse", b.GeometrySetters.setEllipseFromProperty, s.Ellipse), this.addLoader("bcurve", b.GeometrySetters.setBCurveFromProperty, a.BCurve), this.addLoader("plane", b.GeometrySetters.setPlaneFromProperty, c.Plane), this.addLoader("sphere", b.GeometrySetters.setSphereFromProperty, h.Sphere), this.addLoader("torus", b.GeometrySetters.setTorusFromProperty, p.Torus), this.addLoader("cylinder", b.GeometrySetters.setCylinderFromProperty, u.Cylinder), this.addLoader("cone", b.GeometrySetters.setConeFromProperty, d.Cone), this.addLoader("ellipticalcylinder", b.GeometrySetters.setEllipticalCylinderFromProperty, l.EllipticalCylinder), this.addLoader("ellipticalcone", b.GeometrySetters.setEllipticalConeFromProperty, g.EllipticalCone), this.addLoader("bsurface", b.GeometrySetters.setBSurfaceFromProperty, f.BSurface), this.addLoader("nmiattributestr", O.AttributeSetters.setNMIAttributeStr, T.Attribute), this.addLoader("nmiattributearr", O.AttributeSetters.setNMIAttributeArr, T.Attribute), this.addLoader("textattribute", O.AttributeSetters.setTextAttribute, T.Attribute);};w.prototype.addLoader = function (e, t, r) {this._typeidToFuncMap[e] = [t, r];}, w.prototype._reset = function () {this._runTimeMap.clear();}, w.prototype.getDataSettingFunction = function (e) {var t = this._typeidToFuncMap[e];if (t) return t[0];}, w.prototype.createRunTimeObject = function (e) {var t = this.getTypeContructor(e);if (t) return new t();}, w.prototype.getTypeContructor = function (e) {var t = this._typeidToFuncMap[e];if (t && 2 === t.length) return t[1];}, w.prototype.setObjectProperties = function (e, t, r) {var n = this.getDataSettingFunction(e, r);var o = this;"function" == typeof n && n(t, r, function (e) {if (!e) return;var t = e;return t ? o._runTimeMap.get(t) : void 0;});}, w.prototype.makeGeometryObjectsProto = function (e) {var _this2 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.geometry],o = _this2.createRunTimeObject(r.geometry);o && (_this2._runTimeMap.set(t, o), _this2.setObjectProperties(r.geometry, o, n), o.setGuid(t));});}, w.prototype.makeGeometryObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r ? this.setObjectProperties(t, r, e) : console.error("No constructor"), r;}, w.prototype.makeTopologyObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r || console.error("No constructor"), r;}, w.prototype.makeAttributeObjectsProto = function (e) {var _this3 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.attribute],o = new T.Attribute();_this3._runTimeMap.set(t, o), _this3.setObjectProperties(r.attribute, o, n), o.setGuid(t);});}, w.prototype.makeTopologyObjectsProto = function (e) {var _this4 = this;var t = [];Object.keys(e).forEach(function (r) {var n = e[r],o = n[n.topology],i = _this4.createRunTimeObject(n.topology);i && (_this4._runTimeMap.set(r, i), t.push({ type: n.topology, obj: i, prop: o }), i.setGuid(r));});for (var r = 0; r < t.length; ++r) {this.setObjectProperties(t[r].type, t[r].obj, t[r].prop);}}, w.prototype._collectGeometries = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getGeometryType && e.set(t.getGuid(), t);});}, w.prototype._collectTopologies = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getTopologyType && e.set(t.getGuid(), t);});}, w.prototype.loadModelPSet = function (e, t, r) {var n = e.get("geometries");if (n) {var o = e.get("attributes"),i = e.get("topologies");if (i) return this.makeGeometryObjects(n), o && this.makeAttributeObjects(o), this.makeTopologyObjects(i), this.getHighestObject(t, r);}}, w.prototype.getHighestObject = function (e, t) {var r = void 0,n = 0;return this._runTimeMap.forEach(function (e) {if (10 !== n) {var t = M(e);t > n && t > 0 && (n = t, r = e);}}), e && this._collectGeometries(e), t && this._collectTopologies(t), this._reset(), r;}, w.prototype.loadModelProtoMessage = function (e, t, r) {var n = e.geometries;if (!n) return;var o = e.attributes,i = e.topologies;return i ? (this.makeGeometryObjectsProto(n), o && this.makeAttributeObjectsProto(o), this.makeTopologyObjectsProto(i), this.getHighestObject(t, r)) : void 0;}, w.prototype.loadProtoBinary = function (e, t, r) {var n = e;n instanceof ArrayBuffer && (n = new Uint8Array(n));var o = S.Autodesk.lookupType("SolidDef.model_1_0_0").decode(n);return this.loadModelProtoMessage(o, t, r);}, t.getTopologyRank = M, t.SolidDefLoader = w;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologySetters = void 0;var n = r(85);var o = {},i = function i(e, t, r) {var n = t.attributes;if (n) {e.removeAllAttributes();for (var o = 0; o < n.length; ++o) {var _t9 = r(n[o]);e.addAttribute(_t9);}}};o.setBodyData = function (e, t, r) {for (var n = t.lumps, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setBody(e);}e.setLumps(o), i(e, t, r);}, o.setLumpData = function (e, t, r) {for (var n = t.shells, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLump(e);}e.setShells(o), i(e, t, r);}, o.setShellData = function (e, t, r) {for (var n = t.faces, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setShell(e);}e.setFaces(o), i(e, t, r);}, o.setFaceData = function (e, t, r) {for (var n = t.loops, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setFace(e);}e.setLoops(o), e.setReversed(t.reversed), e.setSurface(r(t.geometry)), i(e, t, r);}, o.setLoopData = function (e, t, r) {for (var n = t.coedges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLoop(e);}e.setCoedges(o), i(e, t, r);}, o.setCoedgeData = function (e, t, r) {e.setEdge(r(t.edge)), e.setReversed(t.reversed), e.setPartner(r(t.partner)), e.getEdge() && !e.getEdge().getCoedge() && e.getEdge().setCoedge(e), i(e, t, r);}, o.setEdgeData = function (e, t, r) {e.setVertex(0, r(t.vertex0)), e.setVertex(1, r(t.vertex1));var o = (0, n.propertyToRange)(t, "range");e.sett0(o[0]), e.sett1(o[1]), e.setReversed(t.reversed), e.setPrecision(t.precision), e.setCurve(r(t.geometry)), i(e, t, r);}, o.setVertexData = function (e, t, r) {e.setPrecision(t.precision), e.setPoint(r(t.geometry)), i(e, t, r);}, o.setWireBodyData = function (e, t, r) {for (var n = t.wires, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWireBody(e);}e.setWires(o), i(e, t, r);}, o.setWireData = function (e, t, r) {for (var n = t.edges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWire(e);}e.setEdges(o), i(e, t, r);}, t.TopologySetters = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { setNMIAttributeStr: function setNMIAttributeStr(e, t) {e.typeid = "autodesk.brep:nmiattributestr-1.0.0", e.values = { primaryId: t.primaryId, secondaryId: t.secondaryId, approachId: t.approachId, operationIds: t.operationIds };}, setNMIAttributeArr: function setNMIAttributeArr(e, t) {e.typeid = "autodesk.brep:nmiattributearr-1.0.0";for (var r = t.tagInfo, n = new Array(r.length), o = 0; o < r.length; ++o) {var i = r[o];n[o] = { primaryId: i.primaryId, secondaryId: i.secondaryId, approachId: i.approachId, operationIds: i.operationIds };}e.values = { tagInfo: n };}, setTextAttribute: function setTextAttribute(e, t) {e.typeid = "autodesk.brep:textattribute-1.0.0", e.values = { text: t.text };} };t.AttributeSetters = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.saveToProtoBinary = t.saveToProtoMessage = t.SolidDefSaver = void 0;var n = r(45),o = function o() {};o.prototype.setVersion = function (e) {console.warn("SolidDefSaver.prototype.setVersion is deprecated,");};var i = function i(e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = { topologies: {}, geometries: {}, attributes: {} };return e.addToModelObject(r), t.create(r);};t.SolidDefSaver = o, t.saveToProtoMessage = i, t.saveToProtoBinary = function (e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = i(e);return t.encode(r).finish();};}]);});

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".adsk-viewing-viewer .edge-gizmo:hover {\n  background-color: lime; }\n\n.adsk-viewing-viewer .edge-gizmo {\n  position: absolute;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  cursor: move;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edge-gizmo.selected {\n  background-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover {\n  border-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 7px;\n  height: 7px;\n  left: -2px;\n  top: -2px;\n  background-color: #009bff;\n  border-style: solid;\n  border-width: 2px;\n  border-color: #FFFFFF;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  cursor: move; }\n\n.adsk-viewing-viewer .ellipse-arc-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 5px;\n  height: 5px;\n  left: -1px;\n  top: -1px;\n  background-color: #ff00ff;\n  border-style: solid;\n  border-width: 1px;\n  border-color: #000000;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 2;\n  /* Must always be in front of the EdgeMove gizmo. Otherwise it would become unreachable on low radii.*/\n  cursor: move; }\n\n.adsk-viewing-viewer .vertex-gizmo.selected {\n  border-color: lime; }\n\n.adsk-viewing-viewer .edge-move-gizmo {\n  width: 20px;\n  /* width along the edge */\n  height: 6px;\n  /* height vertical to the edge */ }\n\n.adsk-viewing-viewer .edit2d-label {\n  display: none;\n  position: absolute;\n  height: 19px;\n  left: 0px;\n  top: 0px;\n  padding: 2px 0 2px 0;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  color: #f4f4f4;\n  font-size: 12px;\n  text-align: center;\n  line-height: 1.2;\n  white-space: nowrap;\n  border-radius: 8px;\n  pointer-events: none;\n  cursor: pointer;\n  z-index: 2;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edit2d-label.visible {\n  display: block; }\n\n.adsk-viewing-viewer .edit2d-label-text {\n  display: inline-block;\n  margin: 0 5px 0 5px;\n  vertical-align: middle;\n  font-size: 16px;\n  pointer-events: none; }\n\n/* Mark area labels for invalid shapes with red background */\n.adsk-viewing-viewer .edit2d-label.error-indicator {\n  background-color: red; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?inline!./extensions/Edit2D/SegmentTreeWorker.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?inline!./extensions/Edit2D/SegmentTreeWorker.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/*!\n * LMV v7.47.0\n * \n * Copyright 2021 Autodesk, Inc.\n * All rights reserved.\n * \n * This computer source code and related instructions and comments are the\n * unpublished confidential and proprietary information of Autodesk, Inc.\n * and are protected under Federal copyright and state trade secret law.\n * They may not be disclosed to, copied or used by any third party without\n * the prior written consent of Autodesk, Inc.\n * \n * Autodesk Forge Viewer Usage Limitations:\n * \n * The Autodesk Forge viewer can only be used to view files generated by\n * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be\n * delivered from an Autodesk hosted URL.\n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/babel-loader/lib/index.js?!./extensions/Edit2D/SegmentTreeWorker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./extensions/MemoryLimited/thirdparty/three.js/three-worker.js\":\n/*!**********************************************************************!*\\\n  !*** ./extensions/MemoryLimited/thirdparty/three.js/three-worker.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) {\"@babel/helpers - typeof\";if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} // File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '71' };\n\n// browserify support\n\nif (( false ? undefined : _typeof(module)) === 'object') {\n\n  module.exports = THREE;\n\n}\n\n// polyfills\n\nif (Math.sign === undefined) {\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n  Math.sign = function (x) {\n\n    return x < 0 ? -1 : x > 0 ? 1 : +x;\n\n  };\n\n}\n\n\n// set the default log handlers\nTHREE.log = function () {console.log.apply(console, arguments);};\nTHREE.warn = function () {console.warn.apply(console, arguments);};\nTHREE.error = function () {console.error.apply(console, arguments);};\n\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\n// GL STATE CONSTANTS\n\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\n\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\n\n// SHADOWING TYPES\n\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\n\n// MATERIAL CONSTANTS\n\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n\n// shading\n\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n\n// colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n\n// blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\nTHREE.MinEquation = 103;\nTHREE.MaxEquation = 104;\n\n// custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n\n// custom blending source factors\n\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n\n\n// TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\n\n// Mapping modes\n\nTHREE.UVMapping = 300;\n\nTHREE.CubeReflectionMapping = 301;\nTHREE.CubeRefractionMapping = 302;\n\nTHREE.EquirectangularReflectionMapping = 303;\nTHREE.EquirectangularRefractionMapping = 304;\n\nTHREE.SphericalReflectionMapping = 305;\n\n// Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n\n// Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n\n// Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\nTHREE.HalfFloatType = 1025;\n\n// Pixel types\n\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n\n// Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\n\n// DDS / ST3C Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n\n\n// PVRTC compressed texture formats\n\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n\n\n// DEPRECATED\n\nTHREE.Projector = function () {\n\n  THREE.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');\n\n  this.projectVector = function (vector, camera) {\n\n    THREE.warn('THREE.Projector: .projectVector() is now vector.project().');\n    vector.project(camera);\n\n  };\n\n  this.unprojectVector = function (vector, camera) {\n\n    THREE.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\n    vector.unproject(camera);\n\n  };\n\n  this.pickingRay = function (vector, camera) {\n\n    THREE.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n\n  };\n\n};\n\nTHREE.CanvasRenderer = function () {\n\n  THREE.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');\n\n  this.domElement = document.createElement('canvas');\n  this.clear = function () {};\n  this.render = function () {};\n  this.setClearColor = function () {};\n  this.setSize = function () {};\n\n};\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Quaternion = function (x, y, z, w) {\n\n  this._x = x || 0;\n  this._y = y || 0;\n  this._z = z || 0;\n  this._w = w !== undefined ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n  constructor: THREE.Quaternion,\n\n  _x: 0, _y: 0, _z: 0, _w: 0,\n\n  get x() {\n\n    return this._x;\n\n  },\n\n  set x(value) {\n\n    this._x = value;\n    this.onChangeCallback();\n\n  },\n\n  get y() {\n\n    return this._y;\n\n  },\n\n  set y(value) {\n\n    this._y = value;\n    this.onChangeCallback();\n\n  },\n\n  get z() {\n\n    return this._z;\n\n  },\n\n  set z(value) {\n\n    this._z = value;\n    this.onChangeCallback();\n\n  },\n\n  get w() {\n\n    return this._w;\n\n  },\n\n  set w(value) {\n\n    this._w = value;\n    this.onChangeCallback();\n\n  },\n\n  set: function set(x, y, z, w) {\n\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  copy: function copy(quaternion) {\n\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  setFromEuler: function setFromEuler(euler, update) {\n\n    if (euler instanceof THREE.Euler === false) {\n\n      throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n    }\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    var c1 = Math.cos(euler._x / 2);\n    var c2 = Math.cos(euler._y / 2);\n    var c3 = Math.cos(euler._z / 2);\n    var s1 = Math.sin(euler._x / 2);\n    var s2 = Math.sin(euler._y / 2);\n    var s3 = Math.sin(euler._z / 2);\n\n    if (euler.order === 'XYZ') {\n\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if (euler.order === 'YXZ') {\n\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if (euler.order === 'ZXY') {\n\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if (euler.order === 'ZYX') {\n\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if (euler.order === 'YZX') {\n\n      this._x = s1 * c2 * c3 + c1 * s2 * s3;\n      this._y = c1 * s2 * c3 + s1 * c2 * s3;\n      this._z = c1 * c2 * s3 - s1 * s2 * c3;\n      this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if (euler.order === 'XZY') {\n\n      this._x = s1 * c2 * c3 - c1 * s2 * s3;\n      this._y = c1 * s2 * c3 - s1 * c2 * s3;\n      this._z = c1 * c2 * s3 + s1 * s2 * c3;\n      this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    }\n\n    if (update !== false) this.onChangeCallback();\n\n    return this;\n\n  },\n\n  setFromAxisAngle: function setFromAxisAngle(axis, angle) {\n\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n    // assumes axis is normalized\n\n    var halfAngle = angle / 2,s = Math.sin(halfAngle);\n\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  setFromRotationMatrix: function setFromRotationMatrix(m) {\n\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    var te = m.elements,\n\n    m11 = te[0],m12 = te[4],m13 = te[8],\n    m21 = te[1],m22 = te[5],m23 = te[9],\n    m31 = te[2],m32 = te[6],m33 = te[10],\n\n    trace = m11 + m22 + m33,\n    s;\n\n    if (trace > 0) {\n\n      s = 0.5 / Math.sqrt(trace + 1.0);\n\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n\n    } else if (m11 > m22 && m11 > m33) {\n\n      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n\n    } else if (m22 > m33) {\n\n      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n\n    } else {\n\n      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n\n    }\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  setFromUnitVectors: function () {\n\n    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n    // assumes direction vectors vFrom and vTo are normalized\n\n    var v1, r;\n\n    var EPS = 0.000001;\n\n    return function (vFrom, vTo) {\n\n      if (v1 === undefined) v1 = new THREE.Vector3();\n\n      r = vFrom.dot(vTo) + 1;\n\n      if (r < EPS) {\n\n        r = 0;\n\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\n          v1.set(-vFrom.y, vFrom.x, 0);\n\n        } else {\n\n          v1.set(0, -vFrom.z, vFrom.y);\n\n        }\n\n      } else {\n\n        v1.crossVectors(vFrom, vTo);\n\n      }\n\n      this._x = v1.x;\n      this._y = v1.y;\n      this._z = v1.z;\n      this._w = r;\n\n      this.normalize();\n\n      return this;\n\n    };\n\n  }(),\n\n  inverse: function inverse() {\n\n    this.conjugate().normalize();\n\n    return this;\n\n  },\n\n  conjugate: function conjugate() {\n\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  dot: function dot(v) {\n\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n  },\n\n  lengthSq: function lengthSq() {\n\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n  },\n\n  length: function length() {\n\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n\n  },\n\n  normalize: function normalize() {\n\n    var l = this.length();\n\n    if (l === 0) {\n\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n\n    } else {\n\n      l = 1 / l;\n\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n\n    }\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  multiply: function multiply(q, p) {\n\n    if (p !== undefined) {\n\n      THREE.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n      return this.multiplyQuaternions(q, p);\n\n    }\n\n    return this.multiplyQuaternions(this, q);\n\n  },\n\n  multiplyQuaternions: function multiplyQuaternions(a, b) {\n\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n    var qax = a._x,qay = a._y,qaz = a._z,qaw = a._w;\n    var qbx = b._x,qby = b._y,qbz = b._z,qbw = b._w;\n\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  multiplyVector3: function multiplyVector3(vector) {\n\n    THREE.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n    return vector.applyQuaternion(this);\n\n  },\n\n  slerp: function slerp(qb, t) {\n\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n\n    var x = this._x,y = this._y,z = this._z,w = this._w;\n\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n\n      cosHalfTheta = -cosHalfTheta;\n\n    } else {\n\n      this.copy(qb);\n\n    }\n\n    if (cosHalfTheta >= 1.0) {\n\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n\n      return this;\n\n    }\n\n    var halfTheta = Math.acos(cosHalfTheta);\n    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    if (Math.abs(sinHalfTheta) < 0.001) {\n\n      this._w = 0.5 * (w + this._w);\n      this._x = 0.5 * (x + this._x);\n      this._y = 0.5 * (y + this._y);\n      this._z = 0.5 * (z + this._z);\n\n      return this;\n\n    }\n\n    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  equals: function equals(quaternion) {\n\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n\n  },\n\n  fromArray: function fromArray(array, offset) {\n\n    if (offset === undefined) offset = 0;\n\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n\n    this.onChangeCallback();\n\n    return this;\n\n  },\n\n  toArray: function toArray(array, offset) {\n\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n\n    return array;\n\n  },\n\n  onChange: function onChange(callback) {\n\n    this.onChangeCallback = callback;\n\n    return this;\n\n  },\n\n  onChangeCallback: function onChangeCallback() {},\n\n  clone: function clone() {\n\n    return new THREE.Quaternion(this._x, this._y, this._z, this._w);\n\n  } };\n\n\n\nTHREE.Quaternion.slerp = function (qa, qb, qm, t) {\n\n  return qm.copy(qa).slerp(qb, t);\n\n};\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function (x, y) {\n\n  this.x = x || 0;\n  this.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n  constructor: THREE.Vector2,\n\n  set: function set(x, y) {\n\n    this.x = x;\n    this.y = y;\n\n    return this;\n\n  },\n\n  setX: function setX(x) {\n\n    this.x = x;\n\n    return this;\n\n  },\n\n  setY: function setY(y) {\n\n    this.y = y;\n\n    return this;\n\n  },\n\n  setComponent: function setComponent(index, value) {\n\n    switch (index) {\n\n      case 0:this.x = value;break;\n      case 1:this.y = value;break;\n      default:throw new Error('index is out of range: ' + index);}\n\n\n\n  },\n\n  getComponent: function getComponent(index) {\n\n    switch (index) {\n\n      case 0:return this.x;\n      case 1:return this.y;\n      default:throw new Error('index is out of range: ' + index);}\n\n\n\n  },\n\n  copy: function copy(v) {\n\n    this.x = v.x;\n    this.y = v.y;\n\n    return this;\n\n  },\n\n  add: function add(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n\n    return this;\n\n  },\n\n  addScalar: function addScalar(s) {\n\n    this.x += s;\n    this.y += s;\n\n    return this;\n\n  },\n\n  addVectors: function addVectors(a, b) {\n\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n\n    return this;\n\n  },\n\n  sub: function sub(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n\n    return this;\n\n  },\n\n  subScalar: function subScalar(s) {\n\n    this.x -= s;\n    this.y -= s;\n\n    return this;\n\n  },\n\n  subVectors: function subVectors(a, b) {\n\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n\n    return this;\n\n  },\n\n  multiply: function multiply(v) {\n\n    this.x *= v.x;\n    this.y *= v.y;\n\n    return this;\n\n  },\n\n  multiplyScalar: function multiplyScalar(s) {\n\n    this.x *= s;\n    this.y *= s;\n\n    return this;\n\n  },\n\n  divide: function divide(v) {\n\n    this.x /= v.x;\n    this.y /= v.y;\n\n    return this;\n\n  },\n\n  divideScalar: function divideScalar(scalar) {\n\n    if (scalar !== 0) {\n\n      var invScalar = 1 / scalar;\n\n      this.x *= invScalar;\n      this.y *= invScalar;\n\n    } else {\n\n      this.x = 0;\n      this.y = 0;\n\n    }\n\n    return this;\n\n  },\n\n  min: function min(v) {\n\n    if (this.x > v.x) {\n\n      this.x = v.x;\n\n    }\n\n    if (this.y > v.y) {\n\n      this.y = v.y;\n\n    }\n\n    return this;\n\n  },\n\n  max: function max(v) {\n\n    if (this.x < v.x) {\n\n      this.x = v.x;\n\n    }\n\n    if (this.y < v.y) {\n\n      this.y = v.y;\n\n    }\n\n    return this;\n\n  },\n\n  clamp: function clamp(min, max) {\n\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n    if (this.x < min.x) {\n\n      this.x = min.x;\n\n    } else if (this.x > max.x) {\n\n      this.x = max.x;\n\n    }\n\n    if (this.y < min.y) {\n\n      this.y = min.y;\n\n    } else if (this.y > max.y) {\n\n      this.y = max.y;\n\n    }\n\n    return this;\n  },\n\n  clampScalar: function () {\n\n    var min, max;\n\n    return function (minVal, maxVal) {\n\n      if (min === undefined) {\n\n        min = new THREE.Vector2();\n        max = new THREE.Vector2();\n\n      }\n\n      min.set(minVal, minVal);\n      max.set(maxVal, maxVal);\n\n      return this.clamp(min, max);\n\n    };\n\n  }(),\n\n  floor: function floor() {\n\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n\n    return this;\n\n  },\n\n  ceil: function ceil() {\n\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n\n    return this;\n\n  },\n\n  round: function round() {\n\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n\n    return this;\n\n  },\n\n  roundToZero: function roundToZero() {\n\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\n    return this;\n\n  },\n\n  negate: function negate() {\n\n    this.x = -this.x;\n    this.y = -this.y;\n\n    return this;\n\n  },\n\n  dot: function dot(v) {\n\n    return this.x * v.x + this.y * v.y;\n\n  },\n\n  lengthSq: function lengthSq() {\n\n    return this.x * this.x + this.y * this.y;\n\n  },\n\n  length: function length() {\n\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n\n  },\n\n  normalize: function normalize() {\n\n    return this.divideScalar(this.length());\n\n  },\n\n  distanceTo: function distanceTo(v) {\n\n    return Math.sqrt(this.distanceToSquared(v));\n\n  },\n\n  distanceToSquared: function distanceToSquared(v) {\n\n    var dx = this.x - v.x,dy = this.y - v.y;\n    return dx * dx + dy * dy;\n\n  },\n\n  setLength: function setLength(l) {\n\n    var oldLength = this.length();\n\n    if (oldLength !== 0 && l !== oldLength) {\n\n      this.multiplyScalar(l / oldLength);\n    }\n\n    return this;\n\n  },\n\n  lerp: function lerp(v, alpha) {\n\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n\n    return this;\n\n  },\n\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\n\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n\n    return this;\n\n  },\n\n  equals: function equals(v) {\n\n    return v.x === this.x && v.y === this.y;\n\n  },\n\n  fromArray: function fromArray(array, offset) {\n\n    if (offset === undefined) offset = 0;\n\n    this.x = array[offset];\n    this.y = array[offset + 1];\n\n    return this;\n\n  },\n\n  toArray: function toArray(array, offset) {\n\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n\n    return array;\n\n  },\n\n  fromAttribute: function fromAttribute(attribute, index, offset) {\n\n    if (offset === undefined) offset = 0;\n\n    index = index * attribute.itemSize + offset;\n\n    this.x = attribute.array[index];\n    this.y = attribute.array[index + 1];\n\n    return this;\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Vector2(this.x, this.y);\n\n  } };\n\n\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function (x, y, z) {\n\n  this.x = x || 0;\n  this.y = y || 0;\n  this.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n  constructor: THREE.Vector3,\n\n  set: function set(x, y, z) {\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n\n    return this;\n\n  },\n\n  setX: function setX(x) {\n\n    this.x = x;\n\n    return this;\n\n  },\n\n  setY: function setY(y) {\n\n    this.y = y;\n\n    return this;\n\n  },\n\n  setZ: function setZ(z) {\n\n    this.z = z;\n\n    return this;\n\n  },\n\n  setComponent: function setComponent(index, value) {\n\n    switch (index) {\n\n      case 0:this.x = value;break;\n      case 1:this.y = value;break;\n      case 2:this.z = value;break;\n      default:throw new Error('index is out of range: ' + index);}\n\n\n\n  },\n\n  getComponent: function getComponent(index) {\n\n    switch (index) {\n\n      case 0:return this.x;\n      case 1:return this.y;\n      case 2:return this.z;\n      default:throw new Error('index is out of range: ' + index);}\n\n\n\n  },\n\n  copy: function copy(v) {\n\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n\n    return this;\n\n  },\n\n  add: function add(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n\n    return this;\n\n  },\n\n  addScalar: function addScalar(s) {\n\n    this.x += s;\n    this.y += s;\n    this.z += s;\n\n    return this;\n\n  },\n\n  addVectors: function addVectors(a, b) {\n\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n\n    return this;\n\n  },\n\n  sub: function sub(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n\n    return this;\n\n  },\n\n  subScalar: function subScalar(s) {\n\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n\n    return this;\n\n  },\n\n  subVectors: function subVectors(a, b) {\n\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n\n    return this;\n\n  },\n\n  multiply: function multiply(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n      return this.multiplyVectors(v, w);\n\n    }\n\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n\n    return this;\n\n  },\n\n  multiplyScalar: function multiplyScalar(scalar) {\n\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n\n    return this;\n\n  },\n\n  multiplyVectors: function multiplyVectors(a, b) {\n\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n\n    return this;\n\n  },\n\n  applyEuler: function () {\n\n    var quaternion;\n\n    return function (euler) {\n\n      if (euler instanceof THREE.Euler === false) {\n\n        THREE.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\n      }\n\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\n\n      this.applyQuaternion(quaternion.setFromEuler(euler));\n\n      return this;\n\n    };\n\n  }(),\n\n  applyAxisAngle: function () {\n\n    var quaternion;\n\n    return function (axis, angle) {\n\n      if (quaternion === undefined) quaternion = new THREE.Quaternion();\n\n      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\n\n      return this;\n\n    };\n\n  }(),\n\n  applyMatrix3: function applyMatrix3(m) {\n\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n\n    var e = m.elements;\n\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n\n    return this;\n\n  },\n\n  applyMatrix4: function applyMatrix4(m) {\n\n    // input: THREE.Matrix4 affine matrix\n\n    var x = this.x,y = this.y,z = this.z;\n\n    var e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n    return this;\n\n  },\n\n  applyProjection: function applyProjection(m) {\n\n    // input: THREE.Matrix4 projection matrix\n\n    var x = this.x,y = this.y,z = this.z;\n\n    var e = m.elements;\n    var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide\n\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;\n\n    return this;\n\n  },\n\n  applyQuaternion: function applyQuaternion(q) {\n\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n\n    var qx = q.x;\n    var qy = q.y;\n    var qz = q.z;\n    var qw = q.w;\n\n    // calculate quat * vector\n\n    var ix = qw * x + qy * z - qz * y;\n    var iy = qw * y + qz * x - qx * z;\n    var iz = qw * z + qx * y - qy * x;\n    var iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return this;\n\n  },\n\n  project: function () {\n\n    var matrix;\n\n    return function (camera) {\n\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n\n      matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));\n      return this.applyProjection(matrix);\n\n    };\n\n  }(),\n\n  unproject: function () {\n\n    var matrix;\n\n    return function (camera) {\n\n      if (matrix === undefined) matrix = new THREE.Matrix4();\n\n      matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));\n      return this.applyProjection(matrix);\n\n    };\n\n  }(),\n\n  transformDirection: function transformDirection(m) {\n\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n\n    var x = this.x,y = this.y,z = this.z;\n\n    var e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n\n    this.normalize();\n\n    return this;\n\n  },\n\n  divide: function divide(v) {\n\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n\n    return this;\n\n  },\n\n  divideScalar: function divideScalar(scalar) {\n\n    if (scalar !== 0) {\n\n      var invScalar = 1 / scalar;\n\n      this.x *= invScalar;\n      this.y *= invScalar;\n      this.z *= invScalar;\n\n    } else {\n\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n    }\n\n    return this;\n\n  },\n\n  min: function min(v) {\n\n    if (this.x > v.x) {\n\n      this.x = v.x;\n\n    }\n\n    if (this.y > v.y) {\n\n      this.y = v.y;\n\n    }\n\n    if (this.z > v.z) {\n\n      this.z = v.z;\n\n    }\n\n    return this;\n\n  },\n\n  max: function max(v) {\n\n    if (this.x < v.x) {\n\n      this.x = v.x;\n\n    }\n\n    if (this.y < v.y) {\n\n      this.y = v.y;\n\n    }\n\n    if (this.z < v.z) {\n\n      this.z = v.z;\n\n    }\n\n    return this;\n\n  },\n\n  clamp: function clamp(min, max) {\n\n    // This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n    if (this.x < min.x) {\n\n      this.x = min.x;\n\n    } else if (this.x > max.x) {\n\n      this.x = max.x;\n\n    }\n\n    if (this.y < min.y) {\n\n      this.y = min.y;\n\n    } else if (this.y > max.y) {\n\n      this.y = max.y;\n\n    }\n\n    if (this.z < min.z) {\n\n      this.z = min.z;\n\n    } else if (this.z > max.z) {\n\n      this.z = max.z;\n\n    }\n\n    return this;\n\n  },\n\n  clampScalar: function () {\n\n    var min, max;\n\n    return function (minVal, maxVal) {\n\n      if (min === undefined) {\n\n        min = new THREE.Vector3();\n        max = new THREE.Vector3();\n\n      }\n\n      min.set(minVal, minVal, minVal);\n      max.set(maxVal, maxVal, maxVal);\n\n      return this.clamp(min, max);\n\n    };\n\n  }(),\n\n  floor: function floor() {\n\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n\n    return this;\n\n  },\n\n  ceil: function ceil() {\n\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n\n    return this;\n\n  },\n\n  round: function round() {\n\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n\n    return this;\n\n  },\n\n  roundToZero: function roundToZero() {\n\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\n    return this;\n\n  },\n\n  negate: function negate() {\n\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n\n    return this;\n\n  },\n\n  dot: function dot(v) {\n\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n\n  },\n\n  lengthSq: function lengthSq() {\n\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n\n  },\n\n  length: function length() {\n\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\n  },\n\n  lengthManhattan: function lengthManhattan() {\n\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n\n  },\n\n  normalize: function normalize() {\n\n    return this.divideScalar(this.length());\n\n  },\n\n  setLength: function setLength(l) {\n\n    var oldLength = this.length();\n\n    if (oldLength !== 0 && l !== oldLength) {\n\n      this.multiplyScalar(l / oldLength);\n    }\n\n    return this;\n\n  },\n\n  lerp: function lerp(v, alpha) {\n\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n\n    return this;\n\n  },\n\n  lerpVectors: function lerpVectors(v1, v2, alpha) {\n\n    this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n\n    return this;\n\n  },\n\n  cross: function cross(v, w) {\n\n    if (w !== undefined) {\n\n      THREE.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n      return this.crossVectors(v, w);\n\n    }\n\n    var x = this.x,y = this.y,z = this.z;\n\n    this.x = y * v.z - z * v.y;\n    this.y = z * v.x - x * v.z;\n    this.z = x * v.y - y * v.x;\n\n    return this;\n\n  },\n\n  crossVectors: function crossVectors(a, b) {\n\n    var ax = a.x,ay = a.y,az = a.z;\n    var bx = b.x,by = b.y,bz = b.z;\n\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n\n    return this;\n\n  },\n\n  projectOnVector: function () {\n\n    var v1, dot;\n\n    return function (vector) {\n\n      if (v1 === undefined) v1 = new THREE.Vector3();\n\n      v1.copy(vector).normalize();\n\n      dot = this.dot(v1);\n\n      return this.copy(v1).multiplyScalar(dot);\n\n    };\n\n  }(),\n\n  projectOnPlane: function () {\n\n    var v1;\n\n    return function (planeNormal) {\n\n      if (v1 === undefined) v1 = new THREE.Vector3();\n\n      v1.copy(this).projectOnVector(planeNormal);\n\n      return this.sub(v1);\n\n    };\n\n  }(),\n\n  reflect: function () {\n\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n\n    var v1;\n\n    return function (normal) {\n\n      if (v1 === undefined) v1 = new THREE.Vector3();\n\n      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\n\n    };\n\n  }(),\n\n  angleTo: function angleTo(v) {\n\n    var theta = this.dot(v) / (this.length() * v.length());\n\n    // clamp, to handle numerical problems\n\n    return Math.acos(THREE.Math.clamp(theta, -1, 1));\n\n  },\n\n  distanceTo: function distanceTo(v) {\n\n    return Math.sqrt(this.distanceToSquared(v));\n\n  },\n\n  distanceToSquared: function distanceToSquared(v) {\n\n    var dx = this.x - v.x;\n    var dy = this.y - v.y;\n    var dz = this.z - v.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  },\n\n  setEulerFromRotationMatrix: function setEulerFromRotationMatrix(m, order) {\n\n    THREE.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n\n  },\n\n  setEulerFromQuaternion: function setEulerFromQuaternion(q, order) {\n\n    THREE.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n\n  },\n\n  getPositionFromMatrix: function getPositionFromMatrix(m) {\n\n    THREE.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n\n    return this.setFromMatrixPosition(m);\n\n  },\n\n  getScaleFromMatrix: function getScaleFromMatrix(m) {\n\n    THREE.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n\n    return this.setFromMatrixScale(m);\n  },\n\n  getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {\n\n    THREE.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n\n    return this.setFromMatrixColumn(index, matrix);\n\n  },\n\n  setFromMatrixPosition: function setFromMatrixPosition(m) {\n\n    this.x = m.elements[12];\n    this.y = m.elements[13];\n    this.z = m.elements[14];\n\n    return this;\n\n  },\n\n  setFromMatrixScale: function setFromMatrixScale(m) {\n\n    var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();\n    var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();\n    var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();\n\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n\n    return this;\n  },\n\n  setFromMatrixColumn: function setFromMatrixColumn(index, matrix) {\n\n    var offset = index * 4;\n\n    var me = matrix.elements;\n\n    this.x = me[offset];\n    this.y = me[offset + 1];\n    this.z = me[offset + 2];\n\n    return this;\n\n  },\n\n  equals: function equals(v) {\n\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n\n  },\n\n  fromArray: function fromArray(array, offset) {\n\n    if (offset === undefined) offset = 0;\n\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n\n    return this;\n\n  },\n\n  toArray: function toArray(array, offset) {\n\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n\n    return array;\n\n  },\n\n  fromAttribute: function fromAttribute(attribute, index, offset) {\n\n    if (offset === undefined) offset = 0;\n\n    index = index * attribute.itemSize + offset;\n\n    this.x = attribute.array[index];\n    this.y = attribute.array[index + 1];\n    this.z = attribute.array[index + 2];\n\n    return this;\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Vector3(this.x, this.y, this.z);\n\n  } };\n\n\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Box2 = function (min, max) {\n\n  this.min = min !== undefined ? min : new THREE.Vector2(Infinity, Infinity);\n  this.max = max !== undefined ? max : new THREE.Vector2(-Infinity, -Infinity);\n\n};\n\nTHREE.Box2.prototype = {\n\n  constructor: THREE.Box2,\n\n  set: function set(min, max) {\n\n    this.min.copy(min);\n    this.max.copy(max);\n\n    return this;\n\n  },\n\n  setFromPoints: function setFromPoints(points) {\n\n    this.makeEmpty();\n\n    for (var i = 0, il = points.length; i < il; i++) {\n\n      this.expandByPoint(points[i]);\n\n    }\n\n    return this;\n\n  },\n\n  setFromCenterAndSize: function () {\n\n    var v1 = new THREE.Vector2();\n\n    return function (center, size) {\n\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n\n      return this;\n\n    };\n\n  }(),\n\n  copy: function copy(box) {\n\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n\n    return this;\n\n  },\n\n  makeEmpty: function makeEmpty() {\n\n    this.min.x = this.min.y = Infinity;\n    this.max.x = this.max.y = -Infinity;\n\n    return this;\n\n  },\n\n  empty: function empty() {\n\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n\n  },\n\n  center: function center(optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector2();\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n\n  },\n\n  size: function size(optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector2();\n    return result.subVectors(this.max, this.min);\n\n  },\n\n  expandByPoint: function expandByPoint(point) {\n\n    this.min.min(point);\n    this.max.max(point);\n\n    return this;\n  },\n\n  expandByVector: function expandByVector(vector) {\n\n    this.min.sub(vector);\n    this.max.add(vector);\n\n    return this;\n  },\n\n  expandByScalar: function expandByScalar(scalar) {\n\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n\n    return this;\n  },\n\n  containsPoint: function containsPoint(point) {\n\n    if (point.x < this.min.x || point.x > this.max.x ||\n    point.y < this.min.y || point.y > this.max.y) {\n\n      return false;\n\n    }\n\n    return true;\n\n  },\n\n  containsBox: function containsBox(box) {\n\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x &&\n    this.min.y <= box.min.y && box.max.y <= this.max.y) {\n\n      return true;\n\n    }\n\n    return false;\n\n  },\n\n  getParameter: function getParameter(point, optionalTarget) {\n\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    var result = optionalTarget || new THREE.Vector2();\n\n    return result.set(\n    (point.x - this.min.x) / (this.max.x - this.min.x),\n    (point.y - this.min.y) / (this.max.y - this.min.y));\n\n\n  },\n\n  isIntersectionBox: function isIntersectionBox(box) {\n\n    // using 6 splitting planes to rule out intersections.\n\n    if (box.max.x < this.min.x || box.min.x > this.max.x ||\n    box.max.y < this.min.y || box.min.y > this.max.y) {\n\n      return false;\n\n    }\n\n    return true;\n\n  },\n\n  clampPoint: function clampPoint(point, optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector2();\n    return result.copy(point).clamp(this.min, this.max);\n\n  },\n\n  distanceToPoint: function () {\n\n    var v1 = new THREE.Vector2();\n\n    return function (point) {\n\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n      return clampedPoint.sub(point).length();\n\n    };\n\n  }(),\n\n  intersect: function intersect(box) {\n\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    return this;\n\n  },\n\n  union: function union(box) {\n\n    this.min.min(box.min);\n    this.max.max(box.max);\n\n    return this;\n\n  },\n\n  translate: function translate(offset) {\n\n    this.min.add(offset);\n    this.max.add(offset);\n\n    return this;\n\n  },\n\n  equals: function equals(box) {\n\n    return box.min.equals(this.min) && box.max.equals(this.max);\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Box2().copy(this);\n\n  } };\n\n\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function (min, max) {\n\n  this.min = min !== undefined ? min : new THREE.Vector3(Infinity, Infinity, Infinity);\n  this.max = max !== undefined ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n\n};\n\nTHREE.Box3.prototype = {\n\n  constructor: THREE.Box3,\n\n  set: function set(min, max) {\n\n    this.min.copy(min);\n    this.max.copy(max);\n\n    return this;\n\n  },\n\n  setFromPoints: function setFromPoints(points) {\n\n    this.makeEmpty();\n\n    for (var i = 0, il = points.length; i < il; i++) {\n\n      this.expandByPoint(points[i]);\n\n    }\n\n    return this;\n\n  },\n\n  setFromCenterAndSize: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (center, size) {\n\n      var halfSize = v1.copy(size).multiplyScalar(0.5);\n\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n\n      return this;\n\n    };\n\n  }(),\n\n  setFromObject: function () {\n\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and childrens', world transforms\n\n    var v1 = new THREE.Vector3();\n\n    return function (object) {\n\n      var scope = this;\n\n      object.updateMatrixWorld(true);\n\n      this.makeEmpty();\n\n      object.traverse(function (node) {\n\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n\n          if (geometry instanceof THREE.Geometry) {\n\n            var vertices = geometry.vertices;\n\n            for (var i = 0, il = vertices.length; i < il; i++) {\n\n              v1.copy(vertices[i]);\n\n              v1.applyMatrix4(node.matrixWorld);\n\n              scope.expandByPoint(v1);\n\n            }\n\n          } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {\n\n            var positions = geometry.attributes['position'].array;\n\n            for (var i = 0, il = positions.length; i < il; i += 3) {\n\n              v1.set(positions[i], positions[i + 1], positions[i + 2]);\n\n              v1.applyMatrix4(node.matrixWorld);\n\n              scope.expandByPoint(v1);\n\n            }\n\n          }\n\n        }\n\n      });\n\n      return this;\n\n    };\n\n  }(),\n\n  copy: function copy(box) {\n\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n\n    return this;\n\n  },\n\n  makeEmpty: function makeEmpty() {\n\n    this.min.x = this.min.y = this.min.z = Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n\n    return this;\n\n  },\n\n  empty: function empty() {\n\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n\n  },\n\n  center: function center(optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector3();\n    return result.addVectors(this.min, this.max).multiplyScalar(0.5);\n\n  },\n\n  size: function size(optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector3();\n    return result.subVectors(this.max, this.min);\n\n  },\n\n  expandByPoint: function expandByPoint(point) {\n\n    this.min.min(point);\n    this.max.max(point);\n\n    return this;\n\n  },\n\n  expandByVector: function expandByVector(vector) {\n\n    this.min.sub(vector);\n    this.max.add(vector);\n\n    return this;\n\n  },\n\n  expandByScalar: function expandByScalar(scalar) {\n\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n\n    return this;\n\n  },\n\n  containsPoint: function containsPoint(point) {\n\n    if (point.x < this.min.x || point.x > this.max.x ||\n    point.y < this.min.y || point.y > this.max.y ||\n    point.z < this.min.z || point.z > this.max.z) {\n\n      return false;\n\n    }\n\n    return true;\n\n  },\n\n  containsBox: function containsBox(box) {\n\n    if (this.min.x <= box.min.x && box.max.x <= this.max.x &&\n    this.min.y <= box.min.y && box.max.y <= this.max.y &&\n    this.min.z <= box.min.z && box.max.z <= this.max.z) {\n\n      return true;\n\n    }\n\n    return false;\n\n  },\n\n  getParameter: function getParameter(point, optionalTarget) {\n\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    var result = optionalTarget || new THREE.Vector3();\n\n    return result.set(\n    (point.x - this.min.x) / (this.max.x - this.min.x),\n    (point.y - this.min.y) / (this.max.y - this.min.y),\n    (point.z - this.min.z) / (this.max.z - this.min.z));\n\n\n  },\n\n  isIntersectionBox: function isIntersectionBox(box) {\n\n    // using 6 splitting planes to rule out intersections.\n\n    if (box.max.x < this.min.x || box.min.x > this.max.x ||\n    box.max.y < this.min.y || box.min.y > this.max.y ||\n    box.max.z < this.min.z || box.min.z > this.max.z) {\n\n      return false;\n\n    }\n\n    return true;\n\n  },\n\n  clampPoint: function clampPoint(point, optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(point).clamp(this.min, this.max);\n\n  },\n\n  distanceToPoint: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (point) {\n\n      var clampedPoint = v1.copy(point).clamp(this.min, this.max);\n      return clampedPoint.sub(point).length();\n\n    };\n\n  }(),\n\n  getBoundingSphere: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (optionalTarget) {\n\n      var result = optionalTarget || new THREE.Sphere();\n\n      result.center = this.center();\n      result.radius = this.size(v1).length() * 0.5;\n\n      return result;\n\n    };\n\n  }(),\n\n  intersect: function intersect(box) {\n\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    return this;\n\n  },\n\n  union: function union(box) {\n\n    this.min.min(box.min);\n    this.max.max(box.max);\n\n    return this;\n\n  },\n\n  applyMatrix4: function () {\n\n    var points = [\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3()];\n\n\n    return function (matrix) {\n\n      // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n      this.makeEmpty();\n      this.setFromPoints(points);\n\n      return this;\n\n    };\n\n  }(),\n\n  translate: function translate(offset) {\n\n    this.min.add(offset);\n    this.max.add(offset);\n\n    return this;\n\n  },\n\n  equals: function equals(box) {\n\n    return box.min.equals(this.min) && box.max.equals(this.max);\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Box3().copy(this);\n\n  } };\n\n\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Matrix3 = function () {\n\n  this.elements = new Float32Array([\n\n  1, 0, 0,\n  0, 1, 0,\n  0, 0, 1]);\n\n\n\n  if (arguments.length > 0) {\n\n    THREE.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\n  }\n\n};\n\nTHREE.Matrix3.prototype = {\n\n  constructor: THREE.Matrix3,\n\n  set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n\n    var te = this.elements;\n\n    te[0] = n11;te[3] = n12;te[6] = n13;\n    te[1] = n21;te[4] = n22;te[7] = n23;\n    te[2] = n31;te[5] = n32;te[8] = n33;\n\n    return this;\n\n  },\n\n  identity: function identity() {\n\n    this.set(\n\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  copy: function copy(m) {\n\n    var me = m.elements;\n\n    this.set(\n\n    me[0], me[3], me[6],\n    me[1], me[4], me[7],\n    me[2], me[5], me[8]);\n\n\n\n    return this;\n\n  },\n\n  multiplyVector3: function multiplyVector3(vector) {\n\n    THREE.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n    return vector.applyMatrix3(this);\n\n  },\n\n  multiplyVector3Array: function multiplyVector3Array(a) {\n\n    THREE.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\n    return this.applyToVector3Array(a);\n\n  },\n\n  applyToVector3Array: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (array, offset, length) {\n\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = array.length;\n\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\n\n        v1.x = array[j];\n        v1.y = array[j + 1];\n        v1.z = array[j + 2];\n\n        v1.applyMatrix3(this);\n\n        array[j] = v1.x;\n        array[j + 1] = v1.y;\n        array[j + 2] = v1.z;\n\n      }\n\n      return array;\n\n    };\n\n  }(),\n\n  multiplyScalar: function multiplyScalar(s) {\n\n    var te = this.elements;\n\n    te[0] *= s;te[3] *= s;te[6] *= s;\n    te[1] *= s;te[4] *= s;te[7] *= s;\n    te[2] *= s;te[5] *= s;te[8] *= s;\n\n    return this;\n\n  },\n\n  determinant: function determinant() {\n\n    var te = this.elements;\n\n    var a = te[0],b = te[1],c = te[2],\n    d = te[3],e = te[4],f = te[5],\n    g = te[6],h = te[7],i = te[8];\n\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n  },\n\n  getInverse: function getInverse(matrix, throwOnInvertible) {\n\n    // input: THREE.Matrix4\n    // ( based on http://code.google.com/p/webgl-mjs/ )\n\n    var me = matrix.elements;\n    var te = this.elements;\n\n    te[0] = me[10] * me[5] - me[6] * me[9];\n    te[1] = -me[10] * me[1] + me[2] * me[9];\n    te[2] = me[6] * me[1] - me[2] * me[5];\n    te[3] = -me[10] * me[4] + me[6] * me[8];\n    te[4] = me[10] * me[0] - me[2] * me[8];\n    te[5] = -me[6] * me[0] + me[2] * me[4];\n    te[6] = me[9] * me[4] - me[5] * me[8];\n    te[7] = -me[9] * me[0] + me[1] * me[8];\n    te[8] = me[5] * me[0] - me[1] * me[4];\n\n    var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];\n\n    // no inverse\n\n    if (det === 0) {\n\n      var msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n\n        throw new Error(msg);\n\n      } else {\n\n        THREE.warn(msg);\n\n      }\n\n      this.identity();\n\n      return this;\n\n    }\n\n    this.multiplyScalar(1.0 / det);\n\n    return this;\n\n  },\n\n  transpose: function transpose() {\n\n    var tmp,m = this.elements;\n\n    tmp = m[1];m[1] = m[3];m[3] = tmp;\n    tmp = m[2];m[2] = m[6];m[6] = tmp;\n    tmp = m[5];m[5] = m[7];m[7] = tmp;\n\n    return this;\n\n  },\n\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\n\n    var te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n\n    return array;\n\n  },\n\n  getNormalMatrix: function getNormalMatrix(m) {\n\n    // input: THREE.Matrix4\n\n    this.getInverse(m).transpose();\n\n    return this;\n\n  },\n\n  transposeIntoArray: function transposeIntoArray(r) {\n\n    var m = this.elements;\n\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n\n    return this;\n\n  },\n\n  fromArray: function fromArray(array) {\n\n    this.elements.set(array);\n\n    return this;\n\n  },\n\n  toArray: function toArray() {\n\n    var te = this.elements;\n\n    return [\n    te[0], te[1], te[2],\n    te[3], te[4], te[5],\n    te[6], te[7], te[8]];\n\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Matrix3().fromArray(this.elements);\n\n  } };\n\n\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n  this.elements = new Float32Array([\n\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1]);\n\n\n\n  if (arguments.length > 0) {\n\n    THREE.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\n  }\n\n};\n\nTHREE.Matrix4.prototype = {\n\n  constructor: THREE.Matrix4,\n\n  set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n\n    var te = this.elements;\n\n    te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;\n    te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;\n    te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;\n    te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;\n\n    return this;\n\n  },\n\n  identity: function identity() {\n\n    this.set(\n\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  copy: function copy(m) {\n\n    this.elements.set(m.elements);\n\n    return this;\n\n  },\n\n  extractPosition: function extractPosition(m) {\n\n    THREE.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n    return this.copyPosition(m);\n\n  },\n\n  copyPosition: function copyPosition(m) {\n\n    var te = this.elements;\n    var me = m.elements;\n\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n\n    return this;\n\n  },\n\n  extractBasis: function extractBasis(xAxis, yAxis, zAxis) {\n\n    var te = this.elements;\n\n    xAxis.set(te[0], te[1], te[2]);\n    yAxis.set(te[4], te[5], te[6]);\n    zAxis.set(te[8], te[9], te[10]);\n\n    return this;\n\n  },\n\n  makeBasis: function makeBasis(xAxis, yAxis, zAxis) {\n\n    this.set(\n    xAxis.x, yAxis.x, zAxis.x, 0,\n    xAxis.y, yAxis.y, zAxis.y, 0,\n    xAxis.z, yAxis.z, zAxis.z, 0,\n    0, 0, 0, 1);\n\n\n    return this;\n\n  },\n\n  extractRotation: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (m) {\n\n      var te = this.elements;\n      var me = m.elements;\n\n      var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();\n      var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();\n      var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();\n\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n\n      return this;\n\n    };\n\n  }(),\n\n  makeRotationFromEuler: function makeRotationFromEuler(euler) {\n\n    if (euler instanceof THREE.Euler === false) {\n\n      THREE.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\n    }\n\n    var te = this.elements;\n\n    var x = euler.x,y = euler.y,z = euler.z;\n    var a = Math.cos(x),b = Math.sin(x);\n    var c = Math.cos(y),d = Math.sin(y);\n    var e = Math.cos(z),f = Math.sin(z);\n\n    if (euler.order === 'XYZ') {\n\n      var ae = a * e,af = a * f,be = b * e,bf = b * f;\n\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n\n    } else if (euler.order === 'YXZ') {\n\n      var ce = c * e,cf = c * f,de = d * e,df = d * f;\n\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n\n    } else if (euler.order === 'ZXY') {\n\n      var ce = c * e,cf = c * f,de = d * e,df = d * f;\n\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n\n    } else if (euler.order === 'ZYX') {\n\n      var ae = a * e,af = a * f,be = b * e,bf = b * f;\n\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n\n    } else if (euler.order === 'YZX') {\n\n      var ac = a * c,ad = a * d,bc = b * c,bd = b * d;\n\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n\n    } else if (euler.order === 'XZY') {\n\n      var ac = a * c,ad = a * d,bc = b * c,bd = b * d;\n\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n\n    }\n\n    // last column\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // bottom row\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n\n  },\n\n  setRotationFromQuaternion: function setRotationFromQuaternion(q) {\n\n    THREE.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n\n    return this.makeRotationFromQuaternion(q);\n\n  },\n\n  makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {\n\n    var te = this.elements;\n\n    var x = q.x,y = q.y,z = q.z,w = q.w;\n    var x2 = x + x,y2 = y + y,z2 = z + z;\n    var xx = x * x2,xy = x * y2,xz = x * z2;\n    var yy = y * y2,yz = y * z2,zz = z * z2;\n    var wx = w * x2,wy = w * y2,wz = w * z2;\n\n    te[0] = 1 - (yy + zz);\n    te[4] = xy - wz;\n    te[8] = xz + wy;\n\n    te[1] = xy + wz;\n    te[5] = 1 - (xx + zz);\n    te[9] = yz - wx;\n\n    te[2] = xz - wy;\n    te[6] = yz + wx;\n    te[10] = 1 - (xx + yy);\n\n    // last column\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // bottom row\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n\n  },\n\n  lookAt: function () {\n\n    var x = new THREE.Vector3();\n    var y = new THREE.Vector3();\n    var z = new THREE.Vector3();\n\n    return function (eye, target, up) {\n\n      var te = this.elements;\n\n      z.subVectors(eye, target).normalize();\n\n      if (z.length() === 0) {\n\n        z.z = 1;\n\n      }\n\n      x.crossVectors(up, z).normalize();\n\n      if (x.length() === 0) {\n\n        z.x += 0.0001;\n        x.crossVectors(up, z).normalize();\n\n      }\n\n      y.crossVectors(z, x);\n\n\n      te[0] = x.x;te[4] = y.x;te[8] = z.x;\n      te[1] = x.y;te[5] = y.y;te[9] = z.y;\n      te[2] = x.z;te[6] = y.z;te[10] = z.z;\n\n      return this;\n\n    };\n\n  }(),\n\n  multiply: function multiply(m, n) {\n\n    if (n !== undefined) {\n\n      THREE.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n      return this.multiplyMatrices(m, n);\n\n    }\n\n    return this.multiplyMatrices(this, m);\n\n  },\n\n  multiplyMatrices: function multiplyMatrices(a, b) {\n\n    var ae = a.elements;\n    var be = b.elements;\n    var te = this.elements;\n\n    var a11 = ae[0],a12 = ae[4],a13 = ae[8],a14 = ae[12];\n    var a21 = ae[1],a22 = ae[5],a23 = ae[9],a24 = ae[13];\n    var a31 = ae[2],a32 = ae[6],a33 = ae[10],a34 = ae[14];\n    var a41 = ae[3],a42 = ae[7],a43 = ae[11],a44 = ae[15];\n\n    var b11 = be[0],b12 = be[4],b13 = be[8],b14 = be[12];\n    var b21 = be[1],b22 = be[5],b23 = be[9],b24 = be[13];\n    var b31 = be[2],b32 = be[6],b33 = be[10],b34 = be[14];\n    var b41 = be[3],b42 = be[7],b43 = be[11],b44 = be[15];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n    return this;\n\n  },\n\n  multiplyToArray: function multiplyToArray(a, b, r) {\n\n    var te = this.elements;\n\n    this.multiplyMatrices(a, b);\n\n    r[0] = te[0];r[1] = te[1];r[2] = te[2];r[3] = te[3];\n    r[4] = te[4];r[5] = te[5];r[6] = te[6];r[7] = te[7];\n    r[8] = te[8];r[9] = te[9];r[10] = te[10];r[11] = te[11];\n    r[12] = te[12];r[13] = te[13];r[14] = te[14];r[15] = te[15];\n\n    return this;\n\n  },\n\n  multiplyScalar: function multiplyScalar(s) {\n\n    var te = this.elements;\n\n    te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\n    te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\n    te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\n    te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\n\n    return this;\n\n  },\n\n  multiplyVector3: function multiplyVector3(vector) {\n\n    THREE.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');\n    return vector.applyProjection(this);\n\n  },\n\n  multiplyVector4: function multiplyVector4(vector) {\n\n    THREE.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n    return vector.applyMatrix4(this);\n\n  },\n\n  multiplyVector3Array: function multiplyVector3Array(a) {\n\n    THREE.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\n    return this.applyToVector3Array(a);\n\n  },\n\n  applyToVector3Array: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (array, offset, length) {\n\n      if (offset === undefined) offset = 0;\n      if (length === undefined) length = array.length;\n\n      for (var i = 0, j = offset; i < length; i += 3, j += 3) {\n\n        v1.x = array[j];\n        v1.y = array[j + 1];\n        v1.z = array[j + 2];\n\n        v1.applyMatrix4(this);\n\n        array[j] = v1.x;\n        array[j + 1] = v1.y;\n        array[j + 2] = v1.z;\n\n      }\n\n      return array;\n\n    };\n\n  }(),\n\n  rotateAxis: function rotateAxis(v) {\n\n    THREE.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n\n    v.transformDirection(this);\n\n  },\n\n  crossVector: function crossVector(vector) {\n\n    THREE.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n    return vector.applyMatrix4(this);\n\n  },\n\n  determinant: function determinant() {\n\n    var te = this.elements;\n\n    var n11 = te[0],n12 = te[4],n13 = te[8],n14 = te[12];\n    var n21 = te[1],n22 = te[5],n23 = te[9],n24 = te[13];\n    var n31 = te[2],n32 = te[6],n33 = te[10],n34 = te[14];\n    var n41 = te[3],n42 = te[7],n43 = te[11],n44 = te[15];\n\n    //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return (\n      n41 * (\n      +n14 * n23 * n32 -\n      n13 * n24 * n32 -\n      n14 * n22 * n33 +\n      n12 * n24 * n33 +\n      n13 * n22 * n34 -\n      n12 * n23 * n34) +\n\n      n42 * (\n      +n11 * n23 * n34 -\n      n11 * n24 * n33 +\n      n14 * n21 * n33 -\n      n13 * n21 * n34 +\n      n13 * n24 * n31 -\n      n14 * n23 * n31) +\n\n      n43 * (\n      +n11 * n24 * n32 -\n      n11 * n22 * n34 -\n      n14 * n21 * n32 +\n      n12 * n21 * n34 +\n      n14 * n22 * n31 -\n      n12 * n24 * n31) +\n\n      n44 * (\n      -n13 * n22 * n31 -\n      n11 * n23 * n32 +\n      n11 * n22 * n33 +\n      n13 * n21 * n32 -\n      n12 * n21 * n33 +\n      n12 * n23 * n31));\n\n\n\n\n  },\n\n  transpose: function transpose() {\n\n    var te = this.elements;\n    var tmp;\n\n    tmp = te[1];te[1] = te[4];te[4] = tmp;\n    tmp = te[2];te[2] = te[8];te[8] = tmp;\n    tmp = te[6];te[6] = te[9];te[9] = tmp;\n\n    tmp = te[3];te[3] = te[12];te[12] = tmp;\n    tmp = te[7];te[7] = te[13];te[13] = tmp;\n    tmp = te[11];te[11] = te[14];te[14] = tmp;\n\n    return this;\n\n  },\n\n  flattenToArrayOffset: function flattenToArrayOffset(array, offset) {\n\n    var te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n\n    return array;\n\n  },\n\n  getPosition: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function () {\n\n      THREE.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n\n      var te = this.elements;\n      return v1.set(te[12], te[13], te[14]);\n\n    };\n\n  }(),\n\n  setPosition: function setPosition(v) {\n\n    var te = this.elements;\n\n    te[12] = v.x;\n    te[13] = v.y;\n    te[14] = v.z;\n\n    return this;\n\n  },\n\n  getInverse: function getInverse(m, throwOnInvertible) {\n\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    var te = this.elements;\n    var me = m.elements;\n\n    var n11 = me[0],n12 = me[4],n13 = me[8],n14 = me[12];\n    var n21 = me[1],n22 = me[5],n23 = me[9],n24 = me[13];\n    var n31 = me[2],n32 = me[6],n33 = me[10],n34 = me[14];\n    var n41 = me[3],n42 = me[7],n43 = me[11],n44 = me[15];\n\n    te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n    te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n    te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n    te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\n    te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\n    te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\n    te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\n    te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\n    te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\n    te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\n    te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\n    te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\n    te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\n    te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\n    te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\n\n    var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];\n\n    if (det == 0) {\n\n      var msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n      if (throwOnInvertible || false) {\n\n        throw new Error(msg);\n\n      } else {\n\n        THREE.warn(msg);\n\n      }\n\n      this.identity();\n\n      return this;\n    }\n\n    this.multiplyScalar(1 / det);\n\n    return this;\n\n  },\n\n  translate: function translate(v) {\n\n    THREE.error('THREE.Matrix4: .translate() has been removed.');\n\n  },\n\n  rotateX: function rotateX(angle) {\n\n    THREE.error('THREE.Matrix4: .rotateX() has been removed.');\n\n  },\n\n  rotateY: function rotateY(angle) {\n\n    THREE.error('THREE.Matrix4: .rotateY() has been removed.');\n\n  },\n\n  rotateZ: function rotateZ(angle) {\n\n    THREE.error('THREE.Matrix4: .rotateZ() has been removed.');\n\n  },\n\n  rotateByAxis: function rotateByAxis(axis, angle) {\n\n    THREE.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n\n  },\n\n  scale: function scale(v) {\n\n    var te = this.elements;\n    var x = v.x,y = v.y,z = v.z;\n\n    te[0] *= x;te[4] *= y;te[8] *= z;\n    te[1] *= x;te[5] *= y;te[9] *= z;\n    te[2] *= x;te[6] *= y;te[10] *= z;\n    te[3] *= x;te[7] *= y;te[11] *= z;\n\n    return this;\n\n  },\n\n  getMaxScaleOnAxis: function getMaxScaleOnAxis() {\n\n    var te = this.elements;\n\n    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n    return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\n\n  },\n\n  makeTranslation: function makeTranslation(x, y, z) {\n\n    this.set(\n\n    1, 0, 0, x,\n    0, 1, 0, y,\n    0, 0, 1, z,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  makeRotationX: function makeRotationX(theta) {\n\n    var c = Math.cos(theta),s = Math.sin(theta);\n\n    this.set(\n\n    1, 0, 0, 0,\n    0, c, -s, 0,\n    0, s, c, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  makeRotationY: function makeRotationY(theta) {\n\n    var c = Math.cos(theta),s = Math.sin(theta);\n\n    this.set(\n\n    c, 0, s, 0,\n    0, 1, 0, 0,\n    -s, 0, c, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  makeRotationZ: function makeRotationZ(theta) {\n\n    var c = Math.cos(theta),s = Math.sin(theta);\n\n    this.set(\n\n    c, -s, 0, 0,\n    s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  makeRotationAxis: function makeRotationAxis(axis, angle) {\n\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    var t = 1 - c;\n    var x = axis.x,y = axis.y,z = axis.z;\n    var tx = t * x,ty = t * y;\n\n    this.set(\n\n    tx * x + c, tx * y - s * z, tx * z + s * y, 0,\n    tx * y + s * z, ty * y + c, ty * z - s * x, 0,\n    tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  makeScale: function makeScale(x, y, z) {\n\n    this.set(\n\n    x, 0, 0, 0,\n    0, y, 0, 0,\n    0, 0, z, 0,\n    0, 0, 0, 1);\n\n\n\n    return this;\n\n  },\n\n  compose: function compose(position, quaternion, scale) {\n\n    this.makeRotationFromQuaternion(quaternion);\n    this.scale(scale);\n    this.setPosition(position);\n\n    return this;\n\n  },\n\n  decompose: function () {\n\n    var vector = new THREE.Vector3();\n    var matrix = new THREE.Matrix4();\n\n    return function (position, quaternion, scale) {\n\n      var te = this.elements;\n\n      var sx = vector.set(te[0], te[1], te[2]).length();\n      var sy = vector.set(te[4], te[5], te[6]).length();\n      var sz = vector.set(te[8], te[9], te[10]).length();\n\n      // if determine is negative, we need to invert one scale\n      var det = this.determinant();\n      if (det < 0) {\n        sx = -sx;\n      }\n\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n\n      // scale the rotation part\n\n      matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()\n\n      var invSX = 1 / sx;\n      var invSY = 1 / sy;\n      var invSZ = 1 / sz;\n\n      matrix.elements[0] *= invSX;\n      matrix.elements[1] *= invSX;\n      matrix.elements[2] *= invSX;\n\n      matrix.elements[4] *= invSY;\n      matrix.elements[5] *= invSY;\n      matrix.elements[6] *= invSY;\n\n      matrix.elements[8] *= invSZ;\n      matrix.elements[9] *= invSZ;\n      matrix.elements[10] *= invSZ;\n\n      quaternion.setFromRotationMatrix(matrix);\n\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n\n      return this;\n\n    };\n\n  }(),\n\n  makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {\n\n    var te = this.elements;\n    var x = 2 * near / (right - left);\n    var y = 2 * near / (top - bottom);\n\n    var a = (right + left) / (right - left);\n    var b = (top + bottom) / (top - bottom);\n    var c = -(far + near) / (far - near);\n    var d = -2 * far * near / (far - near);\n\n    te[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\n    te[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\n    te[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\n    te[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\n\n    return this;\n\n  },\n\n  makePerspective: function makePerspective(fov, aspect, near, far) {\n\n    var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));\n    var ymin = -ymax;\n    var xmin = ymin * aspect;\n    var xmax = ymax * aspect;\n\n    return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\n\n  },\n\n  makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {\n\n    var te = this.elements;\n    var w = right - left;\n    var h = top - bottom;\n    var p = far - near;\n\n    var x = (right + left) / w;\n    var y = (top + bottom) / h;\n    var z = (far + near) / p;\n\n    te[0] = 2 / w;te[4] = 0;te[8] = 0;te[12] = -x;\n    te[1] = 0;te[5] = 2 / h;te[9] = 0;te[13] = -y;\n    te[2] = 0;te[6] = 0;te[10] = -2 / p;te[14] = -z;\n    te[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\n\n    return this;\n\n  },\n\n  fromArray: function fromArray(array) {\n\n    this.elements.set(array);\n\n    return this;\n\n  },\n\n  toArray: function toArray() {\n\n    var te = this.elements;\n\n    return [\n    te[0], te[1], te[2], te[3],\n    te[4], te[5], te[6], te[7],\n    te[8], te[9], te[10], te[11],\n    te[12], te[13], te[14], te[15]];\n\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Matrix4().fromArray(this.elements);\n\n  } };\n\n\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function (center, radius) {\n\n  this.center = center !== undefined ? center : new THREE.Vector3();\n  this.radius = radius !== undefined ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n  constructor: THREE.Sphere,\n\n  set: function set(center, radius) {\n\n    this.center.copy(center);\n    this.radius = radius;\n\n    return this;\n  },\n\n  setFromPoints: function () {\n\n    var box = new THREE.Box3();\n\n    return function (points, optionalCenter) {\n\n      var center = this.center;\n\n      if (optionalCenter !== undefined) {\n\n        center.copy(optionalCenter);\n\n      } else {\n\n        box.setFromPoints(points).center(center);\n\n      }\n\n      var maxRadiusSq = 0;\n\n      for (var i = 0, il = points.length; i < il; i++) {\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n\n      }\n\n      this.radius = Math.sqrt(maxRadiusSq);\n\n      return this;\n\n    };\n\n  }(),\n\n  copy: function copy(sphere) {\n\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n\n    return this;\n\n  },\n\n  empty: function empty() {\n\n    return this.radius <= 0;\n\n  },\n\n  containsPoint: function containsPoint(point) {\n\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n\n  },\n\n  distanceToPoint: function distanceToPoint(point) {\n\n    return point.distanceTo(this.center) - this.radius;\n\n  },\n\n  intersectsSphere: function intersectsSphere(sphere) {\n\n    var radiusSum = this.radius + sphere.radius;\n\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n\n  },\n\n  clampPoint: function clampPoint(point, optionalTarget) {\n\n    var deltaLengthSq = this.center.distanceToSquared(point);\n\n    var result = optionalTarget || new THREE.Vector3();\n    result.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n\n      result.sub(this.center).normalize();\n      result.multiplyScalar(this.radius).add(this.center);\n\n    }\n\n    return result;\n\n  },\n\n  getBoundingBox: function getBoundingBox(optionalTarget) {\n\n    var box = optionalTarget || new THREE.Box3();\n\n    box.set(this.center, this.center);\n    box.expandByScalar(this.radius);\n\n    return box;\n\n  },\n\n  applyMatrix4: function applyMatrix4(matrix) {\n\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n    return this;\n\n  },\n\n  translate: function translate(offset) {\n\n    this.center.add(offset);\n\n    return this;\n\n  },\n\n  equals: function equals(sphere) {\n\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Sphere().copy(this);\n\n  } };\n\n\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Frustum = function (p0, p1, p2, p3, p4, p5) {\n\n  this.planes = [\n\n  p0 !== undefined ? p0 : new THREE.Plane(),\n  p1 !== undefined ? p1 : new THREE.Plane(),\n  p2 !== undefined ? p2 : new THREE.Plane(),\n  p3 !== undefined ? p3 : new THREE.Plane(),\n  p4 !== undefined ? p4 : new THREE.Plane(),\n  p5 !== undefined ? p5 : new THREE.Plane()];\n\n\n\n};\n\nTHREE.Frustum.prototype = {\n\n  constructor: THREE.Frustum,\n\n  set: function set(p0, p1, p2, p3, p4, p5) {\n\n    var planes = this.planes;\n\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n\n    return this;\n\n  },\n\n  copy: function copy(frustum) {\n\n    var planes = this.planes;\n\n    for (var i = 0; i < 6; i++) {\n\n      planes[i].copy(frustum.planes[i]);\n\n    }\n\n    return this;\n\n  },\n\n  setFromMatrix: function setFromMatrix(m) {\n\n    var planes = this.planes;\n    var me = m.elements;\n    var me0 = me[0],me1 = me[1],me2 = me[2],me3 = me[3];\n    var me4 = me[4],me5 = me[5],me6 = me[6],me7 = me[7];\n    var me8 = me[8],me9 = me[9],me10 = me[10],me11 = me[11];\n    var me12 = me[12],me13 = me[13],me14 = me[14],me15 = me[15];\n\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\n    return this;\n\n  },\n\n  intersectsObject: function () {\n\n    var sphere = new THREE.Sphere();\n\n    return function (object) {\n\n      var geometry = object.geometry;\n\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      sphere.copy(geometry.boundingSphere);\n      sphere.applyMatrix4(object.matrixWorld);\n\n      return this.intersectsSphere(sphere);\n\n    };\n\n  }(),\n\n  intersectsSphere: function intersectsSphere(sphere) {\n\n    var planes = this.planes;\n    var center = sphere.center;\n    var negRadius = -sphere.radius;\n\n    for (var i = 0; i < 6; i++) {\n\n      var distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  },\n\n  intersectsBox: function () {\n\n    var p1 = new THREE.Vector3(),\n    p2 = new THREE.Vector3();\n\n    return function (box) {\n\n      var planes = this.planes;\n\n      for (var i = 0; i < 6; i++) {\n\n        var plane = planes[i];\n\n        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n        var d1 = plane.distanceToPoint(p1);\n        var d2 = plane.distanceToPoint(p2);\n\n        // if both outside plane, no intersection\n\n        if (d1 < 0 && d2 < 0) {\n\n          return false;\n\n        }\n      }\n\n      return true;\n    };\n\n  }(),\n\n\n  containsPoint: function containsPoint(point) {\n\n    var planes = this.planes;\n\n    for (var i = 0; i < 6; i++) {\n\n      if (planes[i].distanceToPoint(point) < 0) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Frustum().copy(this);\n\n  } };\n\n\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Plane = function (normal, constant) {\n\n  this.normal = normal !== undefined ? normal : new THREE.Vector3(1, 0, 0);\n  this.constant = constant !== undefined ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n  constructor: THREE.Plane,\n\n  set: function set(normal, constant) {\n\n    this.normal.copy(normal);\n    this.constant = constant;\n\n    return this;\n\n  },\n\n  setComponents: function setComponents(x, y, z, w) {\n\n    this.normal.set(x, y, z);\n    this.constant = w;\n\n    return this;\n\n  },\n\n  setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {\n\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized\n\n    return this;\n\n  },\n\n  setFromCoplanarPoints: function () {\n\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n\n    return function (a, b, c) {\n\n      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();\n\n      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n      this.setFromNormalAndCoplanarPoint(normal, a);\n\n      return this;\n\n    };\n\n  }(),\n\n\n  copy: function copy(plane) {\n\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n\n    return this;\n\n  },\n\n  normalize: function normalize() {\n\n    // Note: will lead to a divide by zero if the plane is invalid.\n\n    var inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n\n    return this;\n\n  },\n\n  negate: function negate() {\n\n    this.constant *= -1;\n    this.normal.negate();\n\n    return this;\n\n  },\n\n  distanceToPoint: function distanceToPoint(point) {\n\n    return this.normal.dot(point) + this.constant;\n\n  },\n\n  distanceToSphere: function distanceToSphere(sphere) {\n\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n\n  },\n\n  projectPoint: function projectPoint(point, optionalTarget) {\n\n    return this.orthoPoint(point, optionalTarget).sub(point).negate();\n\n  },\n\n  orthoPoint: function orthoPoint(point, optionalTarget) {\n\n    var perpendicularMagnitude = this.distanceToPoint(point);\n\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);\n\n  },\n\n  isIntersectionLine: function isIntersectionLine(line) {\n\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n    var startSign = this.distanceToPoint(line.start);\n    var endSign = this.distanceToPoint(line.end);\n\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n\n  },\n\n  intersectLine: function () {\n\n    var v1 = new THREE.Vector3();\n\n    return function (line, optionalTarget) {\n\n      var result = optionalTarget || new THREE.Vector3();\n\n      var direction = line.delta(v1);\n\n      var denominator = this.normal.dot(direction);\n\n      if (denominator == 0) {\n\n        // line is coplanar, return origin\n        if (this.distanceToPoint(line.start) == 0) {\n\n          return result.copy(line.start);\n\n        }\n\n        // Unsure if this is the correct method to handle this case.\n        return undefined;\n\n      }\n\n      var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n      if (t < 0 || t > 1) {\n\n        return undefined;\n\n      }\n\n      return result.copy(direction).multiplyScalar(t).add(line.start);\n\n    };\n\n  }(),\n\n\n  coplanarPoint: function coplanarPoint(optionalTarget) {\n\n    var result = optionalTarget || new THREE.Vector3();\n    return result.copy(this.normal).multiplyScalar(-this.constant);\n\n  },\n\n  applyMatrix4: function () {\n\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n    var m1 = new THREE.Matrix3();\n\n    return function (matrix, optionalNormalMatrix) {\n\n      // compute new normal based on theory here:\n      // http://www.songho.ca/opengl/gl_normaltransform.html\n      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);\n      var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);\n\n      var newCoplanarPoint = this.coplanarPoint(v2);\n      newCoplanarPoint.applyMatrix4(matrix);\n\n      this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);\n\n      return this;\n\n    };\n\n  }(),\n\n  translate: function translate(offset) {\n\n    this.constant = this.constant - offset.dot(this.normal);\n\n    return this;\n\n  },\n\n  equals: function equals(plane) {\n\n    return plane.normal.equals(this.normal) && plane.constant == this.constant;\n\n  },\n\n  clone: function clone() {\n\n    return new THREE.Plane().copy(this);\n\n  } };\n\n\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n  generateUUID: function () {\n\n    // http://www.broofa.com/Tools/Math.uuid.htm\n\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0,r;\n\n    return function () {\n\n      for (var i = 0; i < 36; i++) {\n\n        if (i == 8 || i == 13 || i == 18 || i == 23) {\n\n          uuid[i] = '-';\n\n        } else if (i == 14) {\n\n          uuid[i] = '4';\n\n        } else {\n\n          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n          r = rnd & 0xf;\n          rnd = rnd >> 4;\n          uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n\n        }\n      }\n\n      return uuid.join('');\n\n    };\n\n  }(),\n\n  // Clamp value to range <a, b>\n\n  clamp: function clamp(x, a, b) {\n\n    return x < a ? a : x > b ? b : x;\n\n  },\n\n  // Clamp value to range <a, inf)\n\n  clampBottom: function clampBottom(x, a) {\n\n    return x < a ? a : x;\n\n  },\n\n  // Linear mapping from range <a1, a2> to range <b1, b2>\n\n  mapLinear: function mapLinear(x, a1, a2, b1, b2) {\n\n    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n\n  },\n\n  // http://en.wikipedia.org/wiki/Smoothstep\n\n  smoothstep: function smoothstep(x, min, max) {\n\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n\n    x = (x - min) / (max - min);\n\n    return x * x * (3 - 2 * x);\n\n  },\n\n  smootherstep: function smootherstep(x, min, max) {\n\n    if (x <= min) return 0;\n    if (x >= max) return 1;\n\n    x = (x - min) / (max - min);\n\n    return x * x * x * (x * (x * 6 - 15) + 10);\n\n  },\n\n  // Random float from <0, 1> with 16 bits of randomness\n  // (standard Math.random() creates repetitive patterns when applied over larger space)\n\n  random16: function random16() {\n\n    return (65280 * Math.random() + 255 * Math.random()) / 65535;\n\n  },\n\n  // Random integer from <low, high> interval\n\n  randInt: function randInt(low, high) {\n\n    return Math.floor(this.randFloat(low, high));\n\n  },\n\n  // Random float from <low, high> interval\n\n  randFloat: function randFloat(low, high) {\n\n    return low + Math.random() * (high - low);\n\n  },\n\n  // Random float from <-range/2, range/2> interval\n\n  randFloatSpread: function randFloatSpread(range) {\n\n    return range * (0.5 - Math.random());\n\n  },\n\n  degToRad: function () {\n\n    var degreeToRadiansFactor = Math.PI / 180;\n\n    return function (degrees) {\n\n      return degrees * degreeToRadiansFactor;\n\n    };\n\n  }(),\n\n  radToDeg: function () {\n\n    var radianToDegreesFactor = 180 / Math.PI;\n\n    return function (radians) {\n\n      return radians * radianToDegreesFactor;\n\n    };\n\n  }(),\n\n  isPowerOfTwo: function isPowerOfTwo(value) {\n\n    return (value & value - 1) === 0 && value !== 0;\n\n  },\n\n  nextPowerOfTwo: function nextPowerOfTwo(value) {\n\n    value--;\n    value |= value >> 1;\n    value |= value >> 2;\n    value |= value >> 4;\n    value |= value >> 8;\n    value |= value >> 16;\n    value++;\n\n    return value;\n\n  } };\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/babel-loader/lib/index.js?!./extensions/Edit2D/SegmentTreeWorker.js\":\n/*!****************************************************************************************!*\\\n  !*** ./node_modules/babel-loader/lib??ref--4!./extensions/Edit2D/SegmentTreeWorker.js ***!\n  \\****************************************************************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_wgs_scene_VertexBufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/wgs/scene/VertexBufferReader */ \"./src/wgs/scene/VertexBufferReader.js\");\n\n\nvar primCountPerBatch = 5000; // The number of primitives per batch.\nvar numOfArgs = 8; // Number of arguments per primitive\nvar stride = numOfArgs + 1; // Number of arguments plus the position for the primitive type.\nvar size = stride * primCountPerBatch; // Size for the Float64Array\n\n// Allocate the number of arguments per primitive plus a position for the primitive type and multiply it by the batch count.\n// Float64Array is required because there were float arguments that contained more than 7 digits. \nvar primitiveBatch = new Float64Array(size);\n\nvar numGeoms = 0; // Number of geometries processed\nvar totalGeoms = 0; // Total number of geometries to process. This is passed in from the main thread.\nvar batchIndex = 0; // Keeps track of the batch index. When the limit is reached this will be reset.\n\n// Integers to write into the TypeArray for each primitive type\nvar primitiveTypes = {\n  onLineSegment: 1,\n  onCircularArc: 2,\n  onEllipticalArc: 3,\n  finished: 9 };\n\n\n/**\n                  * Batches geom primitives and sends it to the main thread once the primCountPerBatch is reached.\n                  * @param {String} type - Geometry Primitive type string\n                  * @param {Number[]} args - An array of arguments that are returned from the VertexBufferBuilder callbacks\n                  */\nfunction post(type) {var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // The first entry will be the primitive type\n  primitiveBatch[batchIndex++] = primitiveTypes[type];\n\n  // Add the arguments to the batch\n  for (var i = 0; i < numOfArgs; i++) {\n    primitiveBatch[batchIndex++] = i < args.length ? args[i] : 0;\n  }\n\n  // Message the main thread once the primitive count was reached or once the number of processed geometries reaches the total number of geometries\n  if (batchIndex >= primCountPerBatch * stride || numGeoms === totalGeoms) {\n    // Send existing batch and create a new batch\n    postMessage(primitiveBatch, [primitiveBatch.buffer]);\n\n    primitiveBatch = new Float64Array(size);\n    batchIndex = 0;\n  }\n}\n\nonmessage = function onmessage(e) {\n  // First call from the SegementTree.js\n  // This will initialize the geometry count and other global variables.\n  if (e.data.hasOwnProperty('totalGeoms')) {\n    totalGeoms = e.data.totalGeoms;\n    primitiveBatch = new Float64Array(size);\n    numGeoms = 0;\n    batchIndex = 0;\n    return;\n  }\n\n  // Iterate over an array of geometry objects.\n  // A geometry object contains information from the FragmentList that will be used by the VertexBufferReader.\n  for (var i = 0; i < e.data.length; i++) {\n    var geom = e.data[i];\n    var collectSegment = {\n      onLineSegment: function onLineSegment() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}return post('onLineSegment', args);},\n      onCircularArc: function onCircularArc() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}return post('onCircularArc', args);},\n      onEllipticalArc: function onEllipticalArc() {for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}return post('onEllipticalArc', args);} };\n\n    var vbr = new _src_wgs_scene_VertexBufferReader__WEBPACK_IMPORTED_MODULE_0__[\"VertexBufferReader\"](geom);\n\n    vbr.enumGeoms(null, collectSegment);\n    numGeoms++;\n  }\n\n  // Notify the main thread that a geometry was processed.\n  post('finished');\n};\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/buildin/module.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/module.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n\n/***/ \"./src/wgs/scene/VertexBufferReader.js\":\n/*!*********************************************!*\\\n  !*** ./src/wgs/scene/VertexBufferReader.js ***!\n  \\*********************************************/\n/*! exports provided: VertexBufferReader, BoundsCallback */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexBufferReader\", function() { return VertexBufferReader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundsCallback\", function() { return BoundsCallback; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./extensions/MemoryLimited/thirdparty/three.js/three-worker.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\nvar TAU = Math.PI * 2;\n\n//Constants duplicated from src/lmvtk/VertexBufferBuilder.js\nvar VBB_GT_TRIANGLE_INDEXED = 0,\nVBB_GT_LINE_SEGMENT = 1,\nVBB_GT_ARC_CIRCULAR = 2,\nVBB_GT_ARC_ELLIPTICAL = 3,\nVBB_GT_TEX_QUAD = 4,\nVBB_GT_ONE_TRIANGLE = 5;\n\nvar VBB_INSTANCED_FLAG = 0, // this is intentionally 0 for the instancing case!\nVBB_SEG_START_RIGHT = 0, // this starts intentionally at 0!\nVBB_SEG_START_LEFT = 1,\nVBB_SEG_END_RIGHT = 2,\nVBB_SEG_END_LEFT = 3;\n\nvar VBB_COLOR_OFFSET = 6,\nVBB_DBID_OFFSET = 7,\nVBB_FLAGS_OFFSET = 8,\nVBB_LAYER_VP_OFFSET = 9;\n\n/**\n                          * Initializes a \"view\" into a compacted interleaved vertex buffer array using our custom 2D vertex layout.\n                          * See src/lmvtk/VertexBufferBuilder.js for more details.\n                          */\nfunction VertexBufferReader(geometry)\n{var _geometry$tIdColor,_geometry$tIdColor$im,_this = this;\n  this.vb = geometry.vb.buffer;\n  this.vbf = new Float32Array(this.vb);\n  this.vbi = new Int32Array(this.vb);\n  this.vbs = new Uint16Array(this.vb);\n\n  this.ib = geometry.ib;\n\n  this.stride = geometry.vbstride;\n  this.vcount = this.vbf.length / this.stride;\n\n  this.useInstancing = geometry.numInstances > 0;\n  this.useCompactBuffers = geometry.unpackXform;\n  this.texData = this.useCompactBuffers && ((_geometry$tIdColor = geometry.tIdColor) === null || _geometry$tIdColor === void 0 ? void 0 : (_geometry$tIdColor$im = _geometry$tIdColor.image) === null || _geometry$tIdColor$im === void 0 ? void 0 : _geometry$tIdColor$im.data) && new Uint32Array(geometry.tIdColor.image.data.buffer);\n\n  // Does the geom use interleaved vb?\n  // Used by FragmentList.updateVertexBufferForThemingAndGhosting which only\n  // workes with interleaved vb\n  this.isInterleavedVb = function () {\n    var attr = geometry.attributes;\n    if (!attr) return false;\n\n    var atLayerVp = attr.layerVp4b;\n    var atFlags = attr.flags4b;\n\n    if (_this.useCompactBuffers) {\n      var atIdColors = attr.uvIdColor;\n      return atIdColors && atLayerVp && atFlags;\n    } else {\n      var atColors = attr.color4b;\n      var atIds = attr.dbId4b;\n      return atColors && atIds && atLayerVp && atFlags;\n    }\n  }();\n};\n\nVertexBufferReader.prototype.getDbIdAt = function (vindex) {\n  if (this.texData) {\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_DBID_OFFSET]];\n  }\n  return this.vbi[vindex * this.stride + VBB_DBID_OFFSET];\n};\n\nVertexBufferReader.prototype.getColorAt = function (vindex) {\n  if (this.texData) {\n    return this.texData[this.vbs[vindex * this.stride * 2 + VBB_COLOR_OFFSET]];\n  }\n  return this.vbi[vindex * this.stride + VBB_COLOR_OFFSET];\n};\n\nVertexBufferReader.prototype.getVertexFlagsAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 4];\n  }\n  return this.vbi[vindex * this.stride + VBB_FLAGS_OFFSET];\n};\n\nVertexBufferReader.prototype.getLayerIndexAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 5] & 0xffff;\n  }\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] & 0xffff;\n};\n\nVertexBufferReader.prototype.getViewportIndexAt = function (vindex) {\n  if (this.texData) {\n    return this.vbi[vindex * this.stride + 5] >> 16 & 0xffff;\n  }\n  return this.vbi[vindex * this.stride + VBB_LAYER_VP_OFFSET] >> 16 & 0xffff;\n};\n\nVertexBufferReader.prototype.decodeLineAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onLineSegment) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var x0 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y0 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var angle = this.vbs[vertexOffset + 2] / 65535 * TAU - Math.PI;\n    var distAlong = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    var lineWidth = this.vbs[vertexOffset + 4] / 32767 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y) * 2.0;\n  } else {\n    var baseOffset = this.stride * vindex;\n    var x0 = this.vbf[baseOffset];\n    var y0 = this.vbf[baseOffset + 1];\n    var angle = this.vbf[baseOffset + 2] * TAU - Math.PI; // decode angle: see VertexBufferBuilder.addVertexLine\n    var distAlong = this.vbf[baseOffset + 3];\n    var lineWidth = this.vbf[baseOffset + 4] * 2.0;\n  }\n\n  var x1 = x0 + distAlong * Math.cos(angle);\n  var y1 = y0 + distAlong * Math.sin(angle);\n\n  callback.onLineSegment(x0, y0, x1, y1, vpId, lineWidth);\n};\n\nVertexBufferReader.prototype.decodeCircularArcAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onCircularArc) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var cx = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var cy = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var start = this.vbs[vertexOffset + 2] / 65535 * TAU;\n    var end = this.vbs[vertexOffset + 3] / 65535 * TAU;\n    var radius = this.vbs[vertexOffset + 5] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n  } else {\n    var baseOffset = this.stride * vindex;\n    var cx = this.vbf[baseOffset];\n    var cy = this.vbf[baseOffset + 1];\n    var start = this.vbf[baseOffset + 2] * TAU;\n    var end = this.vbf[baseOffset + 3] * TAU;\n    var radius = this.vbf[baseOffset + 5];\n  }\n\n  callback.onCircularArc(cx, cy, start, end, radius, vpId);\n};\n\nVertexBufferReader.prototype.decodeEllipticalArcAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onEllipticalArc) {return;}\n\n  // Note: compaction will not happen for the VBB_GT_ARC_ELLIPTICAL\n  var baseOffset = this.stride * vindex;\n  var cx = this.vbf[baseOffset];\n  var cy = this.vbf[baseOffset + 1];\n  var start = this.vbf[baseOffset + 2] * TAU;\n  var end = this.vbf[baseOffset + 3] * TAU;\n  var major = this.vbf[baseOffset + 5];\n  var minor = this.vbf[baseOffset + 10];\n  var tilt = this.vbf[baseOffset + 11];\n\n  callback.onEllipticalArc(cx, cy, start, end, major, minor, tilt, vpId);\n};\n\nVertexBufferReader.prototype.decodeTexQuadAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onTexQuad) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var centerX = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var centerY = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var rotation = this.vbs[vertexOffset + 2] / 65535 * TAU;\n    var width = this.vbs[vertexOffset + 3] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n    var height = this.vbs[vertexOffset + 4] / 65535 * Math.max(this.useCompactBuffers.x, this.useCompactBuffers.y);\n  } else {\n    var baseOffset = this.stride * vindex;\n    var centerX = this.vbf[baseOffset];\n    var centerY = this.vbf[baseOffset + 1];\n    // yes, this is in a different order than output, following VertexBufferBuilder's order\n    var rotation = this.vbf[baseOffset + 2] * TAU;\n    var width = this.vbf[baseOffset + 3];\n    var height = this.vbf[baseOffset + 4];\n  }\n\n  callback.onTexQuad(centerX, centerY, width, height, rotation, vpId);\n};\n\nVertexBufferReader.prototype.decodeOneTriangleAt = function (vindex, layer, vpId, callback)\n{\n  if (!callback.onOneTriangle) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vindex * 2;\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset + 2] / 65535 + this.useCompactBuffers.z;\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 3] / 65535 + this.useCompactBuffers.w;\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset + 4] / 65535 + this.useCompactBuffers.z;\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 5] / 65535 + this.useCompactBuffers.w;\n  } else {\n    var baseOffset = this.stride * vindex;\n    var x1 = this.vbf[baseOffset];\n    var y1 = this.vbf[baseOffset + 1];\n    var x2 = this.vbf[baseOffset + 2];\n    var y2 = this.vbf[baseOffset + 3];\n    var x3 = this.vbf[baseOffset + 4];\n    var y3 = this.vbf[baseOffset + 5];\n  }\n\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\nVertexBufferReader.prototype.decodeTriangleIndexed = function (vi0, vi1, vi2, layer, vpId, callback)\n{\n  if (!callback.onOneTriangle) {return;}\n\n  if (this.useCompactBuffers) {\n    var vertexOffset = this.stride * vi0 * 2;\n    var x1 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y1 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n\n    vertexOffset = this.stride * vi1 * 2;\n    var x2 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y2 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n\n    vertexOffset = this.stride * vi2 * 2;\n    var x3 = this.useCompactBuffers.x * this.vbs[vertexOffset] / 65535 + this.useCompactBuffers.z;\n    var y3 = this.useCompactBuffers.y * this.vbs[vertexOffset + 1] / 65535 + this.useCompactBuffers.w;\n  } else {\n    var baseOffset = this.stride * vi0;\n    var x1 = this.vbf[baseOffset];\n    var y1 = this.vbf[baseOffset + 1];\n\n    baseOffset = this.stride * vi1;\n    var x2 = this.vbf[baseOffset];\n    var y2 = this.vbf[baseOffset + 1];\n\n    baseOffset = this.stride * vi2;\n    var x3 = this.vbf[baseOffset];\n    var y3 = this.vbf[baseOffset + 1];\n  }\n\n  callback.onOneTriangle(x1, y1, x2, y2, x3, y3, vpId);\n};\n\n\n// used by the snapper and by the bounds finder\nVertexBufferReader.prototype.enumGeomsForObject = function (dbId, callback)\n{\n  if (this.useInstancing) {\n\n    //When instancing is used, each geometry primitive is encoded into a single vertex\n    //and there is no index buffer.\n\n    var i = 0;\n    while (i < this.vcount) {\n      var flag = this.getVertexFlagsAt(i);\n\n      //var vertexId  = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;      //  8 bit\n      var layerId = this.getLayerIndexAt(i); // 16 bit\n      var vpId = this.getViewportIndexAt(i); // 16 bit     \n      var visible = this.getDbIdAt(i) === dbId;\n      if (visible) {\n        switch (geomType) {\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break; //  compaction is not performed\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\n          default:break;}\n\n      }\n\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\n      //move to the next vertex\n      i += 1;\n    }\n  } else {\n\n    var i = 0;\n    while (i < this.ib.length) {\n      var vi = this.ib[i];\n      var flag = this.getVertexFlagsAt(vi);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\n\n      var visible = this.getDbIdAt(vi) === dbId;\n\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n        if (visible) {\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\n        }\n\n        //Advance to the next primitive\n        i += 3;\n\n      } else {\n\n        if (visible) {\n          switch (geomType) {\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\n            default:break;}\n\n        }\n\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n        //each vertex is listed four times with a different vertexId flag\n        i += 6;\n      }\n\n\n    }\n  }\n\n};\n\n\n/**\n    * Used by the bounds finder.\n    * @param {array[number]} layerIdsVisible - list of layer ids that are visible\n    * @param {function} callback\n    * @private\n    */\nVertexBufferReader.prototype.enumGeomsForVisibleLayer = function (layerIdsVisible, callback)\n{\n  var filter = function filter(dbId, layerId, viewportId) {\n    return !layerIdsVisible || layerId !== 0 && layerIdsVisible.indexOf(layerId) !== -1;\n  };\n  this.enumGeoms(filter, callback);\n};\n\n\n/**\n    * Enumerate all geometric primitives that match the given filter.\n    * @param {function} [filter] - function(dbId, layerId, viewportId): Filter function to define a subset of primitives to include. By default, all geometry is included.\n    * @param {function} callback\n    * @private\n    */\nVertexBufferReader.prototype.enumGeoms = function (filter, callback)\n{\n  if (this.useInstancing) {\n\n    //When instancing is used, each geometry primitive is encoded into a single vertex\n    //and there is no index buffer.\n\n    var i = 0;\n    while (i < this.vcount) {\n      var flag = this.getVertexFlagsAt(i);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(i); // 16 bit\n      var vpId = this.getViewportIndexAt(i); // 16 bit\n      var dbId = this.getDbIdAt(i);\n\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n      // If layerId visibility is not set, consider the layer visible.\n      var visible = !filter || filter(dbId, layerId, vpId);\n      if (visible) {\n        switch (geomType) {\n          case VBB_GT_LINE_SEGMENT:this.decodeLineAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(i, layerId, vpId, callback);break;\n          case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(i, layerId, vpId, callback);break;\n          case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(i, layerId, vpId, callback);break;\n          default:break;}\n\n      }\n\n      //In the case of instancing, there is no vertex duplication and no index buffer, we just\n      //move to the next vertex\n      i += 1;\n    }\n  } else {\n\n    var i = 0;\n    while (i < this.ib.length) {\n      var vi = this.ib[i];\n      var flag = this.getVertexFlagsAt(vi);\n\n      //var vertexId    = (flag >>  0) & 0xff;        //  8 bit\n      var geomType = flag >> 8 & 0xff; //  8 bit\n      //var linePattern = (flag >> 16) & 0xff;        //  8 bit\n      var layerId = this.getLayerIndexAt(vi); // 16 bit\n      var vpId = this.getViewportIndexAt(vi); // 16 bit\n      var dbId = this.getDbIdAt(vi);\n\n      // Get the bounds of only the visible layers. Ignore layer 0, which is always the page.\n      // If layerId visibility is not set, consider the layer visible.\n      var visible = !filter || filter(dbId, layerId, vpId);\n\n      if (geomType === VBB_GT_TRIANGLE_INDEXED) {\n\n        //Triangles are encoded in three vertices (like a simple mesh) instead of 4 like everything else\n\n        if (visible) {\n          this.decodeTriangleIndexed(this.ib[i], this.ib[i + 1], this.ib[i + 2], layerId, vpId, callback);\n        }\n\n        //Advance to the next primitive\n        i += 3;\n\n      } else {\n\n        if (visible) {\n          switch (geomType) {\n            case VBB_GT_LINE_SEGMENT:this.decodeLineAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_CIRCULAR:this.decodeCircularArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ARC_ELLIPTICAL:this.decodeEllipticalArcAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_TEX_QUAD:this.decodeTexQuadAt(vi, layerId, vpId, callback);break;\n            case VBB_GT_ONE_TRIANGLE:this.decodeOneTriangleAt(vi, layerId, vpId, callback);break;\n            default:break;}\n\n        }\n\n        //Skip duplicate vertices (when not using instancing and the geometry is not a simple polytriangle,\n        //each vertex is listed four times with a different vertexId flag\n        i += 6;\n      }\n\n    }\n  }\n\n};\n\n\n\n/**\n    * Callback class for calculating bounds of 2D objects via VertexBufferReader\n    * @private\n    */\nfunction BoundsCallback(bounds) {\n  this.bounds = bounds;\n  // workspace, so we don't reallocate this each time\n  this.point = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"]();\n  this.point.z = 0.0;\n  this.point.w = 1.0; // it's a point, not a vector\n}\n\nBoundsCallback.prototype.onVertex = function (cx, cy, vpId) {\n  this.point.x = cx;\n  this.point.y = cy;\n  this.bounds.expandByPoint(this.point);\n};\n\nBoundsCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n  this.onVertex(x1, y1);\n  this.onVertex(x2, y2);\n};\n\nBoundsCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n  this.onEllipticalArc(cx, cy, start, end, radius, radius, 0.0, vpId);\n};\n\nBoundsCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n  if (tilt == 0.0) {\n    // does start and end make a full ellipse?\n    if (start <= 0 && end >= 2.0 * Math.PI - 0.00001) {\n      // full way around, simply treat it like a rectangle\n      this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\n    } else {\n      // Not a full ellipse. We take the start and end points and also figure\n      // out the four \"compass rose\" points that are between these two locations.\n      // The start and end locations often exist as separate vertices so would\n      // already be included, but for some line types they may not exist, so we\n      // include them here.\n      this.point.x = cx + Math.cos(start) * major;\n      this.point.y = cy + Math.sin(start) * minor;\n      this.bounds.expandByPoint(this.point);\n      this.point.x = cx + Math.cos(end) * major;\n      this.point.y = cy + Math.sin(end) * minor;\n      this.bounds.expandByPoint(this.point);\n\n      // now check each NESW compass point, i.e., middle of each edge\n      if (start > end) {\n        // add right edge\n        this.point.x = cx + major;\n        this.point.y = cy;\n        this.bounds.expandByPoint(this.point);\n        // make start < end for the rest of the tests\n        start -= 2.0 * Math.PI;\n      }\n      if (start < 0.5 * Math.PI && end > 0.5 * Math.PI) {\n        // add top edge\n        this.point.x = cx;\n        this.point.y = cy + minor;\n        this.bounds.expandByPoint(this.point);\n      }\n      if (start < Math.PI && end > Math.PI) {\n        // add left edge\n        this.point.x = cx - major;\n        this.point.y = cy;\n        this.bounds.expandByPoint(this.point);\n      }\n      if (start < 1.5 * Math.PI && end > 1.5 * Math.PI) {\n        // add bottom edge\n        this.point.x = cx;\n        this.point.y = cy - minor;\n        this.bounds.expandByPoint(this.point);\n      }\n    }\n  } else {\n    // Has a tilt.\n    // From what we see, you should never reach here, as tilted ellipses are actually\n    // always tessellated. So, we do a fallback: call the onTexQuad with the rotation.\n    // This call will be a pretty good approximation, putting a rotated bounding box\n    // around the whole ellipse. For more accuracy you would need to tessellate the\n    // ellipse and get its points (especially if you don't have a full ellipse).\n    this.onTexQuad(cx, cy, 2 * major, 2 * minor, tilt, vpId);\n\n    // does start and end make a full ellipse?\n    //if ( (start <= 0) && (end >= 2.0 * Math.PI - 0.00001) ) {\n    //}\n  }\n};\n\n// Currently this case does not actually come up, as textured quads, i.e., images, are\n// not something that can be selected, from what data I have tried. So I have not spent\n// any time on the rotated case.\n// TODO: this code is only partially tested: I had problems getting a selectable raster\n// object in a DWG convert to an F2D.\nBoundsCallback.prototype.onTexQuad = function (centerX, centerY, width, height, rotation, vpId) {\n  var halfWidth = 0.5 * width;\n  var halfHeight = 0.5 * width;\n  if (rotation == 0.0) {\n    this.onVertex(centerX - halfWidth, centerY - halfHeight);\n    this.onVertex(centerX + halfWidth, centerY + halfHeight);\n  } else {\n    // A more complex rectangle, rotated. Take the four corners and rotate each\n    // around the center.\n    var rmtx = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"](); // Matrix3() does not have enough helper methods\n    var mtx = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\n    // Take a rectangle centered at the origin, rotate it, translate it to the final\n    // position. Each corner is added to the bounds.\n    rmtx.makeRotationZ(rotation);\n    // put it into the final position:\n    mtx.makeTranslation(centerX, centerY, 0.0);\n    mtx.multiply(rmtx);\n\n    for (var i = 0; i < 4; i++) {\n      this.point.x = i % 2 == 1 ? halfWidth : -halfWidth;\n      this.point.y = i >= 2 ? halfHeight : -halfHeight;\n      this.point.applyMatrix4(mtx);\n      this.bounds.expandByPoint(this.point);\n    }\n  }\n};\n\nBoundsCallback.prototype.onOneTriangle = function (x1, y1, x2, y2, x3, y3, vpId) {\n  this.onVertex(x1, y1);\n  this.onVertex(x2, y2);\n  this.onVertex(x3, y3);\n};\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=be49a3a7a178e96a40a0.worker.js.map", __webpack_require__.p + "be49a3a7a178e96a40a0.worker.js");
};

/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./res/locales/cs/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/cs/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"cs\",\"@@context\":\"Rozen Edit2D\",\"Apply as Cutout\":\"Pout jako vez\",\"Remove Shapes\":\"Odebrat tvary\",\"Unify Shapes\":\"Sjednotit tvary\",\"Remove Vertex\":\"Odebrat vrchol\",\"Insert Vertex\":\"Vloit vrchol\",\"Change to Line Segment\":\"Zmnit na sekov segment\",\"Change to Arc Segment\":\"Zmnit na obloukov segment\",\"Change to Ellipse Segment\":\"Zmnit na segment elipsy\",\"Remove Shape\":\"Odebrat tvar\",\"Remove Shape Part\":\"Odebrat soust tvaru\",\"Remove Hole\":\"Odebrat dru\",\"Remove Loop\":\"Odebrat smyku\",\"Invalid shape\":\"Chyba: Neplatn tvar\"}");

/***/ }),

/***/ "./res/locales/da/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/da/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"da\",\"@@context\":\"Edit2D-udvidelse\",\"Apply as Cutout\":\"Anvend som udskring\",\"Remove Shapes\":\"Fjern former\",\"Unify Shapes\":\"Ensret former\",\"Remove Vertex\":\"Fjern toppunkt\",\"Insert Vertex\":\"Indst toppunkt\",\"Change to Line Segment\":\"Skift til linjesegment\",\"Change to Arc Segment\":\"Skift til buesegment\",\"Change to Ellipse Segment\":\"Skift til ellipsesegment\",\"Remove Shape\":\"Fjern form\",\"Remove Shape Part\":\"Fjern formdel\",\"Remove Hole\":\"Fjern hul\",\"Remove Loop\":\"Fjern loop\",\"Invalid shape\":\"Fejl: Ugyldig form\"}");

/***/ }),

/***/ "./res/locales/de/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/de/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"de\",\"@@context\":\"2D-Erweiterung bearbeiten\",\"Apply as Cutout\":\"Als Aussparung anwenden\",\"Remove Shapes\":\"Konturen entfernen\",\"Unify Shapes\":\"Konturen vereinigen\",\"Remove Vertex\":\"Scheitelpunkt entfernen\",\"Insert Vertex\":\"Scheitelpunkt einfgen\",\"Change to Line Segment\":\"In Liniensegment ndern\",\"Change to Arc Segment\":\"In Bogensegment ndern\",\"Change to Ellipse Segment\":\"In Ellipsensegment ndern\",\"Remove Shape\":\"Kontur entfernen\",\"Remove Shape Part\":\"Formteil entfernen\",\"Remove Hole\":\"Aussparung entfernen\",\"Remove Loop\":\"Schleife entfernen\",\"Invalid shape\":\"Fehler: Ungltige Form\"}");

/***/ }),

/***/ "./res/locales/en-GB/nobundle-edit2d.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/en-GB/nobundle-edit2d.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Edit2D Extension\",\"Apply as Cutout\":\"Apply as Cutout\",\"Remove Shapes\":\"Remove Shapes\",\"Unify Shapes\":\"Unify Shapes\",\"Remove Vertex\":\"Remove Vertex\",\"Insert Vertex\":\"Insert Vertex\",\"Change to Line Segment\":\"Change to Line Segment\",\"Change to Arc Segment\":\"Change to Arc Segment\",\"Change to Ellipse Segment\":\"Change to Ellipse Segment\",\"Remove Shape\":\"Remove Shape\",\"Remove Shape Part\":\"Remove Shape Part\",\"Remove Hole\":\"Remove Hole\",\"Remove Loop\":\"Remove Loop\",\"Invalid shape\":\"Error: Invalid shape\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/en/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Edit2D Extension\",\"Apply as Cutout\":\"Apply as Cutout\",\"Remove Shapes\":\"Remove Shapes\",\"Unify Shapes\":\"Unify Shapes\",\"Remove Vertex\":\"Remove Vertex\",\"Insert Vertex\":\"Insert Vertex\",\"Change to Line Segment\":\"Change to Line Segment\",\"Change to Arc Segment\":\"Change to Arc Segment\",\"Change to Ellipse Segment\":\"Change to Ellipse Segment\",\"Remove Shape\":\"Remove Shape\",\"Remove Shape Part\":\"Remove Shape Part\",\"Remove Hole\":\"Remove Hole\",\"Remove Loop\":\"Remove Loop\",\"Invalid shape\":\"Error: Invalid shape\"}");

/***/ }),

/***/ "./res/locales/es/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/es/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"es\",\"@@context\":\"Edit2D Extension\",\"Apply as Cutout\":\"Aplicar como corte\",\"Remove Shapes\":\"Eliminar formas\",\"Unify Shapes\":\"Unificar formas\",\"Remove Vertex\":\"Eliminar vrtice\",\"Insert Vertex\":\"Insertar vrtice\",\"Change to Line Segment\":\"Cambiar a segmento de lnea\",\"Change to Arc Segment\":\"Cambiar a segmento de arco\",\"Change to Ellipse Segment\":\"Cambiar a segmento de elipse\",\"Remove Shape\":\"Eliminar forma\",\"Remove Shape Part\":\"Eliminar parte de forma\",\"Remove Hole\":\"Eliminar agujero\",\"Remove Loop\":\"Eliminar bucle\",\"Invalid shape\":\"Error: forma no vlida\"}");

/***/ }),

/***/ "./res/locales/fr-CA/nobundle-edit2d.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/fr-CA/nobundle-edit2d.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr-CA\",\"@@context\":\"Extension Edit2D\",\"Apply as Cutout\":\"Appliquer en tant que dcoupe\",\"Remove Shapes\":\"Supprimer les formes\",\"Unify Shapes\":\"Unifier les formes\",\"Remove Vertex\":\"Supprimer le sommet\",\"Insert Vertex\":\"Insrer un sommet\",\"Change to Line Segment\":\"Modifier en segment de ligne\",\"Change to Arc Segment\":\"Modifier en segment d'arc\",\"Change to Ellipse Segment\":\"Modifier en segment d'ellipse\",\"Remove Shape\":\"Supprimer la forme\",\"Remove Shape Part\":\"Supprimer la partie de la forme\",\"Remove Hole\":\"Supprimer le trou\",\"Remove Loop\":\"Supprimer la boucle\",\"Invalid shape\":\"Erreur: forme incorrecte\"}");

/***/ }),

/***/ "./res/locales/fr/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/fr/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr_fr\",\"@@context\":\"Modifier l'extension 2D\",\"Apply as Cutout\":\"Appliquer comme dcoupe\",\"Remove Shapes\":\"Supprimer les formes\",\"Unify Shapes\":\"Unifier les formes\",\"Remove Vertex\":\"Supprimer le sommet\",\"Insert Vertex\":\"Insrer un sommet\",\"Change to Line Segment\":\"Changer en segment de ligne\",\"Change to Arc Segment\":\"Changer en segment d'arc\",\"Change to Ellipse Segment\":\"Changer en segment d'ellipse\",\"Remove Shape\":\"Supprimer la forme\",\"Remove Shape Part\":\"Supprimer la pice de forme\",\"Remove Hole\":\"Supprimer le perage\",\"Remove Loop\":\"Supprimer la boucle\",\"Invalid shape\":\"Erreur: forme incorrecte\"}");

/***/ }),

/***/ "./res/locales/it/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/it/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"it\",\"@@context\":\"Modifica estensione 2D\",\"Apply as Cutout\":\"Applica come ritaglio\",\"Remove Shapes\":\"Rimuovi forme\",\"Unify Shapes\":\"Unifica forme\",\"Remove Vertex\":\"Rimuovi vertice\",\"Insert Vertex\":\"Inserisci vertice\",\"Change to Line Segment\":\"Cambia in segmento di linea\",\"Change to Arc Segment\":\"Cambia in segmento di arco\",\"Change to Ellipse Segment\":\"Cambia in segmento di ellisse\",\"Remove Shape\":\"Rimuovi forma\",\"Remove Shape Part\":\"Rimuovi parte forma\",\"Remove Hole\":\"Rimuovi foro\",\"Remove Loop\":\"Rimuovi linea chiusa\",\"Invalid shape\":\"Errore: forma non valida\"}");

/***/ }),

/***/ "./res/locales/ja/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/ja/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ja\",\"@@context\":\"2D Extension \",\"Apply as Cutout\":\"\",\"Remove Shapes\":\"\",\"Unify Shapes\":\"\",\"Remove Vertex\":\"\",\"Insert Vertex\":\"\",\"Change to Line Segment\":\"\",\"Change to Arc Segment\":\"\",\"Change to Ellipse Segment\":\"\",\"Remove Shape\":\"\",\"Remove Shape Part\":\" \",\"Remove Hole\":\"\",\"Remove Loop\":\"\",\"Invalid shape\":\": \"}");

/***/ }),

/***/ "./res/locales/ko/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/ko/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ko\",\"@@context\":\"Edit2D \",\"Apply as Cutout\":\" \",\"Remove Shapes\":\" \",\"Unify Shapes\":\" \",\"Remove Vertex\":\" \",\"Insert Vertex\":\" \",\"Change to Line Segment\":\"  \",\"Change to Arc Segment\":\"  \",\"Change to Ellipse Segment\":\"  \",\"Remove Shape\":\" \",\"Remove Shape Part\":\"  \",\"Remove Hole\":\" \",\"Remove Loop\":\" \",\"Invalid shape\":\":  \"}");

/***/ }),

/***/ "./res/locales/nl/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/nl/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"nl\",\"@@context\":\"Edit2D-uitbreiding\",\"Apply as Cutout\":\"Toepassen als uitsnijding\",\"Remove Shapes\":\"Vormen verwijderen\",\"Unify Shapes\":\"Vormen uniform maken\",\"Remove Vertex\":\"Vertex verwijderen\",\"Insert Vertex\":\"Vertex invoegen\",\"Change to Line Segment\":\"Wijzigen in lijnsegment\",\"Change to Arc Segment\":\"Wijzigen in boogsegment\",\"Change to Ellipse Segment\":\"Wijzigen in ellipssegment\",\"Remove Shape\":\"Vorm verwijderen\",\"Remove Shape Part\":\"Vormgedeelte verwijderen\",\"Remove Hole\":\"Gat verwijderen\",\"Remove Loop\":\"Lus verwijderen\",\"Invalid shape\":\"Fout: Ongeldige vorm\"}");

/***/ }),

/***/ "./res/locales/pl/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/pl/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pl\",\"@@context\":\"Rozszerzenie Edit2D\",\"Apply as Cutout\":\"Zastosuj jako wycicie\",\"Remove Shapes\":\"Usu ksztaty\",\"Unify Shapes\":\"Ujednoli ksztaty\",\"Remove Vertex\":\"Usu wierzchoek\",\"Insert Vertex\":\"Wstaw wierzchoek\",\"Change to Line Segment\":\"Zmie na segment linii\",\"Change to Arc Segment\":\"Zmie na segment uku\",\"Change to Ellipse Segment\":\"Zmie na segment elipsy\",\"Remove Shape\":\"Usu ksztat\",\"Remove Shape Part\":\"Usu cz ksztatu\",\"Remove Hole\":\"Usu otwr\",\"Remove Loop\":\"Usu ptl\",\"Invalid shape\":\"Bd: nieprawidowy ksztat\"}");

/***/ }),

/***/ "./res/locales/pt-BR/nobundle-edit2d.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/pt-BR/nobundle-edit2d.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ptb\",\"@@context\":\"Extenso Edit2D\",\"Apply as Cutout\":\"Aplicar como corte\",\"Remove Shapes\":\"Remover formas\",\"Unify Shapes\":\"Unificar formas\",\"Remove Vertex\":\"Remover vrtice\",\"Insert Vertex\":\"Inserir vrtice\",\"Change to Line Segment\":\"Alterar para segmento de linha\",\"Change to Arc Segment\":\"Alterar para segmento de arco\",\"Change to Ellipse Segment\":\"Alterar para segmento de elipse\",\"Remove Shape\":\"Remover forma\",\"Remove Shape Part\":\"Remover pea de forma\",\"Remove Hole\":\"Remover furo\",\"Remove Loop\":\"Remover loop\",\"Invalid shape\":\"Erro: Forma invlida\"}");

/***/ }),

/***/ "./res/locales/ru/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/ru/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ru\",\"@@context\":\" Edit2D\",\"Apply as Cutout\":\"  \",\"Remove Shapes\":\" \",\"Unify Shapes\":\" \",\"Remove Vertex\":\" \",\"Insert Vertex\":\" \",\"Change to Line Segment\":\"   \",\"Change to Arc Segment\":\"   \",\"Change to Ellipse Segment\":\"   \",\"Remove Shape\":\" \",\"Remove Shape Part\":\"  \",\"Remove Hole\":\" \",\"Remove Loop\":\" \",\"Invalid shape\":\":  \"}");

/***/ }),

/***/ "./res/locales/sv/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/sv/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"sv\",\"@@context\":\"Edit2D-tillgg\",\"Apply as Cutout\":\"Anvnd som utsnitt\",\"Remove Shapes\":\"Ta bort former\",\"Unify Shapes\":\"Unifiera former\",\"Remove Vertex\":\"Ta bort Vertex\",\"Insert Vertex\":\"Infoga Vertex\",\"Change to Line Segment\":\"ndra till linjesegment\",\"Change to Arc Segment\":\"ndra till bgsegment\",\"Change to Ellipse Segment\":\"ndra till ellipssegment\",\"Remove Shape\":\"Ta bort form\",\"Remove Shape Part\":\"Ta bort del av form\",\"Remove Hole\":\"Ta bort hl\",\"Remove Loop\":\"Ta bort slinga\",\"Invalid shape\":\"Fel: felaktig form\"}");

/***/ }),

/***/ "./res/locales/tr/nobundle-edit2d.loc.json":
/*!*************************************************!*\
  !*** ./res/locales/tr/nobundle-edit2d.loc.json ***!
  \*************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"tr\",\"@@context\":\"Edit2D Uzants\",\"Apply as Cutout\":\"Kesim Olarak Uygula\",\"Remove Shapes\":\"ekilleri Kaldr\",\"Unify Shapes\":\"ekilleri Birletir\",\"Remove Vertex\":\"Tepe Noktay Kaldr\",\"Insert Vertex\":\"Tepe Nokta Ekle\",\"Change to Line Segment\":\"izgi Segmetine Deitir\",\"Change to Arc Segment\":\"Yay Segmentine Deitir\",\"Change to Ellipse Segment\":\"Elips Segmentine Deitir\",\"Remove Shape\":\"ekli Kaldr\",\"Remove Shape Part\":\"ekil Parasn Kaldr\",\"Remove Hole\":\"Delii Kaldr\",\"Remove Loop\":\"Dngy Kaldr\",\"Invalid shape\":\"Hata: Geersiz ekil\"}");

/***/ }),

/***/ "./res/locales/zh-HANS/nobundle-edit2d.loc.json":
/*!******************************************************!*\
  !*** ./res/locales/zh-HANS/nobundle-edit2d.loc.json ***!
  \******************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hans\",\"@@context\":\"\",\"Apply as Cutout\":\"\",\"Remove Shapes\":\"\",\"Unify Shapes\":\"\",\"Remove Vertex\":\"\",\"Insert Vertex\":\"\",\"Change to Line Segment\":\"\",\"Change to Arc Segment\":\"\",\"Change to Ellipse Segment\":\"\",\"Remove Shape\":\"\",\"Remove Shape Part\":\"\",\"Remove Hole\":\"\",\"Remove Loop\":\"\",\"Invalid shape\":\": \"}");

/***/ }),

/***/ "./res/locales/zh-HANT/nobundle-edit2d.loc.json":
/*!******************************************************!*\
  !*** ./res/locales/zh-HANT/nobundle-edit2d.loc.json ***!
  \******************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hant\",\"@@context\":\"Edit2D \",\"Apply as Cutout\":\"\",\"Remove Shapes\":\"\",\"Unify Shapes\":\"\",\"Remove Vertex\":\"\",\"Insert Vertex\":\"\",\"Change to Line Segment\":\"\",\"Change to Arc Segment\":\"\",\"Change to Ellipse Segment\":\"\",\"Remove Shape\":\"\",\"Remove Shape Part\":\"\",\"Remove Hole\":\"\",\"Remove Loop\":\"\",\"Invalid shape\":\": \"}");

/***/ }),

/***/ "./res/locales/zh-HK/nobundle-edit2d.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/zh-HK/nobundle-edit2d.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Apply as Cutout, Remove Shapes, Unify Shapes, Remove Vertex, Insert Vertex, Change to Line Segment, Change to Arc Segment, Change to Ellipse Segment, Remove Shape, Remove Shape Part, Remove Hole, Remove Loop, Invalid shape, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-hk\",\"@@context\":\" 2D \",\"Apply as Cutout\":\"\",\"Remove Shapes\":\"\",\"Unify Shapes\":\"\",\"Remove Vertex\":\"\",\"Insert Vertex\":\"\",\"Change to Line Segment\":\"\",\"Change to Arc Segment\":\"\",\"Change to Ellipse Segment\":\"\",\"Remove Shape\":\"\",\"Remove Shape Part\":\"\",\"Remove Hole\":\"\",\"Remove Loop\":\"\",\"Invalid shape\":\"\"}");

/***/ })

/******/ });
//# sourceMappingURL=Edit2D.js.map