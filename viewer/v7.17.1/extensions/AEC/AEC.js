/*!
 * LMV v7.17.1
 * 
 * Copyright 2020 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.AEC =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/AEC/LibraryExports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/AEC/Avatar/Avatar.scss":
/*!*******************************************!*\
  !*** ./extensions/AEC/Avatar/Avatar.scss ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./Avatar.scss */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarEvents.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarEvents.js ***!
  \***********************************************/
/*! exports provided: AvatarEvents */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AvatarEvents", function() { return AvatarEvents; });
var AvatarEvents = {
  DRAG_START_EVENT: 'dragStart',
  DRAG_MOVE_EVENT: 'dragMove',
  DRAG_END_EVENT: 'dragEnd',
  ROTATE_START_EVENT: 'rotateStart',
  ROTATE_MOVE_EVENT: 'rotateMove',
  ROTATE_END_EVENT: 'rotateEnd' };

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarExtension.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarExtension.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarExtension; });
/* harmony import */ var _AvatarWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AvatarWidget */ "./extensions/AEC/Avatar/AvatarWidget.js");
/* harmony import */ var _SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SheetSync/SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../SheetSync/SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}



var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.AvatarExtension';

var FOCUS_DURATION = 2.0;

/**
                          // AvatarExtension - A viewer extension that displays an avatar on a 2D sheet, based on a targetViewer's 3D camera.
                          // @param {Viewer3D} [viewer]                            - viewer instance
                          // @param {Object} [options]                             - Configuration options for AvatarExtension
                          */var
AvatarExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(AvatarExtension, _Autodesk$Viewing$Ext);
  function AvatarExtension(viewer, options) {var _this;_classCallCheck(this, AvatarExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(AvatarExtension).call(this, viewer, options));

    _this.options = _this.options.avatarOptions || _this.options;

    // Auto focus camera on avatar.
    _this.autoFocus = _this.options.autoFocus === undefined ? true : _this.options.autoFocus;

    // Indicates if the avatar is currently out of focus.
    _this.outOfFocus = true;

    // Time to focus the camera on avatar.
    _this.focusDuration = FOCUS_DURATION;

    // Last 3D camera position.
    _this.last3dCameraPos = new THREE.Vector3();

    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));
    _this.on3dCameraChanged = _this.on3dCameraChanged.bind(_assertThisInitialized(_this));
    _this.onSheetCameraChanged = _this.onSheetCameraChanged.bind(_assertThisInitialized(_this));
    _this.onDragStart = _this.onDragStart.bind(_assertThisInitialized(_this));
    _this.onDragEnd = _this.onDragEnd.bind(_assertThisInitialized(_this));return _this;
  }_createClass(AvatarExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var transforms;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;

                this.targetViewer = this.sheetSyncExt.targetViewer;

                transforms = {
                  mapPixelsToWorld: this.mapPixelsToWorld.bind(this),
                  worldToMapPixels: this.worldToMapPixels.bind(this),
                  mapPixelsToWidget: this.mapPixelsToWidget.bind(this),
                  widgetToMapPixels: this.widgetToMapPixels.bind(this),
                  getMapRotationAngle: this.getCameraRotationAngle.bind(this) };


                this.avatarWidget = new _AvatarWidget__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer.container, this.targetViewer, this.globalManager, transforms, this.options.trackUsage);

                this.addListeners();
                this.activateTool();case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {
      this.sheetSyncExt = null;

      this.removeListeners();
      this.deactivateTool();

      this.avatarWidget.destroy();
      this.avatarWidget = null;

      if (this.focusAnim) {
        this.focusAnim.stop();
        this.focusAnim = null;
      }

      return true;
    } }, { key: "activateTool", value: function activateTool()

    {
      if (this.toolActive) {
        return;
      }

      this.toolActive = true;

      this.viewer.toolController.registerTool(this.avatarWidget.tool);
      this.viewer.toolController.activateTool(this.avatarWidget.tool.getName());

      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);
      this.avatarWidget.addEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);

      this.updateFocus();
    } }, { key: "deactivateTool", value: function deactivateTool()

    {
      if (!this.toolActive) {
        return;
      }

      this.toolActive = false;

      this.viewer.toolController.deactivateTool(this.avatarWidget.tool.getName());
      this.viewer.toolController.deregisterTool(this.avatarWidget.tool);

      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_START_EVENT, this.onDragStart);
      this.avatarWidget.removeEventListener(Autodesk.AEC.AvatarEvents.DRAG_END_EVENT, this.onDragEnd);
    } }, { key: "addListeners", value: function addListeners()

    {
      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 3D viewer, update the widget accordingly.
      this.targetViewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged); // Whenever the 3D camera moved, update the widget accordingly.
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.
      this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update); // Whenever a model has changed in this 2D viewer, update the widget accordingly.
      this.viewer.addEventListener(av.RENDER_PRESENTED_EVENT, this.update); //  Whenever the 2D camera moved, update the widget accordingly (no viewport change).
      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.update); //  Whenever the screen size has been changed.
      this.viewer.addEventListener(_SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.on3dCameraChanged);
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.viewer.removeEventListener(av.RENDER_PRESENTED_EVENT, this.update);
      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.update);
      this.viewer.removeEventListener(_SheetSync_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_2__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.onSheetCameraChanged); // Whenever the 2d camera moved.
    } }, { key: "onDragStart", value: function onDragStart()

    {
      if (this.focusAnim) {
        this.focusAnim.stop();
        this.focusAnim = null;
      }
    } }, { key: "onDragEnd", value: function onDragEnd()

    {
      this.outOfFocus = true;
      this.updateFocus();
    } }, { key: "isBimWalkActive", value: function isBimWalkActive()

    {
      return this.targetViewer.getActiveNavigationTool() === 'bimwalk';
    } }, { key: "onMainMapChanged", value: function onMainMapChanged(_ref)

    {var sheetMap = _ref.sheetMap;
      if (sheetMap) {
        this.update();
      }
    } }, { key: "update", value: function update()

    {
      if (!this.viewer.model || !this.avatarWidget || !this.sheetSyncExt) {
        return;
      }

      if (this.sheetSyncExt.sheetMap && this.isBimWalkActive()) {
        this.avatarWidget.show();
        this.avatarWidget.update();

        this.activateTool();
      } else {
        this.avatarWidget.hide();
        this.deactivateTool();
      }
    } }, { key: "setCameraPosition", value: function setCameraPosition(

    pos, changeZoom) {
      var camera = this.viewer.getCamera();

      // Change x & y values, but keep the same camera distance if changeZoom is off.
      camera.position.set(pos.x, pos.y, changeZoom ? pos.z : camera.position.z);
      camera.target.set(pos.x, pos.y, camera.target.z);

      camera.dirty = true;
    }

    // Map angle is determined according to the viewer's camera rotation.
  }, { key: "getCameraRotationAngle", value: function getCameraRotationAngle() {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);
    }

    // Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
  }, { key: "worldToMapPixels", value: function worldToMapPixels(pos3D) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(this.sheetSyncExt.sheetMap, pos3D);
    }

    // Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.
  }, { key: "mapPixelsToWorld", value: function mapPixelsToWorld(posX, posY, zWorld) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, posX, posY, zWorld);
    } }, { key: "mapPixelsToWidget", value: function mapPixelsToWidget(

    p) {
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWidget"])(this.sheetSyncExt.sheetMap, this.viewer, p);
    }

    // @param {Vector2} p - transformed in-place from widget pixels to map image pixels
    //                      widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)
    // @param {boolean} clamp - In case the resulting position is outside of the map, clamp the value to fit the maps' border.
  }, { key: "widgetToMapPixels", value: function widgetToMapPixels(p, clamp) {
      clamp = clamp && !this.sheetSyncExt.options.cropToViewport;
      return Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p, clamp);
    } }, { key: "world3DtoWorld2D", value: function world3DtoWorld2D(

    point) {
      var pos = this.worldToMapPixels(point);
      this.mapPixelsToWidget(pos);
      var worldPos = Object(_SheetSync_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["clientToWorld"])(this.viewer, pos.x, pos.y);

      return worldPos;
    }

    // Find avatar position according to current 3D camera location.
  }, { key: "getAvatarPositionOn2DSheet", value: function getAvatarPositionOn2DSheet() {
      return this.world3DtoWorld2D(this.targetViewer.getCamera().position);
    } }, { key: "on3dCameraChanged", value: function on3dCameraChanged()

    {
      this.updateFocus();
      this.update();
    } }, { key: "onSheetCameraChanged", value: function onSheetCameraChanged()

    {
      var navTool = this.viewer.toolController.getTool('pan');
      var isPanning = navTool.isInteractionActive();

      if (isPanning) {
        this.outOfFocus = true;

        // If panning has been made during animation - cancel the animation.
        if (this.focusAnim) {
          this.focusAnim.stop();
          this.focusAnim = null;
        }
      }
    }

    // Zoom 2D camera to avatar position.
  }, { key: "focusOnAvatar", value: function focusOnAvatar() {var _this2 = this;
      this.animateFocus(false, function () {
        _this2.outOfFocus = false;
      });
    }

    // Zoom 2D camera to model bounds.
  }, { key: "focusOnModel", value: function focusOnModel() {var _this3 = this;
      this.animateFocus(true, function () {
        _this3.outOfFocus = true;
      });
    } }, { key: "updateFocus", value: function updateFocus()

    {
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.autoFocus || this.avatarWidget.tool.isDragging) {
        this.outOfFocus = true;
        return;
      }

      var camera3d = this.targetViewer.getCamera();

      // Focus the 2D camera only if the 3D camera really moved.
      // Really moved <==> changed x or y position (We ignore z by purpose).
      if (this.last3dCameraPos.x === camera3d.position.x && this.last3dCameraPos.y === camera3d.position.y) {
        return;
      }

      if (!this.isAvatarInsideBounds()) {
        this.focusOnModel();
      } else if (this.outOfFocus) {
        // Animate the transition if we are after:
        // - Panning
        // - Manually dragging the avatar
        // - Double clicked to fly to location
        // - Was outside of the model's visible bounds and now got back in
        this.focusOnAvatar();
      } else {
        // Otherwise, the avatar is already focused, and just need to be updated to the last camera movement.
        var pos = this.getAvatarPositionOn2DSheet();
        this.setCameraPosition(pos);
      }

      this.last3dCameraPos = camera3d.position.clone();
    } }, { key: "getFuzzyBoundsCenter", value: function getFuzzyBoundsCenter()

    {
      var bounds3D = this.sheetSyncExt.getFuzzyBox();
      var min = this.world3DtoWorld2D(bounds3D.min);
      var max = this.world3DtoWorld2D(bounds3D.max);
      var bounds2D = new THREE.Box3().setFromPoints([min, max]);

      var camera = this.viewer.getCamera();
      var fit = this.viewer.navigation.computeFit(camera.position, camera.target, camera.fov, bounds2D, camera.aspect);

      return fit.position;
    } }, { key: "isAvatarInsideBounds", value: function isAvatarInsideBounds()

    {
      var bounds = this.sheetSyncExt.getFuzzyBox();

      // Ignore height when checking these bounds. We care only about x & y here.
      bounds.min.z = -Infinity;
      bounds.max.z = Infinity;

      var pos = this.targetViewer.getCamera().position;
      return bounds.containsPoint(pos);
    } }, { key: "animateFocus", value: function animateFocus(

    isOutside, onDone) {var _this4 = this;
      if (this.focusAnim) {
        return;
      }

      var camera = this.viewer.getCamera();

      var startPos = camera.position;

      var onTimer = function onTimer(t) {
        var targetPos = isOutside ? _this4.getFuzzyBoundsCenter() : _this4.getAvatarPositionOn2DSheet();
        t = Autodesk.Viewing.Private.smootherStep(t);
        var pos = startPos.clone().lerp(targetPos, t);
        _this4.setCameraPosition(pos, isOutside);
      };

      var onFadeEnd = function onFadeEnd() {
        _this4.focusAnim = null;
        onDone && onDone();
      };

      this.focusAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.focusDuration, onTimer, onFadeEnd);
    } }, { key: "getAutoFocus", value: function getAutoFocus()

    {
      return this.autoFocus;
    } }, { key: "setAutoFocus", value: function setAutoFocus(

    enable) {
      this.autoFocus = enable;
      this.updateFocus();
    } }]);return AvatarExtension;}(Autodesk.Viewing.Extension);


namespace.AvatarExtension = AvatarExtension;
av.theExtensionManager.registerExtension(myExtensionName, AvatarExtension);

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarTool.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarTool; });
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;
var zAxis = new THREE.Vector3(0, 0, 1);
var FLY_TO_TIME = 0.5; // same as teleportDuration in BimWalk
var
AvatarTool = /*#__PURE__*/function () {
  function AvatarTool(avatarWidget) {_classCallCheck(this, AvatarTool);
    this.avatarWidget = avatarWidget;
    this.targetViewer = avatarWidget.targetViewer;
    this.transforms = avatarWidget.transforms;

    this.setGlobalManager(avatarWidget.globalManager);

    this.dragDirectionStart = this.dragDirectionStart.bind(this);
    this.dragDirectionMove = this.dragDirectionMove.bind(this);
    this.dragDirectionEnd = this.dragDirectionEnd.bind(this);

    this.dragPositionStart = this.dragPositionStart.bind(this);
    this.dragPositionMove = this.dragPositionMove.bind(this);
    this.dragPositionEnd = this.dragPositionEnd.bind(this);

    // when dragging view direction, we lastAngle stores the angle between +y and the line from playerPos to last mouse position.
    this.lastAngle = undefined;

    // Is avatar being dragged.
    this.isDragging = false;

    // Is avatar being rotated.
    this.isRotating = false;

    // Is tool active.
    this.active = false;

    // Tool name.
    this.names = ['avatar-tool'];
  }_createClass(AvatarTool, [{ key: "getNames", value: function getNames()

    {
      return this.names;
    } }, { key: "getName", value: function getName()

    {
      return this.names[0];
    } }, { key: "isActive", value: function isActive()

    {
      return this.active;
    } }, { key: "activate", value: function activate()

    {
      if (this.isActive()) {
        return;
      }

      this.active = true;

      this.avatarWidget.widgetUI.hitArea.addEventListener('mousedown', this.dragPositionStart);
      this.avatarWidget.widgetUI.hitArea.addEventListener('touchstart', this.dragPositionStart);
      this.avatarWidget.widgetUI.addEventListener('mousedown', this.dragDirectionStart);
      this.avatarWidget.widgetUI.addEventListener('touchstart', this.dragDirectionStart);
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.isActive()) {
        return;
      }

      this.active = false;

      this.avatarWidget.widgetUI.hitArea.removeEventListener('mousedown', this.dragPositionStart);
      this.avatarWidget.widgetUI.hitArea.removeEventListener('touchstart', this.dragPositionStart);
      this.avatarWidget.widgetUI.removeEventListener('mousedown', this.dragDirectionStart);
      this.avatarWidget.widgetUI.removeEventListener('touchstart', this.dragDirectionStart);

      this.dragPositionEnd();
      this.dragDirectionEnd();
    }

    // Convert event client coords to absolute (=zoom and scroll-independent) pixel-coords on the map.
  }, { key: "screenToMap", value: function screenToMap(e, clamp) {
      if (e.type.indexOf('touch') >= 0) {
        e.clientX = e.touches[0].pageX;
        e.clientY = e.touches[0].pageY;
      }

      // get minimap pixel coords
      var clientRect = this.avatarWidget.container.getBoundingClientRect();

      // get position within map widget
      var p = new THREE.Vector2(e.clientX - clientRect.left, e.clientY - clientRect.top);

      // transform point to mapImage pixels
      this.transforms.widgetToMapPixels(p, clamp);

      return p;
    } }, { key: "dragPositionStart", value: function dragPositionStart(

    e) {
      this.addWindowEventListener('mousemove', this.dragPositionMove);
      this.addWindowEventListener('mouseup', this.dragPositionEnd);
      this.addWindowEventListener('touchmove', this.dragPositionMove);
      this.addWindowEventListener('touchend', this.dragPositionEnd);

      e.stopPropagation();
      e.preventDefault();

      // Make sure that map doesn't scroll/follow while we are moving the avatar
      this.isDragging = true;
      this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_START_EVENT });
    } }, { key: "dragPositionMove", value: function dragPositionMove(

    e) {
      // get minimap pixel coords. Clamp x/y to map extent => avoid dragging out of the map
      var _this$screenToMap = this.screenToMap(e, true),x = _this$screenToMap.x,y = _this$screenToMap.y;

      var camera = this.targetViewer.impl.camera;

      // keep z the same as before
      var zWorld = camera.position.z;

      // save current pos
      var oldPosition = camera.position.clone();

      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);

      // move camera to new 3D position
      camera.position.copy(pos3D);

      // apply delta to the target vector
      var delta = camera.position.clone().sub(oldPosition);

      camera.target.add(delta);
      camera.target.z = zWorld;

      this.targetViewer.impl.invalidate(true, true, true);
      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      e.stopPropagation();

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_MOVE_EVENT, camera: camera });
    } }, { key: "dragPositionEnd", value: function dragPositionEnd(

    e) {
      this.removeWindowEventListener('mousemove', this.dragPositionMove);
      this.removeWindowEventListener('mouseup', this.dragPositionEnd);
      this.removeWindowEventListener('touchmove', this.dragPositionMove);
      this.removeWindowEventListener('touchend', this.dragPositionEnd);

      e && e.stopPropagation();

      this.isDragging = false;

      // TODO: use LMV generic analytics infrastructure instead.
      if (!this.avatarInteractionTracked) {
        this.avatarInteractionTracked = true;

        if (this.avatarWidget && this.avatarWidget.trackUsage) {
          this.avatarWidget.trackUsage({
            avatar_interaction_tracked: true });

        }
      }

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.DRAG_END_EVENT });
    }

    // Get targetViewer's camera position on map coordinates.
  }, { key: "getCameraPositionOnMap", value: function getCameraPositionOnMap() {
      var pos3D = this.targetViewer.impl.camera.position;
      var p = this.transforms.worldToMapPixels(pos3D);
      return p;
    } }, { key: "dragDirectionStart", value: function dragDirectionStart(

    e) {
      // remember angle between north and (playerPos, mousePos) at dragStart
      var p1 = this.getCameraPositionOnMap();
      var p2 = this.screenToMap(e);
      this.lastAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_0__["computeAngle"])(p1, p2);

      this.addWindowEventListener('mousemove', this.dragDirectionMove);
      this.addWindowEventListener('mouseup', this.dragDirectionEnd);
      this.addWindowEventListener('touchmove', this.dragDirectionMove);
      this.addWindowEventListener('touchend', this.dragDirectionEnd);

      e.stopPropagation();
      e.preventDefault();

      this.isRotating = true;
      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_START_EVENT, angle: this.lastAngle });
    } }, { key: "dragDirectionMove", value: function dragDirectionMove(

    e) {
      // compute current angle
      var p1 = this.getCameraPositionOnMap();
      var p2 = this.screenToMap(e);
      var newAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_0__["computeAngle"])(p1, p2);
      var delta = this.lastAngle - newAngle;

      // apply delta to view direction
      var camera = this.targetViewer.impl.camera;
      var viewVec = camera.target.clone().sub(camera.position);
      viewVec.applyAxisAngle(zAxis, delta);
      viewVec.add(camera.position);
      camera.target.copy(viewVec);

      // Rotate up-vector as well.
      camera.up.applyAxisAngle(zAxis, delta);

      this.targetViewer.impl.syncCamera();
      this.targetViewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      this.lastAngle = newAngle;

      e.stopPropagation();

      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_MOVE_EVENT, angle: this.lastAngle });
    } }, { key: "dragDirectionEnd", value: function dragDirectionEnd(

    e) {
      this.removeWindowEventListener('mousemove', this.dragDirectionMove);
      this.removeWindowEventListener('mouseup', this.dragDirectionEnd);
      this.removeWindowEventListener('touchmove', this.dragDirectionMove);
      this.removeWindowEventListener('touch', this.dragDirectionEnd);

      e && e.stopPropagation();

      this.isRotating = false;
      this.avatarWidget && this.avatarWidget.dispatchEvent({ type: Autodesk.AEC.AvatarEvents.ROTATE_END_EVENT, angle: this.lastAngle });
    } }, { key: "convertEventHammerToMouse", value: function convertEventHammerToMouse(

    event) {
      if (event.pointers) {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
      }
    } }, { key: "getCurrentLevel", value: function getCurrentLevel()

    {
      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      if (!levelExt) {
        return;
      }

      return levelExt.getCurrentLevel();
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    e) {var _this = this;
      this.convertEventHammerToMouse(e);

      // get minimap pixel coords
      var _this$screenToMap2 = this.screenToMap(e),x = _this$screenToMap2.x,y = _this$screenToMap2.y;

      // preserve camera-direction
      var camera = this.targetViewer.impl.camera;
      var dir = camera.getWorldDirection();

      // when coming from an overview perspective, we don't want to just see the ground afterwards
      dir.z = Math.max(dir.z, 0.0);

      var zWorld = camera.position.z;

      // choose z based on current level
      var level = this.getCurrentLevel();

      if (level) {
        // Floor plus eye height (Should be 1.80m).
        var height = level.zMin + 1.8 / this.targetViewer.model.getUnitScale();

        // In case the ceiling is lower than 1.80m, we don't want to jump accidentally to the next level,
        // So in that case, just set the camera in the middle of the floor.
        if (height >= level.zMax) {
          height = (level.zMin + level.zMax) / 2;
        }

        if (isFinite(height)) {
          zWorld = height;
        }
      }

      // Compute new camera position
      var pos3D = this.transforms.mapPixelsToWorld(x, y, zWorld);
      var target = pos3D.clone().add(dir);
      var dstView = {
        position: pos3D,
        target: target,
        up: camera.up };


      this.isDragging = true;

      Autodesk.Viewing.Private.flyToView(this.targetViewer, dstView, FLY_TO_TIME, function () {
        _this.isDragging = false;
      });

      e.stopPropagation();
      e.preventDefault();

      return true;
    } }, { key: "handleDoubleTap", value: function handleDoubleTap(

    e) {
      return this.handleDoubleClick(e);
    } }]);return AvatarTool;}();


GlobalManagerMixin.call(AvatarTool.prototype);

/***/ }),

/***/ "./extensions/AEC/Avatar/AvatarWidget.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Avatar/AvatarWidget.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AvatarWidget; });
/* harmony import */ var _AvatarTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AvatarTool */ "./extensions/AEC/Avatar/AvatarTool.js");
/* harmony import */ var _AvatarEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AvatarEvents */ "./extensions/AEC/Avatar/AvatarEvents.js");
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _Avatar_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Avatar.scss */ "./extensions/AEC/Avatar/Avatar.scss");
/* harmony import */ var _Avatar_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Avatar_scss__WEBPACK_IMPORTED_MODULE_3__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}


 // IMPORTANT!!

var namespace = AutodeskNamespace('Autodesk.AEC');
var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;
var av = Autodesk.Viewing;var

AvatarWidget = /*#__PURE__*/function (_Autodesk$Viewing$Eve) {_inherits(AvatarWidget, _Autodesk$Viewing$Eve);
  /**
                                                                                                               * 
                                                                                                               * @param {HTMLElement} container - Div element where the avatar should be located.
                                                                                                               * @param {Viewer3D} targetViewer - Target viewer with a 3D model.
                                                                                                               * @param {GlobalManager} globalManager - Global manager.
                                                                                                               * @param {object} transforms - MUST contain these callbacks:
                                                                                                               *                                      mapPixelsToWorld
                                                                                                               *                                      worldToMapPixels
                                                                                                               *                                      mapPixelsToWidget
                                                                                                               *                                      widgetToMapPixels
                                                                                                               *                                      getMapRotationAngle
                                                                                                               * 
                                                                                                               */
  function AvatarWidget(container, targetViewer, globalManager, transforms, trackUsage) {var _this;_classCallCheck(this, AvatarWidget);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(AvatarWidget).call(this));
    _this.container = container;
    _this.targetViewer = targetViewer;
    _this.transforms = transforms;
    _this.trackUsage = trackUsage;
    _this.setGlobalManager(globalManager);

    _this.widgetUI = _this.createUI();

    _this.tool = new _AvatarTool__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this));
    _this.tool.activate();return _this;
  }_createClass(AvatarWidget, [{ key: "createUI", value: function createUI()

    {
      var _document = this.getDocument();

      var widget = _document.createElement('div');
      widget.className = 'avatar-widget';

      this.container.appendChild(widget);

      // Sub-widget to represent view direction
      var frustumWidget = _document.createElement('div');
      frustumWidget.className = 'avatar-frustum';
      widget.appendChild(frustumWidget);
      widget.frustumWidget = frustumWidget;

      // By default, setting left/top to posX/posY would move the top-left corner of the frustum
      // widget to that position. We want to have the tip of the camera there.
      // Note that the offset may change depending on the border sizes in avatar-frustum css class.
      widget.anchorX = 20; // =.avatar-frustum.border-left
      widget.anchorY = 40; // =.avatar-frustum.border-top

      // Filled circle at camera position
      var filledCircle = _document.createElement('div');
      filledCircle.className = 'avatar-position-fill';
      widget.appendChild(filledCircle);
      widget.posCircle = filledCircle;

      // Hit area of the avatar position.
      var hitArea = _document.createElement('div');
      hitArea.className = 'avatar-position-hitarea';
      widget.posCircle.appendChild(hitArea);
      widget.hitArea = hitArea;

      if (av.isTouchDevice()) {
        hitArea.classList.add('touch');
        frustumWidget.classList.add('touch');
        widget.posCircle.classList.add('touch');
        widget.anchorX = 40; // =.avatar-frustum.border-left
        widget.anchorY = 80; // =.avatar-frustum.border-top
      }

      return widget;
    } }, { key: "destroy", value: function destroy()

    {
      this.tool.deactivate();
      this.tool = null;

      this.container.removeChild(this.widgetUI);
      this.widgetUI = null;
    }

    // Show avatar
  }, { key: "show", value: function show() {
      if (!this.widgetUI.classList.contains('visible')) {
        this.widgetUI.classList.add('visible');
      }
    }

    // Hide avatar
  }, { key: "hide", value: function hide() {
      if (this.widgetUI.classList.contains('visible')) {
        this.widgetUI.classList.remove('visible');
      }
    }

    // Update the avatar position and rotation, according to the targetViewer's camera.
  }, { key: "update", value: function update() {
      // get position and target in pixels within the map widget
      var pos3D = this.targetViewer.impl.camera.position;
      var pos2D = this.transforms.worldToMapPixels(pos3D);
      var target3D = this.targetViewer.impl.camera.target;
      var target2D = this.transforms.worldToMapPixels(target3D);

      var playerAngle = Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_2__["computeAngle"])(pos2D, target2D);

      // rotate frustum shape (+ consider map rotation)
      var mapRotationAngle = this.transforms.getMapRotationAngle();
      this.widgetUI.frustumWidget.style.transform = "rotate(".concat(playerAngle + mapRotationAngle, "rad)");

      this.transforms.mapPixelsToWidget(pos2D);

      this.widgetUI.style.transform = "translate(".concat(pos2D.x - this.widgetUI.anchorX, "px, ").concat(pos2D.y - this.widgetUI.anchorY, "px)");
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.tool.isDragging;
    } }, { key: "isRotating", value: function isRotating()

    {
      return this.tool.isRotating;
    } }]);return AvatarWidget;}(Autodesk.Viewing.EventDispatcher);


GlobalManagerMixin.call(AvatarWidget.prototype);
Object.assign(namespace, { AvatarEvents: _AvatarEvents__WEBPACK_IMPORTED_MODULE_1__["AvatarEvents"] });

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!**********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CanvasBookmarkExtension; });
/* harmony import */ var _CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasBookmarkIcons.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js");
/* harmony import */ var _CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreateFrustumShape.js */ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js");
/* harmony import */ var _HCluster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HCluster.js */ "./extensions/AEC/CanvasBookmark/HCluster.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing,avp = av.Private,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.CanvasBookmarkExtension';

var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';





var VISIBILITY_PROP = 'canvasBookmarks';

// Name of the overlay scene that we use graphics overlays (frustum shapes)
var OverlayName = 'CanvasBookmark_Extension_Overlay';
var CutPlaneSetName = 'CanvasBookmark_CutPlanes';

// Interpolate between two given Matrix4 transforms. Note that this requires the transforms
// to be invertible combinations of pos/rotate/scale.
var lerpTransforms = function () {
  var startPos = new THREE.Vector3();
  var endPos = new THREE.Vector3();
  var startScale = new THREE.Vector3();
  var endScale = new THREE.Vector3();
  var startRotate = new THREE.Quaternion();
  var endRotate = new THREE.Quaternion();

  var pos = new THREE.Vector3();
  var scale = new THREE.Vector3();
  var rotate = new THREE.Quaternion();

  return function (startMatrix, endMatrix, t, dstTransform) {
    startMatrix.decompose(startPos, startRotate, startScale);
    endMatrix.decompose(endPos, endRotate, endScale);

    pos.lerpVectors(startPos, endPos, t);
    scale.lerpVectors(startScale, endScale, t);
    THREE.Quaternion.slerp(startRotate, endRotate, rotate, t);

    dstTransform.compose(pos, rotate, scale);

    return dstTransform;
  };
}();

// Interpolates between two bboxes. t is in [0,1]
var lerpBoxes = function lerpBoxes(startBox, endBox, t, dstBox) {
  dstBox.min.lerpVectors(startBox.min, endBox.min, t);
  dstBox.max.lerpVectors(startBox.max, endBox.max, t);
  lerpTransforms(startBox.transform, endBox.transform, t, dstBox.transform);
};

// Clone Box3 with attached transform
var cloneBox = function cloneBox(srcBox) {
  var box = srcBox.clone();
  box.transform = srcBox.transform ? srcBox.transform.clone() : new THREE.Matrix4();
  return box;
};

var setButtonVisible = function setButtonVisible(button, value) {

  // Make it detectable if this button is going to change on next anim frame.
  button.visiblityChangePending = true;

  // Delay class change to next anim frame - otherwise css transitions don't work sometimes.
  requestAnimationFrame(function () {
    if (value) {
      button.container.classList.add('visible');
    } else
    {
      button.container.classList.remove('visible');
    }
    button.visiblityChangePending = false;
  });
};var


CanvasBookmarkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(CanvasBookmarkExtension, _av$Extension);
  function CanvasBookmarkExtension(viewer, options) {var _this;_classCallCheck(this, CanvasBookmarkExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasBookmarkExtension).call(this, viewer, options));

    _this.viewer = viewer;

    _this.bookmarks = [];
    _this.clusteredBookmarks = [];

    _this.camera = _this.viewer.navigation.getCamera();
    _this.cameraMovedCB = _this.onCameraMoved.bind(_assertThisInitialized(_this));
    _this.onVisibilityChangedCB = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));

    // SectionBox animations
    _this.sectionBox = null; // SectionBox as defined by currently hovered bookmark (not changed during anims)
    _this.activeSectionBox = null; // Latest applied SectionBox
    _this.animStartSectionBox = null; // Used only during cutplane animations
    _this.animEndSectionBox = null; // Usually equal to this.sectionBox, but this.sectionBox may be null while animEndSectionBox is always valid during an animation
    _this.sectionBoxAnim = null; // AnimControl - only existing during animations

    // bookmarks visibility logic
    _this.changeBookmarksVisibility = _this.changeBookmarksVisibility.bind(_assertThisInitialized(_this));
    _this.changeBookmarksVisibilityTimeout = null;

    _this._clusteringEnabled = _this.options.clusterfck !== undefined;
    _this._clusteringThreshold = _this.options.clusteringThreshold || 110; // threshold is (icon_width * 5), depends on "THREE.Vector3.distanceTo()"

    // bookmarks clustering
    if (_this._clusteringEnabled) {
      _this.hcluster = new _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _this.options.clusterfck,
      function (b1, b2) {
        var _b1 = new THREE.Vector2(b1.currentPosProjected.x, b1.currentPosProjected.y);
        var _b2 = new THREE.Vector2(b2.currentPosProjected.x, b2.currentPosProjected.y);
        return _b2.distanceTo(_b1);
      },
      _this._clusteringThreshold);

    }

    _this._filterOutInvisibleBookmark = _this._filterOutInvisibleBookmark.bind(_assertThisInitialized(_this));

    _this.levelChangedCB = _this.onLevelChanged.bind(_assertThisInitialized(_this));

    _this.extensionLoadedCB = _this.onExtensionLoaded.bind(_assertThisInitialized(_this));

    // Indicates if any frustumShape is currently fading for hover effects.
    _this.isFrustumFading = false;

    // For testing: Callbacks that will be notified once as soon as Minimap has reached stable state
    _this.waitingCallbacks = [];return _this;
  }_createClass(CanvasBookmarkExtension, [{ key: "setBookmarksVisible", value: function setBookmarksVisible(

    visible) {
      this.bookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      this.clusteredBookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      if (!visible) {
        this.stopGhosting();
      }
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }

      this.setBookmarksVisible(visible);

      if (visible) {
        this.updateBookmarkPositions();
      }
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);
    } }, { key: "onCameraMoved", value: function onCameraMoved()

    {
      this.setBookmarksVisible(false);
      this.debounceBookmarksVisibility();
    } }, { key: "createTooltip", value: function createTooltip(

    button, geomNode) {
      button.setToolTip(geomNode.name());
      button._toolTipElement.innerHTML = "<b>".concat(geomNode.name(), "</b>");
    } }, { key: "flyToBookmark", value: function flyToBookmark(

    bookmark) {
      var dstView = {
        position: bookmark.pos,
        target: bookmark.target,
        up: bookmark.up };

      this.anim = avp.flyToView(this.viewer, dstView, 1.0);
    }

    // geomNode is a BubbleNode of type GEOMETRY_NODE
  }, { key: "createBookmark", value: function createBookmark(geomNode) {var _this2 = this;

      // extract camera data (TODO: Add generic utility function to BubbleNode to read camera)
      var camera = geomNode.extractCamera();
      if (!camera) {
        return;
      }

      var pos = camera.position;
      var target = camera.target;

      // Consider refPointTransform:
      //    cameras are in local Revit coordinates. To support georeferencing, we apply the refPointTransform
      //    from aecModelData and finally subtract the viewer geoOffset
      var root = geomNode.getRootNode();
      var tfMatrix = root.extractRefPointTransform();

      if (this.options.globalOffset && tfMatrix) {

        // apply refPointTransform and globalOffset to pos and target
        pos.applyMatrix4(tfMatrix);
        pos.sub(this.options.globalOffset);
        target.applyMatrix4(tfMatrix);
        target.sub(this.options.globalOffset);
      }

      var dir = new THREE.Vector3(target.x - pos.x, target.y - pos.y, target.z - pos.z).normalize();
      var up = new THREE.Vector3(0, 0, 1);

      // IDs cannot start with numbers and have whitespaces
      var button = new Autodesk.Viewing.UI.Button("b-".concat(geomNode.name().replace(/\s/g, '')));

      // Configure style (TODO: Should move to css class or specified by client app)
      button.container.classList.add('canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createCameraIcon"])();
      setButtonVisible(button, this.isVisible());

      this.createTooltip(button, geomNode);

      this.viewer.container.appendChild(button.container);

      var buttonSize = button.getDimensions();

      var sectionBox = this.findSectionBox(geomNode, geomNode.name());
      var sectionBoxCenter = sectionBox ? sectionBox.center().applyMatrix4(sectionBox.transform) : null;

      var bookmark = {
        marker: button,
        pos: sectionBox ? sectionBoxCenter : pos,
        cameraPos: pos,
        dir: dir,
        up: up,
        target: target,
        name: geomNode.name(),

        // position within the marker that should be centered
        anchorX: buttonSize.width / 2,
        anchorY: buttonSize.height / 2,

        fadeValue: 0.0,
        hovered: false,
        bubbleNode: geomNode,

        clustered: false };


      button.container.addEventListener('mouseenter', function () {_this2.onBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this2.onBookmarkMouseLeave(bookmark);});

      button.addEventListener(avu.Button.Event.CLICK, function () {
        // pass to custom handler
        if (_this2.options && _this2.options.onBookmark) {
          _this2.options.onBookmark(bookmark.bubbleNode, camera);
        }
      });

      return bookmark;
    } }, { key: "createClusteredBookmark", value: function createClusteredBookmark(

    flattenCluster, id, visible) {var _this3 = this;
      var button = new Autodesk.Viewing.UI.Button(id);

      button.container.classList.add('clustered-canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createClusteredCameraIcon"])();

      setButtonVisible(button, this.isVisible() && visible);

      this.viewer.container.appendChild(button.container);

      var res = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].ComputeMeanValueForFlattenCluster(flattenCluster);

      var bookmark = {
        marker: button,
        name: id,

        pos: res.center3D,
        currentPosProjected: res.center2D,

        cluster: flattenCluster,

        fadeValue: 0.0,
        hovered: false,

        folded: true };


      button.container.addEventListener('mouseenter', function () {_this3.onClusteredBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this3.onClusteredBookmarkMouseLeave(bookmark);});
      button.addEventListener(avu.Button.Event.CLICK, function () {_this3.onClusteredBookmarkClicked(bookmark);});

      bookmark.marker.container.style.transform = "translate(".concat(res.center2D.x, "px, ").concat(res.center2D.y, "px)");
      this.clusteredBookmarks.push(bookmark);
    } }, { key: "deleteBookmark", value: function deleteBookmark(

    bookmark) {
      this.viewer.container.removeChild(bookmark.marker.container);
      this.hideFrustumShape(bookmark);
    } }, { key: "clearBookmarks", value: function clearBookmarks()

    {var _this4 = this;
      // Cancel any outdated anims or cutplanes
      this.stopSectionBoxAnim();
      this.applySectionBox();

      this.bookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.bookmarks = [];

      this.clusteredBookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.clusteredBookmarks = [];
    } }, { key: "resetBookmarks", value: function resetBookmarks(

    geomNodes) {var _this5 = this;

      this.clearBookmarks();
      if (!geomNodes) {
        return;
      }

      //The bookmarks make use of AECModelData, so we have to make sure we have that loaded.
      av.Document.getAecModelData(geomNodes).then(function () {

        for (var i = 0; i < geomNodes.length; i++) {
          var geomNode = geomNodes[i];
          var bookmark = _this5.createBookmark(geomNode);
          if (bookmark) {
            _this5.bookmarks.push(bookmark);
          }
        }

        _this5.bookmarkData = geomNodes;

        _this5.updateBookmarkPositions();
      });
    }

    // Create bookmarks with correct positions for the current geoOffset
  }, { key: "resetGlobalOffset", value: function resetGlobalOffset(globalOffset) {
      this.options.globalOffset = globalOffset;
      this.resetBookmarks(this.bookmarkData);
    } }, { key: "showFrustumShape", value: function showFrustumShape(

    bookmark) {
      if (bookmark.frustumShape) {
        return;
      }

      bookmark.frustumShape = Object(_CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__["createFrustumShape"])(bookmark.cameraPos, bookmark.dir);
      this.viewer.impl.addOverlay(OverlayName, bookmark.frustumShape);

      bookmark.frustumShape.name = bookmark.bubbleNode.name();

      // Make LMV recompute near/far plane, so that the frustum shape is considered
      // TODO: It would be easier if LMV would do that automatically, but it
      //       updates the camera only when rendering the scene.
      //       => Clarify if we can generally change that.
      this.viewer.impl.updateCameraMatrices();
    } }, { key: "hideFrustumShape", value: function hideFrustumShape(

    bookmark) {
      if (!bookmark.frustumShape) {
        return;
      }

      this.viewer.impl.removeOverlay(OverlayName, bookmark.frustumShape);
      bookmark.frustumShape = null;
    }

    // Controls the frustum fading. fadeValue is in [0,1]
  }, { key: "setFrustumFadeValue", value: function setFrustumFadeValue(bookmark, fadeValue) {
      bookmark.fadeValue = fadeValue;
      if (bookmark.frustumShape) {
        bookmark.frustumShape.setFadeValue(fadeValue);
      }
    }

    // Update fading of the frustum shape based on elpased time in ms.
  }, { key: "updateFrustumShapeFading", value: function updateFrustumShapeFading(bookmark, elapsed) {
      var FadeInDurationMs = 500;
      var FadeOutDurationMs = 500;

      var fadingIn = bookmark.hovered && bookmark.fadeValue < 1.0;
      var fadingOut = !bookmark.hovered && bookmark.fadeValue > 0.0;

      if (!fadingIn && !fadingOut) {
        return false;
      }

      // compute amount of fading change (1.0 = full fade)
      var fadeInDelta = elapsed / FadeInDurationMs;
      var fadeOutDelta = elapsed / FadeOutDurationMs;
      var newValue = bookmark.fadeValue + (fadingIn ? fadeInDelta : -fadeOutDelta);

      newValue = THREE.Math.clamp(newValue, 0, 1);
      this.setFrustumFadeValue(bookmark, newValue);

      // HACK: Use css fade instead
      if (bookmark.marker && bookmark.marker._toolTipElement) {
        bookmark.marker._toolTipElement.style.opacity = Math.min(1, 3 * newValue);
      }

      // remove frustums if not used anymore
      if (!bookmark.hovered && bookmark.fadeValue === 0) {
        this.hideFrustumShape(bookmark);
      }

      this.viewer.impl.invalidate(false, false, true);

      return true;
    } }, { key: "requestTimer", value: function requestTimer()

    {var _this6 = this;
      var _window = this.getWindow();
      this.timerId = _window.requestAnimationFrame(function () {return _this6.onTimer();});
    } }, { key: "onTimer", value: function onTimer()

    {var _this7 = this;
      // get elapsed time in ms
      var curTime = performance.now();
      var elapsed = curTime - this.lastTime;
      this.lastTime = curTime;

      // Track whether any frustum-shape fading is going on
      this.isFrustumFading = false;

      this.bookmarks.forEach(function (bookmark) {
        var fading = _this7.updateFrustumShapeFading(bookmark, elapsed);
        _this7.isFrustumFading = _this7.isFrustumFading || fading;
      });

      // Trigger notification if fading stuff is finished
      if (this.isAllDone()) {
        this.waitingCallbacks.forEach(function (p) {return p();});
        this.waitingCallbacks.length = 0;
      }

      this.requestTimer();
    }

    // Returns an oriented box (THREE.Box3() + attached Matrix4 box.transform)
  }, { key: "findSectionBox", value: function findSectionBox(bubbleNode, name) {
      var viewNode = bubbleNode.search({ type: 'view' });

      if (!viewNode.length || viewNode[0].data.name !== name)
      return null;

      var sb = viewNode[0].data.sectionBox;
      var sbt = viewNode[0].data.sectionBoxTransform;

      if (!sb || !sbt)
      return null;

      var sbTransformMatrix = new THREE.Matrix4().fromArray([
      sbt[0], sbt[1], sbt[2], sbt[3],
      sbt[4], sbt[5], sbt[6], sbt[7],
      sbt[8], sbt[9], sbt[10], sbt[11],
      sbt[12], sbt[13], sbt[14], sbt[15]]);


      var box = new THREE.Box3();
      box.min.set(sb[0], sb[1], sb[2]);
      box.max.set(sb[3], sb[4], sb[5]);
      box.transform = new THREE.Matrix4();

      var tf = bubbleNode.getRootNode().getAecModelData().refPointTransformation;
      if (this.options.globalOffset && tf) {
        var offset = this.options.globalOffset;

        var geoTransformMatrix = av.BubbleNode.readMatrixFromArray12(tf);

        // Apply sectionBox rotation (if any), geoRefTransform, and finally the viewer offset.
        // Note that matrices must be multiplied in reverse order.
        box.transform.makeTranslation(-offset.x, -offset.y, -offset.z);
        box.transform.multiply(geoTransformMatrix);
        box.transform.multiply(sbTransformMatrix);
      }

      return box;
    }

    // The overlay scene contains the frustum shapes and is always visible by default. We only hide it temporarily
    // when baking an image for showin ghost floors
  }, { key: "setOverlaySceneVisible", value: function setOverlaySceneVisible(visible) {
      // Overlay may be null if this is currently unloaded
      var overlay = this.viewer.impl.overlayScenes[OverlayName];
      var scene = overlay && overlay.scene;
      if (scene) {
        scene.visible = visible;
      }
    } }, { key: "getFadeExtension", value: function getFadeExtension()

    {
      return this.viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Render models without SectionBox into fading target
  }, { key: "showGhosting", value: function showGhosting() {var _this8 = this;
      // Ghosting is an optional effect that requires the CrossFade extension. If we don't have it,
      // we omit ghosting, i.e., only apply the cutplanes for SectionBox previous.
      var fadeExt = this.getFadeExtension();
      if (!fadeExt) {
        return;
      }

      // Take control over CrossFade effect. Purpose is to avoid conflicts with other effects based on CrossFade. E.g., if we are
      // still showing ghost-floors from LevelsExtension, LevelsExtension will properly clean them up first.
      fadeExt.acquireControl('CanvasBookmarks', function () {return _this8.stopGhosting();});

      // If possible, reuse baked ghosting image from previous bookmark
      if (!this.ghostingActive) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName); // disable current SectionBox
        this.setOverlaySceneVisible(false); // make sure that we don't bake Frustum shapes into the screenshot
        fadeExt.renderFadingImage(0); // render snapshot into fading target
        this.applySectionBox(this.activeSectionBox); // recover current SectionBox
        this.setOverlaySceneVisible(true); // show overlay scene again (We don't hide it anywhere else, otherwise we would need to save/restore visibility state)
        this.ghostingActive = true;
      } else {
        // Reuse ghosting from before - just make sure that no fadeOut anim is in-progress
        this.stopGhostFadeOut();
      }
      fadeExt.setCrossFadeOpacity(0, 0.3); // overlay full model with ghost opacity
    } }, { key: "stopGhosting", value: function stopGhosting()

    {
      if (this.ghostingActive) {
        this.stopGhostFadeOut();
        var fadeExt = this.getFadeExtension();
        fadeExt && fadeExt.releaseFadingImage(0);
        this.ghostingActive = false;
      }
    } }, { key: "stopGhostFadeOut", value: function stopGhostFadeOut()

    {
      // skip fade-out animation if in progress
      if (this.ghostFadeAnim) {
        this.ghostFadeAnim.skip();
        this.ghostFadeAnim = null;
      }
    }

    // Fade-out cross-fade target containing the ghosted environment
  }, { key: "fadeOutGhosting", value: function fadeOutGhosting() {
      var fadeExt = this.getFadeExtension();
      if (!this.ghostingActive || !fadeExt) {
        // No ghosting active => nothing to do
        return;
      }

      var ghostAlpha = fadeExt.getCrossFadeOpacity(0);
      this.ghostFadeAnim = avp.fadeValue(ghostAlpha, 0.0, 0.5, function (t) {return fadeExt.setCrossFadeOpacity(0, t);});
    } }, { key: "onBookmarkMouseEnter", value: function onBookmarkMouseEnter(

    bookmark) {
      var sectionBox = this.findSectionBox(bookmark.bubbleNode, bookmark.name);
      if (sectionBox) {
        this.showGhosting();
        this.animateToSectionBox(sectionBox);
      }

      this.showFrustumShape(bookmark);
      bookmark.hovered = true;
    } }, { key: "onBookmarkMouseLeave", value: function onBookmarkMouseLeave(

    bookmark) {
      this.animateToSectionBox(null);
      this.fadeOutGhosting();
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkMouseEnter", value: function onClusteredBookmarkMouseEnter(

    bookmark) {
      bookmark.hovered = true;
    } }, { key: "onClusteredBookmarkMouseLeave", value: function onClusteredBookmarkMouseLeave(

    bookmark) {
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkClicked", value: function onClusteredBookmarkClicked(

    bookmark) {
      // TODO:
      //   - Zoom + zoom level computation
      //   - "Too many" clustered bookmarks -> (n+1) icon should be "..."

      if (bookmark.folded) {
        var _rotate = function _rotate(vector, center, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);

          var x = vector.x - center.x;
          var y = vector.y - center.y;

          vector.x = x * c - y * s + center.x;
          vector.y = x * s + y * c + center.y;
        };

        var n = bookmark.cluster.length;
        var alpha = Math.round(360.0 / n);

        var center = new THREE.Vector2(bookmark.currentPosProjected.x, bookmark.currentPosProjected.y);

        var start = new THREE.Vector2(center.x, center.y + 35);

        for (var i = 0; i < n; ++i) {
          var bm = bookmark.cluster[i];

          var current = start.clone();
          _rotate(current, center, i * alpha * Math.PI / 180.0);

          bm.currentPosProjected.x = current.x;
          bm.currentPosProjected.y = current.y;

          bm.marker.container.style.transform = "translate(".concat(current.x, "px, ").concat(current.y, "px)");
          setButtonVisible(bm.marker, true);
        }

        bookmark.marker.container.classList.add('declustered-canvas-bookmark');
      } else
      {
        bookmark.cluster.forEach(function (bm) {
          setButtonVisible(bm.marker, false);
        });

        bookmark.marker.container.classList.remove('declustered-canvas-bookmark');
      }

      bookmark.folded = !bookmark.folded;
    } }, { key: "debounceBookmarksVisibility", value: function debounceBookmarksVisibility()

    {
      if (this.changeBookmarksVisibilityTimeout) {
        clearTimeout(this.changeBookmarksVisibilityTimeout);
      }

      this.changeBookmarksVisibilityTimeout = setTimeout(this.changeBookmarksVisibility, 100);
    } }, { key: "changeBookmarksVisibility", value: function changeBookmarksVisibility()

    {
      this.updateBookmarkPositions();
    } }, { key: "updateBookmarkPositions", value: function updateBookmarkPositions()

    {var _this9 = this;
      if (!this.isVisible()) {
        return;
      }

      this.bookmarks.forEach(function (bookmark) {
        // Use cropBox center (if available) or camera position to choose label position
        var sBox = bookmark.bubbleNode.sectionBox;
        var pos3D = sBox ? sBox.center() : bookmark.pos;

        bookmark.currentPos3D = pos3D;

        // In-canvas coordinates
        var pos2D = _this9.project(pos3D);
        pos2D.x -= bookmark.anchorX;
        pos2D.y -= bookmark.anchorY;

        bookmark.currentPosProjected = new THREE.Vector3(pos2D.x, pos2D.y, pos2D.z);
        bookmark.marker.container.style.transform = "translate(".concat(pos2D.x, "px, ").concat(pos2D.y, "px)");
      });

      var clusters = this._clusteringEnabled ? this.hcluster.createClusters(this.bookmarks) : [];
      this.updateClusteredBookmarks(clusters);
    } }, { key: "updateClusteredBookmarks", value: function updateClusteredBookmarks(

    clusters) {var _this10 = this;
      // delete all "cluster" bookmarks since we create them all the time (by design), hiding will not really work
      this.clusteredBookmarks.forEach(function (bookmark) {
        _this10.deleteBookmark(bookmark);
      });
      this.clusteredBookmarks = [];

      // hide all bookmarks and reset "clustered" state
      this.bookmarks.forEach(function (bookmark) {
        setButtonVisible(bookmark.marker, false);
      });

      var floorSelector = this._getFloorSelector();
      var currentLevel = floorSelector && floorSelector.currentFloor;
      if (currentLevel !== undefined) {
        return;
      }

      var visibleBookamrks = this.bookmarks.filter(this._filterOutInvisibleBookmark);
      visibleBookamrks.forEach(function (bookmark) {
        bookmark.clustered = false;
        setButtonVisible(bookmark.marker, true);
      });

      for (var i = 0; i < clusters.length; i++) {
        var c = clusters[i];

        if (c.size > 1) {(function () {
            var flCluster = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].FlattenCluster(c);

            var clusterBmVisible = false;
            flCluster.forEach(function (bookmark) {
              bookmark.clustered = true;
              if (!clusterBmVisible && bookmark.marker.isVisible()) {
                // if one of the included bookmarks is visible, mark the cluster bookmark as visible one
                clusterBmVisible = true;
              }
              // now, mark the included bookmark as invisible one
              setButtonVisible(bookmark.marker, false);
            });

            // IDs cannot start with some number
            _this10.createClusteredBookmark(flCluster, "c-".concat(flCluster[0].bubbleNode.data.viewableID), clusterBmVisible);})();
        }
      }
    } }, { key: "project", value: function project(

    position) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3().copy(position);

      var matrix = new THREE.Matrix4();
      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);

      p.applyProjection(matrix);

      return new THREE.Vector3(
      Math.round((p.x + 1) / 2 * containerBounds.width),
      Math.round((-p.y + 1) / 2 * containerBounds.height),
      p.z);

    } }, { key: "load", value: function load()

    {

      this.viewer.prefs.add(VISIBILITY_PROP, true);

      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.addEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // handle the case when this extension is loaded after LevelsExtension is loaded,
      // without making this extension known to LevelsExtension
      this.updateBookmarkPositions();

      this.viewer.impl.createOverlayScene(OverlayName);

      // trigger timer-calls for fading animations
      this.lastTime = performance.now();
      this.requestTimer();

      if (!this.updateSettingsPanel) {
        //We need to connect this to an event that happens after the settings panel has been
        //create by the load sequence. The toolbar created event is serving that purpose.
        this.updateSettingsPanel = this.configureSettings.bind(this);
        this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
      }

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.clearBookmarks();

      this.viewer.impl.removeOverlayScene(OverlayName);

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.removeEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // Stop timer for position updates
      if (this.timerId) {
        var _window = this.getWindow();
        _window.cancelAnimationFrame(this.timerId);
        this.timerId = null;
      }

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      return true;
    } }, { key: "applySectionBox", value: function applySectionBox(

    box) {
      this.activeSectionBox = box;

      // No box => clear cutplanes
      if (!box) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName);
        return;
      }

      var planes = avp.SceneMath.box2CutPlanes(box, box.transform);
      this.viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // get bbox of all visible models
  }, { key: "getModelBox", value: function getModelBox() {
      var mq = this.viewer.impl.modelQueue();
      var models = mq.getModels();

      var box = new THREE.Box3();
      for (var i = 0; i < models.length; i++) {
        box.union(models[i].getBoundingBox());
      }

      return box;
    } }, { key: "stopSectionBoxAnim", value: function stopSectionBoxAnim()

    {
      if (this.sectionBoxAnim) {
        this.sectionBoxAnim.stop();
        this.sectionBoxAnim = null;
      }
    } }, { key: "animateToSectionBox", value: function animateToSectionBox(

    newBox) {var _this11 = this;
      // Nothing to animate
      if (!newBox && !this.activeSectionBox) {
        return;
      }

      // Don't allow overlapping animations
      this.stopSectionBoxAnim();

      var CutPlaneAnimInSeconds = 0.5;

      // Start at latest SectionBox state or with the whole model
      this.animStartBox = this.activeSectionBox ? cloneBox(this.activeSectionBox) : cloneBox(this.getModelBox());
      this.animEndBox = newBox ? cloneBox(newBox) : cloneBox(this.getModelBox());

      // Set target box
      this.sectionBox = newBox;

      // interpolated box used during anim
      var tmpBox = new THREE.Box3();
      tmpBox.transform = new THREE.Matrix4();

      var onUpdate = function onUpdate(t) {
        t = avp.smootherStep(t);
        lerpBoxes(_this11.animStartBox, _this11.animEndBox, t, tmpBox);
        _this11.applySectionBox(tmpBox);
      };

      var onFinished = function onFinished() {
        _this11.applySectionBox(_this11.sectionBox);
        _this11.sectionBoxAnim = null;
      };

      this.sectionBoxAnim = avp.fadeValue(0, 1, CutPlaneAnimInSeconds, onUpdate, onFinished);
    } }, { key: "enableClustering", value: function enableClustering(

    value) {
      if (this._clusteringEnabled !== value) {
        this._clusteringEnabled = value;
        this.updateClusteredBookmarks([]);
      }
    } }, { key: "setClusteringThreshold", value: function setClusteringThreshold(

    value) {
      if (this._clusteringThreshold !== value) {
        this._clusteringThreshold = value;
        this.hcluster.setThreshold(value);
        this.updateClusteredBookmarks([]);
      }
    }

    // Returns true if there are no active transitions, i.e., state is stable and doesn't vary based on timing anymore.    
  }, { key: "isAllDone", value: function isAllDone() {
      // Note: Some aspects are not considered yet, e.g., css-based fading and debounced visibility. For
      //       now, we only address everything that would introduce test instabilities otherwise.
      var sectionBoxAnimActive = this.sectionBoxAnim && this.sectionBoxAnim.isRunning;
      var visChangePending = this.bookmarks.some(function (b) {return b.marker && b.marker.visiblityChangePending;});
      return !sectionBoxAnimActive && !this.isFrustumFading && !visChangePending;
    }

    // Returns a promise that resolves as soon as isAllDone() returns true.
  }, { key: "waitForAllDone", value: function waitForAllDone() {var _this12 = this;

      // Update frustum-fading to check whether there are any changes to process
      this.onTimer();

      if (this.isAllDone()) {
        return Promise.resolve();
      }

      return new Promise(function (resolve) {
        _this12.waitingCallbacks.push(resolve);
      });
    } }, { key: "_filterOutInvisibleBookmark", value: function _filterOutInvisibleBookmark(

    bm) {
      var vp = this.viewer.navigation.getScreenViewport();

      if (bm.currentPosProjected.x < 0 || bm.currentPosProjected.x > vp.width) {
        return false;
      }

      if (bm.currentPosProjected.y < 0 || bm.currentPosProjected.y > vp.height) {
        return false;
      }

      var viewingDirection = this.camera.target.clone().sub(this.camera.position);
      var bookmarkDirection = bm.pos.clone().sub(this.camera.position);
      return viewingDirection.dot(bookmarkDirection) > 0;
    } }, { key: "onLevelChanged", value: function onLevelChanged()

    /*event*/{
      this.updateBookmarkPositions();
    } }, { key: "onExtensionLoaded", value: function onExtensionLoaded(

    event) {
      if (event.extensionId === LEVEL_EXT) {
        this.updateBookmarkPositions();
      }
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return;

      var panel = this.viewer.getSettingsPanel(true);

      if (!panel.is3dMode)
      return;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "Location Icons");

      // add toggle to the hypermodeling tab of the viewer settings
      if (panel && !panel.showLocationIconsChkBoxId) {
        panel.showLocationIconsChkBoxId = panel.addCheckbox(
        navTab,
        "Show location icons",
        "Toggles availability of the location icons when looking at the project model",
        true,
        this.onVisibilityChangedCB,
        VISIBILITY_PROP);

      }
    } }, { key: "_getFloorSelector", value: function _getFloorSelector()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      return levelExt && levelExt.floorSelector;
    } }]);return CanvasBookmarkExtension;}(av.Extension);


namespace.CanvasBookmarkExtension = CanvasBookmarkExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CanvasBookmarkExtension);

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js":
/*!**************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js ***!
  \**************************************************************/
/*! exports provided: createCameraIcon, createClusteredCameraIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCameraIcon", function() { return createCameraIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createClusteredCameraIcon", function() { return createClusteredCameraIcon; });

function createCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 114 114">',
  '<defs>',
  '<path id="camera-view-icon-3-with-shadow-v3-b" d="M60.934065,73.4602645 C54.1164768,73.4602645 48.5886781,67.9324658 48.5886781,61.1148776 C48.5886781,54.2963836 54.1164768,48.7694907 60.934065,48.7694907 C67.752559,48.7694907 73.2803577,54.2963836 73.2803577,61.1148776 C73.2803577,67.9324658 67.752559,73.4602645 60.934065,73.4602645 M78.7230158,42.834104 C77.2575106,42.9581919 75.7711731,42.808743 74.2984219,42.8748628 C73.4714712,42.9119986 72.9388896,42.637556 72.4470667,41.9817922 C70.947143,39.9827997 69.3693246,38.0417751 67.8621549,36.0491228 C67.287003,35.2873862 66.5959149,34.9939228 65.6521223,35.0029804 C62.0046628,35.0355874 58.354486,35.0401161 54.7070265,35.0002631 C53.7097946,34.9893941 53.0033088,35.3145587 52.4046073,36.1116196 C50.9028721,38.1088007 49.382116,40.0951128 47.7852769,42.0171165 C47.4311283,42.4437253 46.748192,42.7707014 46.1884378,42.8187062 C44.8515493,42.9346424 43.4974514,42.855842 41.9640149,42.855842 C41.9640149,42.2091358 41.9929989,41.6520989 41.9576746,41.0995907 C41.8897433,40.036239 41.3046281,39.4293858 40.2331246,39.4112707 C38.5112919,39.381381 36.7894591,39.3759465 35.0676263,39.4130822 C33.9934056,39.4366318 33.4291227,40.057977 33.3892696,41.1303863 C33.3693431,41.6557219 33.3856466,42.1819632 33.3856466,42.8078372 C31.121269,42.9074698 29.8523117,44.2289606 29,46.07941 L29,75.8722796 C30.0434252,78.4165343 31.9636175,79.1737422 34.6482636,79.1583444 C49.3911736,79.0686751 64.1340835,79.0713923 78.8769935,79.1556272 C81.5299383,79.1710249 83.372236,78.3377339 84.4011692,75.8722796 L84.4011692,46.07941 C83.3332887,43.5523646 81.4058504,42.6067605 78.7230158,42.834104"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-a" width="125.3%" height="131.7%" x="-12.6%" y="-11.3%" filterUnits="objectBoundingBox">',
  '<feOffset dy="2" in="SourceAlpha" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '<path id="camera-view-icon-3-with-shadow-v3-d" d="M104.440851,57.2204256 C104.440851,83.2997158 83.2997158,104.440851 57.2204256,104.440851 C31.1411354,104.440851 10,83.2997158 10,57.2204256 C10,31.1411354 31.1411354,10 57.2204256,10 C83.2997158,10 104.440851,31.1411354 104.440851,57.2204256 Z"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-c" width="125.5%" height="125.5%" x="-12.8%" y="-10.6%" filterUnits="objectBoundingBox">',
  '<feMorphology in="SourceAlpha" operator="dilate" radius="5.045" result="shadowSpreadOuter1"/>',
  '<feOffset dy="2" in="shadowSpreadOuter1" result="shadowOffsetOuter1"/>',
  '<feMorphology in="SourceAlpha" radius="5.045" result="shadowInner"/>',
  '<feOffset dy="2" in="shadowInner" result="shadowInner"/>',
  '<feComposite in="shadowOffsetOuter1" in2="shadowInner" operator="out" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '</defs>',
  '<g fill="none" fill-rule="evenodd">',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-a)" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<use fill="currentColor" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<g>',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-c)" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '<use stroke="currentColor" stroke-width="10.09" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '</g>',
  '</g>',
  '</svg>'].
  join('');
}

function createClusteredCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 652 598">',
  '<path fill="currentColor" d="M254.7,94.3A157.6,157.6,0,1,0,412.3,251.9,157.6,157.6,0,0,0,254.7,94.3ZM173.6,281.4a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,173.6,281.4Zm86.6,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,260.2,281.4Zm86.7,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,346.9,281.4Z"/>',
  '<circle fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="42.87px" cx="256" cy="256" r="221.5" transform="translate(-101.8 200.6) rotate(-36.2)"/>',
  '</svg>'].
  join('');
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js":
/*!*************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CreateFrustumShape.js ***!
  \*************************************************************/
/*! exports provided: createFrustumShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFrustumShape", function() { return createFrustumShape; });


// Returns a THREE.Scene to represent the camera frustum
function createFrustumShape(pos, dir) {
  // The frustum shape is a symbol to explain pos and dir - not the exact frustum.
  var FovVert = 17;
  var FovHor = 17;

  // Frustum shape/outline opacity when fully faded in
  var FrustumOpacity = 0.05;
  var LineOpacity = 1.0;

  var radians = THREE.Math.degToRad;
  var dx = Math.sin(radians(FovHor));
  var dy = Math.sin(radians(FovVert));

  // compute z in a way that the results are normalized
  var dz = Math.sqrt(1 - dx * dx - dy * dy);

  // compute directions for the 4 frustum-corners
  var bottomLeft = new THREE.Vector3(-dx, -dy, dz);

  var bottomRight = new THREE.Vector3(dx, -dy, dz);
  var topLeft = new THREE.Vector3(-dx, dy, dz);
  var topRight = new THREE.Vector3(dx, dy, dz);

  // create mesh vertices: 4 corners + origin
  var vertices = new Float32Array([
  bottomLeft.x, bottomLeft.y, bottomLeft.z,
  bottomRight.x, bottomRight.y, bottomRight.z,
  topLeft.x, topLeft.y, topLeft.z,
  topRight.x, topRight.y, topRight.z,
  0, 0, 0]);


  var bl = 0;
  var br = 1;
  var tl = 2;
  var tr = 3;
  var p0 = 4; // index of camera position vertex

  var indices = new Uint32Array([
  p0, br, bl, // bottom face
  p0, tr, br, // right face
  p0, tl, tr, // top face
  p0, bl, tl, // left face
  bl, br, tr, // far face lower tri
  bl, tr, tl // face face upper tri
  ]);

  // Extract vertices to non-indexed, so that we can compute face-normals
  var vertsNonIndexed = new Float32Array(3 * indices.length);
  for (var i = 0; i < indices.length; i++) {
    var index = indices[i];
    vertsNonIndexed[3 * i] = vertices[3 * index];
    vertsNonIndexed[3 * i + 1] = vertices[3 * index + 1];
    vertsNonIndexed[3 * i + 2] = vertices[3 * index + 2];
  }

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(vertsNonIndexed, 3));

  geometry.computeVertexNormals();

  var material = new THREE.MeshPhongMaterial({
    color: 0x5050FF,
    transparent: true,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending });


  var mesh = new THREE.Mesh(geometry, material);

  // create frustum lines
  var lineIndices = new Uint32Array([
  p0, bl,
  p0, br,
  p0, tr,
  p0, tl,
  bl, br,
  br, tr,
  tr, tl,
  tl, bl]);


  var lineGeom = new THREE.BufferGeometry();
  lineGeom.addAttribute('index', new THREE.BufferAttribute(lineIndices, 1));
  lineGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  lineGeom.isLines = true;

  var lineMaterial = new THREE.LineBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    side: THREE.DoubleSide,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending // NOTE: Overlay target is blended anyway. So, using blend here would blend with black.
  });

  var lineMesh = new THREE.Mesh(lineGeom, lineMaterial);

  // Create THREE Scene and add meshes
  var scene = new THREE.Scene();
  scene.add(mesh);
  scene.add(lineMesh);

  // Workaround: Tag geometry as visible - otherwise it is skipped by computeObjectBounds (see Viewer3DImpl).
  // TODO: My guess is that this is a bug in LMV. Once we know for sure that it doesn't break anything
  //       we should change it in LMV instead and don't need to set this manually anymore.
  geometry.visible = true;
  lineGeom.visible = true;

  // Makes it more debugger-friendly (allow you to recognize this shape within LMV)
  mesh.name = 'FrustumGizmo';

  // Set frustum shape size
  // TODO: Consider smarter way to determine size, e.g. consider model units or model box
  var size = 50;
  scene.scale.set(size, size, size);

  // move tip of the frustum to camera position
  scene.position.copy(pos);

  // orient frustum shape to look towards camera direction
  var origin = new THREE.Vector3(0, 0, 0);
  var up = new THREE.Vector3(0, 0, 1);
  var invDir = new THREE.Vector3(-dir.x, -dir.y, -dir.z); // lookat directions in THREE are defined 'towards' an object
  var rotationMatrix = new THREE.Matrix4().lookAt(origin, invDir, up);
  scene.rotation.setFromRotationMatrix(rotationMatrix);

  // Just disable culling - it's not worth to care about computing BoundingSpheres etc.
  scene.frustumCulled = false;
  mesh.frustumCulled = false;
  lineMesh.frustumCulled = false;

  // Attach function to control overall opacity (fadeValue is in [0,1])
  scene.setFadeValue = function (fadeValue) {
    material.opacity = FrustumOpacity * fadeValue;
    lineMaterial.opacity = LineOpacity * fadeValue;
  };

  return scene;
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/HCluster.js":
/*!***************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/HCluster.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HCluster; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var

HCluster = /*#__PURE__*/function () {_createClass(HCluster, null, [{ key: "FlattenCluster", value: function FlattenCluster(
    c) {var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (c.value) {
        values.push(c.value);
      } else
      {
        HCluster.FlattenCluster(c.left, values);
        HCluster.FlattenCluster(c.right, values);
      }

      return values;
    } }, { key: "ComputeMeanValueForFlattenCluster", value: function ComputeMeanValueForFlattenCluster(

    c) {
      var bbox2D = new THREE.Box3();
      var bbox3D = new THREE.Box3();

      c.forEach(function (b) {
        bbox2D.expandByPoint(b.currentPosProjected);
        bbox3D.expandByPoint(b.currentPos3D);
      });

      return {
        center2D: bbox2D.center(),
        center3D: bbox3D.center() };

    } }]);

  function HCluster(clusterfck, distanceFunc) {var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;_classCallCheck(this, HCluster);
    this._clusterfck = clusterfck;
    this.setDistanceFuncAndThreshold(distanceFunc, threshold);
  }_createClass(HCluster, [{ key: "setDistanceFuncAndThreshold", value: function setDistanceFuncAndThreshold(

    distanceFunc) {var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      this._distanceFunc = distanceFunc;
      this._threshold = threshold;
    } }, { key: "setThreshold", value: function setThreshold(

    threshold) {
      this._threshold = threshold;
    } }, { key: "createClusters", value: function createClusters(

    clusterItems) {
      var clusters = this._clusterfck.hcluster(clusterItems, this._distanceFunc, this._clusterfck.AVERAGE_LINKAGE, this._threshold);
      //console.log(clusters);

      return clusters;
    } }]);return HCluster;}();

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.css":
/*!******************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.js":
/*!*****************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeExtension; });
/* harmony import */ var _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DropMeTool.js */ "./extensions/AEC/DropMe/DropMeTool.js");
/* harmony import */ var _ViewObjectIn3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewObjectIn3D.js */ "./extensions/AEC/DropMe/ViewObjectIn3D.js");
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}





var av = Autodesk.Viewing,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.DropMeExtension';var

DropMeExtension = /*#__PURE__*/function (_av$Extension) {_inherits(DropMeExtension, _av$Extension);
  function DropMeExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { teleportOnRelease: true };_classCallCheck(this, DropMeExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropMeExtension).call(this, viewer, options));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.teleportOnRelease = options.teleportOnRelease; // teleportOnRelease used by default, not used on mobile apps.
    _this.viewer = viewer;
    _this._onModelLoaded = _this._onModelLoaded.bind(_assertThisInitialized(_this));
    _this._deactivateTool = _this._deactivateTool.bind(_assertThisInitialized(_this));
    _this.onDropOverride = null;
    _this.options = options;
    _this.options.triggerDeactivate = _this._deactivateTool;
    _this.options.isSupportedViewport = DropMeExtension.IsSupportedViewport;
    _this.toggleIndex = options.toggleIndex || 0; // at which position at the toolbar to toggle DropMe button
    _this.enableGuidance = options.enableGuidance || false;
    _this.dropMeTool = new _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](viewer, function () {var _this2;return (_this2 = _this)._onDrop.apply(_this2, arguments);}, _this.options);
    if (_this.options.enableViewIn3d) {
      _this.viewObjectIn3D = new _ViewObjectIn3D_js__WEBPACK_IMPORTED_MODULE_1__["default"](_assertThisInitialized(_this), viewer, _this.options);
    }return _this;
  }_createClass(DropMeExtension, [{ key: "load", value: function load()

    {
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
      if (this.viewer.model) {
        this._initUI(this.viewer.model);
      }
      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
      this.viewer.toolController.setIsLocked(false);
      this._deactivateTool();
      this._destroyUI();
      return true;
    } }, { key: "setOnDrop", value: function setOnDrop(

    cb) {
      this.onDropOverride = cb;
    } }, { key: "_destroyUI", value: function _destroyUI()

    {
      this._showDrop(false);

      if (this.dropMeButton) {
        this.dropMeButton.removeFromParent();
        this.dropMeButton = null;
      }
    } }, { key: "_onDrop", value: function _onDrop(

    pos, dir, mode) {
      // after drop action had been triggered, we need to deactivate tool as we are transitioning into another view.
      if (this.teleportOnRelease) {
        this.viewer.toolController.setIsLocked(false);
        this._deactivateTool();
      }

      console.log("DropMe: 3D camera position is ".concat(JSON.stringify(pos)));
      console.log("DropMe: 3D camera direction is ".concat(JSON.stringify(dir)));
      this.dispatchEvent({ type: DropMeExtension.DROP_ME_EVENT, pos: pos, dir: dir, mode: mode });

      if (this.onDropOverride) {
        this.onDropOverride(pos, dir, mode);
      } else if (this.options.onDrop) {
        this.options.onDrop(pos, dir, mode);
      } else {
        console.warn('DropMe: No onDrop callback specified ');
      }
    } }, { key: "_onModelLoaded", value: function _onModelLoaded(

    event) {
      if (!this.uiInitialized) {
        this._initUI(event.model);
      } else {
        this._updateUI(event.model);
      }
    } }, { key: "_deactivateTool", value: function _deactivateTool()

    {
      // UI might not be initialized yet. E.g., this can happen if the extensionUnload happens
      // before a model was added. In this case, dropMeButton and guidance UI will not exist anyway.
      if (this.uiInitialized) {
        this._showGuidenaceUI(false);
        this.dropMeButton.setState(avu.Button.State.INACTIVE);
      }
      this.viewer.toolController.deactivateTool('drop-me');
    } }, { key: "isSupportedModel", value: function isSupportedModel(

    model) {
      var is2dAEC = model && model.isAEC && model.isAEC() && model.is2d() && !model.isPdf();
      if (!is2dAEC) {
        return false;
      }

      if (!model.getDocumentNode()) {
        return false;
      }

      var viewports = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_2__["default"].findViewportsOnSheet(model);

      // Here we are just checking whether it makes sense to start working with this model by checking that
      // at least one viewport is fine
      return viewports.length && viewports.find(DropMeExtension.IsSupportedViewport);
    } }, { key: "_updateUI", value: function _updateUI(











    model) {
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();
      if (!toolbar) {
        return;
      }

      this.dropMeButton.removeFromParent();

      var modelTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
      modelTools.addControl(this.dropMeButton, { index: this.toggleIndex });
      this._showDrop(this.isSupportedModel(model));
    } }, { key: "_initUI", value: function _initUI(

    model) {var _this3 = this;
      // There is no need for this function when getToolbar doesn't exist (headless viewer).
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (!toolbar) {
        return;
      }

      this.dropMeButton = new avu.Button('drop-me-icon');
      this.dropMeButton.icon.innerHTML = createDropMeIcon();

      this._updateUI(model);
      this.dropMeButton.onClick = function () {
        if (_this3.dropMeTool.active) {
          _this3._deactivateTool();
        } else {
          _this3.dropMeButton.setState(avu.Button.State.ACTIVE);
          // TODO: when we activate tool we might want to forbid interaction with other tools
          _this3.viewer.toolController.activateTool('drop-me');
          _this3._showGuidenaceUI();
        }
      };
      this.uiInitialized = true;
    } }, { key: "_showGuidenaceUI", value: function _showGuidenaceUI()

    {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.enableGuidance)
      return;

      if (show) {
        var _document = this.getDocument();
        this.guidenaceUI = _document.createElement('div');
        this.guidenaceUI.className = 'dropme-guidenace-ui';
        this.guidenaceUI.innerHTML = Autodesk.Viewing.i18n.translate('Click on a location to ground yourself, then select a camera direction');
        this.viewer.container.appendChild(this.guidenaceUI);
      } else {
        if (this.viewer.container.contains(this.guidenaceUI)) {
          this.viewer.container.removeChild(this.guidenaceUI);
        }
      }
    } }, { key: "_showDrop", value: function _showDrop(

    value) {
      if (!this.dropMeButton) {
        return;
      }

      var toolbar = this.viewer.getToolbar();
      var modelTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

      if (modelTools && !this.container) {
        this.dropMeButton.setState(value ? avu.Button.State.INACTIVE : avu.Button.State.DISABLED);
      }
      var supportedTooltip = Autodesk.Viewing.i18n.translate('Click a 2D location to view that space in 3D');
      var unsupportedTooltip = Autodesk.Viewing.i18n.translate('Current view is not supported by Place Me');

      this.dropMeButton.setToolTip(value ? supportedTooltip : unsupportedTooltip);
    } }], [{ key: "IsSupportedViewport", value: function IsSupportedViewport(vp) {// For FloorPlans, we want to place the camera in pedestrian perspective. 
      // For this, we require to find a linked level to determine z-elevation.
      var hasLevelGuid = Boolean(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_2__["default"].getLinkedLevel(vp));var levelMissing = vp.viewType === 'FloorPlan' && !hasLevelGuid;return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_2__["default"].supports2DTo3DTransform(vp) && !levelMissing;} }]);return DropMeExtension;}(av.Extension);
var createDropMeIcon = function createDropMeIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">',
  '<g stroke="currentColor" fill="currentColor">',
  '<path d="M67,0c2.4.5,4.8.9,7.1,1.6C87.5,5.3,96.6,16.6,98,31a37.2,37.2,0,0,1-2.1,16.2c-4.7,13-23.6,48.1-31.6,58.2-.3-.2-.6-.3-.8-.5-11.1-17.6-21.9-35.4-30-54.7-4.6-10.9-4.6-21.7.6-32.3S47.5,2.6,58.3.7l3-.7ZM64,47A11.8,11.8,0,1,0,52.3,34.9,12,12,0,0,0,64,47Z"/>',
  '<path d="M12.8,103.4c1.4-8,6.9-12.3,14-14.6s12-2.9,18.1-4.2c1.1-.2,2.4.5,3.4,1.5-4.5,1.1-9.1,1.8-13.5,3.3a35,35,0,0,0-9.6,5c-4,3-4.3,7.5-.7,10.9a28.7,28.7,0,0,0,9.6,6.2,87.3,87.3,0,0,0,59.9.1,28.2,28.2,0,0,0,8.7-5.2c4.9-4.1,4.8-9.7-.8-12.8S90.7,89.3,85,87.3c-1.6-.6-3.4-.6-5.3-1.7,1.1-.4,2.2-1.2,3.2-1.1,7.8.9,15.5,2.2,22.6,6,12,6.4,13,17.9,2.1,26.1-8.1,6.1-17.6,8.5-27.4,10L69.1,128H59.2l-5.2-.7c-9.1-.8-18-2.6-26.4-6.5s-13.4-8.1-14.9-16.8Z"/>',
  '</g>',
  '</svg>'].
  join('');
};

namespace.DropMeExtension = DropMeExtension;
DropMeExtension.POSITION_FOUND_EVENT = 'POSITION_FOUND_EVENT';
DropMeExtension.OBJECT_SELECTED_EVENT = 'OBJECT_SELECTED_EVENT';
DropMeExtension.DROP_ME_EVENT = 'DROP_ME_EVENT';

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, DropMeExtension);

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMeTool.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/DropMe/DropMeTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeTool; });
/* harmony import */ var _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewPortOverlay.js */ "./extensions/AEC/DropMe/ViewPortOverlay.js");
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var av = Autodesk.Viewing,avp = av.Private;
var GlobalManagerMixin = av.GlobalManagerMixin;

var DROPME_MODE = { auto: 'Auto', manual: 'Manual' };var

DropMeTool = /*#__PURE__*/function (_av$ToolInterface) {_inherits(DropMeTool, _av$ToolInterface);
  function DropMeTool(viewer, onDrop, options) {var _this;_classCallCheck(this, DropMeTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropMeTool).call(this));

    _this.names = ['drop-me'];
    _this.viewer = viewer;
    _this.setGlobalManager(_this.viewer.globalManager);
    _this.options = options;
    if (_this.options.teleportOnRelease === undefined) {
      _this.options.teleportOnRelease = true; // Set true by default
    }
    _this.viewer.toolController.registerTool(_assertThisInitialized(_this));
    _this.onDrop = onDrop;
    _this.active = false;
    _this._movedSinceFirstClick = false;
    _this.init();

    _this.cameraSelectionState = {
      pending: false,
      pos: null,
      target: null,
      inViewport: false,
      initialVp: null };


    _this.teleportationInProgress = 0;

    // 'False' indicates if the user has clicked a first time alredy to choose position, so that the
    // next click will determine view-direction and instantly invoke the transition.
    _this.isFirstClick = true;

    _this.viewPortOverlay = new _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer);
    _this.escapeHotkeyId = 'Autodesk.AEC.DropMeToolEsc';return _this;
  }_createClass(DropMeTool, [{ key: "init", value: function init()

    {var _this2 = this;

      this.activate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.setGestureParameter('drag', 'threshold', 0);
        }

        var hotkeys = [{
          keycodes: [
          Autodesk.Viewing.KeyCode.ESCAPE],

          onRelease: function onRelease() {return _this2.options.triggerDeactivate && _this2.options.triggerDeactivate();} }];

        _this2.viewer.getHotkeyManager().pushHotkeys(_this2.escapeHotkeyId, hotkeys);
        _this2.viewer.addEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(true);
        _this2.active = true;
      };

      this.deactivate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.restoreGestureParameterDefault('drag', 'threshold');
        }

        _this2.viewer.getHotkeyManager().popHotkeys(_this2.escapeHotkeyId);
        _this2._cancelTeleportation();
        _this2._destroyCameraSelectorUi();
        _this2.viewer.removeEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(false);
        _this2.active = false;
        _this2._movedSinceFirstClick = false;
      };

      this.handleButtonDown = function (event) {
        return true;
      };

      this.handleButtonUp = function (event) {
        if (!this._movedSinceFirstClick || this.isFirstClick) {
          return false;
        }
        return true;
      };

      this.handleSingleClick = function (e, isTouch) {
        if (_this2.isFirstClick) {
          var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);
          if (tmpres && tmpres.pos) {
            _this2.cameraSelectionState.pos = { x: e.canvasX, y: e.canvasY };
            _this2.cameraSelectionState.pending = true;
            _this2.cameraSelectionState.initialVp = tmpres.vp;

            _this2._createCameraSelectorUi(_this2.cameraSelectionState.pos);

            requestAnimationFrame(function () {
              // We should only trigger animation if mouse has not been moved since the first click.
              if (!_this2._movedSinceFirstClick)
              _this2.cameraSelectorPosition.classList.add('camera-selector-position--teleporting');
            });

            if (tmpres.vp.viewType !== 'Section' && !isTouch) {
              // while teleportation is pending this.handleMouseMove will move camera frustum
              _this2._scheduleTeleportation();

              // needed only for scheduled teleportation
              _this2.isFirstClick = false;
              _this2.cursor = 'none';
              _this2.getCursor();
            } else
            {
              _this2._runTeleportation(DROPME_MODE.auto);
            }
          }
        } else
        {
          if (_this2.options.teleportOnRelease) {
            _this2.teleport();
          }
        }

        // As expectation of single click is a teleportation to another view, we simply consume event and do not propogate it further
        return true;
      };

      this.teleport = function () {
        _this2.cameraSelectionState.target = { x: _this2.lastX, y: _this2.lastY };
        _this2._runTeleportation(DROPME_MODE.manual);
        _this2.isFirstClick = _this2.options.teleportOnRelease;
        _this2._movedSinceFirstClick = false;
        _this2._recoverCursor();
      };

      this.handleMouseMove = function (e) {
        if (!_this2.isFirstClick && !_this2._movedSinceFirstClick)
        _this2._movedSinceFirstClick = true;

        if (_this2.cursor)
        _this2._recoverCursor();

        var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);

        if (_this2.cameraSelectionState.initialVp && !_this2.isFirstClick) {
          _this2._addVpOverlay(_this2.cameraSelectionState.initialVp);
        } else
        if (tmpres && tmpres.pos) {
          _this2._addVpOverlay(tmpres.vp);
        } else
        {
          _this2.viewPortOverlay.removeOverlay();
        }

        _this2.cameraSelectionState.inViewport = _this2.isFirstClick && tmpres && tmpres.pos || !_this2.isFirstClick;
        _this2.getCursor();

        if (!_this2.cameraSelectionState.pending) {
          return;
        }

        if (_this2.teleportationInProgress) {
          // cancel position animation
          _this2.cameraSelectorPosition.classList.remove('camera-selector-position--teleporting');
          clearTimeout(_this2.teleportationInProgress);
          _this2.teleportationInProgress = 0;
        }

        _this2.lastX = e.canvasX;
        _this2.lastY = e.canvasY;
        var dx = e.canvasX - _this2.cameraSelectionState.pos.x;
        var dy = e.canvasY - _this2.cameraSelectionState.pos.y;
        var angle = Math.atan2(dy, dx) * 180 / Math.PI;

        // In case the mouse moved:
        if (dx !== 0 || dy !== 0) {
          // atan measures the angle to the x-axis, but the frustum gizmo is originally aligned with y.
          angle += 90;
        }

        _this2.cameraSelector.style.transform = "rotate(".concat(angle, "deg)");

        if (!_this2.options.teleportOnRelease) {
          _this2.teleport();
        }

        //console.log(angle);
        return true;
      };

      this.handleSingleTap = function (event) {
        return this.handleSingleClick(event, true);
      };

      this.handleResize = function () {
        // As teleportation is going to be rather short interaction with a short-living UI, we just do not handle screen resize at all for now, but deactivate tool instead.
        _this2.options.triggerDeactivate && _this2.options.triggerDeactivate();
      };

      this.handleSingleTap = function (event, button) {
        if (_this2.isFirstClick) {
          _this2.handleSingleClick(event);
        } else {
          _this2.handleMouseMove(event);
        }
      };

      this.handleGesture = function (event) {
        switch (event.type) {
          case 'dragstart':
            break;
          case 'dragmove':
            return _this2.handleMouseMove(event, 0);
          case 'dragend':
            return true;
          case 'panmove':
          case 'panstart':
          case 'panend':
          case 'pinchmove':
          case 'pinchstart':
          case 'pinchend':
            return true;
          default:
            break;}


        return false;
      };
    } }, { key: "_recoverCursor", value: function _recoverCursor()

    {
      this.cursor = null;
      this.getCursor();
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.cursor)
      return this.cursor;
      return this.cameraSelectionState.inViewport ? 'cell' : 'default';
    } }, { key: "_addVpOverlay", value: function _addVpOverlay(

    vp) {
      this.viewPortOverlay.removeOverlay();
      var vpRect = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].getViewportBounds(vp, this.viewer.model.getUnitScale());
      var min = vpRect.min;
      var max = vpRect.max;
      this.viewPortOverlay.addOverlay(min.x, min.y, max.x, max.y);
    }

    // mode is only required for analytics purposes
  }, { key: "_runTeleportation", value: function _runTeleportation(mode) {
      this._mapToCameraPositionIn3D(mode);
      this._cancelTeleportation();
    } }, { key: "_scheduleTeleportation", value: function _scheduleTeleportation()

    {var _this3 = this;
      this.teleportationInProgress = setTimeout(function () {
        _this3._runTeleportation(DROPME_MODE.auto);
      }, 3000); // this timeout is alligned with coresponding rule of camera-selector-position css class
    } }, { key: "_cancelTeleportation", value: function _cancelTeleportation()

    {
      if (this.teleportationInProgress) {
        clearTimeout(this.teleportationInProgress);
        this.teleportationInProgress = 0;
      }
    } }, { key: "_createCameraSelectorUi", value: function _createCameraSelectorUi(

    pos) {
      //console.log(`camera position at ${pos.x}, ${pos.y}`);
      var _document = this.getDocument();
      this.cameraSelectorBackground = _document.createElement('div');
      this.cameraSelectorBackground.className = 'camera-selector-background';
      this.viewer.container.appendChild(this.cameraSelectorBackground);
      this.cameraSelectorBackground.style.top = "".concat(pos.y, "px");
      this.cameraSelectorBackground.style.left = "".concat(pos.x, "px");

      this.cameraSelectorPosition = _document.createElement('div');
      this.cameraSelectorPosition.className = 'camera-selector-position';
      this.viewer.container.appendChild(this.cameraSelectorPosition);
      this.cameraSelectorPosition.style.top = "".concat(pos.y - 10, "px");
      this.cameraSelectorPosition.style.left = "".concat(pos.x - 10, "px");

      this.cameraSelector = _document.createElement('div');
      this.cameraSelector.className = 'camera-selector';
      this.viewer.container.appendChild(this.cameraSelector);
      this.cameraSelector.style.top = "".concat(pos.y - 100, "px");
      this.cameraSelector.style.left = "".concat(pos.x - 50, "px");
    } }, { key: "_destroyCameraSelectorUi", value: function _destroyCameraSelectorUi()

    {
      if (this.viewer.container.contains(this.cameraSelector)) {
        this.viewer.container.removeChild(this.cameraSelector);
      }

      if (this.viewer.container.contains(this.cameraSelectorBackground)) {
        this.viewer.container.removeChild(this.cameraSelectorBackground);
      }

      if (this.viewer.container.contains(this.cameraSelectorPosition)) {
        this.viewer.container.removeChild(this.cameraSelectorPosition);
      }

      this.cameraSelectionState = {
        pending: false,
        pos: null,
        target: null,
        inViewport: false,
        initialVp: null };


      this.isFirstClick = true;

      this.viewPortOverlay.removeOverlay();
    }

    // Given F2D world coords (Vec3), this function returns the viewport that was hit.
  }, { key: "_findViewport", value: function _findViewport(f2dWorldPos) {
      var p2d = new THREE.Vector2(f2dWorldPos.x, f2dWorldPos.y);
      var sheet = this.viewer.model;
      return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].findViewportAtPoint(sheet, p2d, this.options.isSupportedViewport);
    } }, { key: "_mapToCameraPositionIn3DForFloorplan", value: function _mapToCameraPositionIn3DForFloorplan(

    pos, mode) {
      var posGeorefed = this._applyGeoRefTransform(pos);

      var dir = new THREE.Vector3(0.0, 1.0, 0.0);

      // in the case of not specified target, use north direction
      if (this.cameraSelectionState.target) {
        var x = this.cameraSelectionState.target.x;
        var y = this.cameraSelectionState.target.y;

        var resTarget = this._get3DCameraPositionAndVp(x, y, true);
        if (resTarget && resTarget.pos) {
          var targetGeorefed = this._applyGeoRefTransform(resTarget.pos);

          var dirX = targetGeorefed.x - posGeorefed.x;
          var dirY = targetGeorefed.y - posGeorefed.y;

          if (dirX !== 0 || dirY !== 0) {
            dir.setX(dirX).setY(dirY);
            dir.normalize();
          }
        }
      }

      // mimic natural looking direction which is not really parallel to the ground
      var rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
      dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

      this.onDrop(posGeorefed, dir, mode);
    } }, { key: "_mapToCameraPositionIn3DForSection", value: function _mapToCameraPositionIn3DForSection(

    pos, mode) {
      var posGeorefed = this._applyGeoRefTransform(pos);

      // by default we are looking into the north direction, in this case "into the screen"
      var dir = new THREE.Vector3(0.0, 1.0, 0.0);

      // mimic natural looking direction which is not really parallel to the ground
      var rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
      dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

      this.onDrop(posGeorefed, dir, mode);
    }

    // if we will come up with a good visualization widget for dir selection for "Section" views
    // the two methods "_mapToCameraPositionIn3DForFloorplan()" and "_mapToCameraPositionIn3DForSection()"
    // could be unified. we will still have two cases in "if (resTarget && resTarget.pos) {...}" code path
    //   1. FloorPlan: x,y - change, z - constant
    //   2. Section:   x - changes, y,z - constant
  }, { key: "_mapToCameraPositionIn3D", value: function _mapToCameraPositionIn3D() {var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DROPME_MODE.manual;
      var x = this.cameraSelectionState.pos.x;
      var y = this.cameraSelectionState.pos.y;
      var resPos = this._get3DCameraPositionAndVp(x, y);

      if (resPos && resPos.pos && resPos.vp) {
        if (resPos.vp.viewType === 'FloorPlan' || resPos.vp.viewType === 'EngineeringPlan' || resPos.vp.viewType === 'CeilingPlan') {
          this._mapToCameraPositionIn3DForFloorplan(resPos.pos, mode);
        } else
        if (resPos.vp.viewType === 'Section') {
          this._mapToCameraPositionIn3DForSection(resPos.pos, DROPME_MODE.auto);
        }
      }
    } }, { key: "_get3DCameraPositionAndVp", value: function _get3DCameraPositionAndVp(

    x, y) {var useInitialVp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var vpVec = this.viewer.impl.clientToViewport(x, y);
      var point = this.viewer.impl.intersectGroundViewport(vpVec);

      // if no viewport can be found for the current mouse position on a second click, try to use initial viewport
      var hitViewport = this._findViewport(point) || useInitialVp && this.cameraSelectionState.initialVp;
      if (!hitViewport) {
        // Clicked outside of the viewport
        // DropMe tool remains active and allows user to pick another point
        return null;
      }

      // Get aecData and unitScale for current sheet
      var model = this.viewer.model;
      var aec = model.getDocumentNode().getAecModelData();
      var sheetUnitScale = this.viewer.model.getUnitScale();

      // Apply 2D->3D transform to get 3D world coords
      var vpTransform = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].get2DTo3DMatrix(hitViewport, sheetUnitScale);
      var pWorld = point.clone().applyMatrix4(vpTransform);

      // Derive z from level metadata
      if (hitViewport.viewType === 'FloorPlan') {
        var level = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].findLevelForViewport(aec, hitViewport);
        if (level) {
          var avatarHeight = 5.74147; // 1.75m
          pWorld.z = level.elevation + avatarHeight;
          //console.log(pWorld.z);
        }
      }

      return {
        pos: pWorld,
        vp: hitViewport };

    } }, { key: "_applyGeoRefTransform", value: function _applyGeoRefTransform(

    pos) {
      var vec = pos.clone();

      // Skip refPoint transform if wanted
      if (this.options.useLocalModelCoords) {
        return vec;
      }
      // This extension requires AEC model data, so there should always be a refPoint tranform
      var root = this.viewer.model.getDocumentNode().getRootNode();
      var matrix = root.extractRefPointTransform();
      vec.applyMatrix4(matrix);

      return vec;
    } }]);return DropMeTool;}(av.ToolInterface);


GlobalManagerMixin.call(DropMeTool.prototype);

/***/ }),

/***/ "./extensions/AEC/DropMe/ViewObjectIn3D.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/DropMe/ViewObjectIn3D.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewObjectIn3D; });
/* harmony import */ var _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../levels/LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _DropMe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropMe.js */ "./extensions/AEC/DropMe/DropMe.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter) {if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;
/*
                           //   This file contains the logic of choosing the right position to watch a selected object in the 3D scene.
                           //   The logic of choosing the right position is created in steps:
                           //   1) Creating 8 different positions around the selected object.
                           //   2) Check if there are intersections between the optional positions to the selected object.
                           //      Choose the ones which have the least intersections, and ignore positions which looks on very narrow sides of the object
                           //      (like in doors and walls).
                           //   3) From the chosen positions, check more intersections between the position and different points on the object.
                           //      Choose the one with the least intersections. If there are more then one with the same - choose the closest.
                           //   If this logic is happening after the geometry was already loaded, we check intersections with raycast and actual geometries.
                           //   If it happens before geometry was loaded we will wait for the bounding-boxes and check intersections with them.
                           //   
                           //   While waiting for the geometry to load, there is an interval that is eliminating objects that are hiding the object during the
                           //   waiting time.
                           */var

ViewObjectIn3D = /*#__PURE__*/function () {

  function ViewObjectIn3D(dropMeExt, viewer, options) {var _this = this;_classCallCheck(this, ViewObjectIn3D);

    this.viewer = viewer;
    this.dropMeExt = dropMeExt;
    this.options = options;
    this._onModelAdded = this._onModelAdded.bind(this);
    this._onGeometryLoaded = this._onGeometryLoaded.bind(this);
    this._onModelUnloaded = this._onModelUnloaded.bind(this);
    this._onAggregatedSelectionChanged = this._onAggregatedSelectionChanged.bind(this);

    this.viewer.registerContextMenuCallback('ViewObjectIn3D', function (menu, status) {
      var is2d = _this.viewer.model.is2d();
      var isSuported = _this.options.enableViewIn3d && _this.dropMeExt.isSupportedModel(_this.viewer.model);
      var selected = isSuported && _this.viewer.getAggregateSelection();
      if (is2d && selected && selected.length === 1 && selected[0].selection.length === 1) {
        _this.pos3dFrom2d = _this._getSelected3dPosFrom2d(selected[0].selection[0], selected[0].model);
        menu.push({
          title: "View in 3D",
          target: function target() {return _this.selectObject(selected[0].selection[0]);} });

      }
    });
  }_createClass(ViewObjectIn3D, [{ key: "selectObject", value: function selectObject(

    selectedObjectID) {
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelAdded, { once: true });
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._onModelUnloaded);
      this.viewer.addEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);
      this.selectedObjectID = selectedObjectID;
      this.dropMeExt.dispatchEvent({ type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].OBJECT_SELECTED_EVENT, selectedObjectID: selectedObjectID });
    }

    // If another object was selected while waiting for the model to load, stop other selections.
  }, { key: "_onAggregatedSelectionChanged", value: function _onAggregatedSelectionChanged(selection) {
      var selected = selection.selections && selection.selections.length === 1 && selection.selections[0];
      var dbId = selected.dbIdArray && selected.dbIdArray.length === 1 && selected.dbIdArray[0];
      if (dbId === this.selectedObjectID || !selection.selections.length) {
        return;
      }

      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.viewer.removeEventListener(av.AGGREGATE_SELECTION_CHANGED_EVENT, this._onAggregatedSelectionChanged);
      this.chosenPos = null;
      this.selectedObjectID = null;
    } }, { key: "_onModelAdded", value: function _onModelAdded(_ref)

    {var _this2 = this;var model = _ref.model;
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);

      if (!this.selectedObjectID || !model.is3d()) {
        return;
      }

      this._waitForAllModels().then(function () {return _this2._placeMeToObject();});
    } }, { key: "_onModelUnloaded", value: function _onModelUnloaded()

    {
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);
    } }, { key: "_placeMeToObject", value: function _placeMeToObject()

    {var _this3 = this;

      this.isGeometryLoaded = this._loadingAllGeometriesDone();

      // Get the objects bounding boxes
      var boxes = this._getAllBoundingBoxes();
      this.selectionBox = boxes[this.selectedObjectID];

      if (!this.selectionBox) {
        // In case the selected object doesn't have a bounding box, locate the camera
        // based on the 2D position and size of the selected object.
        if (this.pos3dFrom2d) {
          this.dropMeExt.dispatchEvent({
            type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSITION_FOUND_EVENT,
            position: this.pos3dFrom2d,
            // look forward along the y axis
            target: this.pos3dFrom2d.clone().add(new THREE.Vector3(0, 1, 0)),
            isPosFrom2dTo3dMatrix: true });

        }
        return;
      } else {
        this._setBoundingBoxPoints();

        // Separate the selected object's bounding box
        this.selectionCenter = this.selectionBox.center();
        delete boxes[this.selectedObjectID];
      }

      // Create 8 optional positions around the selected target
      var optionalPositionsObjects = this._createCandidates();

      // Create a list of relatively close objects, so we don't check intersections with
      // un-relevant objects and decrease performance.
      var closeBoxesKeys = this._getCloseBoxesKeys(boxes);

      // Choose the position options which have the least interferences
      var betterOptions = this._getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys);

      // Choose the best option from the betterOptions
      this.chosenPos = this._chooseBestCandidate(betterOptions, boxes, closeBoxesKeys);

      // console.log('Chosen Position >> ', this.chosenPos.index, this.chosenPos);

      // Notify about the chosen position
      this.dropMeExt.dispatchEvent({ type: _DropMe_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSITION_FOUND_EVENT, position: this.chosenPos.position, target: this.selectionCenter, applySelectionCB: function applySelectionCB() {return _this3._applySelections(_this3.chosenPos);} });

      if (!this.isGeometryLoaded) {
        this._waitForAllInstanceTrees().then(function () {
          _this3.hidingObjectInterval && clearInterval(_this3.hidingObjectInterval);
          _this3.hidingObjectInterval = setInterval(function () {return _this3._hideCurrentIntersections();}, ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY);
        });
      }
    } }, { key: "_getAllBoundingBoxes", value: function _getAllBoundingBoxes()

    {
      var boxes = {};
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; i++) {
        var fragmentList = models[i].getFragmentList();
        boxes = Object.assign(boxes, this._getBoundingBoxes(fragmentList));
      }
      return boxes;
    } }, { key: "_getBoundingBoxes", value: function _getBoundingBoxes(

    fragmentList) {
      var boxes = {};
      var tmpBox = new THREE.Box3();
      for (var fragId = 0; fragId < fragmentList.fragments.length; fragId++) {
        var dbid = fragmentList.fragments.fragId2dbId[fragId];
        if (!boxes[dbid]) {
          boxes[dbid] = new THREE.Box3();
        }
        fragmentList.getWorldBounds(fragId, tmpBox);
        boxes[dbid].union(tmpBox);
      }

      return boxes;
    } }, { key: "_createCandidates", value: function _createCandidates()

    {

      var height = this._getHeight(this.selectionCenter.z);
      this.maxDistance = Number.MIN_VALUE;

      // Checks if the object has a very wide side relatively to it's other side so we can ignore
      // angles that look at it from the narrower side.
      var rightVec = this.viewer.navigation.getWorldRightVector();
      var upVec = this.viewer.navigation.getWorldUpVector();
      var frontVec = upVec.cross(rightVec);
      var size = this.selectionBox.size();

      var rightSide = Math.abs(size.clone().multiply(rightVec).length());
      var frontSide = Math.abs(size.clone().multiply(frontVec).length());

      var widerVector;
      var wideSide = Math.max(rightSide, frontSide);
      var narrowSide = Math.min(rightSide, frontSide);
      if (wideSide / narrowSide > ViewObjectIn3D.COVERAGE_FACTOR)
      widerVector = wideSide === rightSide ? rightVec : frontVec;

      // Set the camera to be Perspective before calling this.viewer.navigation.computeFit
      // so we will get the right positions for bimwalk.
      this.viewer.navigation.toPerspective();

      var options = [];
      for (var index = 0; index < ViewObjectIn3D.NUMBER_OF_POSITION; ++index) {
        var angle = index / (ViewObjectIn3D.NUMBER_OF_POSITION / 2) * Math.PI;

        // get a positon that fits the the selected object to view
        var newPos = this.selectionCenter.clone().add(new THREE.Vector3(Math.cos(angle), -Math.sin(angle), 0));
        var fov = this.viewer.navigation.getVerticalFov();
        var camera = this.viewer.getCamera();
        var aspect = camera.aspect;
        var optionalPositionObject = this.viewer.navigation.computeFit(newPos, this.selectionCenter, fov, this.selectionBox, aspect);var
        position = optionalPositionObject.position;

        // get the camera a bit further from the object
        var direction = position.clone().sub(this.selectionCenter);
        position.add(direction.clone().multiplyScalar(0.1));

        // set the height
        position.z = height;

        // If the wider side dot eye vector is greater then 0.8 we would like to ignore this position. 
        var dot = widerVector && direction.normalize().dot(widerVector);
        var ignore = dot && Math.abs(dot) > Math.cos(THREE.Math.degToRad(ViewObjectIn3D.IGNORE_ANGLE));

        // create a ray from the optional position towards the selected target and compute distances
        var newDiff = this.selectionCenter.clone().sub(position.clone());
        var dir = newDiff.clone().normalize();
        var ray = new THREE.Ray(position.clone(), dir.clone());
        var intersectionPos = ray.intersectBox(this.selectionBox);
        var distanceToTarget = intersectionPos && intersectionPos.sub(position).length();
        var distanceToCenterTarget = newDiff.length();

        // this.maxDistance is used to remove un-relevant objects from calculations to improve performance
        this.maxDistance = Math.max(this.maxDistance, distanceToTarget, distanceToCenterTarget);

        // When the bounding box's size is 0 in one or more dimensions, the ray can miss the object, and in that case we eliminate this option.
        distanceToTarget && !ignore && options.push({
          index: index,
          position: position,
          ray: ray,
          distanceToTarget: distanceToTarget,
          distanceToCenterTarget: distanceToCenterTarget,
          selectionID: this.selectedObjectID,
          intersections: [],
          cornerIntersections: [],
          cornerIntersectionsToHide: [] });

      }

      return options;
    } }, { key: "_getClientViewBoundingBox", value: function _getClientViewBoundingBox(

    camera) {
      var clientBB = new THREE.Box3();
      for (var k = 0; k < this.boundingBoxPoints.length; k++) {
        var vec = this.boundingBoxPoints[k];
        var point = this.viewer.impl.worldToClient(vec, camera);
        if (clientBB.min.x > point.x) clientBB.min.x = point.x;
        if (clientBB.max.x < point.x) clientBB.max.x = point.x;
        if (clientBB.min.y > point.y) clientBB.min.y = point.y;
        if (clientBB.max.y < point.y) clientBB.max.y = point.y;
      }
      return clientBB;
    } }, { key: "_setBoundingBoxPoints", value: function _setBoundingBoxPoints()

    {
      this.boundingBoxPoints = [];
      for (var k = 0; k < 8; k++) {
        var vec = new THREE.Vector3();
        vec.x = !!(k & 0x1) === false ? this.selectionBox.max.x : this.selectionBox.min.x;
        vec.y = !!(k & 0x2) === false ? this.selectionBox.max.y : this.selectionBox.min.y;
        vec.z = !!(k & 0x4) === false ? this.selectionBox.max.z : this.selectionBox.min.z;
        this.boundingBoxPoints.push(vec);
      }
    } }, { key: "_getCloseBoxesKeys", value: function _getCloseBoxesKeys(

    boxes) {var _this4 = this;
      return Object.keys(boxes).filter(function (key) {
        var center = boxes[key].center();
        var diff = center.clone().sub(_this4.selectionCenter);
        var dist = diff.length();
        return dist < _this4.maxDistance * ViewObjectIn3D.DISTANCE_FACTOR;
      });
    }

    // Choose the position options which have the least interferences
  }, { key: "_getBetterCandidates", value: function _getBetterCandidates(optionalPositionsObjects, boxes, closeBoxesKeys) {var _this5 = this;

      var betterOptions = [];
      var minIntersects = Number.POSITIVE_INFINITY;var _loop = function _loop(

      i) {
        var posObj = optionalPositionsObjects[i];

        // This check is done on the object's bounding boxes and is used in cases when the geometry is not loaded yet.
        if (!_this5.isGeometryLoaded) {
          // Intersections between the camera's position and the object's bounding box
          posObj.intersections = _this5._getIntersectionsOfRayWithBoundingBoxes(posObj, posObj.ray, minIntersects, boxes, closeBoxesKeys);
        } else {
          var candidates = [];
          posObj.intersections = [];
          _this5.viewer.impl.rayIntersect(posObj.ray, false, false, false, candidates);
          var distToObject = _this5._getClosestIntersectionWithSelectedObject(candidates);
          if (!distToObject) {
            // If no intersection with object, use the distance to it's center.
            distToObject = posObj.distanceToCenterTarget;
          } else {
            // If there is an intersection with object - use it, instead of the not-always-accurate the distance to the bounding-box.
            posObj.distanceToTarget = distToObject;
          }

          // Consider only intersections that are closer than the selected object's intersection.
          candidates.forEach(function (item) {
            if (item.dbId !== _this5.selectedObjectID && posObj.intersections.indexOf(item.dbId) === -1 && item.distance < distToObject) {
              posObj.intersections.push(item.dbId);
            }
          });
        }

        // Make a list of the optional positions that have the least objects interfering
        if (posObj.intersections.length === minIntersects) {
          betterOptions.push(posObj);
        } else if (posObj.intersections.length < minIntersects) {
          betterOptions = [posObj];
          minIntersects = posObj.intersections.length;
        }};for (var i = 0; i < optionalPositionsObjects.length; ++i) {_loop(i);
      }

      return betterOptions;
    }

    // Choose the best option from the betterOptions
  }, { key: "_chooseBestCandidate", value: function _chooseBestCandidate(betterOptions, boxes, closeBoxesKeys) {var _this6 = this;

      var chosenPos;
      var minIntersections = Number.MAX_VALUE;
      betterOptions.forEach(function (posObj) {

        chosenPos = chosenPos || posObj;

        // Create rays from the optional position to 8 corenrs of the selected object's bounding box
        // and store the intersections
        for (var k = 0; k < _this6.boundingBoxPoints.length; k++) {
          var vec = _this6.boundingBoxPoints[k];

          // Choose a point that is slightly towards the center of the object
          var offset = vec.clone().sub(_this6.selectionCenter).multiplyScalar(0.1);
          vec.sub(offset);

          // To Do: If geometry is already loaded: find a better way to choose more points on the object.

          var dir = vec.clone().sub(posObj.position).normalize();
          var ray = new THREE.Ray(posObj.position.clone(), dir);

          var cornerIntersections = [];

          if (!_this6.isGeometryLoaded) {
            cornerIntersections = _this6._getIntersectionsOfRayWithBoundingBoxes(posObj, ray, minIntersections, boxes, closeBoxesKeys);
          } else {var _ret = function () {
              _this6.viewer.impl.rayIntersect(ray, false, false, false, cornerIntersections);
              var distToObject = _this6._getClosestIntersectionWithSelectedObject(cornerIntersections);
              // If no intersection with the selected object, don't check intersections with other objects for this corner.
              if (!distToObject) {
                return "continue";
              }

              // Consider only objects that are closer then the selected object's intersection.
              cornerIntersections = cornerIntersections.filter(function (intersection) {return intersection.dbId !== _this6.selectedObjectID && intersection.distance <= distToObject;});
              cornerIntersections = cornerIntersections.map(function (intersection) {return intersection.dbId;});}();if (_ret === "continue") continue;
          }

          // This list is made for help choosing the right position.
          // Make the array of corner intersections to be of unique ones.
          if (cornerIntersections.length) {var _posObj$cornerInterse;
            (_posObj$cornerInterse = posObj.cornerIntersections).push.apply(_posObj$cornerInterse, _toConsumableArray(cornerIntersections));
            posObj.cornerIntersections = _toConsumableArray(new Set(posObj.cornerIntersections));
            // No need to continiune checking in case there are more intersections then the minimum (of the current chosen one).
            if (posObj.cornerIntersections.length > minIntersections) break;
          }

          // This is a list of objects to hide in case this optional position will be chosen.
          // We would like to hide only objects that were intersected with the front parts of the bounding box.
          if (_this6.isGeometryLoaded) {
            var vecDir = vec.clone().sub(_this6.selectionCenter);
            var eyeDot = vecDir.dot(posObj.ray.direction);
            if (eyeDot > 0 && cornerIntersections.length) {var _posObj$cornerInterse2;
              (_posObj$cornerInterse2 = posObj.cornerIntersectionsToHide).push.apply(_posObj$cornerInterse2, _toConsumableArray(cornerIntersections));
              posObj.cornerIntersectionsToHide = _toConsumableArray(new Set(posObj.cornerIntersections));
            }
          }
        }

        var count = posObj.cornerIntersections.length;
        if (_this6._isInsideOtherObject(posObj, boxes, closeBoxesKeys)) {
          count++;
        }

        // Choose the option with the least corner intersections.
        // If it is the same, choose the one that is closest to the center of the object.
        // If it is the same, choose the one that is closer to intersection with the object / it's boundng-box.
        if (count < minIntersections) {
          minIntersections = count;
          chosenPos = posObj;
        } else if (count === minIntersections) {
          if (posObj.distanceToCenterTarget === chosenPos.distanceToCenterTarget) {
            if (posObj.distanceToTarget < chosenPos.distanceToTarget) {
              chosenPos = posObj;
            }
          } else if (posObj.distanceToCenterTarget < chosenPos.distanceToCenterTarget) {
            chosenPos = posObj;
          }
        }
      });

      return chosenPos;
    } }, { key: "_getIntersectionsOfRayWithBoundingBoxes", value: function _getIntersectionsOfRayWithBoundingBoxes(

    candidate, ray, minimumIntersections, boxes, keys) {
      var intersections = [];
      var l = keys.length;

      for (var i = 0; i < l; ++i)
      {
        var dbid = keys[i];
        var box = boxes[dbid];
        var parsedDbId = parseInt(dbid);
        var vec = box && ray.intersectBox(box);
        var distToBox = vec && candidate.position.clone().sub(vec).length();

        if (distToBox) {
          if (distToBox < candidate.distanceToTarget) {
            intersections.push(parsedDbId);
            if (intersections.length > minimumIntersections) break;
          }
        }
      }

      return intersections;
    } }, { key: "_isInsideOtherObject", value: function _isInsideOtherObject(

    candidate, boxes, dbids) {
      for (var i = 0; i < dbids.length; ++i)
      {
        var dbid = dbids[i];
        var box = boxes[dbid];
        var isContain = box.containsPoint(candidate.position);
        if (isContain)
        return true;
      }

      return false;
    } }, { key: "_getClosestIntersectionWithSelectedObject", value: function _getClosestIntersectionWithSelectedObject(

    intersections) {var _this7 = this;
      var selectionDist = intersections.filter(function (intersection) {return intersection.dbId === _this7.selectedObjectID;});
      var min = Number.MAX_VALUE;
      if (!selectionDist[0]) {
        return null;
      }
      for (var j = 0; j < selectionDist.length; j++) {
        if (selectionDist[j].distance < min) {
          min = selectionDist[j].distance;
        }
      }
      return min;
    } }, { key: "_hideCurrentIntersections", value: function _hideCurrentIntersections(

    withCorners) {

      if (!this.chosenPos) {
        return;
      }

      var needsUpdate = false;
      var candidates = [];
      this.viewer.impl.rayIntersect(this.chosenPos.ray, false, false, false, candidates);
      needsUpdate = this._hideIntersectionsCandidates(candidates, true);

      // When geometry finnished loading we will check intersections towards the corners of object
      if (withCorners) {
        needsUpdate = this._hideCornersIntersections() || needsUpdate;
      }

      if (needsUpdate) {
        this.viewer.impl.invalidate(true, true, true);
      }
    } }, { key: "_hideCornersIntersections", value: function _hideCornersIntersections()

    {
      var needsUpdate = false;
      for (var k = 0; k < this.boundingBoxPoints.length; k++) {
        var vec = this.boundingBoxPoints[k];
        for (var i = 0; i < ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS; i++) {
          var cornerCandidates = [];
          var offset = vec.clone().sub(this.selectionCenter).multiplyScalar(i / ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS);
          vec.sub(offset);
          var dir = vec.clone().sub(this.chosenPos.position).normalize();
          var ray = new THREE.Ray(this.chosenPos.position.clone(), dir);
          this.viewer.impl.rayIntersect(ray, false, false, false, cornerCandidates);

          needsUpdate = this._hideIntersectionsCandidates(cornerCandidates) || needsUpdate;
        }
      }

      return needsUpdate;
    } }, { key: "_hideIntersectionsCandidates", value: function _hideIntersectionsCandidates(

    candidates, isCenterIntersection) {
      var length = candidates.length;
      var needsUpdate = false;
      var distToObject;
      if (length > 1) {
        distToObject = this._getClosestIntersectionWithSelectedObject(candidates);
        if (isCenterIntersection && distToObject && !this._isSelected(this.selectedObjectID) && this.allTreesLoaded()) {
          this.viewer.select(this.selectedObjectID);
        }
        if (isCenterIntersection || distToObject) {
          for (var i = 0; i < length; i++) {
            var item = candidates[i];
            if (item.dbId !== this.selectedObjectID && item.distance < (distToObject || this.chosenPos.distanceToCenterTarget)) {
              this.viewer.hide(item.dbId);
              needsUpdate = true;
            }
          }
        }
      }
      return needsUpdate;
    } }, { key: "_isSelected", value: function _isSelected(

    dbId) {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        if (models[i].selector.isSelected(dbId)) {
          return true;
        }
      }
      return false;
    }

    // Select the selected object and hide the covering objects
  }, { key: "_applySelections", value: function _applySelections(chosenPos) {

      if (!chosenPos || !this.allTreesLoaded()) {
        return;
      }

      if (!this._isSelected(chosenPos.selectionID)) {
        this.viewer.select(chosenPos.selectionID);
      }

      if (this.isGeometryLoaded) {
        this._hideCurrentIntersections(true);
      } else {

        for (var i = 0; i < chosenPos.intersections.length; ++i) {
          this.viewer.hide(chosenPos.intersections[i]);
        }

        for (var _i = 0; _i < chosenPos.cornerIntersectionsToHide.length; ++_i) {
          this.viewer.hide(chosenPos.cornerIntersectionsToHide[_i]);
        }
      }
    }

    // get camera's position height from level's height + avatar's height
  }, { key: "_getHeight", value: function _getHeight(elevation) {
      var units = this.viewer.model.getData().metadata['distance unit'].value || 'foot';
      var unitScale = this.viewer.model.getUnitData(units).unitScale;
      var avatarHeight = 1.8 / unitScale; // this.bimwalkExt.tool.navigator.get('cameraDistanceFromFloor')

      var aec = this.viewer.model.getDocumentNode().getAecModelData();
      var placementTf = this.viewer.model.myData.placementWithOffset;

      var floors = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_0__["aecModelDataToLevels"])(aec, placementTf);
      if (!floors.length) {
        return this.selectionBox.min.z + avatarHeight;
      }

      var level;
      if (elevation < floors[0].zMin) {
        level = floors[0];
      } else
      if (elevation > floors[floors.length - 1].zMax) {
        level = floors[floors.length - 1];
      } else
      {
        level = floors.find(function (f) {return f.zMin <= elevation && f.zMax >= elevation;});
      }

      return level.zMin + avatarHeight;
    } }, { key: "_pending3DLoaders", value: function _pending3DLoaders()

    {
      return !!this.viewer.impl.loaders.filter(function (loader) {return loader.is3d();}).length;
    } }, { key: "_loadingAllGeometriesDone", value: function _loadingAllGeometriesDone()

    {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        var loaded = models[i].isLoadDone();
        if (!loaded) {
          return false;
        }
      }
      return !this._pending3DLoaders();
    } }, { key: "_waitForAllModels", value: function _waitForAllModels()

    {var _this8 = this;

      return new Promise(function (resolve, reject) {

        var allRootModelLoaded = function allRootModelLoaded() {
          var models = _this8.viewer.getVisibleModels();
          for (var i = 0; i < models.length; ++i) {
            if (!models[i].modelRootLoaded) {
              return false;
            }
          }
          return !_this8._pending3DLoaders();
        };

        var cb = function cb(event) {
          if (allRootModelLoaded()) {
            resolve();
          } else {
            _this8.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, cb, { once: true });
          }
        };

        cb();
      });
    } }, { key: "allTreesLoaded", value: function allTreesLoaded()

    {
      var models = this.viewer.getVisibleModels();
      for (var i = 0; i < models.length; ++i) {
        if (!models[i].getInstanceTree()) {
          return false;
        }
      }
      return !this._pending3DLoaders();
    } }, { key: "_waitForAllInstanceTrees", value: function _waitForAllInstanceTrees()

    {var _this9 = this;

      return new Promise(function (resolve, reject) {

        var cb = function cb(event) {
          if (_this9.allTreesLoaded()) {
            resolve();
          } else {
            _this9.viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, cb, { once: true });
          }
        };

        cb();
      });
    } }, { key: "_onGeometryLoaded", value: function _onGeometryLoaded()

    {var _this10 = this;

      if (!this._loadingAllGeometriesDone()) {
        return;
      }

      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this._onGeometryLoaded);
      this.hidingObjectInterval && clearInterval(this.hidingObjectInterval);

      if (!this.selectedObjectID || !this.chosenPos) {
        return;
      }

      // In case gemotry was loaded before the instance tree, it will not be possible to select the object.
      // We will wait until the instance tree is loaded in order to select the object.
      this._waitForAllInstanceTrees().then(function () {

        // Select the right object again (clearSelection is called onGeometryLoaded)
        _this10.viewer.clearSelection();
        if (!_this10._isSelected(_this10.selectedObjectID)) {
          _this10.viewer.select(_this10.selectedObjectID);
        }

        // Now that the geometey is loaded we can check with a raycast if objects have to be hidden
        _this10._hideCurrentIntersections(true);

        _this10.viewer.impl.invalidate(true, true, true);

        _this10.chosenPos = null;
        _this10.selectedObjectID = null;
      });
    }

    // In cases the object is does not exist in the 3d view, we will locate the camera on the coordinations
    // taken based on the 2d position of the selected object.
  }, { key: "_getSelected3dPosFrom2d", value: function _getSelected3dPosFrom2d(selectedID, model) {
      var bounds = this.viewer.impl.computeSelectionBounds([selectedID], model);
      var point = this.viewer.impl.worldToClient(bounds.center());
      var obj = this.dropMeExt.dropMeTool._get3DCameraPositionAndVp(point.x, point.y);
      return obj && obj.pos;
    } }]);return ViewObjectIn3D;}();


// The frequency of checking objects to hide.
ViewObjectIn3D.HIDING_INTERVAL_FREQUENCY = 300;

// When geometry is already loaded we want to check intersections so we can hide them.
// In order to hide as much covering objects as possible we take the 8 bounding box's corners and
// raycast towards NUMBER_OF_CORNER_INTERSECTIONS points on the way between the center and the corners
ViewObjectIn3D.NUMBER_OF_CORNER_INTERSECTIONS = 10;

// In order to reduce calculations of rey-box intersections we remove from the iteration boxes that are far away
// from the chosen object (more than DISTANCE_FACTOR times the the distance between the camera and the object)
ViewObjectIn3D.DISTANCE_FACTOR = 3;

// In case of narrow objects like doors and walls, when one side is wider then the other by more then COVERAGE_FACTOR times
//  we would like to ignore positions that looks at the object from its narrow side.
ViewObjectIn3D.COVERAGE_FACTOR = 4.0;

// When the angle between the camera's direction and to wider side of the object is less hen IGNORE_ANGLE dgrees
// Ignore this position
ViewObjectIn3D.IGNORE_ANGLE = 35;

// The number of position candidates we create around the chosen object.
ViewObjectIn3D.NUMBER_OF_POSITION = 8;

/***/ }),

/***/ "./extensions/AEC/DropMe/ViewPortOverlay.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/DropMe/ViewPortOverlay.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewPortOverlay; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing,avp = av.Private;var

ViewPortOverlay = /*#__PURE__*/function () {
  function ViewPortOverlay(viewer) {_classCallCheck(this, ViewPortOverlay);
    this.viewer = viewer;
    this.overlayName = 'DropMeViewPortOverlay';
  }_createClass(ViewPortOverlay, [{ key: "addOverlay", value: function addOverlay(

    xMin, yMin, xMax, yMax) {
      this.viewer.impl.createOverlayScene(this.overlayName);

      var mesh = this._createMesh(xMin, yMin, xMax, yMax);
      this.viewer.impl.addOverlay(this.overlayName, mesh);
    } }, { key: "removeOverlay", value: function removeOverlay()

    {
      this.viewer.impl.removeOverlayScene(this.overlayName);
    } }, { key: "_createMesh", value: function _createMesh(

    xMin, yMin, xMax, yMax) {
      var vpId = 0;
      var dbId = -1;
      var layer = 0;
      var borderColor = 0x99d79606;
      var lineWidth = 0.1;
      var totalDist = 0;

      var vbb = new avp.VertexBufferBuilder(false, undefined, 4);

      // add border
      vbb.addSegment(xMin, yMin, xMax, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMin, xMax, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMax, xMin, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMin, yMax, xMin, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);

      var meshData = vbb.toMesh();
      var mdata = {
        mesh: meshData,
        is2d: true,
        packId: '0',
        meshIndex: 1 };


      avp.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      var materialParams = {
        skipEllipticals: true,
        skipCircles: true,
        skipTriangleGeoms: true,
        useInstancing: false };


      var matman = this.viewer.impl.matman();
      var matName = matman.create2DMaterial(this.viewer.impl.model, materialParams);
      var material = matman.findMaterial(this.viewer.impl.model, matName);

      var mesh = new THREE.Mesh(geom, material);
      return mesh;
    } }]);return ViewPortOverlay;}();

/***/ }),

/***/ "./extensions/AEC/Hypermodeling/Hypermodeling.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/Hypermodeling/Hypermodeling.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HypermodelingExtension; });
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _SheetRenderContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetRenderContext */ "./extensions/AEC/Hypermodeling/SheetRenderContext.js");
/* harmony import */ var _levels_LevelUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../levels/LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}



var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';

var namespace = AutodeskNamespace('Autodesk.AEC');
var extensionName = 'Autodesk.AEC.Hypermodeling';

/**
                                                   * The hypermodeling extension allows placing Revit 2D sheets at their correct location in the 3D model
                                                   * This relies on the 2D-3D transform available from AEC model data, and as such is limited to a certain
                                                   * type of sheets, namely floor plans (see {@link supports2DTo3DTransform})
                                                   *
                                                   * Future work: allow placing any sheet (such as PDFs) manually
                                                   *              Open the 3D model from the sheet model (inverse workflow from the current one)
                                                   */var
HypermodelingExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(HypermodelingExtension, _Autodesk$Viewing$Ext);
  function HypermodelingExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, HypermodelingExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(HypermodelingExtension).call(this, viewer, options));

    _this.loadedSheets = {};
    _this.sheetsPerLevelCache = {};
    _this.zPositionPerLevel = {};
    _this.onModelRootLoaded = _this.onModelRootLoaded.bind(_assertThisInitialized(_this));
    _this.onModelChanged = _this.onModelChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(HypermodelingExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var model3D;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension(LEVEL_EXT));case 2:this.levelExtension = _context.sent;

                this.addListeners();

                // Currently this extension works only for extending a 3D model with 2D sheets.
                // Could be extended to support the opposite workflow.
                model3D = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_2__["chooseMainModel"])(this.viewer);
                this.init(model3D);return _context.abrupt("return",

                true);case 7:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "onModelChanged", value: function onModelChanged(_ref)


    {var model = _ref.model;
      if (model.is2d()) {
        return;
      }

      var model3D = Object(_levels_LevelUtils__WEBPACK_IMPORTED_MODULE_2__["chooseMainModel"])(this.viewer);
      if (model3D !== this.model3D) {
        this.unloadAll();
        this.init(model3D);
      }
    } }, { key: "init", value: function init(

    model3D) {
      this.loadedSheets = {};
      this.sheetsPerLevelCache = {};
      this.zPositionPerLevel = {};
      this.floorSelector = this.levelExtension.floorSelector;

      this.model3D = model3D;
      if (!model3D) {
        return;
      }

      this.rootNode = this.model3D.getDocumentNode().getRootNode();
      this.document = this.rootNode.getDocument();
      this.aec = this.rootNode.getAecModelData();

      // The sheet renderer context is for pre-rendering the sheet into a different target, before placing it into
      // the 3D scene. This avoids z-fighting issues because the 2D sheets have many overlapping elements (the problem
      // doesn't appear in regular sheet viewing because depth testing is disabled there)
      if (!this.sheetRendererContext) {
        this.sheetRendererContext = new _SheetRenderContext__WEBPACK_IMPORTED_MODULE_1__["default"](this.viewer);
      }
    } }, { key: "unload", value: function unload()

    {
      this.removeListeners();

      if (this.sheetRendererContext) {
        this.sheetRendererContext.destroy();
        this.sheetRendererContext = null;
      }

      this.unloadAll();

      this.floorSelector = null;
      this.model3D = null;
      this.rootNode = null;
      this.document = null;
      this.aec = null;

      return true;
    } }, { key: "addListeners", value: function addListeners()

    {
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);
      this.viewer.addEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, this.onModelRootLoaded);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_ADDED_EVENT, this.onModelChanged);
      this.viewer.removeEventListener(Autodesk.Viewing.MODEL_REMOVED_EVENT, this.onModelChanged);
    } }, { key: "getHashNameForViewportAndLevel", value: function getHashNameForViewportAndLevel(

    viewport, levelIndex) {
      return viewport.viewportGuid + '.' + levelIndex;
    } }, { key: "onModelRootLoaded", value: function onModelRootLoaded(_ref2)

    {var model = _ref2.model;
      if (model.is3d()) {
        return;
      }

      // Since this is an async event, and multiple sheets might be loading at the same time, have to make sure
      // we get the relevant level data for the correct one.
      var hash = model.loader.options.hyperModelingHashName;
      var loadedSheet = this.loadedSheets[hash];
      if (!loadedSheet || !loadedSheet.loading) {
        Autodesk.Viewing.Private.logger.warn('Model root loaded called for sheet not being loaded');
        return;
      }

      // Only after the model root has being loaded can we fetch the unit scale.
      // And this is just in time to set the placement transform before it's used
      // to create the meshes.
      var sheetUnitScale = model.getUnitScale();
      var vpTransform = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].get2DTo3DMatrix(loadedSheet.viewport, sheetUnitScale);

      var level = this.floorSelector.floorData[loadedSheet.levelIndex];
      // Move an inch so it matches the floor. Reverses the hack in LevelUtils.js.
      // Add another tenth of an inch to avoid z-fighting with the floor (no particular reason for this number,
      // might be possible to lower it)
      // Add another small value per level to avoid z-fighting in overlapping sheets
      if (!this.zPositionPerLevel.hasOwnProperty(loadedSheet.levelIndex)) {
        this.zPositionPerLevel[loadedSheet.levelIndex] = 0;
      } else {
        this.zPositionPerLevel[loadedSheet.levelIndex] += 0.001;
      }
      var zOffsetHack = 1 / 12 + 1 / 120 + this.zPositionPerLevel[loadedSheet.levelIndex];

      var pos = new THREE.Vector3();
      pos.setFromMatrixPosition(vpTransform);

      var placementTf = this.model3D.getData().placementWithOffset;
      pos.applyMatrix4(placementTf);
      //The level's zMin already contains the transform, so it's ok to overwrite.
      pos.z = level.zMin + zOffsetHack;

      vpTransform.setPosition(pos);

      model.loader.options.placementTransform = vpTransform;
      model.loader.modelScale = vpTransform.getMaxScaleOnAxis();
    }

    /**
       * Returns the sheets available for the desired level index.
       * @param {number} levelIndex
       * @returns {array} - the sheets corresponding to the input level index
       */ }, { key: "getAvailableSheetsForLevel", value: function getAvailableSheetsForLevel(
    levelIndex) {var _this2 = this;
      if (this.sheetsPerLevelCache[levelIndex]) {
        return this.sheetsPerLevelCache[levelIndex];
      }

      var level = this.floorSelector.floorData[levelIndex];

      var viewports = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findViewportsForLevel(this.aec, level.guid);

      viewports = viewports.filter(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].supports2DTo3DTransform);

      if (viewports.length === 0) {
        Autodesk.Viewing.Private.logger.warn('No supported viewports for current level');
        return [];
      }

      var sheets = [];
      var box = new THREE.Box3();

      viewports.forEach(function (viewport) {
        var geometries = _this2.rootNode.search({ type: 'geometry', role: '2d', guid: viewport.sheetGuid });
        if (geometries.length) {
          box.set(viewport.sectionBox.min, viewport.sectionBox.max);
          var transform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(viewport.sectionBox.transform);
          box.applyMatrix4(transform);
          var size = box.size();
          sheets.push({ viewport: viewport, node: geometries[0], boxSize: size.x * size.y });
        }
      });

      // Sort viewports by size, give priority to one with largest extent
      // This might not work well in the future because it depends on the sectionBox being correct, and this is only
      // true when `isCropBoxActive` is set during export from Revit. Right now this is the only supported situation
      // (see supports2DTo3DTransform), but it might change in the future.
      // TODO make sorting an option (with maybe other types of sort such as title)
      sheets.sort(function (a, b) {return b.boxSize - a.boxSize;});

      this.sheetsPerLevelCache[levelIndex] = sheets;

      return sheets;
    }

    /**
       * Loads a sheet corresponding to a level
       * @param {number} levelIndex
       * @param {number} [sheetIndex=0] - the index of the sheet according to the order returned by {@link getAvailableSheetsForLevel}
       * @param {function} [cb=null] - an optional callback to run after the sheet has been loaded
       */ }, { key: "loadSheetFromLevel", value: function loadSheetFromLevel(
    levelIndex) {var _this3 = this;var sheetIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var sheets = this.getAvailableSheetsForLevel(levelIndex);

      if (!sheets.length) {
        return;
      }

      var selectedSheet = sheets[sheetIndex];
      var hash = this.getHashNameForViewportAndLevel(selectedSheet.viewport, levelIndex);
      var node = selectedSheet.node;

      if (this.loadedSheets[hash]) {
        var loadedSheet = this.loadedSheets[hash];
        if (!loadedSheet.loading) {
          // If already loaded just make sure sheet is visible
          this.viewer.showModel(loadedSheet.model);
        }
        cb && cb({ hash: hash, model: loadedSheet.model });
        return;
      }

      var options = {
        isAEC: true,
        useConsolidation: false,
        preserveView: true,
        keepCurrentModels: true,
        disable3DModelLayers: true,
        disablePrecomputedNodeBoxes: true,
        noShadow: true,
        doNotCut: true,
        hyperModelingHashName: hash };


      if (this.options.hidePaper) {
        options.modelSpace = true;
        options.bgColor = 0x0;
      }

      this.loadedSheets[hash] = { node: node, levelIndex: levelIndex, sheetIndex: sheetIndex, viewport: selectedSheet.viewport, loading: true };

      this.viewer.loadDocumentNode(this.document, node, options).then(function (model) {
        // Check if sheet hasn't been unloaded in the meantime
        if (!_this3.loadedSheets[hash]) {
          cb && cb({});
          return;
        }

        _this3.loadedSheets[hash].loading = false;
        _this3.loadedSheets[hash].model = model;
        // When loading the 2D sheet on a 3D model, the visible bounds z length is larger than it should be
        // Force a recalculation so that we get a correct value (needed for the SheetRenderContext)
        model.invalidateBBoxes();
        cb && cb({ hash: hash, model: model });
      });
    } }, { key: "findLoadedSheetsFromLevelIndex", value: function findLoadedSheetsFromLevelIndex(

    levelIndex) {
      var ret = []; // There might be more than one sheet loaded per level
      for (var sheet in this.loadedSheets) {
        if (this.loadedSheets[sheet].levelIndex === levelIndex) {
          ret.push(sheet);
        }
      }

      return ret;
    } }, { key: "findLoadedSheetFromLevelAndSheetIndex", value: function findLoadedSheetFromLevelAndSheetIndex(

    levelIndex, sheetIndex) {
      for (var sheet in this.loadedSheets) {
        if (this.loadedSheets[sheet].levelIndex === levelIndex && this.loadedSheets[sheet].sheetIndex === sheetIndex) {
          return sheet;
        }
      }
    } }, { key: "unloadSheet", value: function unloadSheet(

    hash) {
      var sheet = this.loadedSheets[hash];
      if (!sheet) {
        return;
      }

      this.viewer.unloadDocumentNode(sheet.node);
      delete this.loadedSheets[hash];
    } }, { key: "hideModel", value: function hideModel(

    hash) {
      var sheet = this.loadedSheets[hash];

      if (sheet) {
        if (sheet.model) {
          this.viewer.hideModel(sheet.model);
        } else if (sheet.loading) {
          this.unloadSheet(hash);
        }
      }
    } }, { key: "hideSheetFromLevel", value: function hideSheetFromLevel(

    levelIndex, sheetIndex) {
      var sheet = this.findLoadedSheetFromLevelAndSheetIndex(levelIndex, sheetIndex);
      if (sheet) {
        this.hideModel(sheet);
      }
    } }, { key: "hideAllSheetsFromLevel", value: function hideAllSheetsFromLevel(

    levelIndex) {var _this4 = this;
      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);
      sheets.forEach(function (sheet) {
        _this4.hideModel(sheet);
      });
    } }, { key: "unloadSheetsFromLevel", value: function unloadSheetsFromLevel(

    levelIndex) {var _this5 = this;
      var sheets = this.findLoadedSheetsFromLevelIndex(levelIndex);
      sheets.forEach(function (sheet) {
        _this5.unloadSheet(sheet);
      });
    } }, { key: "unloadAll", value: function unloadAll()

    {
      for (var sheet in this.loadedSheets) {
        this.viewer.unloadDocumentNode(this.loadedSheets[sheet].node);
      }

      this.loadedSheets = {};
    } }]);return HypermodelingExtension;}(Autodesk.Viewing.Extension);


namespace.HypermodelingExtension = HypermodelingExtension;
Autodesk.Viewing.theExtensionManager.registerExtension(extensionName, HypermodelingExtension);

/***/ }),

/***/ "./extensions/AEC/Hypermodeling/Shaders/SheetRenderFrag.glsl":
/*!*******************************************************************!*\
  !*** ./extensions/AEC/Hypermodeling/Shaders/SheetRenderFrag.glsl ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "uniform sampler2D sheetMap;\nuniform vec2 resolution;\nvoid main() {\n    vec2 uv = vec2(gl_FragCoord.x * resolution.x, gl_FragCoord.y * resolution.y);\n    vec4 c = texture2D(sheetMap, uv);\n    if (c.a == 0.0)\n        discard;\n    \n    gl_FragColor = c;\n}\n";

/***/ }),

/***/ "./extensions/AEC/Hypermodeling/Shaders/SheetRenderVert.glsl":
/*!*******************************************************************!*\
  !*** ./extensions/AEC/Hypermodeling/Shaders/SheetRenderVert.glsl ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "void main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

/***/ }),

/***/ "./extensions/AEC/Hypermodeling/SheetRenderContext.js":
/*!************************************************************!*\
  !*** ./extensions/AEC/Hypermodeling/SheetRenderContext.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetRenderContext; });
/* harmony import */ var _Shaders_SheetRenderVert_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shaders/SheetRenderVert.glsl */ "./extensions/AEC/Hypermodeling/Shaders/SheetRenderVert.glsl");
/* harmony import */ var _Shaders_SheetRenderVert_glsl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Shaders_SheetRenderVert_glsl__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Shaders_SheetRenderFrag_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shaders/SheetRenderFrag.glsl */ "./extensions/AEC/Hypermodeling/Shaders/SheetRenderFrag.glsl");
/* harmony import */ var _Shaders_SheetRenderFrag_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_Shaders_SheetRenderFrag_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _src_wgs_scene_SceneMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/wgs/scene/SceneMath */ "./src/wgs/scene/SceneMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// Used for pre-rendering the sheet into a different target, before placing it into the 3D scene.
var SheetRenderContext = /*#__PURE__*/function () {
  function SheetRenderContext(viewer) {_classCallCheck(this, SheetRenderContext);
    this.viewer = viewer;
    this.renderContext = this.viewer.impl.renderer();
    this.glRenderer = this.viewer.impl.glrenderer();

    this.materialName = '__material_2Don3D__';

    this.renderScene = this.renderScene.bind(this);
    this.onResize = this.onResize.bind(this);

    this.addListeners();
  }_createClass(SheetRenderContext, [{ key: "createContext", value: function createContext()

    {
      this.sheetContext = new Autodesk.Viewing.Private.RenderContext();
      this.sheetContext.init(this.glRenderer, this.viewer.canvas.clientWidth, this.viewer.canvas.clientHeight, { offscreen: true });

      var config = this.renderContext.getConfig();
      // Disable unneeded things. Set background color to transparent.
      config.antialias = false;
      config.aoEnabled = false;
      config.renderEdges = false;
      config.clearAlpha = 0;
      config.clearColorBottom.set(0, 0, 0);
      config.clearColorTop.set(0, 0, 0);

      this.sheetContext.applyConfig(config);
    } }, { key: "createTarget", value: function createTarget(

    w, h) {
      this.target = new THREE.WebGLRenderTarget(w, h, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        type: THREE.UnsignedByteType,
        depthBuffer: false });


      this.sheetContext.setOffscreenTarget(this.target);
    } }, { key: "onResize", value: function onResize(

    e) {
      this.setSize(e.width, e.height);
    } }, { key: "setSize", value: function setSize(

    w, h) {
      if (!this.sheetContext) {
        return;
      }

      this.cleanup();
      this.createTarget(w, h);

      this.sheetContext.setSize(w, h);

      this.width = this.sheetContext.settings.deviceWidth;
      this.height = this.sheetContext.settings.deviceHeight;
      this.updateMaterial();
    }

    // Creates a scene for the plane geometry to sit on
  }, { key: "createScene", value: function createScene() {
      if (!this.sheetContext) {
        this.createContext();
      }

      this.setSize(this.viewer.canvas.clientWidth, this.viewer.canvas.clientHeight);

      this.scene = new THREE.Scene();
      // Create unit size mesh. The size will be set by setting the scale
      this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);

      this.material = new THREE.ShaderMaterial({
        uniforms: {
          sheetMap: { type: 't', value: this.target },
          resolution: { type: 'v2', value: new THREE.Vector2() } },

        vertexShader: _Shaders_SheetRenderVert_glsl__WEBPACK_IMPORTED_MODULE_0___default.a,
        fragmentShader: _Shaders_SheetRenderFrag_glsl__WEBPACK_IMPORTED_MODULE_1___default.a,
        side: THREE.DoubleSide,
        transparent: true });


      this.updateMaterial();

      var materialManager = this.viewer.impl.getMaterials();
      materialManager.addMaterialNonHDR(this.materialName, this.material);

      this.mesh = new THREE.Mesh(this.planeGeometry, this.material);
      this.scene.add(this.mesh);
    } }, { key: "updateMaterial", value: function updateMaterial()

    {
      if (this.material) {
        this.material.uniforms.sheetMap.value = this.target; // Update because in resize the target will be recreated
        this.material.uniforms.resolution.value.set(1 / (this.width || 1), 1 / (this.height || 1));
      }
    }

    // The sheet is rendered onto a separate buffer, without depth testing. This buffer is then used as a texture
    // which is projected onto a plane, that matches the pose and size of the original plane. This way, we can have
    // depth testing for the sheet so it blends correctly with the 3D model, while avoiding artifacts created by
    // rendering the sheet regularly with depth testing on
  }, { key: "renderScene", value: function renderScene(event) {var
      originalScene = event.scene,want_colorTarget = event.want_colorTarget,want_saoTarget = event.want_saoTarget,want_idTarget = event.want_idTarget,context = event.context;
      if (!originalScene.frags || !originalScene.frags.is2d) {
        return;
      }

      if (!this.scene) {
        this.createScene();
      }

      // E.g. for printing the context is different (which could have a different size as well)
      context = context || this.viewer.impl.renderer();
      if (context !== this.renderContext) {
        this.renderContext = context;
        var settings = context.settings;
        if (settings.deviceWidth !== this.width || settings.deviceHeight !== this.height) {
          this.setSize(settings.logicalWidth, settings.logicalHeight);
        }
      }

      this.glRenderer.pushViewport();

      var camera = this.viewer.impl.camera;
      var model = this.viewer.impl.modelQueue().findModel(originalScene.frags.modelId);
      var bounds = model.getVisibleBounds();

      // Set pixelsPerUnit according to this sheet. In general, it is set according to the modelQueue's bounds
      // which is not related to how we want to present the sheet (i.e. the line thickness will vary when selecting a
      // floor as a result, because of the changing viewing volume)
      var materialManager = this.viewer.impl.getMaterials();
      var modelMaterials = materialManager.getModelMaterials(model);
      var modelBox = model.getBoundingBox();
      var pixelsPerUnit = _src_wgs_scene_SceneMath__WEBPACK_IMPORTED_MODULE_2__["SceneMath"].getPixelsPerUnit(camera, false, bounds, this.height, null, modelBox);

      Object.keys(modelMaterials.mats).forEach(function (key) {
        var m = modelMaterials.mats[key];
        m.uniforms["aaRange"].value = 0.5 / (pixelsPerUnit * m.modelScale);
        m.uniforms["pixelsPerUnit"].value = pixelsPerUnit * m.modelScale;
      });

      // Render original scene to separate buffer
      this.sheetContext.beginScene(this.viewer.impl.scene, camera, this.viewer.impl.noLights, true);
      this.sheetContext.renderScenePart(originalScene, true, false, false, false);
      this.sheetContext.presentBuffer();

      this.glRenderer.popViewport();

      // Update mesh with this scene's model's bounds
      this.mesh.scale.x = bounds.size().x;
      this.mesh.scale.y = bounds.size().y;
      bounds.center(this.mesh.position);

      // Now render mesh with projected texture
      this.scene.modelId = originalScene.modelId;
      this.renderContext.renderScenePart(this.scene, want_colorTarget, want_saoTarget, want_idTarget);

      event.preventDefault = true;
    } }, { key: "cleanup", value: function cleanup()

    {
      if (this.target) {
        this.target.dispose();
        this.target = null;
      }
    } }, { key: "addListeners", value: function addListeners()

    {
      this.viewer.addEventListener(Autodesk.Viewing.RENDER_SCENE_PART, this.renderScene);
      this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.RENDER_SCENE_PART, this.renderScene);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);
    } }, { key: "destroy", value: function destroy()

    {
      this.cleanup();

      this.removeListeners();

      if (this.sheetContext) {
        this.sheetContext.cleanup();
        this.context = null;
      }

      this.viewer = null;
      this.renderContext = null;
      this.glRenderer = null;

    } }]);return SheetRenderContext;}();

/***/ }),

/***/ "./extensions/AEC/LibraryExports.js":
/*!******************************************!*\
  !*** ./extensions/AEC/LibraryExports.js ***!
  \******************************************/
/*! exports provided: FloorSelector, ListPanel, ListPanelEvents, LevelsExtension, HyperlinkTracker, HyperlinkExtension, DropMeExtension, CanvasBookmarkExtension, Minimap3DExtension, AecModelData, Locations, AvatarExtension, SheetSyncExtension, TopViewRendererExtension, Hypermodeling */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/ListPanel.css */ "./extensions/AEC/ui/ListPanel.css");
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropMe/DropMe.css */ "./extensions/AEC/DropMe/DropMe.css");
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.css */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css");
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./levels/FloorSelector.js */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FloorSelector", function() { return _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./levels/LevelsExtension.js */ "./extensions/AEC/levels/LevelsExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LevelsExtension", function() { return _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hyperlinks/HyperlinkTracker.js */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkTracker", function() { return _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hyperlinks/HyperlinkExtension.js */ "./extensions/AEC/hyperlinks/HyperlinkExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkExtension", function() { return _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanelEvents"]; });

/* harmony import */ var _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DropMe/DropMe.js */ "./extensions/AEC/DropMe/DropMe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DropMeExtension", function() { return _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasBookmarkExtension", function() { return _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Minimap3D/Minimap3D.js */ "./extensions/AEC/Minimap3D/Minimap3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Minimap3DExtension", function() { return _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _Hypermodeling_Hypermodeling__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Hypermodeling/Hypermodeling */ "./extensions/AEC/Hypermodeling/Hypermodeling.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Hypermodeling", function() { return _Hypermodeling_Hypermodeling__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AecModelData", function() { return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _Locations_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Locations/index.js */ "./extensions/AEC/Locations/index.js");
/* harmony import */ var _Locations_index_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_Locations_index_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Locations", function() { return _Locations_index_js__WEBPACK_IMPORTED_MODULE_13___default.a; });
/* harmony import */ var _Avatar_AvatarExtension_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Avatar/AvatarExtension.js */ "./extensions/AEC/Avatar/AvatarExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AvatarExtension", function() { return _Avatar_AvatarExtension_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _SheetSync_SheetSyncExtension_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SheetSync/SheetSyncExtension.js */ "./extensions/AEC/SheetSync/SheetSyncExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SheetSyncExtension", function() { return _SheetSync_SheetSyncExtension_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SheetSync/TopViewRenderer */ "./extensions/AEC/SheetSync/TopViewRenderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TopViewRendererExtension", function() { return _SheetSync_TopViewRenderer__WEBPACK_IMPORTED_MODULE_16__["default"]; });



// Each one of these CSS imports gets injected into the HTML's headers inside its own <style>.





















/***/ }),

/***/ "./extensions/AEC/Locations/LocationsCommon.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Locations/LocationsCommon.js ***!
  \*****************************************************/
/*! exports provided: getPointLocations, parseLocationsMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointLocations", function() { return getPointLocations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseLocationsMetadata", function() { return parseLocationsMetadata; });
/* harmony import */ var _Edit2D_EditShapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Edit2D/EditShapes */ "./extensions/Edit2D/EditShapes.js");


// Return true if locationA is a descendant of locationB.
function isDescendant(locationA, locationB) {
  if (!locationA || !locationB) {
    return false;
  }

  if (locationA === locationB) {
    return true;
  }

  return isDescendant(locationA.parent, locationB);
};

// Given a point and location list, return all the locations that the point is inside of them.
function getPointLocations(point, locations) {
  var candidates = [];

  // For each location on the list, check if we have an intersection.
  // In case of overlap, push both candidates.
  for (var i = 0; i < locations.length; i++) {
    var location = locations[i];

    if (location.polygon.hitTest(point.x, point.y)) {
      candidates.push(location);
    }
  }

  // If one candidate is a parent of another, keep only the descendant.
  for (var _i = 0; _i < candidates.length - 1; _i++) {
    for (var j = _i + 1; j < candidates.length; j++) {
      if (isDescendant(candidates[_i], candidates[j])) {
        // Note the we remove the location node only from the candidates array - we are not deleting the parent itself.
        candidates[j] = null;
      } else if (isDescendant(candidates[j], candidates[_i])) {
        candidates[_i] = null;
      }
    }
  }

  // Filter the candidates that we removed in previous step.
  candidates = candidates.filter(function (e) {return e;});

  return candidates;
};

// Given locations metadata array, return a new array of the form [{ metadata, polygon, parent }].
function parseLocationsMetadata(locationsMetadata) {
  var locationsMap = {};

  var locations = locationsMetadata.map(function (metadata) {
    if (metadata.area) {
      if (metadata.area.format === 'Svg') {
        var polygon = _Edit2D_EditShapes__WEBPACK_IMPORTED_MODULE_0__["Shape"].fromSVG(metadata.area.geometry);

        // Depends on the API that is being used, "id" attribute can be located in a different place.
        // When using `getTreeDocuments` API, the id will be located under `node` object.
        // When using `node:search` API, the id will be located on the root.
        var id = metadata.node && metadata.node.id || metadata.id;

        var location = {
          id: id,
          metadata: metadata,
          polygon: polygon,
          parent: undefined };


        locationsMap[id] = location;

        return location;
      }
    }
  }).filter(function (e) {return e;});

  // The location list the we get from the BE is flat.
  // Traverse and link every location to its parent.
  locations.forEach(function (location) {
    // Depends on the API that is being used, "parentId" attribute can be located in a different place.
    // When using `getTreeDocuments` API, the parentId will be located under `node` object.
    // When using `node:search` API, the parentId will be located on the root.
    var parentId = location.metadata.node && location.metadata.node.parentId || location.metadata.parentId;
    location.parent = locationsMap[parentId];
  });

  return locations;
};

/***/ }),

/***/ "./extensions/AEC/Locations/LocationsService.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/Locations/LocationsService.js ***!
  \******************************************************/
/*! exports provided: fetch2dLocations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch2dLocations", function() { return fetch2dLocations; });
function createRequest(requestType, url, contentType, token, onSuccess, onError) {
  var xhr = new XMLHttpRequest();

  xhr.open(requestType, url);

  if (contentType) {
    xhr.setRequestHeader('Content-Type', contentType);
  }

  xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
  xhr.setRequestHeader('Authorization', 'Bearer ' + token);

  xhr.onload = function (event) {
    if (event.currentTarget.status === 201 || event.currentTarget.status === 200 || event.currentTarget.status === 204) {
      onSuccess(event.currentTarget.responseText);
    } else {
      onError();
    }
  };

  xhr.onerror = onError;
  xhr.ontimeout = onError;
  xhr.onabort = onError;

  return xhr;
};

function getApiSuffix(urlEnv) {
  switch (urlEnv) {
    case 'qa':
      return '-qa';
    case 'dev':
    case 'local':
      return '-dev';
    default:
      return '';}

}

function getApiEndpoint(urlEnv) {
  switch (urlEnv) {
    case 'staging':
    case 'qa':
    case 'dev':
    case 'local':
      return 'https://developer-stg.api.autodesk.com';
    default:
      return 'https://developer.api.autodesk.com';}

}

function fetch2dLocations(getAccessToken, containerId, documentLineageUrn, urlEnv) {
  return new Promise(function (resolve, reject) {
    getAccessToken(function (token) {
      if (!token) {
        return reject('Invalid access token.');
      }

      var endpoint = getApiEndpoint(urlEnv);
      var suffix = getApiSuffix(urlEnv);
      var api = "bim360/locations".concat(suffix, "/v2");
      var treeId = 'default'; // Currently this is the only treeId that's supported.
      var url = "".concat(endpoint, "/").concat(api, "/containers/").concat(containerId, "/trees/").concat(treeId, "/nodes:search");
      var results = [];

      // Handle fetching with pagination.
      function doFetch(url) {
        function onSuccess(response) {
          var responseJson = JSON.parse(response);
          results = results.concat(responseJson.results);

          if (responseJson.pagination.next) {
            doFetch(endpoint + responseJson.pagination.next);
          } else {
            resolve(results);
          }
        }

        var xhr = createRequest('POST', url, 'application/json', token, onSuccess, reject);

        var body = {
          documentUrns: [documentLineageUrn] };


        xhr.send(JSON.stringify(body));
      }

      doFetch(url);
    });
  });
};

/***/ }),

/***/ "./extensions/AEC/Locations/index.js":
/*!*******************************************!*\
  !*** ./extensions/AEC/Locations/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}
var av = Autodesk.Viewing;
var avel = AutodeskNamespace('Autodesk.AEC.Locations');

function _export(m, ns) {
  for (var prop in m) {
    if (m.hasOwnProperty(prop)) {
      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)
      module.exports[prop] = m[prop];

      //Export into the desired viewer namespace
      ns[prop] = m[prop];
    }
  }
}

_export(__webpack_require__(/*! ./LocationsService */ "./extensions/AEC/Locations/LocationsService.js"), avel);
_export(__webpack_require__(/*! ./LocationsCommon */ "./extensions/AEC/Locations/LocationsCommon.js"), avel);

/**
                                              * 2D locations library extension
                                              */var
LocationsExtension = /*#__PURE__*/function (_av$Extension) {"use strict";_inherits(LocationsExtension, _av$Extension);

  function LocationsExtension(viewer, options) {_classCallCheck(this, LocationsExtension);return _possibleConstructorReturn(this, _getPrototypeOf(LocationsExtension).call(this,
    viewer, options));
  }_createClass(LocationsExtension, [{ key: "load", value: function load()

    {
      this.locations = [];

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.locations = [];

      return true;
    } }, { key: "activate", value: function activate()
    {return true;} }, { key: "deactivate", value: function deactivate()
    {return false;}

    /**
                     * Set locations array.
                     */ }, { key: "setLocations", value: function setLocations(
    locations) {
      this.locations = locations;
    }

    /**
       * Get locations array.
       */ }, { key: "getLocations", value: function getLocations()
    {
      return this.locations;
    } }]);return LocationsExtension;}(av.Extension);


// The ExtensionManager requires an extension to be registered.
av.theExtensionManager.registerExtension('Autodesk.AEC.LocationsExtension', LocationsExtension);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.css":
/*!************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Minimap3DExtension; });
/* harmony import */ var _Minimap3DLayout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Minimap3DLayout */ "./extensions/AEC/Minimap3D/Minimap3DLayout.js");
/* harmony import */ var _src_file_loaders_main_Empty2DModelLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../src/file-loaders/main/Empty2DModelLoader */ "./src/file-loaders/main/Empty2DModelLoader.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.Minimap3DExtension';

var BIMWALK_EXT = 'Autodesk.BimWalk';
var AVATAR_EXT = 'Autodesk.AEC.AvatarExtension';
var TOP_VIEW_EXT = 'Autodesk.AEC.TopViewRendererExtension';

var VISIBILITY_PROP = 'miniMap3D';var

Minimap3DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Minimap3DExtension, _av$Extension);
  function Minimap3DExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, Minimap3DExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Minimap3DExtension).call(this, viewer, options));

    _this.mapViewerHighlightEnabled = options.mapViewerHighlightEnabled || false; // By default, mapViewer highlight (hover) is off.
    _this.mapViewerSelectionEnabled = options.mapViewerSelectionEnabled || false; // By default, mapViewer 2D object selection is off.

    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onVisibilityChanged = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(Minimap3DExtension, [{ key: "load", value: function load()

    {
      this.loaded = true;

      // Default layout is Minimap3DLayout. An optional LayoutClass can be used instead.
      var LayoutClass = this.options.LayoutClass || _Minimap3DLayout__WEBPACK_IMPORTED_MODULE_0__["default"];
      this.layout = new LayoutClass(this);

      this.viewer.prefs.add(VISIBILITY_PROP, true);

      this.viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.update);

      if (!this.configureSettings()) {
        if (!this.updateSettingsPanel) {
          //We need to connect this to an event that happens after the settings panel has been
          //create by the load sequence. The toolbar created event is serving that purpose.
          this.updateSettingsPanel = this.configureSettings.bind(this);
          this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        }
      }

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.loaded = false;

      if (this.mapViewer) {
        this.mapViewer.finish();
        this.mapViewer = null;
      }

      if (this.layout) {
        this.layout.destroy && this.layout.destroy();
        this.layout = null;
      }

      this.viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.update);

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      // Make sure that we don't leak models
      return true;
    }


    // Check if minimap is enabled in viewer config & BIM-Walk is active.
  }, { key: "isEnabled", value: function isEnabled() {
      // Check if minimap pref is setting panel is enabled.
      var prefEnabled = this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);

      // Check if bim walk is active.
      var bimWalkExt = this.viewer.getExtension(BIMWALK_EXT);
      var bimWalkEnabled = bimWalkExt && bimWalkExt.tool && bimWalkExt.tool.active;

      return prefEnabled && bimWalkEnabled;
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }

      this.update();
    } }, { key: "initMapViewer", value: function initMapViewer()

    {
      var container = this.layout.getMapViewerContainer();

      if (this.options.getMapViewer) {
        // Get mapViewer using an external callback.
        // Important! if you create a viewer of your own, make sure to initialize it with { webglInitParams: { alpha: true }.
        // Otherwise, you won't be able to see the 3D top view.
        this.mapViewer = this.options.getMapViewer(container);

      } else {
        var _window = av.getGlobal();
        // Generate a new mapViewer.
        var mainViewer = _window.NOP_VIEWER; // Keep NOP_VIEWER hack alive: NOP_VIEWER should still point to the main viewer instance

        var ViewerClass = this.options.MapViewerClass || Autodesk.Viewing.Viewer3D;

        this.mapViewer = new ViewerClass(container, {});

        // Map viewer has to have a transparent background in order to support topViewRenderer on the back. This is why `alpha:true` is mandatory.
        this.mapViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });

        _window.NOP_VIEWER = mainViewer;
      }

      // Load SheetSync, Avatar & topViewRenderer extensions.
      this.mapViewer.config.extensions = this.mapViewer.config.extensions || [];

      this.mapViewer.config.sheetSyncOptions = {
        targetViewer: this.viewer,
        cropToViewport: true,
        hideSheetWhenNotFocused: true,
        autoSwitchSheet: true,
        hidePaper: true,
        useCustomModel: this.options.useCustomModel,
        showSheet: this.options.showSheet,
        loadDocumentNode: this.options.loadDocumentNode,
        unloadModel: this.options.unloadModel };


      this.mapViewer.config.avatarOptions = {
        trackUsage: this.options.trackUsage,
        autoFocus: this.options.autoFocus };


      if (this.mapViewer.config.extensions.indexOf(AVATAR_EXT) === -1) {
        this.mapViewer.config.extensions.push(AVATAR_EXT);
      }

      if (this.mapViewer.config.extensions.indexOf(TOP_VIEW_EXT) === -1) {
        this.mapViewer.config.extensions.push(TOP_VIEW_EXT);
      }

      this.mapViewer.disableHighlight(!this.mapViewerHighlightEnabled);
      this.mapViewer.disableSelection(!this.mapViewerSelectionEnabled);

      // Load an empty model to initialize extensions and enable camera.
      this.mapViewer.loadModel("Dummy", { fileLoader: _src_file_loaders_main_Empty2DModelLoader__WEBPACK_IMPORTED_MODULE_1__["default"], headlessViewer: true });
    } }, { key: "update", value: function update()

    {
      if (this.isEnabled() && !this.mapViewer) {
        this.initMapViewer();
      }

      if (this.layout && this.layout.update) {
        this.layout.update();
      }
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return false;

      var panel = this.viewer.getSettingsPanel();

      if (!panel || !panel.is3dMode)
      return false;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "3D Mini-map");

      // add toggle to the hypermodeling tab of the viewer settings
      if (!panel.showMinimapChkBoxId) {
        panel.showMinimapChkBoxId = panel.addCheckbox(
        navTab,
        "Show 3D mini-map",
        "Toggles availability of the 3D mini-map when using first person mode",
        true,
        this.onVisibilityChanged,
        VISIBILITY_PROP);

      }

      return true;
    }

    // Toggle between auto-generated map image and sheets. Note that sheets may not be available for a level.
    // In this case, we fall back to the default map.
  }, { key: "setSheetMapEnabled", value: function setSheetMapEnabled(enabled) {
      var sheetSyncExtension = this.mapViewer && this.mapViewer.getExtension('Autodesk.AEC.SheetSyncExtension');

      if (sheetSyncExtension) {
        sheetSyncExtension.setShowSheet(enabled);
        this.update();
      }
    } }, { key: "getSheetMapEnabled", value: function getSheetMapEnabled()

    {
      var sheetSyncExtension = this.mapViewer && this.mapViewer.getExtension('Autodesk.AEC.SheetSyncExtension');
      return sheetSyncExtension && sheetSyncExtension.getShowSheet();
    } }, { key: "setSideBySideEnabled", value: function setSideBySideEnabled(

    enabled) {
      if (this.layout && this.layout.setSideBySideEnabled) {
        this.layout.setSideBySideEnabled(enabled);
      }
    } }, { key: "setSideBySideSplit", value: function setSideBySideSplit(

    value) {
      if (this.layout && this.layout.setSideBySideSplit) {
        this.layout.setSideBySideSplit(value);
      }
    } }]);return Minimap3DExtension;}(av.Extension);


namespace.Minimap3DExtension = Minimap3DExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Minimap3DExtension);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3DLayout.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3DLayout.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Minimap3DLayout; });
/* harmony import */ var _MinimapDropdown_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapDropdown.js */ "./extensions/AEC/Minimap3D/MinimapDropdown.js");
/* harmony import */ var _MinimapExpandButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapExpandButton */ "./extensions/AEC/Minimap3D/MinimapExpandButton.js");
/* harmony import */ var _MinimapSheetButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MinimapSheetButton */ "./extensions/AEC/Minimap3D/MinimapSheetButton.js");
/* harmony import */ var _Minimap3DLocales__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Minimap3DLocales */ "./extensions/AEC/Minimap3D/Minimap3DLocales.js");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Minimap3D.css */ "./extensions/AEC/Minimap3D/Minimap3D.css");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_Minimap3D_css__WEBPACK_IMPORTED_MODULE_4__);
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




// eslint-disable-next-line no-unused-vars
 // IMPORTANT!!

var av = Autodesk.Viewing;
var GlobalManagerMixin = av.GlobalManagerMixin;

var BIMWALK_EXT = 'Autodesk.BimWalk';

// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};var

Minimap3DLayout = /*#__PURE__*/function () {
  function Minimap3DLayout(minimap3DExtension) {_classCallCheck(this, Minimap3DLayout);
    this.minimap3DExtension = minimap3DExtension;
    this.viewer = this.minimap3DExtension.viewer;
    this.options = minimap3DExtension.options;

    this.setGlobalManager(this.viewer.globalManager);

    minimap3DExtension.extendLocalization(_Minimap3DLocales__WEBPACK_IMPORTED_MODULE_3__["locales"]);

    this.sideBySideOptions = this.options.sideBySideOptions || {};

    this.update = this.update.bind(this);
    this.onResize = this.onResize.bind(this);

    // Map widget size
    this.mapWidgetWidth = 300;
    this.mapWidgetHeight = 300;

    // Params for choosing mapWidget size based on canvas size
    this.relMapWidgetSizeLongEdge = 0.25; // Restrict to max 25% of the canvas along the longer axis with
    this.relMapWidgetSizeShortEdge = 0.37; // Restrict to max 37% of the canvas along the shorter axis (more tolerance here, to keep map useful for widescreen)

    // Dropdown for levels, only instantiated when there are levels
    this.dropdown = null;

    // Toggle between..
    //  - Small map on top-right of the screen (false)
    //  - Large map that fills left half of the screen (true)
    this.sideBySideEnabled = this.sideBySideOptions.sideBySideDefault || false;

    // Indicates if layout is currently configured for side-by-side view
    // (always false when map is hidden, because viewer needs to be resized to full width then)
    this.sideBySide = false;

    // Percent of viewer width that we reserve for minimap in side-by-side mode. 
    // E.g. 40 => Minimap gets 40%, Main canvas gets 60%
    this.sideBySideSplit = this.sideBySideOptions.sideBySideSplit || 40;

    this.init();
  }_createClass(Minimap3DLayout, [{ key: "setMinimapVisible", value: function setMinimapVisible(

    visible) {var _this = this;
      this.visible = visible;

      // While switching sheets, mapWidget might be null
      if (!this.mapWidget)
      return;

      // Trigger css anim. Note that doing this synchronously would skip the animation.
      var _window = this.getWindow();
      _window.requestAnimationFrame(function () {
        // Since the callback is async, we need to make sure the extension is still loaded when we get here (UI might be destroyed already).
        if (!_this.mapWidgetRoot) {
          return;
        }

        if (visible) {
          _this.mapWidgetRoot.classList.add('visible');
          _this.viewer.getExtension("Autodesk.ViewCubeUi", function (ext) {
            ext.displayViewCube(false, false);
          });
        } else {
          _this.mapWidgetRoot.classList.remove('visible');
        }
      });

      // Make sure that we reserve space for the minimap as soon as we start fade-in
      this.updateBimWalkInfoButtonPos();

      // Apply side-by-side layout immediately when starting to fade in. On fade-out, we
      // delay this until the fade-out transition is done (see transitionend-handler in initWidgets)
      if (visible) {
        this.updateSideBySide();
      }
    } }, { key: "initWidgets", value: function initWidgets()

    {var _this2 = this;
      var _document = this.getDocument();

      // Optional: add extra css class
      var classPostfix = this.options.additionalWrapperCss ? ' ' + this.options.additionalWrapperCss : '';

      // Root div for the minimap. This is only used for the toolbar: Since it is left outside the Minimap bounds, it cannot be inside the mapWidget directly,
      // because the mapWidget uses overflow:hidden to implement scrolling.
      this.mapWidgetRoot = _document.createElement('div');
      this.mapWidgetRoot.style.width = toPixels(this.mapWidgetWidth);
      this.mapWidgetRoot.style.height = toPixels(this.mapWidgetHeight);
      this.mapWidgetRoot.className = "minimap3D ".concat(classPostfix, " ");
      this.mapWidgetRoot.classList.add('adsk-viewing-viewer');
      this.mapWidgetRoot.classList.add(this.viewer.theme);

      this.mapWidgetHeader = _document.createElement('div');
      this.mapWidgetHeader.className = 'minimap-header';
      this.mapWidgetHeader.classList.add('adsk-viewing-viewer');
      this.mapWidgetHeader.classList.add('adsk-control-group');
      this.mapWidgetHeader.classList.add(this.viewer.theme);

      this.mapWidgetRoot.appendChild(this.mapWidgetHeader);

      // Div showing the minimap
      this.mapWidget = _document.createElement('div');
      this.mapWidget.className = 'minimapScrollArea';
      this.mapWidgetRoot.appendChild(this.mapWidget);

      this.dropdown = new _MinimapDropdown_js__WEBPACK_IMPORTED_MODULE_0__["default"](this);
      this.sheetModeButton = new _MinimapSheetButton__WEBPACK_IMPORTED_MODULE_2__["default"](this);
      this.sideBySideButton = new _MinimapExpandButton__WEBPACK_IMPORTED_MODULE_1__["default"](this);

      // hidden until level map is set
      this.setMinimapVisible(false);

      // Whenver the mapWidget finished fading in or out, we might need to re-adjust
      // the position of the annoying Info button of BimWalk to avoid overlapping.
      this.mapWidgetRoot.addEventListener('transitionend', function () {
        _this2.updateBimWalkInfoButtonPos();
        _this2.updateSideBySide();

        if (_this2.minimap3DExtension.mapViewer) {
          _this2.minimap3DExtension.mapViewer.resize();
        }
      });
    } }, { key: "destroyWidgets", value: function destroyWidgets()

    {
      if (this.mapWidgetRoot.parentElement) {
        this.mapWidgetRoot.parentElement.removeChild(this.mapWidgetRoot);
      }

      this.mapWidgetRoot = null;
      this.mapWidget = null;
      this.mapWidgetHeader = null;
      this.dropdown = null;
      this.sheetModeButton = null;
      this.sideBySideButton = null;
    } }, { key: "init", value: function init()

    {
      this.initWidgets();

      // choose widget size based on current canvas size
      this.updateMapSize();

      this.viewer.container.appendChild(this.mapWidgetRoot);

      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);
    } }, { key: "destroy", value: function destroy()

    {
      this.destroyWidgets();

      // Restore viewer to its default dimensions.
      this.restoreViewerContainerStyle();
      this.viewer.resize();

      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }
    } }, { key: "updateToolbar", value: function updateToolbar()

    {
      this.sideBySideButton && this.sideBySideButton.update();
      this.sheetModeButton && this.sheetModeButton.update();
    } }, { key: "update", value: function update()

    {
      if (this.minimap3DExtension.isEnabled()) {
        this.setMinimapVisible(true);
      } else {
        this.setMinimapVisible(false);
      }

      this.updateToolbar();
      this.updateSideBySide();

      if (this.minimap3DExtension.mapViewer) {
        this.minimap3DExtension.mapViewer.resize();
      }
    } }, { key: "setWidgetSize", value: function setWidgetSize(

    w, h) {
      this.mapWidgetWidth = w;
      this.mapWidgetHeight = h;

      var wStr = toPixels(w);
      var hStr = toPixels(h);
      this.mapWidgetRoot.style.width = wStr;
      this.mapWidgetRoot.style.height = hStr;

      this.update();
    }

    // Update mapWidget size based on canvas size
  }, { key: "updateMapSize", value: function updateMapSize() {
      var canvasWidth = this.viewer.container.clientWidth;
      var canvasHeight = this.viewer.container.clientHeight;

      var width, height;
      if (this.sideBySide) {
        // Fill x percent of the parent widget (x = sideBySideSplit)
        if (this.verticalSideBySide) {
          width = canvasWidth;
          height = canvasHeight * (this.sideBySideSplit / (100 - this.sideBySideSplit));
        } else {
          width = canvasWidth * (this.sideBySideSplit / (100 - this.sideBySideSplit));
          height = canvasHeight;
        }
      } else {
        // Default mode: Small map on top-right of the screen
        var longEdge = Math.max(canvasWidth, canvasHeight);
        var shortEdge = Math.min(canvasWidth, canvasHeight);
        var minimapWidthToHeightRatio = 0.66;
        // Restrict mapSize to not exceed a certain percentage of canvas width/height
        width = Math.min(this.relMapWidgetSizeLongEdge * longEdge, this.relMapWidgetSizeShortEdge * shortEdge);
        height = width * minimapWidthToHeightRatio + this.mapWidgetHeader.clientHeight; // make the minimap ratio 2:3, and include the height for the header
      }
      this.setWidgetSize(width, height);
    } }, { key: "onResize", value: function onResize()

    {
      if (this.sideBySide) {
        // Check if container bounds actually changed
        var containerBounds = this.viewer.clientContainer.getBoundingClientRect();
        var boundsChanged = !this.lastContainerBounds || this.lastContainerBounds.width !== containerBounds.width || this.lastContainerBounds.height !== containerBounds.height;

        // Update side-by-side mode, because canvas ratio might have changed from horizontal side-by-side to vertical side-by-side or vice versa.
        if (boundsChanged) {
          this.lastContainerBounds = containerBounds;
          this.updateSideBySide(true);

          return;
        }
      }

      this.updateMapSize();
    }

    // Relocate BimWalk info button to avoid overlap with Map widget
  }, { key: "updateBimWalkInfoButtonPos", value: function updateBimWalkInfoButtonPos() {
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      var button = bimWalk && bimWalk.getInfoButton();
      if (!button) {
        return;
      }

      // If the infor icon is hidden, we don't need all the mess. Hopefully this will get the default
      // state if others remove the info button as well
      if (bimWalk.options.disableBimWalkInfoIcon) {
        return;
      }


      // Only reserve space minimap is visible or about to fade in.
      var _window = this.getWindow();
      var style = _window.getComputedStyle(this.mapWidgetRoot);
      var visible = this.visible || style.opacity > 0;
      var reservedWidth = visible ? this.mapWidgetWidth : 0;

      // Shifting the info button is not needed in side-by-side mode,
      // because the map widget is outside the viewer canvas in this case.
      if (this.sideBySide) {
        reservedWidth = 0;
      }

      // Includes space between InfoButton and MapWidget + Space between MapWidget and right canvas boundary
      var Margin = 20;
      var right = reservedWidth + Margin;
      button.style.right = toPixels(right);
    } }, { key: "setSideBySideEnabled", value: function setSideBySideEnabled(

    value) {
      this.sideBySideEnabled = value;
      this.updateSideBySide();
    } }, { key: "setSideBySideSplit", value: function setSideBySideSplit(

    value) {
      this.sideBySideSplit = value;
      this.updateSideBySide(true);
      this.updateBimWalkInfoButtonPos();
    }

    // Make sure that side-by-side layout is activated if and only if minimap is visible
  }, { key: "updateSideBySide", value: function updateSideBySide(force) {

      var wasSideBySide = this.sideBySide;
      this.sideBySide = this.visible && this.sideBySideEnabled;

      if (!force && wasSideBySide === this.sideBySide) {
        return;
      }

      if (this.sideBySide) {
        var containerBounds = this.viewer.clientContainer.getBoundingClientRect();

        // Insert widget into parent of main viewer (this also removes it from viewer.container)
        var parent = this.viewer.clientContainer;
        parent.appendChild(this.mapWidgetRoot);

        this.mapWidgetRoot.classList.add('side-by-side');

        if (containerBounds.width >= containerBounds.height) {
          // reduce width of main viewer to leave space for minimap on the right
          this.viewer.container.style.width = (100 - this.sideBySideSplit).toString() + "%";
          this.viewer.container.style.height = '100%';

          if (this.sideBySideOptions.left2DView) {
            this.viewer.container.style.left = this.sideBySideSplit.toString() + "%";
          } else {
            this.viewer.container.style.right = this.sideBySideSplit.toString() + "%";
          }

          this.viewer.container.style.top = '0px';

          if (this.sideBySideOptions.left2DView) {
            this.mapWidgetRoot.classList.add('left-2d-view');
          }

          this.verticalSideBySide = false;
        } else {
          this.viewer.container.style.width = '100%';
          this.viewer.container.style.height = (100 - this.sideBySideSplit).toString() + "%";
          this.viewer.container.style.top = this.sideBySideSplit.toString() + "%";
          this.viewer.container.style.left = '0px';
          this.viewer.container.style.right = 'initial';

          this.verticalSideBySide = true;
        }

        if (this.sideBySideOptions.onSideBySideUpdated) {
          this.sideBySideOptions.onSideBySideUpdated(this.sideBySideSplit);
        }
      } else {

        // Move minimap back into viewer container (as overlay)
        this.viewer.container.appendChild(this.mapWidgetRoot);

        // resize main viewer back to 100% and move it back to the left
        this.restoreViewerContainerStyle();

        this.mapWidgetRoot.classList.remove('side-by-side');
        this.mapWidgetRoot.classList.remove('left-2d-view');
      }

      // keep canvas/camera in-sync, because we changed container size
      this.viewer.resize();

      this.updateMapSize();
    }

    // Restores default state of container for 3D Minimap and Design Diff Extensions
  }, { key: "restoreViewerContainerStyle", value: function restoreViewerContainerStyle() {
      this.viewer.container.style.width = "100%";
      this.viewer.container.style.height = "100%";
      this.viewer.container.style.left = "";
      this.viewer.container.style.right = "";
      this.viewer.container.style.top = "";
    } }, { key: "getMapViewerContainer", value: function getMapViewerContainer()

    {
      return this.mapWidget;
    } }]);return Minimap3DLayout;}();


GlobalManagerMixin.call(Minimap3DLayout.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3DLocales.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3DLocales.js ***!
  \******************************************************/
/*! exports provided: locales */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locales", function() { return locales; });
/* harmony import */ var _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../res/locales/en/nobundle-minimap3D.loc.json */ "./res/locales/en/nobundle-minimap3D.loc.json");
var _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/en/nobundle-minimap3D.loc.json */ "./res/locales/en/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../res/locales/cs/nobundle-minimap3D.loc.json */ "./res/locales/cs/nobundle-minimap3D.loc.json");
var _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/cs/nobundle-minimap3D.loc.json */ "./res/locales/cs/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../res/locales/de/nobundle-minimap3D.loc.json */ "./res/locales/de/nobundle-minimap3D.loc.json");
var _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/de/nobundle-minimap3D.loc.json */ "./res/locales/de/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../res/locales/es/nobundle-minimap3D.loc.json */ "./res/locales/es/nobundle-minimap3D.loc.json");
var _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/es/nobundle-minimap3D.loc.json */ "./res/locales/es/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../res/locales/fr/nobundle-minimap3D.loc.json */ "./res/locales/fr/nobundle-minimap3D.loc.json");
var _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr/nobundle-minimap3D.loc.json */ "./res/locales/fr/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../res/locales/fr-CA/nobundle-minimap3D.loc.json */ "./res/locales/fr-CA/nobundle-minimap3D.loc.json");
var _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/fr-CA/nobundle-minimap3D.loc.json */ "./res/locales/fr-CA/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../res/locales/it/nobundle-minimap3D.loc.json */ "./res/locales/it/nobundle-minimap3D.loc.json");
var _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/it/nobundle-minimap3D.loc.json */ "./res/locales/it/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../res/locales/ja/nobundle-minimap3D.loc.json */ "./res/locales/ja/nobundle-minimap3D.loc.json");
var _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ja/nobundle-minimap3D.loc.json */ "./res/locales/ja/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../res/locales/ko/nobundle-minimap3D.loc.json */ "./res/locales/ko/nobundle-minimap3D.loc.json");
var _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ko/nobundle-minimap3D.loc.json */ "./res/locales/ko/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../res/locales/pl/nobundle-minimap3D.loc.json */ "./res/locales/pl/nobundle-minimap3D.loc.json");
var _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pl/nobundle-minimap3D.loc.json */ "./res/locales/pl/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../res/locales/pt-BR/nobundle-minimap3D.loc.json */ "./res/locales/pt-BR/nobundle-minimap3D.loc.json");
var _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/pt-BR/nobundle-minimap3D.loc.json */ "./res/locales/pt-BR/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../res/locales/ru/nobundle-minimap3D.loc.json */ "./res/locales/ru/nobundle-minimap3D.loc.json");
var _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/ru/nobundle-minimap3D.loc.json */ "./res/locales/ru/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../res/locales/tr/nobundle-minimap3D.loc.json */ "./res/locales/tr/nobundle-minimap3D.loc.json");
var _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/tr/nobundle-minimap3D.loc.json */ "./res/locales/tr/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../res/locales/zh-HANS/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json");
var _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANS/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../res/locales/zh-HANT/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json");
var _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/zh-HANT/nobundle-minimap3D.loc.json */ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../res/locales/nl/nobundle-minimap3D.loc.json */ "./res/locales/nl/nobundle-minimap3D.loc.json");
var _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/nl/nobundle-minimap3D.loc.json */ "./res/locales/nl/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../res/locales/sv/nobundle-minimap3D.loc.json */ "./res/locales/sv/nobundle-minimap3D.loc.json");
var _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/sv/nobundle-minimap3D.loc.json */ "./res/locales/sv/nobundle-minimap3D.loc.json", 1);
/* harmony import */ var _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../../res/locales/da/nobundle-minimap3D.loc.json */ "./res/locales/da/nobundle-minimap3D.loc.json");
var _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../../res/locales/da/nobundle-minimap3D.loc.json */ "./res/locales/da/nobundle-minimap3D.loc.json", 1);
/**
 * Include each locale json file and return it in an object
 * that can be consumed by i18n
 */





















var locales = {
  en: _res_locales_en_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_0__,
  cs: _res_locales_cs_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_1__,
  de: _res_locales_de_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_2__,
  es: _res_locales_es_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_3__,
  fr: _res_locales_fr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_4__,
  "fr-CA": _res_locales_fr_CA_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_5__,
  it: _res_locales_it_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_6__,
  ja: _res_locales_ja_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_7__,
  ko: _res_locales_ko_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_8__,
  pl: _res_locales_pl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_9__,
  "pt-BR": _res_locales_pt_BR_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_10__,
  ru: _res_locales_ru_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_11__,
  tr: _res_locales_tr_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_12__,
  "zh-HANS": _res_locales_zh_HANS_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_13__,
  "zh-HANT": _res_locales_zh_HANT_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_14__,
  nl: _res_locales_nl_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_15__,
  sv: _res_locales_sv_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_16__,
  da: _res_locales_da_nobundle_minimap3D_loc_json__WEBPACK_IMPORTED_MODULE_17__ };

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapDropdown.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapDropdown.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapDropdown; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;
var GlobalManagerMixin = av.GlobalManagerMixin;
var BIMWALK_EXT = "Autodesk.BimWalk";
var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';var

MinimapDropdown = /*#__PURE__*/function () {
  function MinimapDropdown(parent) {_classCallCheck(this, MinimapDropdown);
    var DROPDOWN_HEIGHT = 50;
    this.parent = parent;
    this.viewer = parent.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.dropdownWrapper = null;
    this.parentContainer = parent.mapWidgetHeader;
    this.onClickOptionHandler = this.onClickOption.bind(this);

    this.createWrapper(DROPDOWN_HEIGHT);

    var floorData = this.getFloorDataFromLevelExtension();
    this.createDropdown(floorData);

    if (floorData.length === 0) {
      this.dropdownWrapper.classList.add("hidden");
    }

    this.onLevelChanged = this.onLevelChanged.bind(this);

    this.viewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);

    var levelExt = this.viewer.getExtension(LEVEL_EXT);
    levelExt && levelExt.floorSelector && levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.onLevelChanged);
  }_createClass(MinimapDropdown, [{ key: "createWrapper", value: function createWrapper(

    dropdownHeight) {
      var _document = this.getDocument();
      var wrapper = _document.createElement("div");
      wrapper.classList.add("minimap-dropdown-wrapper");
      wrapper.id = 'minimap-dropdown-wrapper';
      wrapper.style.height = dropdownHeight;


      this.parentContainer.insertBefore(
      wrapper,
      this.parentContainer.firstChild);


      this.dropdownWrapper = wrapper;
    } }, { key: "createDropdown", value: function createDropdown(

    floorData) {var _this = this;
      var _document = this.getDocument();
      this.titleElement = _document.createElement("div");
      this.titleElement.classList.add("minimap-title");
      this.dropdownWrapper.appendChild(this.titleElement);
      this.createDropdownOptions(floorData);

      this.dropdownWrapper.addEventListener("click", function (event) {
        _this.dropdownElement.classList.toggle("active");
        event.stopPropagation();
      });
    } }, { key: "onClickOption", value: function onClickOption(

    e) {
      var _document = this.getDocument();
      this.titleElement.id = e.target.id;
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      bimWalk.jumpToFloor(e.target.id);
      var event = _document.createEvent("Event");

      event.initEvent("change", true, true);

      this.titleElement.dispatchEvent(event);

      Array.from(this.dropdownElement.children).forEach(function (e) {return (
          e.classList.remove("active"));});

      this.dropdownWrapper.classList.toggle("active");
      e.target.classList.toggle("active");
    } }, { key: "createDropdownOptions", value: function createDropdownOptions(

    floorData) {
      var _document = this.getDocument();
      this.dropdownElement &&
      this.dropdownWrapper.removeChild(this.dropdownElement);

      this.dropdownElement = _document.createElement("ul");
      this.dropdownElement.classList.add("minimap-dropdown");
      this.dropdownElement.id = 'minimap-dropdown';
      this.dropdownWrapper.appendChild(this.dropdownElement);

      // Reordering floors in 3D minimap to match the order in Levels Panel
      for (var i = floorData.length - 1; i >= 0; i--) {
        this.createNewOption(floorData[i].name, i);
      }
    } }, { key: "createNewOption", value: function createNewOption(

    name, id) {
      var _document = this.getDocument();
      var optionElement = _document.createElement("li");

      optionElement.appendChild(_document.createTextNode(name));
      optionElement.setAttribute("id", id);
      optionElement.onclick = this.onClickOptionHandler;
      this.dropdownElement.appendChild(optionElement);
    } }, { key: "onLevelChanged", value: function onLevelChanged()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      var level = levelExt.getCurrentLevel();
      var floorData = this.getFloorDataFromLevelExtension();
      this.update(level.index, floorData);
    } }, { key: "getFloorDataFromLevelExtension", value: function getFloorDataFromLevelExtension()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      if (levelExt && levelExt.floorSelector && levelExt.floorSelector.floorData) {
        return levelExt.floorSelector.floorData;
      }
      return [];
    } }, { key: "update", value: function update(

    floorIndex, floorData) {
      if (floorData.length === 0) {
        this.dropdownWrapper.classList.add("hidden");
      } else {
        this.dropdownWrapper.classList.remove("hidden");
      }
      this.createDropdownOptions(floorData);
      if (floorIndex >= 0 && floorData[floorIndex]) {
        var floor = floorData[floorIndex];
        this.dropdownWrapper.style.display = "flex";

        this.setSelectedValue(floor.name);

        Array.from(this.dropdownElement.children).forEach(function (element) {
          element.classList.remove("active");
          if (element.textContent === floor.name) {
            element.classList.add("active");
          }
        });
      }
    } }, { key: "setSelectedValue", value: function setSelectedValue(

    valueToSet) {
      this.titleElement.textContent = valueToSet;
    } }, { key: "terminate", value: function terminate()

    {
      this.viewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.onLevelChanged);

      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      levelExt && levelExt.floorSelector && levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.onLevelChanged);

      this.dropdownWrapper.parentNode.removeChild(this.dropdownWrapper);
      this.dropdownWrapper = null;
    } }]);return MinimapDropdown;}();


GlobalManagerMixin.call(MinimapDropdown.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapExpandButton.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapExpandButton.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapExpandButton; });
/* harmony import */ var _adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjustButtonStyle */ "./extensions/AEC/Minimap3D/adjustButtonStyle.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;
var avu = av.UI;

var GlobalManagerMixin = av.GlobalManagerMixin;var

MinimapExpandButton = /*#__PURE__*/function () {
  function MinimapExpandButton(parent) {_classCallCheck(this, MinimapExpandButton);
    this.parent = parent;
    this.parentElement = parent.mapWidgetHeader;
    this.setGlobalManager(parent.viewer.globalManager);
    // Create toggle to switch between small map and side-by-side map
    this.sideBySideButton = new avu.Button("Minimap_SideBySide");
    this.sideBySideButton.setGlobalManager(this.globalManager);
    this.sideBySideButton.onClick = function () {return (
        parent.setSideBySideEnabled(!parent.sideBySideEnabled));};
    this.sideBySideButton.icon.innerHTML = createMapExpandIcon();
    this.parentElement.appendChild(this.sideBySideButton.container);

    // Create alternative icon that we show in expanded mode
    var _document = this.getDocument();
    this.shrinkIcon = _document.createElement("div");
    this.shrinkIcon.innerHTML = createMapShrinkIcon();
    this.sideBySideButton.container.appendChild(this.shrinkIcon);

    Object(_adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__["default"])(this.sideBySideButton);

    // Hide toolbar by default - unless activated by feature flag
    if (!this.parent.options.enableSheetMapAndSideBySide) {
      this.parentElement.style.display = "none";
    }

    // Set icons and tooltips
    this.update();
  }_createClass(MinimapExpandButton, [{ key: "setSideBySideButtonDisabled", value: function setSideBySideButtonDisabled(

    disable) {
      this.parent.options.sideBySideButtonDisabled = disable;
    } }, { key: "update", value: function update()

    {
      var sideBySideIsEnabled = this.parent.sideBySideEnabled;
      // Show expand/collapse icon depending on current state
      this.shrinkIcon.style.display = sideBySideIsEnabled ? "block" : "none";
      this.sideBySideButton.icon.style.width = "20px";
      this.sideBySideButton.icon.style.height = "20px";
      this.sideBySideButton.icon.style.display = sideBySideIsEnabled ?
      "none" :
      "block";

      this.sideBySideButton.setState(
      this.parent.options.sideBySideButtonDisabled ?
      avu.Button.State.DISABLED :
      avu.Button.State.INACTIVE);


      // Set tooltips based on current states
      var Expand = Autodesk.Viewing.i18n.translate("Show large map");
      var Shrink = Autodesk.Viewing.i18n.translate("Show small map");
      this.sideBySideButton.setToolTip(sideBySideIsEnabled ? Shrink : Expand);
    } }]);return MinimapExpandButton;}();


GlobalManagerMixin.call(MinimapExpandButton.prototype);

var createMapExpandIcon = function createMapExpandIcon() {
  return [
  '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">',
  '<path d="M18.5 6C18.5 5.72386 18.2761 5.5 18 5.5L13.5 5.5C13.2239 5.5 13 5.72386 13 6C13 6.27614 13.2239 6.5 13.5 6.5L17.5 6.5L17.5 10.5C17.5 10.7761 17.7239 11 18 11C18.2761 11 18.5 10.7761 18.5 10.5L18.5 6ZM5.5 18C5.5 18.2761 5.72386 18.5 6 18.5L10.5 18.5C10.7761 18.5 11 18.2761 11 18C11 17.7239 10.7761 17.5 10.5 17.5L6.5 17.5L6.5 13.5C6.5 13.2239 6.27614 13 6 13C5.72386 13 5.5 13.2239 5.5 13.5L5.5 18ZM17.6464 5.64645L5.64645 17.6464L6.35355 18.3536L18.3536 6.35355L17.6464 5.64645Z" fill="currentColor"/>',
  "</svg>"].
  join("");
};

var createMapShrinkIcon = function createMapShrinkIcon() {
  return [
  '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">',
  '<path d="M18 6L13 11M13 11L13 6.83333M13 11L17.1667 11" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
  '<path d="M6 18L11 13M11 13L11 17.1667M11 13L6.83333 13" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
  "</svg>"].
  join("");
};

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapMath.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapMath.js ***!
  \*************************************************/
/*! exports provided: worldToMapPixels, mapPixelsToWorld, posIsInsideMap, setCameraFromFrustumCorners, setTopView, compute3DTo2DMatrix, motionSmoothing, rotateAround, expandToSquare, boundsToUnitQuad, computeAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToMapPixels", function() { return worldToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWorld", function() { return mapPixelsToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "posIsInsideMap", function() { return posIsInsideMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCameraFromFrustumCorners", function() { return setCameraFromFrustumCorners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTopView", function() { return setTopView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compute3DTo2DMatrix", function() { return compute3DTo2DMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "motionSmoothing", function() { return motionSmoothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAround", function() { return rotateAround; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandToSquare", function() { return expandToSquare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsToUnitQuad", function() { return boundsToUnitQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAngle", function() { return computeAngle; });
// Utility functions used by Minimap


// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
var worldToMapPixels = function worldToMapPixels(pos3D, mapMatrix, mapWidth, mapHeight) {
  var p = pos3D.clone().applyProjection(mapMatrix);
  var res = new THREE.Vector2(
  (p.x + 1) / 2 * mapWidth,
  (-p.y + 1) / 2 * mapHeight);

  return res;
};

var mapPixelsToWorld = function mapPixelsToWorld(posX, posY, zWorld, mapMatrixInv, mapWidth, mapHeight) {
  // convert pixels to normalized viewport coords in [-1,1]
  var vx = 2 * (posX / mapWidth) - 1.0;
  var vy = 2 * (posY / mapHeight) - 1.0;

  // Beware of the annoying y-flip
  var p = new THREE.Vector3(vx, -vy, 0.0).applyProjection(mapMatrixInv);
  p.z = zWorld;
  return p;
};

// Checks whether the given 3D position would appear inside the map for the given mapMatrix.
//  @param {Vector3} pos3D
//  @param {Matrix4} mapMatrix
//  @returns {bool}
var _tmpVec = null;
var posIsInsideMap = function posIsInsideMap(pos3D, mapMatrix) {

  _tmpVec = _tmpVec || new THREE.Vector3();

  // Compute position in map space [-1, 1] that we would get when using this map
  var mapPos = _tmpVec.copy(pos3D).applyProjection(mapMatrix);

  // Check if camera position is inside
  return Math.abs(mapPos.x) < 1.0 && Math.abs(mapPos.y) < 1.0;
};

// Configures the ortho-camera from given 3 points, so that:
//  p0: appears at lower-left corner
//  p1: appears at lower-right corner
//  p2: appears at upper-left corner
//
// We assume that camera target.z is already set and on the sheet-plane level
var setCameraFromFrustumCorners = function setCameraFromFrustumCorners(camera, p0, p1, p2) {

  // up-vector: p2-p0
  camera.up.x = p2.x - p0.x;
  camera.up.y = p2.y - p0.y;

  // position
  camera.position.x = 0.5 * (p1.x + p2.x);
  camera.position.y = 0.5 * (p1.y + p2.y);

  var frustumHeight = camera.up.length();

  // normalize up-vector
  camera.up.multiplyScalar(1.0 / frustumHeight);

  // For LMV ortho-cameras...
  // - The vertical frustum height is identical with the orthoScale 
  // - The orthoScale is determined by the distance between position and target
  // - For sheets, the view direction is always -z and zoom is manipulated by changing pos.z while having a constant target.z
  // Therefore, we obtain the desired frustum height by:
  var targetDist = frustumHeight;
  camera.position.z = camera.target.z + targetDist;

  // keep horizontal target position in sync
  camera.target.x = camera.position.x;
  camera.target.y = camera.position.y;

  // This updates the camera quaternion. Without this, modifying the up-vector would not have any effect.
  Autodesk.Viewing.Navigation.prototype.orient(camera, camera.target, camera.position, camera.up);

  camera.dirty = true;
};

var setTopView = function setTopView(camera, bbox, zMin, zMax, orthoScale) {

  var center = THREE.Box3.prototype.center.call(bbox);

  // set camera pos to upper face center
  camera.position.copy(center);
  camera.position.z = zMax;

  // target distance defines orthoScale, which finally
  // defines the height of the orthoCam frustum in world-space
  camera.target.copy(camera.position);
  camera.target.z -= orthoScale;
  camera.isPerspective = false;

  // set up-vector for view from top
  camera.up.set(0, 1, 0);
  camera.worldup.set(0, 1, 0);

  // Configure near/far to see only zMin/zMax range
  camera.near = 0;
  camera.far = zMax - zMin;

  // This makes sure that compute3DTo2DMatrix() produces always the same resuts, no matter whether we do it before or after rendering.
  camera.updateCameraMatrices();
};

// Computes a Matrix4 that transforms from 3D model position to
// normalized viewport coords ([-1,1]^2) on the minimap.
var compute3DTo2DMatrix = function compute3DTo2DMatrix(camera, dstMatrix) {
  dstMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
};

// Helper function to smoothen movement of scroll position and zoomScale.
//  @param {number} dist      - distance to move to reach target directly. Must be >=0.
//  @param {number} elapsed   - elapsed time in seconds
//  @param {number} maxSpeed  - maximum allowed distance units per second
//  @param {number} lastSpeed - motion speed according to last cycle (delta / elapsed)
//  @param {number} acc       - acceleration speed (in distance units per s^2)
//  @returns {number} Result is a distance <=dist, which is slowed down if needed for smoother movement.
var motionSmoothing = function motionSmoothing(dist, elapsed, maxSpeed, lastSpeed, acc) {

  // Limit max scroll speed and avoid too sudden acceleration compared to last cycle
  var speed = Math.min(maxSpeed, lastSpeed + acc * elapsed);

  // Slow down with constant deceleration when approaching the target position:
  //
  //   With a constant acceleration a for a time of t seconds, we have:
  //     speed    = t*a
  //     distance = 0.5 * a * t^2
  //
  // To scroll a given distance d with constant acceleration a, the time needed is:
  //   t = sqrt(2*d / a)
  //
  // The speed reached at that point is:
  //   s = a * sqrt(2*d / a)
  //
  // Therefore, s as given above gives us the speed that we must have if distance d
  // to the target if we want to stop at the target given a constant deceleration of a.
  var slowDownSpeed = acc * Math.sqrt(2 * dist / acc);
  speed = Math.min(slowDownSpeed, speed);

  // restrict distance based on computed speed limit
  var maxDist = speed * elapsed;
  return Math.min(dist, maxDist);
};

// Rotates p around the center point. Works for Vector3 in xy too.
//  @param {Vector2} p
//  @param {Vector2} center
//  @param {number}  angle  - counterclockwise angle in radians
var rotateAround = function rotateAround(p, center, angle) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  var x = p.x - center.x;
  var y = p.y - center.y;

  p.x = x * c - y * s + center.x;
  p.y = x * s + y * c + center.y;
};

// Expands rect in-place by expanding the smallest axis around the center.
//  @param {Box2} rect
var expandToSquare = function expandToSquare(rect) {

  // determine scale factor from max-axis of sheet bounds
  var diag = rect.size();
  var center = rect.center();

  var radius = 0.5 * Math.max(diag.x, diag.y);

  rect.min.set(center.x - radius, center.y - radius);
  rect.max.set(center.x + radius, center.y + radius);
};

// Rescales a point p within srcBounds to [0.1]^2. Works in-place.
//  @param {Vector2} p
//  @param {Box2} srcBounds
var boundsToUnitQuad = function boundsToUnitQuad(p, srcBounds) {
  var diagX = srcBounds.max.x - srcBounds.min.x;
  var diagY = srcBounds.max.y - srcBounds.min.y;

  p.x -= srcBounds.min.x;
  p.y -= srcBounds.min.y;

  p.x /= diagX;
  p.y /= diagY;
};

// Compute rotation angle for camera view-cone on map.
//  @param {THREE.Vector2} pos    - camera position     in minimap pixel space
//  @param {THREE.Vector2} target - camera target point in minimap pixel space
//  @returns {number}  Rotation angle in radians to transform a originally up-facing div located
//                     in a way that it points towards (p2-p1).
var computeAngle = function computeAngle(pos, target) {
  var dx = target.x - pos.x;
  var dy = target.y - pos.y;
  var angle = Math.atan2(dy, dx);

  // atan measures the angle to the x-axis, but we want it to work for divs originally aligned with +y.
  angle += Math.PI / 2;

  return angle;
};



/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapSheetButton.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapSheetButton.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapSheetButton; });
/* harmony import */ var _adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adjustButtonStyle */ "./extensions/AEC/Minimap3D/adjustButtonStyle.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;
var avu = av.UI;

var GlobalManagerMixin = av.GlobalManagerMixin;var

MinimapSheetButton = /*#__PURE__*/function () {
  function MinimapSheetButton(parent) {var _this = this;_classCallCheck(this, MinimapSheetButton);
    this.minimap3DExtension = parent.minimap3DExtension;
    this.parentElement = parent.mapWidgetHeader;
    this.setGlobalManager(parent.globalManager);

    // Create toggle to switch between default map and sheets
    this.sheetModeButton = new avu.Button("Minimap_SheetMode");
    this.sheetModeButton.setGlobalManager(this.globalManager);
    this.sheetModeButton.onClick = function () {return (
        _this.minimap3DExtension.setSheetMapEnabled(!_this.minimap3DExtension.getSheetMapEnabled()));};
    this.sheetModeButton.icon.innerHTML = createSheetMapIcon();
    this.parentElement.appendChild(this.sheetModeButton.container);

    Object(_adjustButtonStyle__WEBPACK_IMPORTED_MODULE_0__["default"])(this.sheetModeButton);

    this.sheetModeButton.icon.style.display = "block";
    this.sheetModeButton.icon.style.width = "20px";
    this.sheetModeButton.icon.style.height = "20px";
    this.sheetModeButton.icon.style.verticalAlign = "middle";
    // Set icons and tooltips
    this.update();
  }_createClass(MinimapSheetButton, [{ key: "update", value: function update()

    {
      var state = this.minimap3DExtension.getSheetMapEnabled() ?
      avu.Button.State.ACTIVE :
      avu.Button.State.INACTIVE;
      this.sheetModeButton.setState(state);

      // Set tooltips based on current states
      var showSheets = Autodesk.Viewing.i18n.translate("Show sheet");
      var hideSheets = Autodesk.Viewing.i18n.translate("Hide sheet");

      this.sheetModeButton.setToolTip(state === avu.Button.State.INACTIVE ? showSheets : hideSheets);
    } }]);return MinimapSheetButton;}();


GlobalManagerMixin.call(MinimapSheetButton.prototype);

var createSheetMapIcon = function createSheetMapIcon() {
  return [
  '<svg viewBox="2 2 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">',
  '<path d="M20 10V17C20 17.5523 19.5523 18 19 18H5C4.44772 18 4 17.5523 4 17V7C4 6.44772 4.44772 6 5 6H16M20 10L16 6M20 10H17C16.4477 10 16 9.55228 16 9V6" stroke="currentColor"/>',
  '<path d="M13 9H7V15.5H12V13" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
  '<path d="M11.5 15.5H16V12" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
  '<path d="M10 9V11.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>',
  "</svg>"].
  join("");
};

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetMap.js":
/*!**********************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetMap.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMap; });
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} //
// SheetMap is used by Minimap in order to display a sheet in an own viewer instance - instead of a pre-rendered image containg the automatically generated map.
//


var

SheetMapConfig = /*#__PURE__*/function () {
  function SheetMapConfig(sheetNode, viewport, mapMatrix, levelGuid) {_classCallCheck(this, SheetMapConfig);

    // {av.BubbleNode}
    this.sheetNode = sheetNode;

    // {object}: viewport on the sheet, as obtained from AecModelData
    this.viewport = viewport;

    // {Matrix4} transforms from 3D world coords to sheetmap coords in [-1,1]^2
    this.mapMatrix = mapMatrix;
    this.mapMatrixInv = new THREE.Matrix4().getInverse(mapMatrix);

    // {string}
    this.levelGuid = levelGuid;

    // {SheetMapThumbnail}
    this.thumbnail = undefined;
  }_createClass(SheetMapConfig, [{ key: "isUsable", value: function isUsable(

    pos3D, levelGuid) {
      return this.levelGuid === levelGuid && Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["posIsInsideMap"])(pos3D, this.mapMatrix);
    } }]);return SheetMapConfig;}();


var tmpMatrix = new THREE.Matrix4();var

SheetMap = /*#__PURE__*/function () {function SheetMap() {_classCallCheck(this, SheetMap);}_createClass(SheetMap, null, [{ key: "computeMapMatrix",

    // Computes a mapMatrix based on a viewport on a sheet. The matrix transforms from 3D model coordinates to 
    // normalized map coords in [-1,1]^2.
    //  @param {Object} viewport - Viewport data obtained from AECModelData.json    
    //  @param {av.Model} model  - A currently visible 3D model of the Revit document for which we found the sheet.
    //  @param {THREE.Matrix4}   - Optional target to avoid matrix alloc.
    //  @returns THREE.Matrix4
    value: function computeMapMatrix(vp, model3D, optionalTarget) {

      // We map from model coords via sheet coords to finally [-1,1]^2.
      //
      // The functions getViewportBounds() and get3DTo2DMatrix() work in sheet-space, so that they require
      // the sheetUnitScale - which we don't know before loading the sheet.
      //
      // But, since we finally map the viewport to [-1,1] anyway, a uniform scaling of the sheet has no impact on 
      // the final map matrix anyway. So we can assume a dummy unitScale of 1.0 here.
      var DummyUnitScale = 1.0;

      var sheetRegion = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].getViewportBounds(vp, DummyUnitScale);

      // Create matrix to map sheetRegion to [-1,1]^2
      var sheetToMap = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].remapRectangle(
      sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // from: SheetRegion
      -1, -1, 1, 1 // to: [0,1]^2
      );

      var modelToSheet = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].get3DTo2DMatrix(vp, DummyUnitScale);
      var mapMatrix = new THREE.Matrix4().multiplyMatrices(sheetToMap, modelToSheet);

      // Note that placementWithOffset may be null if globalOffset is (0,0,0) and there is no placement transform
      if (model3D.myData.placementWithOffset) {
        // The mapMatrix computed so far maps local model coordinates to map coordinates. 
        // Finally, we want to map from local LMV coordinates. Therefore, the final transform
        // must revert any load-time transforms first.
        var lmvToModel = optionalTarget || new THREE.Matrix4();
        lmvToModel.getInverse(model3D.myData.placementWithOffset);

        // The lmvToModel matrix must be applied first. For this, we post-multiply it to the mapMatrix.
        mapMatrix.multiply(lmvToModel);
      }

      return mapMatrix;
    }

    // Finds all viewports associated with the given floor.
    //  @param {av.Model[]} mapModels - All models in which we search for sheets
    //  @param {string}     levelGuid
    //  @returns {SheetMapConfig[]} Sheetmap configurations for all viewports found for that floor
  }, { key: "findMaps", value: function findMaps(mapModels, levelGuid) {

      // Find all viewports that would be suitable as a floor map. 
      var result = [];
      for (var i = 0; i < mapModels.length; i++) {

        // Find viewports for levelGuid in the document of mapModel[i]
        var model = mapModels[i];
        var aec = model.getDocumentNode().getAecModelData();
        var modelViewports = aec && _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findViewportsForLevel(aec, levelGuid).filter(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].supports2DTo3DTransform);
        if (!modelViewports) {
          // Skip models that don't provide AecModelData
          continue;
        }

        // get doc root containing the model
        var root = model.getDocumentNode().getRootNode();

        // For each viewport...
        for (var j = 0; j < modelViewports.length; j++) {

          var viewport = modelViewports[j];

          // Check if we find a BubbleNode for the sheet containing it
          var sheetNode = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findSheetForViewport(root, viewport);
          if (!sheetNode) {
            continue;
          }

          // Compute mapMatrix for this viewport
          var mapMatrix = SheetMap.computeMapMatrix(viewport, model, tmpMatrix);

          // We found a candidate (viewport, sheet) pair
          result.push(new SheetMapConfig(sheetNode, viewport, mapMatrix, levelGuid));
        }
      }
      return result;
    }

    // Creates sheetmap configurations for all sheetMaps that are found on the current floor.
    //  @param {av.Model[]} mapModels - models in which we search for viewports/sheets
    //  @param {string}     levelGuid
    //  @returns {SheetMapConfig[]} 
  }, { key: "createSheetMapConfigs", value: function createSheetMapConfigs(mapModels, levelGuid) {

      var maps = SheetMap.findMaps(mapModels, levelGuid);
      var result = [];
      for (var i = 0; i < maps.length; i++) {
        var map = maps[i];

        // create & attach thumbnail
        // only map configs with a "view" child should be added, otherwise it won't contain a viewbox.
        if (map.sheetNode.search({ type: 'view' }).length > 0) {
          result.push(map);
        }
      }
      return result;
    } }]);return SheetMap;}();

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetThumbnail.js":
/*!****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetThumbnail.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMapThumbnail; });
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;

// Use the largest we can get from DS
var DsThumbnailSize = 400;
var GeneratedThumbnailSize = 1500;

var getThumbnailCropRegion = function getThumbnailCropRegion(sheetNode, viewport) {

  // Actually, we shouldn't care about sheetUnitScale here. We only
  // need it because Revit extractor gives us viewport bounds and sheet bounds in different coordinate systems. 
  // Unfortunately, we have to guess the sheetUnitScale here, because we cannot load all sheets first just to get the unitScale.
  //
  // TODO: If we provide the viewport boundary in sheet coordinates in Revit extractor, we don't need this hack anymore.
  var sheetUnitScale = 0.0254;

  // get viewport bounds in sheet coords (usually inches)    
  var viewportBounds = Autodesk.AEC.AecModelData.getViewportBounds(viewport, sheetUnitScale);

  // get sheet bounds 
  var viewNode = sheetNode.search({ type: 'view' })[0];

  if (!viewNode) {
    return null;
  }

  var viewBoxValues = viewNode.getViewBox();
  var sheetBox = new THREE.Box2();
  sheetBox.min.set(viewBoxValues[0], viewBoxValues[1]);
  sheetBox.max.set(viewBoxValues[2], viewBoxValues[3]);

  // Thumbnails are squared and contain empty pixels to expand the rectangle to a square.
  // Therefore, the are whole thumbnail image does not match the sheet bounds exactly,
  // but actually corresponds to the square containing it.
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["expandToSquare"])(sheetBox);

  // map from sheetBox to thumbnail pixels
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.min, sheetBox);
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.max, sheetBox);

  return viewportBounds;
};

// Applies css styling on image element, so that the given cropRegion fits the parent div
//
// @param {Box2}  cropRegion - in [0,1]^2, relative to the full image
// @param {Image} image      - html image element
var cropImage = function cropImage(image, cropRegion) {
  var _document = av.getGlobal().document;
  var canvas = _document.createElement("canvas");
  var ctx = canvas.getContext("2d");

  // compute size of crop region (relative to full image)
  var cropWidthRatio = cropRegion.max.x - cropRegion.min.x;
  var cropHeightRatio = cropRegion.max.y - cropRegion.min.y;

  var destWidth = cropWidthRatio * image.width;
  var destHeight = cropHeightRatio * image.height;

  canvas.width = destWidth;
  canvas.height = destHeight;

  ctx.drawImage(
  image,
  cropRegion.min.x * image.width, (1 - cropRegion.max.y) * image.height,
  destWidth, destHeight,
  0, 0,
  destWidth, destHeight);


  var texImage = new Image();
  texImage.src = canvas.toDataURL();

  return texImage;
};

// Sheetmap thumbnails are embedded in the minimap to display for which regions inside the minimap a sheetmap is available. 
// A sheetmap thumbnail is a sheet thumbnail that is cropped down to a single viewport and embedded into the main map.
var SheetMapThumbnail = /*#__PURE__*/function () {

  // @param {SheetMapConfig} sheetMapConfig - Config object for the sheet to be represented by this thumbnail
  function SheetMapThumbnail(sheetMapConfig, viewer, onThumbnailReady) {var _this = this;_classCallCheck(this, SheetMapThumbnail);
    this.sheetMapConfig = sheetMapConfig;

    this.viewer = viewer;

    this.thumbnailImage = null;

    this.thumbnailRefined = false;

    this.img = new Image();
    this.img.onload = function () {var _this$sheetMapConfig =
      _this.sheetMapConfig,sheetNode = _this$sheetMapConfig.sheetNode,viewport = _this$sheetMapConfig.viewport;
      var cropRegion = getThumbnailCropRegion(sheetNode, viewport);
      var croppedThumbnail = cropImage(_this.img, cropRegion);

      croppedThumbnail.onload = function () {
        _this.thumbnailImage = croppedThumbnail;
        onThumbnailReady(_this.sheetMapConfig);
      };
    };
  }_createClass(SheetMapThumbnail, [{ key: "onThumbnailDownloaded", value: function onThumbnailDownloaded(

    blobUrl) {
      // Verify that the thumbnail wasn't generated locally meanwhile.
      if (!this.thumbnailRefined) {
        this.img.src = blobUrl;
      }
    }

    // Creates a div containing the thumbnail of a given sheet node as an image element.
  }, { key: "requestThumbnail", value: function requestThumbnail() {var _this2 = this;var

      sheetNode = this.sheetMapConfig.sheetNode;

      // get thumbnail url
      var root = sheetNode.getRootNode();
      var doc = root.getDocument();

      var options = doc.getThumbnailOptions(sheetNode.data, DsThumbnailSize, DsThumbnailSize);

      // takes care of local bubbles
      if (sheetNode.data.thumbnailUrn) {
        options.urn = sheetNode.getDocument().getFullPath(sheetNode.data.thumbnailUrn);
        options.responseType = 'blob';
        Autodesk.Viewing.Private.ViewingService.getThumbnail(Autodesk.Viewing.initLoadContext(), options.urn, function (response) {
          var reader = new FileReader();
          reader.onload = function (e) {
            _this2.onThumbnailDownloaded(e.target.result);
          };
          reader.readAsDataURL(response);

        },
        function () {console.warn("Failed to load sheet thumbnail. Error: ".concat(error, ", Urn: ").concat(options.urn, ", SheetName: ").concat(sheetNode.name()));},
        options);
      } else if (Autodesk.Viewing.endpoint.getUseCookie()) {
        // Set derivative service Url directly and use cookie for credentials
        var url = doc.getThumbnailPath(sheetNode.data, DsThumbnailSize, DsThumbnailSize);
        this.onThumbnailDownloaded(url);
      } else {
        // When not using a cookie for credentials, we have to request the thumbnails using ViewingService.
        var onReceive = function onReceive(error, blob) {

          // Display a warning if overlay thumbnail will not show up
          if (error) {
            console.warn("Failed to load sheet thumbnail. Error: ".concat(error, ", Urn: ").concat(options.urn, ", SheetName: ").concat(sheetNode.name()));
            return;
          }

          // assign imageUrl 
          var blobUrl = av.getGlobal().URL.createObjectURL(blob);
          _this2.onThumbnailDownloaded(blobUrl);
        };

        // Request thumbnail from DS
        Autodesk.Viewing.Document.requestThumbnailWithSecurity(options, onReceive);
      }
    }

    // Takes a screenshot of the 2D sheet, and replace the low-res thumbnail with it.
  }, { key: "refineThumbnail", value: function refineThumbnail() {var _this3 = this;

      // Make sure that we do the screenshot only once per sheetMap
      if (this.thumbnailRefined) {
        return;
      }

      this.thumbnailRefined = true;

      // Align camera to capture the whole sheet
      var box = this.viewer.model.getBoundingBox();

      // We want to create a thumbnail that matches the ones from DerivativeService. To make it harder, the boundingBox is slightly
      // different from the model box, because it is enlarged in x/y by a shadow. Therefore, we must adjust the values using the viewbox
      // values from manifest.
      var node = this.viewer.model.getDocumentNode();
      var view = node.search({ type: "view" })[0];
      var values = view && view.getViewBox();
      if (values) {
        // We cannot use set here, because the box returned by model.getBoundingBox() just contain {x,y,z} objects.
        box.min.x = values[0];
        box.min.y = values[1];
        box.max.x = values[2];
        box.max.y = values[3];
      }

      // Setup camera for the snapshot
      var camera = new Autodesk.Viewing.UnifiedCamera(GeneratedThumbnailSize, GeneratedThumbnailSize);
      camera.setViewFromBox(box, true);

      var onScreenshotDone = function onScreenshotDone(imageUrl) {
        _this3.img.src = imageUrl;
      };

      var options = {
        camera: camera };


      this.viewer.impl.getScreenShotProgressive(GeneratedThumbnailSize, GeneratedThumbnailSize, onScreenshotDone, options);
    } }]);return SheetMapThumbnail;}();

/***/ }),

/***/ "./extensions/AEC/Minimap3D/adjustButtonStyle.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/Minimap3D/adjustButtonStyle.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Some customizations for LMV buttons
/* harmony default export */ __webpack_exports__["default"] = (function (button) {
  //Default LMV buttons are too large for the minimap
  button.container.style.width = "20px";
  button.container.style.height = "20px";
  button.container.style.padding = "3px";

  // The icon class adds a top-padding of 3 which broke the centering of the button.
  button.icon.classList.remove("adsk-button-icon");

  // Show tooltips left of the buttons and vertically centered.
  // The default behavior would place the tooltip outside of canvas and minimap,
  // so that they would not be visible.
  button.setToolTip(""); // Init tooltip element
  var tts = button._toolTipElement.style;
  tts.bottom = "7px";
  tts.top = "auto";
  tts.left = "auto";
  tts.right = "130%";
  tts.zIndex = 3;
});

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetSyncConstants.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetSyncConstants.js ***!
  \********************************************************/
/*! exports provided: SheetSyncEvents, SHEET_OPACITY, FADE_DURATION, ROTATION_DURATION, WAIT_BEFORE_ROTATION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SheetSyncEvents", function() { return SheetSyncEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SHEET_OPACITY", function() { return SHEET_OPACITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FADE_DURATION", function() { return FADE_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ROTATION_DURATION", function() { return ROTATION_DURATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WAIT_BEFORE_ROTATION", function() { return WAIT_BEFORE_ROTATION; });
var SheetSyncEvents = {
  MAIN_MAP_CHANGED_EVENT: 'mapChanged',
  CHANGING_SHEET_EVENT: 'changingSheet' };


var SHEET_OPACITY = 0.8; // When sheet is displayed on top of top view screenshot, it should be half transparent.
var FADE_DURATION = 0.7; // Time to fade sheet's opacity. Value matches "transition: opacity 0.7s" inside Avatar.scss
var ROTATION_DURATION = 2.0; // Time to rotate a sheet in order for it to face upwards.
var WAIT_BEFORE_ROTATION = 1.0; // Time to rotate a sheet in order for it to face upwards.

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetSyncExtension.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetSyncExtension.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetSyncExtension; });
/* harmony import */ var _Minimap3D_SheetMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/SheetMap */ "./extensions/AEC/Minimap3D/SheetMap.js");
/* harmony import */ var _Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Minimap3D/MinimapMath */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _common_AecModelData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/AecModelData */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
/* harmony import */ var _SheetTransforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _SheetVisibilityManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SheetVisibilityManager */ "./extensions/AEC/SheetSync/SheetVisibilityManager.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}






var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.SheetSyncExtension';

/**
                                                         // SheetSyncExtension - A viewer extension that syncs between a 3D model and its corresponding 2D sheet.
                                                         //                      Works only when BimWalk is active. Whenever the player changes position, the 2D sheet will be updated according to the correct viewport.
                                                         //
                                                         // @param {Viewer3D} [viewer]                       - viewer instance
                                                         // @param {Object} [options]                        - Configuration options for SheetSyncExtension
                                                         // @param {Viewer3D} [options.targetViewer]         - Target viewer instance.
                                                         // @param {bool} [options.cropToViewport]           - When enabled, the viewport that's related to the 3D camera will be cropped.
                                                         // @param {bool} [options.hideSheetWhenNotFocused]  - When enabled, when the 3D camera is not inside the sheet's viewport, the sheet will disappear.
                                                         // @param {function} [options.autoSwitchSheet]      - Automatically load sheet when map has been changed.
                                                         // @param {function} [options.loadDocumentNode]     - Optional item loading API.
                                                         // @param {function} [options.unloadModel]          - Optional item unloading loading API.
                                                         // @param {Viewer3D} [options.hidePaper]            - Hide the white paper from the 2D sheet.
                                                         // @param {Viewer3D} [options.useCustomModel]       - Use a specific 3D model to sync, instead of using all visible models by default.
                                                         */var
SheetSyncExtension = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(SheetSyncExtension, _Autodesk$Viewing$Ext);
  function SheetSyncExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, SheetSyncExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(SheetSyncExtension).call(this, viewer, options));

    _this.options = _this.options.sheetSyncOptions || _this.options;
    _this.targetViewer = _this.options.targetViewer;

    // SheetMap that is relevant to the current camera position.
    _this.sheetMap = null;

    // Models in 3D target viewer that we are going to sync to.
    _this.targetModels = [];

    // Cache for all sheetMapConfigs.
    _this.mapCache = {};

    // Cache for fuzzyBox per model id.
    _this.modelIdToFuzzyBox = [];

    // [modelKey -> boolean] map that represents if a sheet model is being currently loaded.
    _this.isModelLoadingMap = {};

    // Whether to show 2D sheet.
    _this.showSheet = _this.options.showSheet || false;

    // Controller of 2D sheet visibility and crop.
    _this.sheetVisibilityManager = new _SheetVisibilityManager__WEBPACK_IMPORTED_MODULE_5__["default"](_this.viewer, _this.options);

    _this.onNavigationToolChanged = _this.onNavigationToolChanged.bind(_assertThisInitialized(_this));
    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));
    _this.on3dGeometryLoaded = _this.on3dGeometryLoaded.bind(_assertThisInitialized(_this));
    _this.updateSheetAppearance = _this.updateSheetAppearance.bind(_assertThisInitialized(_this));
    _this.isCameraInsideMap = _this.isCameraInsideMap.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));return _this;
  }_createClass(SheetSyncExtension, [{ key: "load", value: function load()

    {
      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged);

      this.onNavigationToolChanged();

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.deactivate();

      // Clear cut planes if needed, and update opacity.
      this.sheetVisibilityManager.setVisibilityImmediate(true);
      this.sheetVisibilityManager.updateCrop(null);

      this.sheetMap = null;
      this.targetModels = [];

      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.onNavigationToolChanged); // This listener should be removed specifically here, not inside removeListeners.

      this.throttleTimeout && clearTimeout(this.throttleTimeout);

      return true;
    } }, { key: "activate", value: function activate()

    {
      if (this.active) {
        return;
      }

      this.active = true;

      this.addListeners();

      this.on3dGeometryLoaded();
    } }, { key: "deactivate", value: function deactivate()

    {
      if (!this.active) {
        return;
      }

      this.active = false;

      this.sheetMap = null;

      this.removeListeners();
    } }, { key: "addListeners", value: function addListeners()

    {
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);
      this.targetViewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);
      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);
      this.viewer.addEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.addEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);

    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.update);
      this.targetViewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.on3dGeometryLoaded);
      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.updateSheetAppearance);
      this.viewer.removeEventListener(av.MODEL_ROOT_LOADED, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(av.TEXTURES_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.viewer.removeEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.updateSheetAppearance);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);
    } }, { key: "isBimWalkActive", value: function isBimWalkActive()

    {
      return this.targetViewer.getActiveNavigationTool() === 'bimwalk';
    } }, { key: "onNavigationToolChanged", value: function onNavigationToolChanged()

    {
      if (this.isBimWalkActive()) {
        this.activate();
      } else {
        this.deactivate();
      }

      this.update();
    }

    // Update sheet's opacity and crop bounds.
  }, { key: "updateSheetAppearance", value: function updateSheetAppearance() {
      if (!this.isSheetMapLoaded(this.sheetMap) || !this.isMapOnCurrentLevel(this.sheetMap)) {
        this.sheetVisibilityManager.setVisibilityImmediate(false);
        this.sheetVisibilityManager.updateCrop(null);
      } else {
        var visible = this.showSheet && this.isCameraInsideMap(this.sheetMap) && this.isBimWalkActive();
        this.sheetVisibilityManager.updateSheetAppearance(this.sheetMap, visible);
      }
    }

    // Get a union of all targetModel's fuzzy-boxes.
  }, { key: "getFuzzyBox", value: function getFuzzyBox() {
      var fuzzyBoxRes = new THREE.Box3();

      // sum up fuzzy boxes of all map models
      for (var i = 0; i < this.targetModels.length; i++) {

        var model = this.targetModels[i];

        // get bbox from cache if possible
        var bbox = this.modelIdToFuzzyBox[model.id];

        if (!bbox) {
          // compute fuzzybox and add it to cache
          bbox = model.getFuzzyBox();
          this.modelIdToFuzzyBox[model.id] = bbox;
        }

        fuzzyBoxRes.union(bbox);
      }

      return fuzzyBoxRes;
    }

    // Generate a dummy sheetMap, according to the entire 3D model bounding box.
    // Initially, the map should fully fit the canvas.
  }, { key: "generateDummyMap", value: function generateDummyMap() {
      // If sheetmap already set, no need to generate dummy map.
      if (this.sheetMap) {
        return;
      }

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      var currentLevel = levelExt.getCurrentLevel();
      var zRange = levelExt.getZRange(currentLevel.index);

      var modelFuzzyBox = this.getFuzzyBox();

      modelFuzzyBox.min.z = 0;
      modelFuzzyBox.max.z = 0;

      var renderer = this.viewer.impl.renderer();
      var canvasWidth = renderer.settings.logicalWidth;
      var canvasHeight = renderer.settings.logicalHeight;

      var camera = new av.UnifiedCamera(canvasWidth, canvasHeight);
      Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__["setTopView"])(camera, modelFuzzyBox, zRange.zMin, zRange.zMax, modelFuzzyBox.size().y);

      var mapMatrix = new THREE.Matrix4();
      var mapMatrixInv = new THREE.Matrix4();
      Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__["compute3DTo2DMatrix"])(camera, mapMatrix);
      mapMatrixInv.getInverse(mapMatrix);

      var min = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_4__["clientToWorld"])(this.viewer, 0, 0);
      var max = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_4__["clientToWorld"])(this.viewer, canvasWidth, canvasHeight);

      var viewportBounds = new THREE.Box3().setFromPoints([min, max]);

      this.sheetMap = {
        viewportBounds: viewportBounds,
        mapMatrix: mapMatrix,
        mapMatrixInv: mapMatrixInv,
        viewport: {} };


      this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });

      this.update();
    } }, { key: "on3dGeometryLoaded", value: function on3dGeometryLoaded()

    {
      this.updateTargetModels();

      // No target models yet.
      if (!this.targetModels) {
        return;
      }

      this.generateDummyMap();

      this.update();
    } }, { key: "onSheetGeometryLoaded", value: function onSheetGeometryLoaded(_ref)

    {var model = _ref.model;
      if (this.options.hidePaper) {
        model.getFragmentList().setObject2DVisible(-1, false); // hide paper.
        this.viewer.impl.invalidate(true);
      }

      this.update();
    } }, { key: "updateTargetModels", value: function updateTargetModels()

    {
      if (!this.options.useCustomModel) {
        // Filter only 3D models.
        var models = this.targetViewer.getVisibleModels().filter(function (m) {return m.is3d();});
        this.setTargetModels(models);
      }
    } }, { key: "setTargetModels", value: function setTargetModels(

    models) {
      this.targetModels = models;
    } }, { key: "getSheetNodeKey", value: function getSheetNodeKey(

    map) {
      var key = map && map.sheetNode && map.sheetNode.getModelKey();
      return key;
    } }, { key: "isLoadingSheetNode", value: function isLoadingSheetNode(

    map) {
      var key = this.getSheetNodeKey(map);
      return key && this.isModelLoadingMap[key];
    } }, { key: "shouldSwitchSheet", value: function shouldSwitchSheet()

    {
      var showSheet = this.showSheet;
      var isAutoSwitchEnabled = this.options.autoSwitchSheet;
      var isDifferentSheetLoaded = !this.isSheetMapLoaded(this.sheetMap);
      var isCameraInside = this.isCameraInsideMap(this.sheetMap);
      var isAlreadyLoading = this.isLoadingSheetNode(this.sheetMap);

      return isAutoSwitchEnabled && isDifferentSheetLoaded && showSheet && isCameraInside && !isAlreadyLoading;
    } }, { key: "getCurrentLevel", value: function getCurrentLevel()

    {
      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');

      if (!levelExt) {
        return;
      }

      return levelExt.getCurrentLevel();
    } }, { key: "update", value: function update()

    {
      if (!this.viewer.model) {
        return;
      }

      var level = this.getCurrentLevel();

      if (!level) {
        return;
      }

      if (!this.isBimWalkActive()) {
        return;
      }

      this.updateTargetModels();

      this.updateSheetMaps();

      this.updateSheetAppearance();

      this.switchSheetIfNeededDebounce();
    } }, { key: "switchSheetIfNeededDebounce", value: function switchSheetIfNeededDebounce()

    {
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }

      this.debounceTimeout = setTimeout(this.switchSheetIfNeeded.bind(this), 300);
    } }, { key: "switchSheetIfNeeded", value: function switchSheetIfNeeded()

    {var _this2 = this;
      if (this.shouldSwitchSheet()) {
        this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].CHANGING_SHEET_EVENT, sheetNode: this.sheetMap.sheetNode });

        // Load sheet
        var previousModel = this.viewer.model;
        var doc = this.sheetMap.sheetNode.getRootNode().getDocument();
        var initialOpacity = this.options.hideSheetWhenNotFocused ? 0.0 : 1.0;
        var loadFunction = this.options.loadDocumentNode || this.viewer.loadDocumentNode.bind(this.viewer);
        var unloadFunction = this.options.unloadModel || this.viewer.unloadModel.bind(this.viewer);
        var key = this.getSheetNodeKey(this.sheetMap);
        this.isModelLoadingMap[key] = true;
        // There are some critical flags here:
        // loadAsHidden - We have to first load the model is hidden, and only then show it. The reason is because we
        //                have to make sure that `renderer.enter2DMode()` will be called, and it won't get called if there is more the one loaded model.
        //                Without calling `enter2DMode`, there is a chance for different rendering errors.
        //
        // keepCurrentModels - In order to prevent tearDown of the viewer, a thing that will cause the navigation to stop,
        //                     we have to first load the new model (as hidden), then hide the previous model, and then show the new one.
        // preserveView - Keeps the camera in the same spot.
        loadFunction(doc, this.sheetMap.sheetNode, { opacity: initialOpacity, preserveView: true, keepCurrentModels: true, loadAsHidden: true }).
        catch(function (error) {return console.error("Failed to load sheet: ", _this2.sheetMap.sheetNode.name(), ": ", error);}).
        then(function (model) {
          if (previousModel && previousModel !== model) {
            unloadFunction(previousModel);
          }

          _this2.isModelLoadingMap[key] = false;
          _this2.viewer.showModel(model, true);
          _this2.sheetVisibilityManager.setVisibilityImmediate(false);
          _this2.update();
          _this2.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: _this2.sheetMap });
        });
      }
    }

    // we can't just shallow compare the instances, because SheetMap.findMaps returns a new pointer each time.
    // Instead, we compare the viewportGuid, that stays the same.
  }, { key: "isSheetMapsEqual", value: function isSheetMapsEqual(map1, map2) {
      return !(!!map1 ^ !!map2) && (!map1 || map1.viewport.viewportGuid === map2.viewport.viewportGuid);
    } }, { key: "isMapOnCurrentLevel", value: function isMapOnCurrentLevel(

    map) {
      if (!map) {
        return false;
      }

      var currentLevel = this.getCurrentLevel();

      // Different level.
      if (!currentLevel || map.levelGuid !== currentLevel.guid) {
        return false;
      }

      return true;
    } }, { key: "isSheetMapLoaded", value: function isSheetMapLoaded(

    map) {
      return map && map.sheetNode && this.viewer.model && map.sheetNode.guid() === this.viewer.model.getDocumentNode().guid();
    }

    // Is current 3D camera is inside a loaded map.
  }, { key: "isCameraInsideMap", value: function isCameraInsideMap(map) {
      if (!map) {
        return false;
      }

      if (!this.isMapOnCurrentLevel(map)) {
        return false;
      }

      // Relevant sheet is not currently loaded.
      if (!this.options.autoSwitchSheet && !this.isSheetMapLoaded(map)) {
        return false;
      }

      return Object(_Minimap3D_MinimapMath__WEBPACK_IMPORTED_MODULE_1__["posIsInsideMap"])(this.targetViewer.getCamera().position, map.mapMatrix);
    }

    // Update current sheet map according to current level.
  }, { key: "updateSheetMaps", value: function updateSheetMaps() {var _this3 = this;
      var maps;

      var currentLevel = this.getCurrentLevel();

      if (!this.mapCache[currentLevel.guid]) {
        // Find maps that are relevant to these models, and for the current level.
        maps = _Minimap3D_SheetMap__WEBPACK_IMPORTED_MODULE_0__["default"].createSheetMapConfigs(this.targetModels, currentLevel.guid);

        maps.forEach(function (map) {
          // Calculate viewport bounds and store it as part of the sheetMap.
          map.viewportBounds = _common_AecModelData__WEBPACK_IMPORTED_MODULE_2__["default"].getViewportBounds(map.viewport, _this3.viewer.model.getUnitScale());
        });

        this.mapCache[currentLevel.guid] = maps;
      } else {
        maps = this.mapCache[currentLevel.guid];
      }

      // In case we didn't find another map - keep it only if cropToViewport.
      // Otherwise, it can cause a confusion when the avatar is floating above a viewport that it doesn't really belongs to.
      // In that case, unset the map.
      var map = maps.find(this.isCameraInsideMap) || (this.options.cropToViewport ? this.sheetMap : undefined);

      var mapChanged = !this.isSheetMapsEqual(this.sheetMap, map);

      this.sheetMap = map;

      if (mapChanged) {
        this.viewer.dispatchEvent({ type: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, sheetMap: this.sheetMap });
      }
    } }, { key: "setShowSheet", value: function setShowSheet(

    show) {
      this.showSheet = show;
      this.update();
    } }, { key: "getShowSheet", value: function getShowSheet()

    {
      return this.showSheet;
    } }]);return SheetSyncExtension;}(Autodesk.Viewing.Extension);

Object.assign(namespace, { SheetSyncEvents: _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"] });
namespace.SheetSyncExtension = SheetSyncExtension;
av.theExtensionManager.registerExtension(myExtensionName, SheetSyncExtension);

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetTransforms.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetTransforms.js ***!
  \*****************************************************/
/*! exports provided: worldToMapPixels, mapPixelsToWorld, mapPixelsToSheet, mapPixelsToWidget, clientToWorld, widgetToMapPixels, getCameraRotationAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToMapPixels", function() { return worldToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWorld", function() { return mapPixelsToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToSheet", function() { return mapPixelsToSheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWidget", function() { return mapPixelsToWidget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientToWorld", function() { return clientToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "widgetToMapPixels", function() { return widgetToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCameraRotationAngle", function() { return getCameraRotationAngle; });
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");


// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
function worldToMapPixels(sheetMap, pos3D) {
  var size = sheetMap.viewportBounds.size();
  return _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["worldToMapPixels"](pos3D, sheetMap.mapMatrix, size.x, size.y);
};

// Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.
function mapPixelsToWorld(sheetMap, posX, posY, zWorld) {
  var size = sheetMap.viewportBounds.size();
  return _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"](posX, posY, zWorld, sheetMap.mapMatrixInv, size.x, size.y);
};

function mapPixelsToSheet(sheetMap, p) {
  // Widget pixel origin is at top-left, i.e., y-axis points down.
  // For that reason, we have to flip the y coordinate.
  p.y = sheetMap.viewportBounds.size().y - p.y;

  var min = sheetMap.viewportBounds.min;
  p.x += min.x;
  p.y += min.y;
};

// @param {Vector2} p - point in map-pixel space:             Value range is [0, 0] x [viewportSize.width, viewportSize.height]
// Converts p to a relative pixel-position in the map widget: Value range is [0, 0] x [viewerWidth, viewerHeight]
function mapPixelsToWidget(sheetMap, viewer, p) {
  mapPixelsToSheet(sheetMap, p);
  p.copy(viewer.worldToClient(p));
};

// Client to world transformation.
function clientToWorld(viewer, x, y) {
  var p = viewer.impl.clientToViewport(x, y);
  var projMatrix = viewer.impl.camera.projectionMatrix;
  var projMatrixIns = new THREE.Matrix4();
  projMatrixIns.getInverse(projMatrix);
  p.applyMatrix4(projMatrixIns);
  p.applyMatrix4(viewer.impl.camera.matrixWorld);
  p.z = 0;

  return p;
};

var EPSILON = 0.001;

// @param {Vector2} p - transformed in-place from viewer pixels to map image pixels
//                      widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)
// @param {boolean} clamp - In case the resulting position is outside of the map, clamp the value to fit the maps' border.
function widgetToMapPixels(sheetMap, viewer, p, clamp) {
  // We can't use viewer.clientToWorld, because we do want to support the case where p is outside of the paper.
  p.copy(clientToWorld(viewer, p.x, p.y));

  var min = sheetMap.viewportBounds.min;
  p.x -= min.x;
  p.y -= min.y;

  // Widget pixel origin is at top-left, i.e., y-axis points down.
  // For that reason, we have to flip the y coordinate.
  p.y = sheetMap.viewportBounds.size().y - p.y;

  if (clamp) {
    var size = sheetMap.viewportBounds.size();
    p.x = THREE.Math.clamp(p.x, EPSILON, size.x - EPSILON);
    p.y = THREE.Math.clamp(p.y, EPSILON, size.y - EPSILON);
  }
};

function getCameraRotationAngle(viewer) {
  var upVec = viewer.navigation.getCameraUpVector();
  return Math.atan2(upVec.y, upVec.x) - 0.5 * Math.PI;
};

/***/ }),

/***/ "./extensions/AEC/SheetSync/SheetVisibilityManager.js":
/*!************************************************************!*\
  !*** ./extensions/AEC/SheetSync/SheetVisibilityManager.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetVisibilityManager; });
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var INFINITE_BOX = new THREE.Box3().setFromPoints([new THREE.Vector3(-1e20, -1e20, -1e20), new THREE.Vector3(1e20, 1e20, 1e20)]);

/**
                                                                                                                                  // SheetVisibilityManager - Manage the visibility of the sheet - opacity and crop.
                                                                                                                                  */var
SheetVisibilityManager = /*#__PURE__*/function () {
  function SheetVisibilityManager(viewer, options) {_classCallCheck(this, SheetVisibilityManager);
    this.viewer = viewer;
    this.options = options;
  }

  // Update sheet's opacity and crop bounds.
  _createClass(SheetVisibilityManager, [{ key: "updateSheetAppearance", value: function updateSheetAppearance(sheetMap, visible) {var _this = this;
      var model = this.viewer.model;

      if (!model) {
        return;
      }

      var targetOpacity = visible ? _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["SHEET_OPACITY"] : 0.0;
      var viewportBounds = sheetMap && sheetMap.viewportBounds;

      if (visible) {
        this.updateCrop(visible, viewportBounds);
      }

      this.animateOpacity(this.viewer.model, targetOpacity, function () {_this.updateCrop(visible, viewportBounds);});
    }

    // Set sheet visibility immediately.
  }, { key: "setVisibilityImmediate", value: function setVisibilityImmediate(visible) {
      var model = this.viewer.model;

      if (!model) {
        return;
      }

      if (model.fadeAnim) {
        model.fadeAnim.stop();
        model.fadeAnim = null;
      }

      this.setModelOpacity(model, visible ? 1.0 : 0.0);
    }

    // Animate sheet's opacity.
  }, { key: "animateOpacity", value: function animateOpacity(model, targetValue, onFadeDone) {var _this2 = this;
      if (!model) {
        return;
      }

      if (model.fadeAnim) {
        model.fadeAnim.stop();
        model.fadeAnim = null;
      }

      var startVal = model.opacity || 0.0;

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);
        _this2.setModelOpacity(model, opacity);
      };

      var onFadeEnd = function onFadeEnd() {
        model.fadeAnim = null;
        onFadeDone && onFadeDone();
      };

      model.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_0__["FADE_DURATION"], onTimer, onFadeEnd);
      model.fadeAnim.targetValue = targetValue;
    }

    // Change all sheet's materials to be in with a given opacity.
  }, { key: "setModelOpacity", value: function setModelOpacity(model, value) {
      if (!this.options.hideSheetWhenNotFocused) {
        return;
      }

      if (model) {
        var materialsManager = this.viewer.impl.matman();
        var materials = materialsManager.getModelMaterials(model).mats;

        var changed = false;

        Object.keys(materials).forEach(function (key) {
          if (materials[key].uniforms && materials[key].uniforms.opacity && materials[key].uniforms.opacity.value !== value) {
            materials[key].uniforms.opacity.value = value;
            changed = true;
          }
        });

        model.opacity = value;

        if (changed) {
          this.viewer.impl.invalidate(true);
        }
      }
    }

    // Update the crop according to given viewport bounds.
  }, { key: "updateCrop", value: function updateCrop(visible) {var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INFINITE_BOX;
      if (this.options.cropToViewport) {
        var model = this.viewer.model;

        if (!model) {
          return;
        }

        if (!model.latestCropBounds) {
          model.latestCropBounds = new THREE.Box3();
        }

        var cropBounds;
        if (visible) {
          cropBounds = bounds;
        } else {
          // put the cut planes in infinity.
          // This is more efficient then removing the cutplanes from all the materials.
          cropBounds = INFINITE_BOX;
        }

        if (!model.latestCropBounds.equals(cropBounds)) {
          model.latestCropBounds = cropBounds.clone();
          this.cropToViewport(cropBounds);
        }
      }
    }

    // Sets 4 cutplanes in sheet viewer that restricts the sheet to the viewport that we are currently using.
  }, { key: "cropToViewport", value: function cropToViewport(sheetRegion) {

      // A cutplane cp = (nx, ny, nz, c) 
      // excludes all points p with dot(v, n) + c > 0.0.
      // That is...
      //  - the normal points to the excluded half-space.
      //  - For a point (x,y) on the plane, we get the constant
      //    as c = -dot(p, n).
      var lower = new THREE.Vector4(0, -1, 0, sheetRegion.min.y);
      var upper = new THREE.Vector4(0, 1, 0, -sheetRegion.max.y);
      var left = new THREE.Vector4(-1, 0, 0, sheetRegion.min.x);
      var right = new THREE.Vector4(1, 0, 0, -sheetRegion.max.x);

      var cutPlanes = [lower, upper, left, right];

      this.viewer.impl.setCutPlaneSet("SheetRegion", cutPlanes);
    } }]);return SheetVisibilityManager;}();

/***/ }),

/***/ "./extensions/AEC/SheetSync/ThumbnailsOverlay.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/SheetSync/ThumbnailsOverlay.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ThumbnailsOverlay; });
/* harmony import */ var _SheetTransforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _Minimap3D_SheetThumbnail__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Minimap3D/SheetThumbnail */ "./extensions/AEC/Minimap3D/SheetThumbnail.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var OVERLAY_SCENE = 'thumbnail-overlay-scene';
var EPSILON = 0.0001;

// ThumbnailsOverlay - An overlay of sheet thumbnails.
// For every sheet on the current level, a request for DS will be made in order to get its thumbnail.
// The thumbnail will be displayed as a plane as an overlay on top of the top-view 3D rendering.
//
// In case that the 2D sheet is fully displayed, a (sort of) high-res snapshot of the sheet will be taken,
// and will be used as the thumbnail texture.
var ThumbnailsOverlay = /*#__PURE__*/function () {
  function ThumbnailsOverlay(viewer, sheetSyncExt) {_classCallCheck(this, ThumbnailsOverlay);
    this.viewer = viewer;
    this.sheetSyncExt = sheetSyncExt;

    this.planeGeometry = new THREE.PlaneBufferGeometry(1, 1);

    this.viewer.impl.createOverlayScene(OVERLAY_SCENE);
    this.createThumbnailMesh = this.createThumbnailMesh.bind(this);
  }

  // Create a plane, position it in the correct place in the scene, and assign the thumbnail texture to it.
  _createClass(ThumbnailsOverlay, [{ key: "createThumbnailMesh", value: function createThumbnailMesh(map) {
      var mesh = map.thumbnail.mesh;

      if (!mesh) {
        var minWorld = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);
        var maxWorld = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.max.y, 0);
        var p2 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);

        var angle = Math.atan2(p2.y - minWorld.y, p2.x - minWorld.x);
        var box = new THREE.Box3().setFromPoints([minWorld, maxWorld]);
        var boxCenter = box.center();
        Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["rotateAround"])(minWorld, boxCenter, -angle);
        Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["rotateAround"])(maxWorld, boxCenter, -angle);

        box.setFromPoints([minWorld, maxWorld]);

        var meshSize = box.size();
        var mapSize = map.viewportBounds.size();

        // Height of the plane is camera position minus epsilon, in order to make sure the plane is inside the frustum.
        var center = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_0__["mapPixelsToWorld"])(map, mapSize.x / 2, mapSize.y / 2, this.viewer.getCamera().position.z - EPSILON);

        var material = new THREE.MeshBasicMaterial({
          opacity: 0.0, // Initially, thumbnail should be hidden.
          transparent: true,
          blending: THREE.NoBlending });


        mesh = new THREE.Mesh(this.planeGeometry, material);
        mesh.position.copy(center);
        mesh.rotation.set(0, 0, angle);
        mesh.scale.set(meshSize.x, meshSize.y, 1);
        map.thumbnail.mesh = mesh;

        var texture = new THREE.Texture();
        texture.minFilter = THREE.LinearFilter;
        mesh.material.map = texture;
      }

      // Update texture.
      mesh.material.map.image = map.thumbnail.thumbnailImage;
      mesh.material.map.needsUpdate = true;

      this.update();
    } }, { key: "showThumbnail", value: function showThumbnail(

    thumbnail) {
      if (thumbnail && thumbnail.mesh) {
        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) === -1) {
          this.viewer.impl.addOverlay(OVERLAY_SCENE, thumbnail.mesh);
          this.animateOpacity(thumbnail, 0.5);
        }
      }
    } }, { key: "hideThumbnail", value: function hideThumbnail(

    thumbnail, immediate) {var _this = this;
      if (thumbnail && thumbnail.mesh) {
        if (this.viewer.impl.overlayScenes[OVERLAY_SCENE].scene.children.indexOf(thumbnail.mesh) !== -1) {
          if (immediate) {
            this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);
            thumbnail.mesh.material.opacity = 0;
          } else {
            this.animateOpacity(thumbnail, 0.0, function () {
              _this.viewer.impl.removeOverlay(OVERLAY_SCENE, thumbnail.mesh);
            });
          }
        }
      }
    } }, { key: "animateOpacity", value: function animateOpacity(

    thumbnail, targetValue, onDone) {var _this2 = this;
      if (thumbnail.fadeAnim) {
        if (thumbnail.fadeAnim.targetValue === targetValue) {
          return;
        }

        thumbnail.fadeAnim.stop();
        thumbnail.fadeAnim = null;
      }

      var startVal = thumbnail.mesh.material.opacity;

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var opacity = Autodesk.Viewing.Private.lerp(startVal, targetValue, t);
        _this2.setThumbnailOpacity(thumbnail, opacity);
      };

      var onFadeEnd = function onFadeEnd() {
        thumbnail.fadeAnim = null;
        onDone && onDone();
      };

      thumbnail.fadeAnim = Autodesk.Viewing.Private.fadeValue(0, 1, _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["FADE_DURATION"], onTimer, onFadeEnd);
      thumbnail.fadeAnim.targetValue = targetValue;
    } }, { key: "setThumbnailOpacity", value: function setThumbnailOpacity(

    thumbnail, value) {
      if (thumbnail.mesh.material.opacity !== value) {
        thumbnail.mesh.material.opacity = value;
        this.viewer.impl.invalidate(false, false, true);
      }
    } }, { key: "requestThumbnailDebounce", value: function requestThumbnailDebounce(

    map) {var _this3 = this;
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }

      this.debounceTimeout = setTimeout(function () {
        map.thumbnail = new _Minimap3D_SheetThumbnail__WEBPACK_IMPORTED_MODULE_2__["default"](map, _this3.sheetSyncExt.viewer, _this3.createThumbnailMesh);

        if (!_this3.tryRefineThumbnail(map)) {
          map.thumbnail.requestThumbnail();
        }
      }, 300);
    } }, { key: "tryRefineThumbnail", value: function tryRefineThumbnail(

    map) {
      if (this.sheetSyncExt.isSheetMapLoaded(map) &&
      this.sheetSyncExt.viewer.model.isLoadDone() &&
      this.sheetSyncExt.viewer.model.opacity === _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SHEET_OPACITY"]) {

        map.thumbnail.refineThumbnail();
        return true;
      }

      return false;
    }

    // Verify all the thumbnails are displayed correctly.
  }, { key: "update", value: function update() {var _this4 = this;
      var sheetMaps = this.sheetSyncExt.mapCache;
      var currentLevel = this.sheetSyncExt.getCurrentLevel();

      if (!currentLevel) {
        return;
      }

      var showSheetEnabled = this.sheetSyncExt.getShowSheet();

      Object.keys(sheetMaps).forEach(function (levelGuid) {
        var levelMaps = sheetMaps[levelGuid];
        var sameLevel = levelGuid === currentLevel.guid;
        levelMaps.forEach(function (map) {
          var showThumbnail = sameLevel && showSheetEnabled && !_this4.sheetSyncExt.isCameraInsideMap(map);

          if (sameLevel) {
            if (!map.thumbnail) {
              // Thumbnail was not fetched yet - initialize thumbnail object and request thumbnail image.
              // Update when loaded.
              _this4.requestThumbnailDebounce(map);
            } else if (!map.thumbnail.thumbnailRefined) {
              _this4.tryRefineThumbnail(map);
            }
          }

          if (showThumbnail) {
            // If thumbnail mesh is ready - add it to the overlay scene if it's not there already.
            _this4.showThumbnail(map.thumbnail);
          } else {
            // Thumbnail mesh is ready, but should be hidden because it's not on the current level -
            // Remove it from the overlay scene if it's there.
            _this4.hideThumbnail(map.thumbnail, levelGuid !== currentLevel.guid);
          }
        });
      });
    } }, { key: "destroy", value: function destroy()

    {
      this.planeGeometry.dispose();
      this.planeGeometry = null;

      this.viewer.impl.removeOverlayScene(OVERLAY_SCENE);

      this.sheetSyncExt = null;
      this.viewer = null;
    } }]);return ThumbnailsOverlay;}();

/***/ }),

/***/ "./extensions/AEC/SheetSync/TopViewRenderer.js":
/*!*****************************************************!*\
  !*** ./extensions/AEC/SheetSync/TopViewRenderer.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TopViewRenderer; });
/* harmony import */ var _Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Minimap3D/MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _SheetTransforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetTransforms */ "./extensions/AEC/SheetSync/SheetTransforms.js");
/* harmony import */ var _src_application_ProgressState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../src/application/ProgressState */ "./src/application/ProgressState.js");
/* harmony import */ var _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SheetSyncConstants */ "./extensions/AEC/SheetSync/SheetSyncConstants.js");
/* harmony import */ var _ThumbnailsOverlay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ThumbnailsOverlay */ "./extensions/AEC/SheetSync/ThumbnailsOverlay.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}





var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.TopViewRendererExtension';

var tempVec3 = new THREE.Vector3();
var tempVec2 = new THREE.Vector2();
var box = new THREE.Box3();

/**
                            // TopViewRenderer - A viewer extension renders a 3D top view of a target model.
                            //                   It is highly recommended to use LeechViewer for the target viewer - otherwise the 3D model will be loaded again,
                            //                   and no shared resources will be used.
                            //
                            // @param {Viewer3D} [viewer]                       - viewer instance
                            // @param {Object} [options]                        - Configuration options for TopViewRenderer
                            */var
TopViewRenderer = /*#__PURE__*/function (_Autodesk$Viewing$Ext) {_inherits(TopViewRenderer, _Autodesk$Viewing$Ext);
  function TopViewRenderer(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, TopViewRenderer);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(TopViewRenderer).call(this, viewer, options));

    _this.options = _this.options.topViewRendererOptions || _this.options;

    // [modelKey -> boolean] map that represents if a model is being currently loaded on the topViewViewer.
    _this.isModelLoadingMap = {};

    // Time to wait before start rotating to sheet origin.
    _this.waitBeforeRotation = _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["WAIT_BEFORE_ROTATION"];

    // Rotation speed.
    _this.rotationDuration = _SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["ROTATION_DURATION"];

    _this.onBeginScene = _this.onBeginScene.bind(_assertThisInitialized(_this));
    _this.update = _this.update.bind(_assertThisInitialized(_this));
    _this.onMainMapChanged = _this.onMainMapChanged.bind(_assertThisInitialized(_this));
    _this.onResize = _this.onResize.bind(_assertThisInitialized(_this));
    _this.rotateToSheet = _this.rotateToSheet.bind(_assertThisInitialized(_this));
    _this.onSheetGeometryLoaded = _this.onSheetGeometryLoaded.bind(_assertThisInitialized(_this));return _this;
  }_createClass(TopViewRenderer, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.viewer.loadExtension('Autodesk.AEC.SheetSyncExtension', this.viewer.config));case 2:this.sheetSyncExt = _context.sent;

                this.targetViewer = this.sheetSyncExt.targetViewer;

                this.initTopViewViewer();

                this.thumbnailsOverlay = new _ThumbnailsOverlay__WEBPACK_IMPORTED_MODULE_4__["default"](this.topViewViewer, this.sheetSyncExt);

                this.addListeners();case 7:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "initTopViewViewer", value: function initTopViewViewer()


    {
      var container = this.viewer.container;
      var sharedResources = this.targetViewer.sharedResources;

      // In case targetViewer is a LeechViewer, create a leechViewer and use the shared resources.
      if (sharedResources) {
        this.topViewViewer = Autodesk.Viewing.createLeechViewer(container, {}, sharedResources, Autodesk.Viewing.Viewer3D);
      } else {
        // Otherwise, it's unfortunate, and you'll have to create a regular Viewer3D, without resource sharing.
        console.warn('TopViewRenderer - It is highly recommended using LeechViewer as your target viewer when using this extension.');
        this.topViewViewer = new Autodesk.Viewing.Viewer3D(container, {});
      }

      this.viewer.container.insertBefore(this.topViewViewer.container, this.viewer.container.firstChild);
      this.topViewViewer.container.style.zIndex = -1;
      this.topViewViewer.container.style.pointerEvents = 'none';
      this.topViewViewer.container.style.transition = 'opacity 0.7s'; // Value matches "FADE_DURATION" inside SheetSyncConstants.js
      this.topViewViewer.container.style.backgroundColor = 'transparent';
      this.topViewViewer.start(undefined, undefined, undefined, undefined, { webglInitParams: { alpha: true } });
      this.topViewViewer.impl.skipCameraUpdate = true; // Used in order to set near-far values manually.
      this.topViewViewer.setBackgroundOpacity(0);

      this.backgroundColorBackup = this.viewer.container.style.backgroundColor;
      this.viewer.container.style.backgroundColor = 'transparent';
      this.backgroundOpacityBackup = this.viewer.impl.glrenderer().getClearAlpha();
      this.viewer.setBackgroundOpacity(0);
    } }, { key: "destroyTopViewViewer", value: function destroyTopViewViewer()

    {
      if (this.topViewViewer) {
        this.topViewViewer.finish();
        this.topViewViewer = null;
        this.viewer.container.style.backgroundColor = this.backgroundColorBackup;
        this.viewer.setBackgroundOpacity(this.backgroundOpacityBackup);
      }
    } }, { key: "unload", value: function unload()

    {
      this.removeListeners();

      if (this.thumbnailsOverlay) {
        this.thumbnailsOverlay.destroy();
        this.thumbnailsOverlay = null;
      }

      this.destroyTopViewViewer();

      if (this.rotationAnim) {
        this.rotationAnim.stop();
        this.rotationAnim = null;
      }

      this.rotationTimeout && clearTimeout(this.rotationTimeout);

      this.viewer = null;
      this.targetViewer = null;
      this.sheetSyncExt = null;

      return true;
    } }, { key: "addListeners", value: function addListeners()

    {
      this.targetViewer.addEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.addEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.addEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);
      this.viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      this.viewer.addEventListener(av.RENDER_SCENE_PART, this.update);
      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.addEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.topViewViewer.addEventListener(av.MODEL_ADDED_EVENT, this.update);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);
    } }, { key: "removeListeners", value: function removeListeners()

    {
      this.targetViewer.removeEventListener(av.NAVIGATION_MODE_CHANGED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);
      this.targetViewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.update);
      this.targetViewer.removeEventListener(Autodesk.AEC.LevelsExtension.LEVEL_CHANGED, this.update);
      this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onBeginScene);
      this.viewer.removeEventListener(av.RENDER_SCENE_PART, this.update);
      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.removeEventListener(_SheetSyncConstants__WEBPACK_IMPORTED_MODULE_3__["SheetSyncEvents"].MAIN_MAP_CHANGED_EVENT, this.onMainMapChanged);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onSheetGeometryLoaded);
      this.topViewViewer.removeEventListener(av.MODEL_ADDED_EVENT, this.update);

      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      levelExt && levelExt.floorSelector && levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.SELECTED_FLOOR_CHANGED, this.update);
    } }, { key: "isBimWalkActive", value: function isBimWalkActive()

    {
      return this.targetViewer && this.targetViewer.getActiveNavigationTool() === 'bimwalk';
    }

    // Make sure that when the main 2D viewer is resizing - topViewViewer updates as well.
  }, { key: "onResize", value: function onResize(_ref) {var width = _ref.width,height = _ref.height;
      this.topViewViewer.impl.resize(width, height, true);
      this.update();
    } }, { key: "onMainMapChanged", value: function onMainMapChanged()

    {
      this.syncCamera();
      this.update();
      this.validateRotation();
    } }, { key: "onSheetGeometryLoaded", value: function onSheetGeometryLoaded()

    {
      this.validateRotation();
    } }, { key: "validateRotation", value: function validateRotation()

    {
      this.rotationTimeout && clearTimeout(this.rotationTimeout);
      this.rotationTimeout = setTimeout(this.rotateToSheet, this.waitBeforeRotation * 1000);
    } }, { key: "isDraggingAvatar", value: function isDraggingAvatar()

    {
      var avatarExt = this.viewer.getExtension('Autodesk.AEC.AvatarExtension');
      var isDraggingAvatar = !avatarExt || !avatarExt.avatarWidget || avatarExt.avatarWidget.isDragging();

      return isDraggingAvatar;
    } }, { key: "rotateToSheet", value: function rotateToSheet()

    {var _this2 = this;
      if (!this.viewer) {
        return;
      }

      // Rotate only if sheet is shown. Otherwise there is no reason to rotate.
      if (!this.sheetSyncExt.getShowSheet()) {
        return;
      }

      if (this.rotationAnim) {
        this.rotationAnim.stop();
        this.rotationAnim = null;
      }

      // In case the avatar is currently being dragged - don't rotate yet, cause it's annoying.
      if (this.isDraggingAvatar()) {
        // Postpone rotation to the next timeout.
        this.validateRotation();
        return;
      }

      var startAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);

      // Find shortest rotation (keep angle between -PI and PI)
      if (startAngle < -Math.PI) {
        startAngle += 2 * Math.PI;
      } else if (startAngle > Math.PI) {
        startAngle -= 2 * Math.PI;
      }

      var onTimer = function onTimer(t) {
        t = Autodesk.Viewing.Private.smootherStep(t);
        var rotation = startAngle * (1 - t);
        var camera = _this2.viewer.getCamera();
        camera.up.set(0, 1, 0);
        Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(camera.up, tempVec3, rotation);
        camera.dirty = true;
        camera.updateCameraMatrices();
      };

      var onRotationEnd = function onRotationEnd() {
        _this2.rotationAnim = null;
      };

      this.rotationAnim = Autodesk.Viewing.Private.fadeValue(0, 1, this.rotationDuration, onTimer, onRotationEnd);

    }

    // Sync top view whenever the 2d sheet starts rendering.
  }, { key: "onBeginScene", value: function onBeginScene(_ref2) {var percent = _ref2.percent,state = _ref2.state;
      if (percent === 0 && state === _src_application_ProgressState__WEBPACK_IMPORTED_MODULE_2__["ProgressState"].RENDERING) {
        this.update();
      }
    }

    // Jump the camera to make the illusion that we keep the same position, scale and rotation while switching to a different sheetMap.
  }, { key: "syncCamera", value: function syncCamera() {
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer.model || !this.worldBoundingBox) {
        return;
      }

      var camera = this.viewer.getCamera();
      var map = this.sheetSyncExt.sheetMap;

      var viewportLowerLeft = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(map, map.viewportBounds.min.x, map.viewportBounds.min.y, 0);
      var viewportLowerRight = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(map, map.viewportBounds.max.x, map.viewportBounds.min.y, 0);

      var angle = Math.atan2(viewportLowerRight.y - viewportLowerLeft.y, viewportLowerRight.x - viewportLowerLeft.x);

      // Rotate bounding box according to the map's rotation.
      var center = this.worldBoundingBox.center();
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(this.worldBoundingBox.min, center, angle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(this.worldBoundingBox.max, center, angle);

      var p0 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, this.worldBoundingBox.min.clone());
      var p1 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, new THREE.Vector3(this.worldBoundingBox.min.x, this.worldBoundingBox.max.y, 0));
      var p2 = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["worldToMapPixels"])(map, this.worldBoundingBox.max.clone());

      p0.z = 0;
      p1.z = 0;
      p2.z = 0;

      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p0);
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p2);
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToSheet"])(map, p1);

      box.setFromPoints([p0, p2]);

      camera.setViewFromBox(box, true);

      var worldAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.topViewViewer);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(camera.up, tempVec3, worldAngle - angle);

      camera.dirty = true;
      camera.updateCameraMatrices();

      this.viewer.impl.invalidate(true);

      // Restart rotation if it's during rotation.
      if (this.rotationAnim) {
        this.rotateToSheet();
      }
    }

    // Setup a virtual camera according to sheetMap's bounds.
    // This camera should be used in the 3D scene in order to create a top view screenshot.
  }, { key: "updateTopViewViewerCamera", value: function updateTopViewViewerCamera() {
      // If there is no 2D model loaded, worldBounds are infinity, and it will cause calculation errors here.
      // For this reason, we have to wait until there is a loaded model.
      if (!this.viewer.model) {
        return;
      }

      var currentLevel = this.sheetSyncExt.getCurrentLevel();

      if (!currentLevel) {
        return;
      }

      this.viewer.impl.updateCameraMatrices();
      var levelExt = this.targetViewer.getExtension('Autodesk.AEC.LevelsExtension');
      var zRange = levelExt.getZRange(currentLevel.index);

      var renderer = this.viewer.impl.renderer();
      var canvasWidth = renderer.settings.logicalWidth;
      var canvasHeight = renderer.settings.logicalHeight;
      var up = this.viewer.getCamera().up.clone();

      // get position within map widget
      var p0 = tempVec2.set(0, canvasHeight); // lower-left corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p0);
      var p0World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p0.x, p0.y, 0);

      var p1 = tempVec2.set(canvasWidth, canvasHeight); // lower-right corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p1);
      var p1World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p1.x, p1.y, 0);

      var p2 = tempVec2.set(canvasWidth, 0); // upper-right corner
      Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["widgetToMapPixels"])(this.sheetSyncExt.sheetMap, this.viewer, p2);
      var p2World = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["mapPixelsToWorld"])(this.sheetSyncExt.sheetMap, p2.x, p2.y, 0);

      // First set the box in order to get its center. It's needed for calculating the rotation.
      box.setFromPoints([p0World, p2World]);
      var center = box.center();

      // calculate world angle according the world direction from lower left corner, to lower right corner.
      var cameraAngle = Object(_SheetTransforms__WEBPACK_IMPORTED_MODULE_1__["getCameraRotationAngle"])(this.viewer);
      var worldAngle = Math.atan2(p1World.y - p0World.y, p1World.x - p0World.x);

      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(p0World, center, -worldAngle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(p2World, center, -worldAngle);
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(up, tempVec3, worldAngle - cameraAngle);

      // Bounding box rotated according to camera rotation.
      box.setFromPoints([p0World, p2World]);

      // Save worldBoundingBox for later use - in order to sync the camera position.
      this.worldBoundingBox = box.clone();

      var worldBounds = this.targetViewer.impl.getVisibleBounds();

      // The near and far plans are determined according to these values.
      var zMax = Math.min(zRange.zMax, worldBounds.max.z);
      var zMin = worldBounds.min.z;

      // Set camera according to the bounding box.
      var camera = this.topViewViewer.getCamera();
      Object(_Minimap3D_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["setTopView"])(camera, box, zMin, zMax, box.size().y);

      // Rotate 3D camera's up vector according to world angle.
      camera.up.copy(up);
      camera.updateCameraMatrices();
      camera.dirty = true;
    } }, { key: "getModelKey", value: function getModelKey(

    model) {
      var documentNode = model.getDocumentNode();

      if (documentNode) {
        return documentNode.getModelKey();
      } else {
        return model.getData().urn;
      }
    } }, { key: "unloadIrrelevant3DModels", value: function unloadIrrelevant3DModels()

    {var _this3 = this;
      if (!this.sheetSyncExt.targetModels) {
        return;
      }

      var visibleModelsKeys = this.sheetSyncExt.targetModels.map(function (model) {return _this3.getModelKey(model);});

      this.topViewViewer.getVisibleModels().forEach(function (model) {
        var key = _this3.getModelKey(model);
        if (visibleModelsKeys.indexOf(key) === -1) {
          _this3.topViewViewer.unloadModel(model);
          _this3.isModelLoadingMap[key] = false;
        }
      });
    } }, { key: "loadRelevant3DModels", value: function loadRelevant3DModels()

    {var _this4 = this;
      if (!this.sheetSyncExt.targetModels) {
        return;
      }

      var visibleModelsKeys = this.topViewViewer.getVisibleModels().map(function (model) {return _this4.getModelKey(model);});

      this.sheetSyncExt.targetModels.forEach(function (model) {
        var key = _this4.getModelKey(model);

        if (visibleModelsKeys.indexOf(key) === -1 && !_this4.isModelLoadingMap[key]) {
          _this4.isModelLoadingMap[key] = true;

          _this4.topViewViewer.loadDocumentNode(model.getDocumentNode().getRootNode().getDocument(), model.getDocumentNode(), { keepCurrentModels: true }).then(function () {
            // Set topView render config.
            var config = _this4.targetViewer.impl.renderer().getConfig();
            config.renderEdges = true;
            config.envMapBackground = null;
            config.aoEnabled = false;
            config.antialias = true;
            config.envMap = null; // Can't share this resource between viewers.
            _this4.topViewViewer.impl.renderer().applyConfig(config);
            _this4.topViewViewer.setBackgroundOpacity(0);
          });
        }
      });
    } }, { key: "hideTopViewViewer", value: function hideTopViewViewer()

    {
      this.topViewViewer.container.style.opacity = 0;
    } }, { key: "showTopViewViewer", value: function showTopViewViewer()

    {
      this.topViewViewer.container.style.opacity = 1;
    } }, { key: "update", value: function update()

    {
      if (!this.sheetSyncExt || !this.sheetSyncExt.sheetMap || !this.viewer || !this.targetViewer || !this.topViewViewer) {
        this.hideTopViewViewer();
        return;
      }

      this.showTopViewViewer();

      // Remove unused 3D models from topViewViewer.
      this.unloadIrrelevant3DModels();

      // Load relevant 3D models to toViewViewer.
      this.loadRelevant3DModels();

      // Update top view camera, according to the current sheet map.
      this.updateTopViewViewerCamera();

      this.thumbnailsOverlay.update();
    } }]);return TopViewRenderer;}(Autodesk.Viewing.Extension);


namespace.TopViewRenderer = TopViewRenderer;
av.theExtensionManager.registerExtension(myExtensionName, TopViewRenderer);

/***/ }),

/***/ "./extensions/AEC/common/AecModelData.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/common/AecModelData.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. 
// Currently only available for Revit files.
//

// If changed to true, LMV starts using the new modelToSheetTransform from AECModelData.json for the 2D/3D transform (if available).
var USE_MODELTOSHEET_TRANSFORM = false;

var namespace = AutodeskNamespace('Autodesk.AEC');

// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.
var remapRectangle = function remapRectangle(
xMinFrom, yMinFrom, xMaxFrom, yMaxFrom,
xMinTo, yMinTo, xMaxTo, yMaxTo)
{
  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);
  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);

  // Note that the translation component of the matrix works on the scaled values.
  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want 
  // to map it to xMinTo instead. (analog for y)
  var offsetX = xMinTo - scaleX * xMinFrom;
  var offsetY = yMinTo - scaleY * yMinFrom;

  // Create Matrix4 that applies both
  var matrix = new THREE.Matrix4();
  matrix.elements[0] = scaleX;
  matrix.elements[5] = scaleY;
  matrix.elements[12] = offsetX;
  matrix.elements[13] = offsetY;
  return matrix;
};

var getFeetToSheetUnits = function getFeetToSheetUnits(sheetUnitScale) {
  var FeetToMeter = 0.3048;
  var MeterToSheetUnits = 1.0 / sheetUnitScale;
  return FeetToMeter * MeterToSheetUnits;
};

// Returns the 2D bbox of a viewport on a sheet.
// 
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
// @returns {THREE.Box2|null}
var getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {

  // viewport region in foot as array (6 floats)
  var values = vp.geometryViewportRegion;
  if (!values) {
    return null;
  }

  // Convert from foot to sheet units (usually inches)
  var scale = getFeetToSheetUnits(sheetUnitScale);

  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.
  // We remove that offset before scaling. 
  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)
  var boundsCorrection = 0.01;

  var res = new THREE.Box2();
  res.min.x = (values[0] + boundsCorrection) * scale;
  res.min.y = (values[1] + boundsCorrection) * scale;
  res.max.x = (values[3] - boundsCorrection) * scale;
  res.max.y = (values[4] - boundsCorrection) * scale;
  return res;
};

// Handle available view rotation modes in Revit
// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.
// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])
//
//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:
//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm
//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation
var getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {

  var matrix = new THREE.Matrix4();
  switch (viewRotationType) {
    // No rotation => done
    case 0:return matrix;

    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw
    case 1:{
        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the
        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.
        // Therefore, the desired effect of the matrix is:
        //
        //  (x, y) => (1-y, x)
        //
        // Note the memory layout of THREE matrices is column-major.

        // out.x = (1-y)
        matrix.elements[0] = 0; //  0 * in.x
        matrix.elements[4] = -1; // -1 * in.y
        matrix.elements[12] = 1; // + 1

        // out.y = x
        matrix.elements[1] = 1; // 1 * in.x
        matrix.elements[5] = 0; // 0 * in.y

        break;
      }

    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw
    case 2:{
        // Desired transform here is:
        //
        // (x, y) => (y, 1-x)

        // out.x = y
        matrix.elements[0] = 0; // 0 * in.x
        matrix.elements[4] = 1; // 1 * in.y

        // out.y = (1-x)
        matrix.elements[1] = -1; //    -in.x
        matrix.elements[5] = 0; // 0 * in.y
        matrix.elements[13] = 1; // + 1

        break;
      }
    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}

  return matrix;
};

// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.
//
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
//
// @returns {THREE.Matrix4|null} May return null if a viewport does not support a 2D/3D transform.
//
// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. 
var get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get the 3DTo2D matrix directly.
  if (USE_MODELTOSHEET_TRANSFORM && vp.modelToSheetTransform) {
    var matrix = get3DTo2DMatrix(vp, sheetUnitScale);
    return matrix.getInverse(matrix);
  }

  // Viewport bbox on sheet (Box2)
  var sheetRegion = getViewportBounds(vp, sheetUnitScale);

  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume
  // that is mapped to the sheet.
  var sectionBox = vp.sectionBox;
  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var sheetToViewport = remapRectangle(
  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates
  0, 0, 1, 1 // ...to [0,1] 
  );

  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)
  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var viewportToSectionBox = remapRectangle(
  0, 0, 1, 1, // ...from normalized viewport coords
  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox
  );

  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.
  return sectionBoxTransform.
  multiply(viewportToSectionBox).
  multiply(vpRotationInv).
  multiply(sheetToViewport);
};

// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().
var get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {

  // If AECModelData has been produced using latest RevitAPI changes, 
  // we get a matrix directly.
  if (USE_MODELTOSHEET_TRANSFORM && vp.modelToSheetTransform) {

    // So far, we only support a single matrix per viewport
    var values = vp.modelToSheetTransform;
    var _matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(values);

    // apply post-scaling from feet to sheet-units
    // Note that using multiplyScalar() here is only similar, but not the same: E.g., it would also multiply component 15
    // which may cause weird side-effects when multiplying with other matrices.
    var feetToSheetUnits = getFeetToSheetUnits(sheetUnitScale);
    var scaleTf = new THREE.Matrix4().makeScale(feetToSheetUnits, feetToSheetUnits, 1.0);
    _matrix.multiplyMatrices(scaleTf, _matrix);

    return _matrix;
  }

  var matrix = get2DTo3DMatrix(vp, sheetUnitScale);
  matrix.getInverse(matrix);
  return matrix;
};

// Find Sheet BubbleNode containing the given viewport.
//
//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets
//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)
//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).
var findSheetForViewport = function findSheetForViewport(root, vp) {
  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);
  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};
  return sheetNodes.find(linkedByVp);
};

// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.
// Note that not all viewports support 2D/3D transform.
//
//  @param {av.BubbleNode|av.Model} sheet
var findViewportsOnSheet = function findViewportsOnSheet(sheet) {

  // get aecModelData from model or node
  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;
  var sheetNode = isNode ? sheet : sheet.getDocumentNode();
  var aec = sheetNode.getAecModelData();
  if (!aec || !aec.viewports) {
    return [];
  }

  // Find viewports linking the sheet guid
  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});
};

// Given a sheet and a point on that sheet, this function returns the viewport containing it.
// If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
// where the distance from the viewport edges is largest.
//
//  @param {av.Model}         sheet
//  @param {Vector2}          point            - Point in sheet world-coords.
//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports
//
//  @returns {Object|undefined} 
var findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  // Find sheets linking this sheet
  var viewports = findViewportsOnSheet(sheet);

  // Apply option filter
  if (viewportFilter) {
    viewports = viewports.filter(viewportFilter);
  }

  // Couple each viewport with viewport bounds 
  viewports = viewports.map(function (vp) {
    return {
      viewport: vp,
      bounds: getViewportBounds(vp, sheet.getUnitScale()) };

  });

  // Reduce to viewports containing the given point
  var containsPoint = function containsPoint(vp) {
    return vp.bounds && vp.bounds.containsPoint(point);
  };
  viewports = viewports.filter(containsPoint);

  // Point may be outside of all viewports
  if (!viewports.length) {
    return;
  }

  // Viewports may overlap. For this case, we need a heuristic metric
  // to choose the best match. For this, we use the
  // distance to the viewport boundary edges.
  var distanceFromEdge = function distanceFromEdge(box, p) {
    return Math.min(
    Math.min(p.x - box.min.x, box.max.x - p.x),
    Math.min(p.y - box.min.y, box.max.y - p.y));

  };

  // Pick the viewport that minimizes distanceFromEdge
  var getBestMatch = function getBestMatch(vp1, vp2) {
    var d1 = distanceFromEdge(vp1.bounds, point);
    var d2 = distanceFromEdge(vp2.bounds, point);
    return d2 > d1 ? vp2 : vp1;
  };
  return viewports.reduce(getBestMatch).viewport;
};

// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)
//  @param {Object} vp - viewport object from aecModelData
//  @returns {string|undefined} levelGuid
var getLinkedLevel = function getLinkedLevel(vp) {

  // Viewports come directly from aecModelData json and do not always reference a level. 
  // So, we should not crash if anything is null here.
  var viewRange = vp.extensions && vp.extensions.viewRange;
  var cutPlane = viewRange && viewRange.cutPlane;
  return cutPlane && cutPlane.levelGuid;
};

// Find all viewports in the document that link the level indicated by levelGuid
//
// @param {Object} aecData   - as obtained from AECModelData.json
// @param {string} levelGuid
// @retuns {Object[]} Array of viewport data objects
var findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {

  // Find viewports that links this level
  var viewports = aecData.viewports || [];

  var matchesLevel = function matchesLevel(vp) {
    var vpLevelGuid = getLinkedLevel(vp);
    return vpLevelGuid === levelGuid;
  };
  return viewports.filter(matchesLevel);
};

// Find level in aecModelData that links the given viewport.
//
// @param {Object} aecData - as obtained from AECModelData.json
// @param {Object} viewport object
// @retuns {Object|undefined} level object from aecModelData
var findLevelForViewport = function findLevelForViewport(aecData, viewport) {
  var levelGuid = getLinkedLevel(viewport);

  // Search for a level with this levelGuid
  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};
  return levelGuid && aecData.levels.find(hasLevelGuid);
};

// Checks if a viewport provides all required information to compute a 2D/3D transform.
//  @param {Object} vp - vieport data object as obtained from AecModelData.json
var supports2DTo3DTransform = function supports2DTo3DTransform(vp) {

  // If AECModelData contains a modelToSheetTransform (only possible for models produced using latest RevitAPI changes), we get a matrix directly
  // and don't have to care for sectionBox or isCropBoxActive anymore.
  var canUseTransform = Boolean(USE_MODELTOSHEET_TRANSFORM && vp.modelToSheetTransform);

  // Check if we can use the old code path to reverse-engineer the transform from the SectionBox
  var canUseWorkaround = Boolean(vp.sectionBox && vp.isCropBoxActive);

  // If neither of the two work, we can stop here.
  if (!canUseTransform && !canUseWorkaround) {
    return false;
  }

  // Viewport types for which we know that we get valid transform data.
  // For 'Section', it worked for some examples, but wasn't reliably enough to enable it by default yet.
  var supportedTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];

  return Boolean(supportedTypes.includes(vp.viewType) &&
  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)
  !vp.hasBreaks && // A view in Revit may be split into separate parts using "View breaks". This is not supported yet.
  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.
};

var AecModelData = {
  get2DTo3DMatrix: get2DTo3DMatrix,
  get3DTo2DMatrix: get3DTo2DMatrix,
  getViewportBounds: getViewportBounds,
  remapRectangle: remapRectangle,
  findSheetForViewport: findSheetForViewport,
  findViewportsForLevel: findViewportsForLevel,
  supports2DTo3DTransform: supports2DTo3DTransform,
  getLinkedLevel: getLinkedLevel,
  findViewportsOnSheet: findViewportsOnSheet,
  findViewportAtPoint: findViewportAtPoint,
  findLevelForViewport: findLevelForViewport };


/* harmony default export */ __webpack_exports__["default"] = (AecModelData);

namespace.AecModelData = AecModelData;

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkExtension.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkExtension.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkExtension; });
/* harmony import */ var _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HyperlinkTracker */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.HyperlinkExtension';


// Hyperlink extension which will display hyperlinks in 2D sheets to other sheets
//  @param {Number} options.rootBubbleNode Root bubble node of model
//  @callback options.loadViewableCb Will be called in case a hyperlink is clicked with bubble node of the sheet and
//      the total number of hyperlinks present in the sheet
//  @callback options.hyperlinksAddedCb Will be called each time hyperlinks have been added to a sheet with the id of
//      the model and the total number of hyperlinks present in the sheet
var HyperlinkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(HyperlinkExtension, _av$Extension);
  function HyperlinkExtension(viewer, options) {var _this;_classCallCheck(this, HyperlinkExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(HyperlinkExtension).call(this, viewer, options));

    _this.hyperlinkTracker = new _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer, _this.options.rootBubbleNode,
    _this.options.loadViewableCb, _this.options.hyperlinksAddedCb);return _this;
  }_createClass(HyperlinkExtension, [{ key: "load", value: function load()

    {
      this.viewer.toolController.activateTool('hyperlink-tracker');
      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.toolController.deactivateTool('hyperlink-tracker');
      return true;
    } }]);return HyperlinkExtension;}(av.Extension);


namespace.HyperlinkExtension = HyperlinkExtension;
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, HyperlinkExtension);

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkTracker.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkTracker.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkTracker; });

//A tool that:
//Implements heuristically derived hyperlinks from text geometries in F2D drawings (and mouse hover support for hyperlinks)
//Taken from Fluent POC:
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L273
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L171




var av = Autodesk.Viewing,
avp = Autodesk.Viewing.Private;

function HyperlinkTracker(viewer, rootBubbleNode, loadViewableCb, hyperlinksAddedCb) {
  av.ToolInterface.call(this);
  this.names = ['hyperlink-tracker'];
  viewer.toolController.registerTool(this);

  var _viewer = viewer;
  var _loadViewableCb = loadViewableCb;
  var _hyperlinksAddedCb = hyperlinksAddedCb;
  var _idRead = [0, 0];
  var _linkMaps = {};
  var _dbId = 0;
  var _lastX, _lastY;
  var _mouseMoved = false;
  var _isDragging = false;

  this.update = function () {
    if (!_isDragging) {
      if (_mouseMoved) {
        var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
        _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);
        _mouseMoved = false;
      }
    } else {
      _dbId = 0;
    }
    return false;
  };

  function getCurrentModel() {
    var mq = _viewer.impl.modelQueue();
    var visibleModels = mq.getModels();

    return visibleModels.length === 1 ? visibleModels[0] : undefined;
  }

  function getCurrentLinkMap() {
    var linkMap = _linkMaps[_idRead[1]];

    //Fallback for when a single model is loaded and the Model ID buffer is not working
    if (!linkMap) {
      var cm = getCurrentModel();
      if (cm) {
        linkMap = _linkMaps[cm.id];
      }
    }

    return linkMap;
  }

  function isLinkMapValid(map) {
    return map && Object.keys(map).length > 0;
  }

  this.handleSingleClick = function () {
    if (!_viewer.model || !_viewer.model.is2d())
    return;

    var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
    _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);

    var linkMap = getCurrentLinkMap();

    var linkNode = isLinkMapValid(linkMap) ? linkMap[_dbId] : null;

    if (linkNode) {
      _loadViewableCb(linkNode, linkMap.numHyperlinks);
      return true;
    }

    return false;
  };

  this.handleButtonDown = function (event) {
    _isDragging = true;
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    return false;
  };

  this.handleButtonUp = function () {
    _isDragging = false;
    return false;
  };

  this.handleMouseMove = function (event) {
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    _mouseMoved = true;
    return false;
  };

  function addRenderBox(vbb, f2d, stringIndex, modelScale) {
    var i4 = 4 * stringIndex;

    var miny = f2d.stringBoxes[i4 + 1];
    var maxy = f2d.stringBoxes[i4 + 3];
    var border = (maxy - miny) * 0.2;
    miny = miny - border;
    maxy = maxy + border;
    var minx = f2d.stringBoxes[i4] - border;
    var maxx = f2d.stringBoxes[i4 + 2] + border;

    var dbId = f2d.stringDbIds[stringIndex];
    var vbase = vbb.vcount;

    var linkFillColor = 0x77bfbb3f;
    vbb.addVertexPolytriangle(minx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, maxy, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(minx, maxy, linkFillColor, dbId, 0, 0);

    vbb.addIndices([0, 1, 2, 0, 2, 3], vbase);

    vbb.addSegment(minx, miny, maxx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, miny, maxx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, maxy, minx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(minx, maxy, minx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
  }

  function addLinkBoxMesh(model, vbb) {
    var fragId = model.getFragmentList().vizmeshes.length;
    var mdata = { mesh: vbb.toMesh(), is2d: true, packId: '0', meshIndex: fragId };
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var matman = _viewer.impl.matman();
    var materialId = matman.create2DMaterial(model, {});
    var m = _viewer.impl.setupMesh(model, mdata.geometry, materialId, model.getData().loadOptions.placementTransform);
    model.activateFragment(fragId, m);
    return fragId;
  }

  function removeLinkBoxMesh(model, fragId) {
    // get link box mesh
    var fragList = model.getFragmentList();
    var mesh = fragList.vizmeshes[fragId];

    // Dispose geometry. MaterialManager will take care of the material dispose on model unload. 
    // We don't dispose material here because it may be shared with other fragments of the model.
    mesh.geometry.dispose();

    delete fragList.vizmeshes[fragId];
  }

  function initializeHyperlinks(model) {
    if (!model || !model.is2d()) {
      return;
    }

    // Check if this model has been initialized already
    var linkMap = _linkMaps[model.id];
    if (linkMap) {
      return;
    }

    // find all sheets of the same document
    var node = model.getDocumentNode();
    var root = node && node.getRootNode();
    var sheets = root && root.search({ role: '2d', type: 'geometry' });
    if (!sheets || !sheets.length) {
      return;
    }

    linkMap = _linkMaps[model.id] = {};

    var currentSheetBasePath = '';
    if (model.myData) {
      currentSheetBasePath = model.myData.basePath;
    }

    var getSheetUrn = function getSheetUrn(sheet) {
      var resourceType = 'resource';
      if (sheet.children) {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
          for (var _iterator = sheet.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var child = _step.value;
            if (child.type() === resourceType) {
              var urn = child.urn();
              if (urn) {
                // We remove the primaryGraphics.f2d part from the urn
                var elements = urn.split('/');
                elements.pop();
                return elements.join('/');
              }
            }
          }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return != null) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}
      }
      return null;
    };

    var sheetIds = sheets.map(function (s) {
      var sheetUrn = getSheetUrn(s);
      //exclude current sheet, i. e. no links to self
      if (currentSheetBasePath.indexOf(sheetUrn) === -1) {
        var split = s.name().split(' ');
        var sheetName = split[0];
        if (sheetName.length > 2) {
          return sheetName;
        }
      }
      return '';
    });

    //while finding hyperlink strings, we will also
    //create a geometry buffer containing all their bboxes
    //so we can render with their IDs.
    linkMap.numHyperlinks = 0;
    var vbb = new avp.VertexBufferBuilder();
    var modelScale = 1.0 / (model.getData().loadOptions.modelScale || 1);
    var f2d = model.getData();
    for (var i = 0; i < f2d.strings.length; i++) {

      var idx = sheetIds.indexOf(f2d.strings[i]);

      if (idx >= 0) {
        linkMap[f2d.stringDbIds[i]] = sheets[idx];

        addRenderBox(vbb, f2d, i, modelScale);
        linkMap.numHyperlinks++;
      }
    }

    linkMap.boxFragId = addLinkBoxMesh(model, vbb);

    if (_hyperlinksAddedCb) {
      _hyperlinksAddedCb(e.model.id, linkMap.numHyperlinks);
    }
  }

  function onGeomLoaded(e) {
    initializeHyperlinks(e.model);
  }

  // Execute cb for all sheets that are (completely) in memory
  function forAllSheetsInMemory(cb) {
    var allModels = _viewer.getVisibleModels().concat(_viewer.getHiddenModels());
    for (var i = 0; i < allModels.length; i++) {
      var model = allModels[i];
      if (model.is2d() && model.isLoadDone()) {
        cb(model);
      }
    }
  }

  function removeHyperlinks() {

    // Keep _linkMaps consistent with models: We don't want to leak dead box meshes in the models.
    // Therefore, we remove them from all models in memory
    forAllSheetsInMemory(function (model) {
      var linkMap = _linkMaps[model.id];
      if (linkMap) {
        removeLinkBoxMesh(model, linkMap.boxFragId);
      }
    });

    _linkMaps = {};

    // make sure that removed hyperlink quads are not visible anymore
    _viewer.impl.invalidate(true, true);
  }

  this.activate = function () {

    // Make sure that we don't forget to init hyperlinks if the geom-load event has already happened
    forAllSheetsInMemory(function (model) {
      initializeHyperlinks(model);
    });

    _viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);

    // make sure that added hyperlink quads appear instantly
    _viewer.impl.invalidate(true, true);
  };

  this.deactivate = function () {
    _viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);
    removeHyperlinks();
  };

  // Show a hand cursor, if the cursor is close to a hyperlink
  this.getCursor = function () {
    var linkMap = getCurrentLinkMap();

    if (_dbId < -1 && isLinkMapValid(linkMap) && linkMap[_dbId]) {
      return 'pointer';
    }

    return null;
  };
}

var namespace = AutodeskNamespace('Autodesk.AEC');
namespace.HyperlinkTracker = HyperlinkTracker;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelector.js":
/*!************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelector.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelector; });
/* harmony import */ var _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelectorFilter.js */ "./extensions/AEC/levels/FloorSelectorFilter.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;
var namespace = AutodeskNamespace('Autodesk.AEC');


// FloorSelector provides graphics effects to be used by UI for floor selection.
//
// This includes:
//
//  - Setting cutplanes accordingly when a floor is selected.
//
//  - Animated transitions if the selected floor changes.
//
//  - Applying mouse-over highlighting of floors - to be used when hovering over a floor button
//
//  - "Ghost-Floors": By default, we render selected floors only. If the mouse enters the floor panel, we
//     also fade-in the other floors, but with strongly reduced opacity. (+ fade-out on mouse leave)
//
//
// How to use it:
//
//  1. Create a FloorSelector by passing the viewer to the ctor.
//
//  2. Before using the FloorSelector, you have to provide floor data that you get from the Revit metadata
//     json file. (see setFloorData comment)
//
//  3. Connect events for hovering over floor selector UI panel:
//     - Connect mouseover  to floorSelector.enterHoverMode()
//     - Connect mouseleave to floorSelector.existHoverMode()
//
//  4. Connect events for hovering over floor selection buttons: For each floor button...
//     - Connect mouseover  to floorSelector.rollOverFloor(floorIndex) - floorIndex must be the index into the floor array (see setFloorData)
//     - Connect mouseleave to floorSelector.rollOverFloor()
//
//  5. Connect floor selection button: For each floor button,
//     connect button mousedown to floorSelector.selectFloor(floorIndex, true)
//
//  6. If the set of visible models has changed
//
//  7. When discarding the FloorSelector (while keeping the Viewer alive), call FloorSelector dtor.
//
// How to enable the optional filtering of objects by dbIds per model provided by the AECModelData.json on level selection?
//
//  1. You have to provide floor filter data containing a Map of dbIds per model. The key has to be the model version URN (see setFloorFilterData).
//
//     Example on how to set the floor filter data:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// How to control the calculated lower level boundary value by defining the levelHeightFactor factor? The factor is multiplied with the level height
// and added to the level minZ value. This newly calculated minZ value defines the lower level boundary used to filter the Floor and Ceiling elements.
//
//     Example on how to set the floor filter data with a levelHeightFactor:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds,
//         levelHeightFactor: 0.6 // Allowed values have to be within 0-1.
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// Technical requirements/restrictions to be aware of:
//
//  - Cross-Fading Support: FloorSelector uses LMV render target fading for some effects. For this, it activates
//    cross-fading support in LMV (if not active already). This requires 2 extra color targets, i.e.
//    consumes some additional GPU-side memory.
//
//  - Camera Movement: The camera should not be moving while using the floor selector.
//    This is because we partially use static images for the fading effects.
//    If the user moves the camera, we instantly switch off the ghost floors.
//
//  - SAO opacity: FloorSelector needs to temporarily hide SAO. For this, we have to overwrite SAO opacity
//    and recover it later. This requires that the SAO opacity is not changed in the meantime
//    while using the FloorSelector. Otherwise, it will cause a warning and may cause visual
//    artifacts.



// Time in seconds to fade in/out ghosted floors when hovering over the floor selector panel
var GhostFloorFadingTime = 0.5;

// Opacity for ghost floors when fade-in is finished.
var MaxGhostFloorOpacity = 0.2;

// These should actually be infinity and -infinity, but since the values are passed to a shader,
// we have to use large finite values instead. Setting as cutplane elevations actually corresponds to
// switching cutplanes off. But, changes the number of cutplanes triggers expesnive shader recompiles.
var MaxZLimit = 1e20;
var MinZLimit = -MaxZLimit;

// Internally used enum values for state management
var FloorRenderMode = {

  // mouse is hovering over a floor button
  Hovering: 0,

  // new floor has been selected and anim is running
  Transition: 1,

  // default rendering
  Off: 2 };


// Reserved floor-index constant to select all floors at once.
var AllFloors = -1;
var NoFloor = undefined;

// Used for setCutPlane calls to lmv. This ensures that FloorSelector controls its own cutplanes,
// which is independent of other cutplane changes like from SectionTool.
var CutPlaneSetName = 'Autodesk.AEC.FloorSelector';var

FloorSelector = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelector(viewer) {_classCallCheck(this, FloorSelector);

    av.EventDispatcher.prototype.apply(this);

    this._viewer = viewer;
    this._renderer = viewer.impl.renderer();

    // Make sure that ghost-floors are switched off as soon as the user starts navigating.
    // This is needed because the selected floor is just a static image when ghost-floors are shown.
    this._cameraMovedCB = this._interruptFading.bind(this);
    viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);

    // Stop panel-hover effect on viewer-resize: Ghost-floors use a static image overlay that becomes unusable
    // if the target size changes.
    this._viewerResizeCB = this._onViewerResized.bind(this);
    viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);

    // If SAO is switched off, we have to switch off roll-over highlighting too.
    this._renderOptionsChangedCB = this._onRenderOptionsChanged.bind(this);
    viewer.addEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);

    // callback for the floor selection filtering
    this._floorSelectionFilterToBeUpdated = this._runFloorSelectorFilterEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
    viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);

    // callback for the unloading of disabled models
    this._modelUnloadingCB = this._runModelUnloadingEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);

    // {Object[]} Contains the floor data. see setFloorData() comment.
    this._floors = [];

    // current state (hover/transition/off)
    this._currentMode = FloorRenderMode.Off;
    this._hovering = false; // used to track hovering state while in transition mode

    // current floor section (if cutplanes are active)
    this._floorSectionMin = undefined;
    this._floorSectionMax = undefined;

    // Determine z-range for "all-floors"
    // We determine that dynamically from the currently visible models.
    // Note that we need this value also for cutplane transitions - so we cannot
    // simply choose something arbitrarily far outside.
    this._zMinAllModels = undefined;
    this._zMaxAllModels = undefined;

    // {AnimControl} Needed to interrupt a running cutplane animation (see moveFloors)
    this._floorAnim = null;

    // {AnimControl} Needed to interrupt a runnign fade-in/out anim for ghost-floors
    this._fadeAnim = null;

    // Opacity of the render target that shows floors that are currently not selected ("ghost floors")
    // Always 0.0 if the extra target for ghost floors is not used.
    this._ghostFloorOpacity = 0.0;

    // {number|undefined} index of selected floor (or undefined if no floor is selected)
    this._currentFloor = undefined;

    // We render ghost-floors without AO, because AO cannot be smoothly faded out with them.
    // To activate AO, we need to 'backup' the current AO opacity and recover it later.
    this._aoVisible = true;
    this._aoOpacity = undefined; // if ao is blocked, we store the original ao opacity here to recover it later.

    this._floorSelectorFilter = new _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._viewer);
    this._floorFilterData = undefined;

    // Indicates if we are currently using mouse-over highlighting for a floor.
    this._floorRollOverActive = false;

    // Whether to use the ghosting effect
    this._fadeEnabled = true;

    // If disabled, make sure that cutplanes keep unset. This is needed to avoid side-effects on 2D views.
    this.enabled = true;

    // Maximum time in ms that we allow for rendering offline images for fading effects.
    // By default (undefined), we use the frameBudget of regular rendering.
    this.offscreenRenderBudget = undefined;

    this.fadingTime = GhostFloorFadingTime;
  }_createClass(FloorSelector, [{ key: "dtor", value: function dtor()

    {
      if (this._viewer) {
        this._viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);
        this._viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);
        this._viewer.removeEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);
        this._viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);
        this._viewer = null;
      }
    }

    // -----------------
    // --- Main API ----
    // -----------------

    // Before selecting any floors, setFloorData() must be called to provide the elevation ranges
    // of all available floors.
    //  @param {Object[]} floors - data about available floors, each item f must contain two finite floats f.zMin < f.zMax
  }, { key: "resetState",











    // sets back level isolation, selection filter and the floors.
    value: function resetState() {
      // we have to clear the settings
      this._floors = [];
      this._selectFloor(NoFloor);
      this._clearFloorSection();
      this._floorSelectorFilter.clearFilter();
    }

    // Before any objects can be filtered using the FloorSelectorFilter, setFloorFilterData() must be called to
    // provide the array of Floor and Ceiling dbIds per model.
    //  @param {Object[]} floorFilterData - A floor filter data object containing an array of dbIds per model.
  }, { key: "enterHoverMode",







    // Fades in the ghost-floors.
    // Triggered when floor selection begins, i.e., mouse is entering floor selector panel.
    value: function enterHoverMode() {

      // make sure that the ghosted floors are in a static image,
      // so that we can move the solid floor
      if (this._currentMode !== FloorRenderMode.Transition) {
        this._setMode(FloorRenderMode.Hovering);
      }

      // track hovering state - so that we can recover it after transitions
      this._hovering = true;
    }

    // Fades out the ghost floors.
    // Triggered when floor selection ends, i.e., mouse is leaving the floor selector panel.
    // @param {boolean} [force] - will exit ghosting immediately even if during transition
  }, { key: "exitHoverMode", value: function exitHoverMode(force) {

      // If a floor-transition is running, we only track the hover state and
      // set the mode when the transition has finished.
      if (this._currentMode !== FloorRenderMode.Transition || force) {
        this._setMode(FloorRenderMode.Off);
      }
      this._hovering = false;

      // make sure that no spatial filter for mouse-over highlight is set anymore, so that we don't
      // have side-effects on subsequent object selection.
      this._setSpatialFilterForRollOver();
    } }, { key: "setPanelHoverEffectEnabled", value: function setPanelHoverEffectEnabled(

    enabled) {
      this.exitHoverMode(true);
      this._skipFadeAnimations();
      this._fadeEnabled = enabled;
    } }, { key: "_getFadeExtension", value: function _getFadeExtension()

    {
      return this._fadeEnabled && this._viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Ghosted display of inactive floors on panel hover is only supported if CrossFadeEffects extension is loaded
  }, { key: "_ghostFloorsEnabled", value: function _ghostFloorsEnabled() {
      return Boolean(this._getFadeExtension());
    }

    // Select for which floor rollOver highlighting is shown.
    //   @param {number} [floorIndex] must be either
    //                                a) a valid index into this.floors
    //                                b) a reserved constant (FloorSelector.AllFloors or FloorSelector.NoFloor)
  }, { key: "rollOverFloor", value: function rollOverFloor(floorIndex) {

      // If we don't show ghost-floors, roll-over highlighting does not make much sense if only 1 floor is visible anyway.
      // It just looks confusing, because occasionally it would only be visible for the selected floor and some parts of others
      // that overlap the z-range a bit.
      var enabled = this._ghostFloorsEnabled() || this._currentFloor === NoFloor;

      // rollOver highlight is only possible if SAO is enabled and supported.
      var supported = this._renderer.spatialFilterForRollOverSupported();
      if (floorIndex === undefined || !supported || !enabled) {

        // switch off floor highlight
        this._setSpatialFilterForRollOver();
        this._renderer.rolloverObjectId(0);
        return;
      }

      // Activate roll-over highlighting for all objects
      this._renderer.rolloverObjectId(1);

      // restrict highlighting to floor range unless all floors are selected.
      this._setSpatialFilterForRollOver(floorIndex);

      // TODO: Clarify why this call is needed. It should actually not required to re-render here.
      this._viewer.impl.invalidate(false, true, true);
    }

    // Sets the currently visible floor.
    //  @param {number}   [floorIndex]    A valid index into the floor data array (see setFloors) selects a single floor.
    //                                    FloorSelector.NoFloor discards the floor selection => all floors visible.
    //  @param {bool}     [useTransition] If true, a short animation is used to morph between previous and new floor
    //  returns false in case no selection cannot be performed
  }, { key: "selectFloor", value: function selectFloor(floorIndex, useTransition) {

      if (!this.floorSelectionValid(floorIndex)) {
        return;
      }

      if (useTransition) {
        this._moveToFloor(floorIndex);
      } else {
        this._selectFloor(floorIndex);
      }

      this._runFloorSelectorFilter();

      // If no ghosting is used, we disable rollOver highlighting if only a single floor is visible.
      if (!this._ghostFloorsEnabled()) {
        this.rollOverFloor();
      }

      this.fireEvent({ type: FloorSelector.SELECTED_FLOOR_CHANGED, levelIndex: floorIndex });
    }

    // Gets the index of the current selected floor or FloorSelector.NoFloor
  }, { key: "floorSelectionValid",



    // Returns whether a floorSelection can be performed with the specified floor
    // checks for valid value, whether floorData is available, the floor is already selected
    // and whether the floor is within the expected range.
    value: function floorSelectionValid() {var newFloor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NoFloor;
      // force boolean
      return !!((Number.isInteger(newFloor) || newFloor === NoFloor) && // not a valid value
      this.floorData && this.floorData.length !== 0 // has no floor data
      && this.currentFloor !== newFloor // newFloor floor is not selected
      && (newFloor === NoFloor ||
      newFloor >= 0 || this.floorData.length > newFloor)); // new floor is in range;
    }

    // returns true if a dbId is either hidden by FloorSelectorFilter or fully outside the cutplanes
  }, { key: "isVisible", value: function isVisible(model, dbId) {

      // reused tmp variable
      if (!this._tmpNodeBox) {
        this._tmpNodeBox = new Float32Array(6);
      }

      // Determine zMin/zMax to ceck against. We could use _floorSectionMin/Max. But this would
      // make this function depending on current animation state. Since we don't want to do permanent
      // filter-updates during animations, we use currentFloor instead, which represents the target state - independent of animations.
      var floor = this._floors[this._currentFloor];
      if (floor === NoFloor) {
        // No floor selected => Nothing hidden
        return true;
      }

      var instanceTree = model.getInstanceTree();
      if (!instanceTree) {
        // If there is not instance tree, FloorSelectorFilter would have warned already if a floor was selected.
        return true;
      }

      // get zMin/zMax for this node
      var nodeBox = this._tmpNodeBox;
      instanceTree.getNodeBox(dbId, nodeBox);
      var nodeBoxZMin = nodeBox[2];
      var nodeBoxZMax = nodeBox[5];

      // Node is hidden if...
      //  a) outside the level's cutplanes, or
      //  b) hidden by levels filter
      var outsideCutplane = nodeBoxZMin > floor.zMax || nodeBoxZMax < floor.zMin;
      return !outsideCutplane && this._floorSelectorFilter.isVisible(model, dbId);
    } }, { key: "setEnabled", value: function setEnabled(

    enabled) {
      this.enabled = enabled;
      this._applySelectedFloorSection();
    }

    // ------------------------
    // --- Internal methods ---
    // ------------------------
  }, { key: "_stopFloorAnim", value: function _stopFloorAnim()
    {
      if (this._floorAnim) {
        this._floorAnim.stop();
        this._floorAnim = null;
      }
    } }, { key: "_stopFadeAnim", value: function _stopFadeAnim()

    {
      if (this._fadeAnim) {
        this._fadeAnim.stop();
        this._fadeAnim = null;
      }
    } }, { key: "_skipFadeAnimations", value: function _skipFadeAnimations()

    {
      if (this._fadeAnim) {
        this._fadeAnim.skip();
        this._fadeAnim = null;
      }

      if (this._floorAnim) {
        this._floorAnim.skip();
        this._floorAnim = null;
      }
    } }, { key: "_leaveHoverMode", value: function _leaveHoverMode()

    {

      var fadeExt = this._getFadeExtension();
      if (!fadeExt) {
        // Nothing todo if ghosting effect is not used.
        return;
      }

      // release any baked images
      fadeExt.releaseFadingImage(0);
      fadeExt.releaseFadingImage(1);

      // make sure that model is rendered into default color target
      fadeExt.setModelTargetIndexForAll(undefined);

      // apply cutplanes according to currently selected floor
      this._applySelectedFloorSection();

      // we are now rendering real floors again,
      // so that we can switch SAO on again.
      this._setAOVisible(true);
    }

    // When rendering ghost-floors, the static part is always a static image.
    // Therefore, we have to skip the fading if the user moves the camera.
  }, { key: "_interruptFading", value: function _interruptFading() {

      // If we just left hover-mode, but the floors did not finish to fade out yet,
      // stop the anim and finish it immediately.
      if (!this._hovering && this._fadeAnim && this._fadeAnim.isRunning) {
        this._stopFadeAnim();
        this._leaveHoverMode();
      }
    } }, { key: "_onViewerResized", value: function _onViewerResized()

    {
      this.forceImageRefresh();
    } }, { key: "forceImageRefresh", value: function forceImageRefresh()

    {
      // Stop any image-based hovering effects immediately, because the baked ghost-floor image has incorrect size now.
      var isHovering = this._hovering;

      this.exitHoverMode();
      this._skipFadeAnimations();

      // Restart hovering effect if mouse is still on the panel. Now using the new render target size.
      if (isHovering) {
        this.enterHoverMode();
        this._skipFadeAnimations();
      }
    } }, { key: "_onRenderOptionsChanged", value: function _onRenderOptionsChanged()

    {
      // Make sure that we stop using roll-over-floor highlight if the depth
      // target is not available anymore.
      if (this._floorRollOverActive && !this._renderer.spatialFilterForRollOverSupported()) {
        this.rollOverFloor();
      }
    }

    // Get array of all visible models
  }, { key: "_getVisibleModels", value: function _getVisibleModels() {
      var mq = this._viewer.impl.modelQueue();
      return mq.getModels();
    }

    // Updates min/max limits for cutplane z-level, based on the bboxes of all visible models
  }, { key: "_updateZLimits", value: function _updateZLimits() {
      var models = this._getVisibleModels();

      this._zMinAllModels = MaxZLimit;
      this._zMaxAllModels = MinZLimit;
      for (var i = 0; i < models.length; i++) {
        var model = models[i];
        var box = model.getBoundingBox();

        this._zMinAllModels = Math.min(box.min.z, this._zMinAllModels);
        this._zMaxAllModels = Math.max(box.max.z, this._zMaxAllModels);
      }

      // make sure the range is valid also when no models are available
      if (this._zMinAllModels > this._zMaxAllModels) {
        this._zMinAllModels = MinZLimit;
        this._zMaxAllModels = MaxZLimit;
      }
    } }, { key: "_setAOVisible", value: function _setAOVisible(

    visible) {
      if (visible === this._aoVisible) {
        return;
      }
      this._aoVisible = visible;

      var blendPass = this._renderer.getBlendPass();

      var newOpacity = 0.0;
      if (!visible) {
        // ao switched off => backup original ao opacity
        this._aoOpacity = blendPass.uniforms['aoOpacity'].value;
      } else {

        // Opacity should be 0. Any other value indicates that it has been changed from
        // outside while ao was hidden by floor selector.
        var curOpacity = blendPass.uniforms['aoOpacity'].value;
        if (curOpacity !== 0.0) {
          console.warn('ao opacity should not be changed while FloorSelector is in use.');
        }

        // ao switched on => recover original ao opacity
        newOpacity = this._aoOpacity;
      }

      this._renderer.setAOOptions(this._renderer.getAORadius(), this._renderer.getAOIntensity(), newOpacity);
    }

    // @param {number} val - float in [0,1]
  }, { key: "_setGhostFloorOpactiy", value: function _setGhostFloorOpactiy(val) {

      // ghost-floors are always rendered into extra target 1
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.setCrossFadeOpacity(1, val);

      this._ghostFloorOpacity = val;

    }

    // Apply/Remove spatial filter that restricts rollOver highlighting to a single floor
    //  @param {number} If floorIndex is a valid index into this.floors, highlighting is restricted to that floor.
    //                  Otherwise, the spatial filter is switched off.
  }, { key: "_setSpatialFilterForRollOver", value: function _setSpatialFilterForRollOver(floorIndex) {

      var filter = undefined;
      var floor = this._floors[floorIndex];

      var createSpatialFilter = function createSpatialFilter(zMin, zMax) {
        // Define filter to restrict rollOver highlighting to floor elevation range
        return 'bool spatialFilter(vec3 worldPos) { return (worldPos.z >= float(' + zMin + ') && worldPos.z <= float(' + zMax + ')); }';
      };

      if (floor) {
        filter = createSpatialFilter(floor.zMin, floor.zMax);
      } else if (floorIndex === FloorSelector.AllFloors) {
        filter = createSpatialFilter(this._zMinAllModels, this._zMaxAllModels);
      }

      this._renderer.setSpatialFilterForRollOver(filter);

      // If spatial filter is defined, make sure that ghost floors are always rendered to depth target.
      // Otherwise, the spatial filter for roll-over highlighting does not work.
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.crossFade.setSaoHeuristicEnabled(!filter);

      this._floorRollOverActive = !!filter;
    } }, { key: "_applyFloorSection", value: function _applyFloorSection(

    zMin, zMax) {

      // Do not allow any cutplane when disabled
      if (!this.enabled) {
        this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
        return;
      }

      // reset the defined z values to the minimum in case the value is not specified
      if (!Number.isFinite(zMin)) {
        zMin = MinZLimit;
      }
      if (!Number.isFinite(zMax)) {
        zMax = MaxZLimit;
      }


      var planes = [new THREE.Vector4(0, 0, -1, zMin), new THREE.Vector4(0, 0, 1, -zMax)];
      this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // Set cut plane according to currently selected floor
  }, { key: "_applySelectedFloorSection", value: function _applySelectedFloorSection() {

      // If no floor section is active, set cutplanes to maximum range.
      // Doing this instead of clearing them avoids the repeated shader recompile
      var zMin = this._floorSectionMin !== undefined ? this._floorSectionMin : MinZLimit;
      var zMax = this._floorSectionMax !== undefined ? this._floorSectionMax : MaxZLimit;
      this._applyFloorSection(zMin, zMax);
    } }, { key: "_setFloorSection", value: function _setFloorSection(

    minElev, maxElev) {
      this._floorSectionMin = isNaN(minElev) ? undefined : minElev;
      this._floorSectionMax = isNaN(maxElev) ? undefined : maxElev;
      this._applySelectedFloorSection();
    }

    // Temporarily disable floor section cut planes. This is needed to render ghost floors.
  }, { key: "_clearFloorSection", value: function _clearFloorSection() {
      // Changing the number of cutplanes would cause a shader recompile.
      // To avoid that, we set dummy cutplanes instead.
      this._updateZLimits();
      this._applyFloorSection();
    } }, { key: "_setMode", value: function _setMode(

    mode) {var _this = this;

      if (mode === this._currentMode) {
        return;
      }
      this._currentMode = mode;

      if (mode === FloorRenderMode.Hovering) {

        var fadeExt = this._getFadeExtension();
        if (fadeExt) {

          // Take control over CrossFade effect.
          // NOTE: As long as the mouse is hovering over the LevelsPanel, we assume that no one else overtakes the crossFade effect. If the mouse leaves the LevelsPanel
          //       the ghost-floors a fading out. If the fading is needed for something else at that time, we skip the fading and drop the ghost floors immediately.
          fadeExt.acquireControl('FloorSelector', function () {return _this._interruptFading();});

          // Render snapshot of selected floors into target 0
          fadeExt.setModelTargetIndexForAll(undefined); // render to main target
          this._applySelectedFloorSection(); // set cutplanes according to selected floor
          this._renderer.rolloverObjectId(0); // keep mouse-over highlighting out of the snapshot
          this._setAOVisible(true); // Make sure that the selected floors are rendered with AO
          fadeExt.renderFadingImage(0, this.offscreenRenderBudget); // render static snapshot of selected floors into extra target 0

          // show this snapshot at full opacity
          fadeExt.setCrossFadeOpacity(0, 1.0);

          // Render remaining floors...
          this._clearFloorSection();

          // ..into target 1
          fadeExt.setModelTargetIndexForAll(1);

          // before starting to fade-in the ghost-floors,
          // hide SAO. Otherwise, SAO of the ghost
          // floors would pop in at fade start.
          this._setAOVisible(false);

          // stop any prior fade-anim
          this._stopFadeAnim();

          // fade-in ghost floors (starting at the prior opacity)
          var onTimer = this._setGhostFloorOpactiy.bind(this);
          this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, MaxGhostFloorOpacity, this.fadingTime, onTimer);
        }
      } else if (mode === FloorRenderMode.Transition) {

        // protect ghost floors from clear
        var _fadeExt = this._getFadeExtension();
        if (_fadeExt) {
          _fadeExt.setClearEnabled(1, false);

          // render into target 0 again
          _fadeExt.setClearEnabled(0, true);
          _fadeExt.setModelTargetIndexForAll(0);

          // make sure that target 0 has full opacity to make sure that floor keeps visible after moving to target 0
          _fadeExt.setCrossFadeOpacity(0, 1.0);
        }

        // reactivate AO
        this._setAOVisible(true);

        // Render selected/moving floor...
        this._applySelectedFloorSection();

      } else if (mode === FloorRenderMode.Off) {

        // stop any prior fade-anim
        this._stopFadeAnim();

        // fade-out ghost floors (starting at current opacity)
        var _onTimer = this._setGhostFloorOpactiy.bind(this);
        var onFinished = this._leaveHoverMode.bind(this);
        this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, 0.0, this.fadingTime, _onTimer, onFinished);
      }
    } }, { key: "_moveToFloor", value: function _moveToFloor(

    floorIndex) {var _this2 = this;

      this._currentFloor = floorIndex;

      this._setMode(FloorRenderMode.Transition);

      var floor = this._floors[floorIndex];

      this._updateZLimits();

      var minElevStart = this._floorSectionMin === undefined ? this._zMinAllModels : this._floorSectionMin;
      var maxElevStart = this._floorSectionMax === undefined ? this._zMaxAllModels : this._floorSectionMax;
      var minElevEnd = floor ? floor.zMin : this._zMinAllModels;
      var maxElevEnd = floor ? floor.zMax : this._zMaxAllModels;

      var updateCutPlanes = function updateCutPlanes(unitTime) {
        var t = avp.smootherStep(unitTime);
        var minElev = avp.lerp(minElevStart, minElevEnd, t);
        var maxElev = avp.lerp(maxElevStart, maxElevEnd, t);

        _this2._setFloorSection(minElev, maxElev);

        // fade-out mouse over while animating
        var blendPass = _this2._renderer.getBlendPass();
        var uniform = blendPass.uniforms['highlightIntensity'];
        uniform.value = Math.min(uniform.value, 1.0 - t);
      };

      var onAnimEnd = function onAnimEnd() {
        // leave transition mode to hovering or off
        var mode = _this2._hovering ? FloorRenderMode.Hovering : FloorRenderMode.Off;
        _this2._setMode(mode);
      };

      // If another floor anim is in running, stop it first.
      this._stopFloorAnim();

      this._floorAnim = avp.fadeValue(0.0, 1.0, this.fadingTime, updateCutPlanes, onAnimEnd);
    } }, { key: "_selectFloor", value: function _selectFloor(

    floorIndex) {

      // Make sure that a previous anim does not overwrite the cutplanes again.
      this._stopFloorAnim();

      this._currentFloor = floorIndex;

      // Note that zMin/zMax may also be undefined if no floor is selected
      var floor = this._floors[floorIndex];

      // Set min/maxElev from floor or set both to undefined (for 'no floor selected')
      var minElev = floor ? floor.zMin : undefined;
      var maxElev = floor ? floor.zMax : undefined;

      this._setFloorSection(minElev, maxElev);
    } }, { key: "_runFloorSelectorFilter", value: function _runFloorSelectorFilter()

    {
      // Make sure all previously hidden objects are set to visible again.
      this._floorSelectorFilter.clearFilter();

      if (this._floorFilterData && this._currentFloor !== undefined) {
        var floor = this._floors[this._currentFloor];
        this._floorSelectorFilter.filter(this._floorFilterData, floor);
      }
    } }, { key: "_runFloorSelectorFilterEventHandler", value: function _runFloorSelectorFilterEventHandler(

    event) {
      var model = event.model;

      if (!model.isObjectTreeLoaded()) {
        return;
      }
      if (!(this._floorFilterData && this._currentFloor !== undefined)) {
        // Handles the case when a level was deactivated while the model was not visible.
        // When activating again the model, we need to make sure that the previously
        // filtered elements are set to visible again.
        this._floorSelectorFilter.clearFilter();
        return;
      }
      this._runFloorSelectorFilter();
    } }, { key: "_runModelUnloadingEventHandler", value: function _runModelUnloadingEventHandler(

    event) {
      if (this._floorFilterData && this._currentFloor !== undefined) {
        this._floorSelectorFilter.unhideModel(event.model);
      }
    } }, { key: "floorData", get: function get() {return this._floors;}, set: function set(floors) {// always reset the floor selector when floors data changes to avoid inconstancy
      this.resetState();this._floors = Array.isArray(floors) ? floors : [];this.fireEvent({ type: FloorSelector.FLOOR_DATA_CHANGED, floorData: this._floors });} }, { key: "floorFilterData", get: function get() {return this._floorFilterData;}, set: function set(floorFilterData) {this._floorFilterData = floorFilterData;} }, { key: "currentFloor", get: function get() {return this._currentFloor;} }]);return FloorSelector;}();


FloorSelector.AllFloors = AllFloors;
FloorSelector.NoFloor = NoFloor;

FloorSelector.SELECTED_FLOOR_CHANGED = "selectedFloorChanged";
FloorSelector.FLOOR_DATA_CHANGED = "floorDataChanged";

namespace.FloorSelector = FloorSelector;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelectorFilter.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelectorFilter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelectorFilter; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var namespace = AutodeskNamespace('Autodesk.AEC');

// The FloorSelectorFilter provides functionality to additionally apply object filtering
// by dbIds on level selection.
//
var
FloorSelectorFilter = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelectorFilter(viewer) {_classCallCheck(this, FloorSelectorFilter);
    this._viewer = viewer;
    // Contains all dbIds per model used to un-hide the objects whenever another level gets selected.
    this._dbIdsToUnhide = new Map();
    this._cache = {};
  }

  // Filter all elements by dbIds on level selection.
  //  @param {Object}   floorFilterData   - A floor filter data object containing all dbIds per model and an optional level height factor.
  //  @param {Object}   floor             - A floor.
  _createClass(FloorSelectorFilter, [{ key: "filter", value: function filter(floorFilterData, floor) {var _this = this;
      if (!floorFilterData) {
        throw new Error('floorFilterData cannot be undefined.');
      }
      if (!(floorFilterData.modelsDbIds instanceof Map)) {
        throw new Error('floorFilterData.modelsDbIds has to be a Map.');
      }
      if (!floor) {
        throw new Error('floor cannot be undefined.');
      }

      // Get the level height factor and also do some basic number checks.
      var levelHeightFactor = this._getLevelHeightFactor(floorFilterData.levelHeightFactor);

      // All Floor and Ceiling db ids per model to hide.
      var modelsDbIds = floorFilterData.modelsDbIds;

      // Do nothing in case no db ids are set.
      if (!this._hasModelDbIds(modelsDbIds)) {
        return;
      }

      var minZ = floor.zMin;
      var maxZ = floor.zMax;

      // Calculate the new minZ/maxZ values of the level boundary used to spatially filter the Floor and
      // Ceiling elements.
      // 1. The lower boundary value (zMin) is moved up by the factor of the level height, because the Ceiling
      //    elements we want to filter are located in the upper part of the level.
      // 2. The upper boundary value (zMax) is moved up by 10% of the level height, because in some models
      //    this helps to also remove floors which would be still shown otherwise.
      var newMinZ = minZ + (maxZ - minZ) * levelHeightFactor;
      var newMaxZ = maxZ + (maxZ - minZ) * 0.1;

      // Setup cache for each floor.
      if (!this._cache[floor.name]) {
        this._cache[floor.name] = {};
      }

      var modelQueue = this._viewer.impl.modelQueue();
      var models = modelQueue.getModels();var _loop2 = function _loop2(

      m, l) {
        var model = models[m];

        if (!model.visibilityManager) {
          console.warn("The VisibilityManager of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "break";
        }

        // Try to get the db ids for a specific level and model from the cache.
        if (_this._cache[floor.name][model.id]) {
          var cachedDbIds = _this._cache[floor.name][model.id];
          if (cachedDbIds.size > 0) {
            _this.hideDbIds(model, cachedDbIds);
          }
          return "continue";
        }

        var instanceTree = model.getInstanceTree();
        if (!instanceTree) {
          console.warn("The instanceTree of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "continue";
        }

        var dbIdsToHide = new Set();
        var dbIds = modelsDbIds.get(model.id);
        if (!dbIds) {
          return "continue";
        }

        dbIds.forEach(function (dbId) {
          var nodeBox = new Float32Array(6);
          instanceTree.getNodeBox(dbId, nodeBox);

          var nodeBoxMinZ = nodeBox[2];
          var nodeBoxMaxZ = nodeBox[5];

          if (nodeBoxMinZ >= newMinZ && nodeBoxMinZ <= newMaxZ ||
          nodeBoxMaxZ >= newMinZ && nodeBoxMaxZ <= newMaxZ ||
          nodeBoxMinZ <= newMinZ && nodeBoxMaxZ >= newMaxZ) {
            dbIdsToHide.add(dbId);
          }
        });

        if (dbIdsToHide.size > 0) {
          _this.hideDbIds(model, dbIdsToHide);
        }

        _this._cache[floor.name][model.id] = dbIdsToHide;};_loop: for (var m = 0, l = models.length; m < l; m++) {var _ret = _loop2(m, l);switch (_ret) {case "break":break _loop;case "continue":continue;}
      }
    } }, { key: "hideDbIds", value: function hideDbIds(

    model, dbIds) {
      if (!model.visibilityManager) {
        return;
      }

      dbIds.forEach(function (id) {
        model.visibilityManager.setNodeOff(id, true);
      });

      // Collect all dbIds per model, so we can un-hide them later on again.
      if (this._dbIdsToUnhide.has(model)) {
        var _dbIds = this._dbIdsToUnhide.get(model);var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
          for (var _iterator = _dbIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var dbId = _step.value;
            _dbIds.add(dbId);
          }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return != null) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}
      } else {
        this._dbIdsToUnhide.set(model, dbIds);
      }
    }

    // Un-hides all objects (using the dbId) per model.
  }, { key: "clearFilter", value: function clearFilter() {
      if (this._dbIdsToUnhide.size === 0) {
        return;
      }

      this._dbIdsToUnhide.forEach(function (dbIds, model) {
        // Handles the case when the model is not visible and the level isolation is deactivated.
        if (!model.visibilityManager) {
          return;
        }

        dbIds.forEach(function (id) {
          model.visibilityManager.setNodeOff(id, false);
        });

        // Only remove the model dbIds if they are successfully set to visible.
        this._dbIdsToUnhide.delete(model);
      }.bind(this));
    }

    // Un-hides only one model. It's all we can do, as the model.visibilityManager is null,
    // that is we can not call setNodeOff function again
  }, { key: "unhideModel", value: function unhideModel(model) {
      this._dbIdsToUnhide.delete(model);
    } }, { key: "_hasModelDbIds", value: function _hasModelDbIds(

    modelsDbIds) {

      if (modelsDbIds.size === 0) {
        return false;
      }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {

        for (var _iterator2 = modelsDbIds.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var dbIds = _step2.value;
          if (dbIds && dbIds.length > 0) {
            return true;
          }
        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2.return != null) {_iterator2.return();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}

      return false;
    } }, { key: "_getLevelHeightFactor", value: function _getLevelHeightFactor(

    levelHeightFactor) {
      if (levelHeightFactor === undefined) {
        // Return default factor.
        return 0.5;
      }

      if (typeof levelHeightFactor !== 'number') {
        throw new Error('floorFilterData.levelHeightFactor has to be a number');
      }
      if (levelHeightFactor < 0 || levelHeightFactor >= 1) {
        throw new Error('floorFilterData.levelHeightFactor has to be a number between 0-1.');
      }

      return levelHeightFactor;
    }

    // Hides all dbIds in a model that are currently expected to be hidden. 
  }, { key: "reApplyFilter", value: function reApplyFilter(model) {
      var dbIds = this._dbIdsToUnhide.get(model);
      var visMan = model.visibilityManager;
      if (!dbIds || !visMan) {
        return;
      }

      dbIds.forEach(function (id) {
        visMan.setNodeOff(id, true);
      });
    } }, { key: "isVisible", value: function isVisible(

    model, dbId) {
      var dbIds = this._dbIdsToUnhide.get(model);
      return !dbIds || !dbIds.has(dbId);
    } }]);return FloorSelectorFilter;}();


namespace.FloorSelectorFilter = FloorSelectorFilter;

/***/ }),

/***/ "./extensions/AEC/levels/LevelUtils.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/levels/LevelUtils.js ***!
  \*********************************************/
/*! exports provided: transformLevelsByMatrix, transformLevels, modelToLevels, aecModelDataToLevels, chooseMainModel, modelDataOccluders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevelsByMatrix", function() { return transformLevelsByMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevels", function() { return transformLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelToLevels", function() { return modelToLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aecModelDataToLevels", function() { return aecModelDataToLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseMainModel", function() { return chooseMainModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelDataOccluders", function() { return modelDataOccluders; });

function getProjectElevation(level) {
  var ext = level.extension;

  if (ext && ext.hasOwnProperty('projectElevation'))
  return ext.projectElevation;

  return level.elevation;
}

function transformLevelsByMatrix(levels, refPointTransformation) {

  var v = new THREE.Vector3();
  var transformByMatrix = function transformByMatrix(value) {
    v.set(0, 0, value);
    v.applyMatrix4(refPointTransformation);
    return v.z;
  };

  levels.forEach(function (currentLevel) {
    currentLevel.zMin = transformByMatrix(currentLevel.zMin);
    currentLevel.zMax = transformByMatrix(currentLevel.zMax);
  });
}


// transform is given as 12 floats
function transformLevels(levels, refPointTransformation) {
  if (!refPointTransformation)
  return;

  // get transform as THREE.Matrix4
  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(refPointTransformation);
  transformLevelsByMatrix(levels, matrix);
}

function modelToLevels(model) {

  var bubbleNode = model.getDocumentNode();
  var modelData = bubbleNode.getAecModelData();

  if (!modelData || !modelData.levels || !modelData.levels.length) {
    return [];
  }

  return aecModelDataToLevels(modelData);
}

function aecModelDataToLevels(aecModelData, placementTf) {
  // levels are sorted ascending

  // we have to handle the building story flag of a Revit level
  // filter out all Revit levels which do not have building story set to true
  var filteredLevels = aecModelData.levels.filter(function (l) {
    var ext = l.extension;

    if (!ext)
    return true;

    //So.... if it has no buildingStory property, it's a building story...
    if (!ext.hasOwnProperty('buildingStory'))
    return true;

    return ext.buildingStory;
  });

  var levels = [];

  var count = filteredLevels.length;
  filteredLevels.forEach(function (currentLevel, index) {

    var nextElevation = undefined;
    if (index + 1 < count) {
      nextElevation = getProjectElevation(filteredLevels[index + 1]);
    } else
    {
      // for the topmost floor, we must use its height to determine the next boundary
      var topLevel = filteredLevels[filteredLevels.length - 1];
      var topLevelElevation = getProjectElevation(topLevel);
      nextElevation = topLevelElevation + topLevel.height;
    }

    //Explanation from design-collaboration repo:
    // Hint: the idea to move the level zMin value an inch down is to make sure that the
    // end-user can also see the bottom floor. Otherwise in some cases the floor would just
    // be cut-away by the floor selection. This value was defined after experimenting with
    // several models and maybe needs adjustment in the future.
    var zOffsetHack = 1 / 12;

    levels.push({
      index: levels.length,
      name: currentLevel.name,
      zMin: getProjectElevation(currentLevel) - zOffsetHack,
      zMax: nextElevation,
      guid: currentLevel.guid });

  });

  // If the model is known, use its attached transform. This variant works with any loadOptions. 
  if (placementTf) {
    transformLevelsByMatrix(levels, placementTf);
  } else {
    // If the model is not known, we assume that no zOffset is applied. This is only
    // true when using applyRefPoint=true and a gobalOffset with z=0.
    transformLevels(levels, aecModelData.refPointTransformation);
  }
  return levels;
}

function chooseMainModel(viewer) {

  var models = viewer.impl.modelQueue().getModels();
  var mainModel = null;
  var mainModelSize = -1;
  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();

    if (!bubbleNode)
    return;

    var aecModelData = bubbleNode.getAecModelData();

    if (!aecModelData)
    return;

    if (bubbleNode.data.size > mainModelSize) {
      mainModel = model;
      mainModelSize = bubbleNode.data.size;
    } else if (!bubbleNode.data.size && mainModelSize === -1) {
      mainModel = model;
      mainModelSize = 0;
    }
  });
  return mainModel;
}

function modelDataOccluders(viewer) {

  var models = viewer.impl.modelQueue().getModels();

  var occludersPerModel = new Map();

  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();
    if (!bubbleNode)
    return;
    var aecModelData = bubbleNode.getAecModelData();
    if (!aecModelData)
    return;

    occludersPerModel.set(model.id, aecModelData.levelOccluderIds);
  });

  return { modelsDbIds: occludersPerModel };
}

/***/ }),

/***/ "./extensions/AEC/levels/LevelsExtension.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/levels/LevelsExtension.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelsExtension; });
/* harmony import */ var _FloorSelector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelector */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony import */ var _LevelUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing,avu = av.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.LevelsExtension';





// Options:
//   @param {bool} [autoDetectAecModelData = true]
//         Level selection requires data about existing floors. By default (true), these are extracted automatically:
//          - For a single model, we get them by calling getAecModelData() on the document node.
//          - If multiple models with aecModelData are visible, we choose the largest one to define the levels.
//
//         If set to false, an application can (and has to) call setAecModelData() explicitly instead.
var LevelsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(LevelsExtension, _av$Extension);
  function LevelsExtension(viewer, options) {var _this;_classCallCheck(this, LevelsExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(LevelsExtension).call(this, viewer, options));

    _this.container = _this.options.panelUIContainers && _this.options.panelUIContainers.levelsPanel;

    _this._onCameraMoved = _this._onCameraMoved.bind(_assertThisInitialized(_this));
    _this.onItemMouseEnter = _this.onItemMouseEnter.bind(_assertThisInitialized(_this));
    _this.onItemMouseLeave = _this.onItemMouseLeave.bind(_assertThisInitialized(_this));
    _this.onItemSelected = _this.onItemSelected.bind(_assertThisInitialized(_this));

    _this._currentLevel = undefined;return _this;
  }_createClass(LevelsExtension, [{ key: "_onCameraMoved", value: function _onCameraMoved()

    {
      var currentLevel = this._mapCameraToLevel();

      if (!currentLevel)
      return;

      if (!this._currentLevel || currentLevel.guid !== this._currentLevel.guid) {
        this._currentLevel = currentLevel;
        this.viewer.dispatchEvent({ type: LevelsExtension.LEVEL_CHANGED, level: currentLevel });
      }
    } }, { key: "_mapCameraToLevel", value: function _mapCameraToLevel()

    {
      var floors = this.floorSelector.floorData;
      if (!floors.length) {
        return;
      }

      var currentElevation = this.viewer.impl.camera.position.z;

      if (currentElevation < floors[0].zMin) {
        return floors[0];
      } else
      if (currentElevation > floors[floors.length - 1].zMax) {
        return floors[floors.length - 1];
      } else
      {
        return floors.find(function (f) {return f.zMin <= currentElevation && f.zMax >= currentElevation;});
      }
    } }, { key: "onToolbarCreated", value: function onToolbarCreated()

    {

      if (this.container) {
        //Add our button to the toolbar if host app did not ask to render UI in some other place
        return;
      }

      // Add levelsButton to modelTools. 
      // We can safely assume toolbar to exis, because onToolbarCreated() is only called if 
      // 1. GuiViewer is used and 2. the toolbar is ready.
      var toolbar = this.viewer.getToolbar();
      var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
      if (modelTools) {
        modelTools.addControl(this.levelsButton);
      }
    } }, { key: "onItemMouseEnter", value: function onItemMouseEnter(_ref)

    {var item = _ref.item;
      var levelIndex = item.index;

      // Selecting an already selected level again will unselect => i.e. all Floors will be shown.
      // Correspondingly, we trigger rollover highlighting for all floors when hovering over the selected level.
      if (levelIndex === this.floorSelector.currentFloor) {
        levelIndex = _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].AllFloors;
      }

      this.floorSelector.rollOverFloor(levelIndex);
      this.hoveredFloor = levelIndex;
    } }, { key: "onItemMouseLeave", value: function onItemMouseLeave(_ref2)

    {var item = _ref2.item;
      if (this.hoveredFloor === item.index) {
        this.hoveredFloor = undefined;
        this.floorSelector.rollOverFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor);
      }
    } }, { key: "onItemSelected", value: function onItemSelected(_ref3)

    {var item = _ref3.item;
      // on item selected
      var levelIndex = item.index !== this.floorSelector.currentFloor ? item.index : undefined;
      this.floorSelector.selectFloor(levelIndex, true);
    } }, { key: "_createUI", value: function _createUI()

    {var _this2 = this;

      this.levelsButton = new avu.Button("toolbar-levelsTool");
      this.levelsButton.setToolTip('Levels');
      this.levelsButton.icon.innerHTML = createLevelsIcon();

      this.levelsPanel = new _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanel"](this.container || this.viewer.container, 'LevelsPanel-' + this.viewer.id, 'Levels');
      this.levelsPanel.setGlobalManager(this.globalManager);

      if (!this.container) {
        // This ensures that the Panel keeps visible within the viewer canvas on resize.
        this.viewer.addPanel && this.viewer.addPanel(this.levelsPanel);
      }


      // Keep button-state consistent when pressing panel close
      this.levelsPanel.addVisibilityListener(function (visible) {
        _this2.levelsButton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
      });

      // allow client app to be notified on panel close
      this.levelsPanel.closer.addEventListener('click', function () {
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(false);
        }
      });

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_ENTER, this.onItemMouseEnter);

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_LEAVE, this.onItemMouseLeave);

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_SELECT, this.onItemSelected);

      // Handle hovering over panel
      this.levelsPanel.container.addEventListener("mouseenter", function () {return _this2.floorSelector.enterHoverMode();});
      this.levelsPanel.container.addEventListener("mouseleave", function () {return _this2.floorSelector.exitHoverMode();});

      // Keep selected item in-sync with selected Floor
      this.floorSelector.addEventListener(
      _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].SELECTED_FLOOR_CHANGED,
      function () {return _this2.levelsPanel.updateItemStates();});


      this.levelsPanel.setItemHandlers(
      function (item) {return item.index === _this2.floorSelector.currentFloor;},
      function (item) {return item.text;});


      // Connect levelsButton
      this.levelsButton.onClick = function () {
        var visible = !_this2.levelsPanel.isVisible();
        _this2.levelsPanel.setVisible(visible);

        // allow client app to be notified
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(visible);
        }
      };
    }

    // If placementTf is undefined, we use the refPointTransform of aecModelData.
    // Note that this is correct when using applyRefPoint=true and a globalOffset with z=0
    // for the model load options.
  }, { key: "setAecModelData", value: function setAecModelData(aecModelData, placementTf) {

      if (aecModelData !== this.aecModelData) {

        this.aecModelData = aecModelData;

        if (aecModelData) {
          // init level data
          this.floorSelector.floorData = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["aecModelDataToLevels"])(aecModelData, placementTf);
        } else {
          this.floorSelector.floorData = [];
        }

        var levels = this.floorSelector.floorData;
        var items = [];
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          items.push({
            text: level.name,
            index: i });

        }

        // list items in reverse order, because aecModelData levels are sorted by increasing z
        items.reverse();
        this.levelsPanel.setItems(items);

        this._updateOccluderData();
      }
    } }, { key: "_updateOccluderData", value: function _updateOccluderData()

    {
      // Make sure that occluder data is known if a main model is specified
      var occludersPerModel = this.aecModelData ? Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["modelDataOccluders"])(this.viewer) : undefined;
      this.floorSelector.floorFilterData = occludersPerModel;
    } }, { key: "load", value: function load()

    {var _this3 = this;
      this.floorSelector = new _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer);

      this.updateFloorSelector = function () {
        if (!_this3.floorSelector) {
          return;
        }

        // auto-detect main model if not disabled
        var autoDetect = _this3.options.autoDetectAecModelData !== false;
        if (autoDetect) {
          var model = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["chooseMainModel"])(_this3.viewer);
          var bubbleNode = model && model.getDocumentNode();
          var aecModelData = bubbleNode && bubbleNode.getAecModelData();

          // provde placement matrix as well.
          var placementTf = model && model.myData.placementWithOffset;
          _this3.setAecModelData(aecModelData, placementTf);
        }

        _this3._updateOccluderData();

        // Make sure that cutplanes are disabled when in 2d views and reactivated in 3d
        // Todo: Check if we can move the MODEL_ADDED event at the end of addModel, so that we could simply use viewer.is2d here.
        var is3d = _this3.viewer.getVisibleModels().some(function (model) {return model.is3d();});
        _this3.floorSelector.setEnabled(is3d);
      };

      this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
      this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);
      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);

      this._createUI();
      this.updateFloorSelector();

      return true;
    } }, { key: "unload", value: function unload()

    {
      if (!this.container) {
        this.viewer.removePanel && this.viewer.removePanel(this.levelsPanel);
      }
      this.floorSelector.selectFloor(undefined, false);
      this.levelsPanel = null;

      if (this.updateFloorSelector) {
        this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);
        this.updateFloorSelector = null;
      }

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
      this._currentLevel = null;

      this.floorSelector = null;

      return true;
    }

    /**
       * Gets the extension state as a plain object. Invoked automatically by viewer.getState()
       * @param {object} viewerState - Object to inject extension values.
       */ }, { key: "getState", value: function getState(
    viewerState) {
      if (!this.viewer.model || this.viewer.model.is2d()) {
        return;
      }

      var floor = this.floorSelector.currentFloor;
      viewerState.floorGuid = floor ? this.floorSelector.floorData[floor].guid : null;
    } }, { key: "restoreState",

    /**
                                 * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()
                                 * @param {object} viewerState - Viewer state.
                                 * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).
                                 * @returns {boolean} True if restore operation was successful.
                                 */value: function restoreState(
    viewerState, immediate) {
      // If floorGuid is undefined we should keep the extension as it is. (unlike null which means 'no levels') 
      if (viewerState.floorGuid === undefined) {
        return;
      }
      if (viewerState.floorGuid) {
        var floor = this.floorSelector.floorData.find(function (data) {return data.guid === viewerState.floorGuid;});

        if (floor) {
          this.floorSelector.selectFloor(floor.index, false);
        }
      } else {
        this.floorSelector.selectFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor, false);
      }

      return true;
    } }, { key: "getCurrentLevel",

    // Returns a floor object {index, name}
    value: function getCurrentLevel() {
      // If a level is selected, use that one and ignore camera z
      var fs = this.floorSelector;
      var level = fs.floorData[fs.currentFloor];
      if (level) {
        return level;
      }

      // No floor selected => determine based on camera z
      return this._mapCameraToLevel();
    }

    // index must be a valid FloorIndex
  }, { key: "getZRange", value: function getZRange(index) {
      var floor = this.floorSelector && this.floorSelector.floorData[index];

      // Cut everything above zMid of current floor
      var zMax = floor.zMin + 0.5 * (floor.zMax - floor.zMin);

      // Cut everything below zMid of the floor below
      // (Cutting below zMin keeps stairs to lower floors visible)
      var floorBelow = this.floorSelector.floorData[index - 1];
      var zMin = floorBelow ? 0.5 * (floorBelow.zMin + floorBelow.zMax) : floor.zMin;

      return { zMin: zMin, zMax: zMax };
    } }]);return LevelsExtension;}(av.Extension);


var createLevelsIcon = function createLevelsIcon() {
  return [
  '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
  '<g stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">',
  '<path d="M4 8 L12 3 L 20 8 L12 13Z"/>',
  '<path d="M4 12 L12 17 L 20 12"/>',
  '<path d="M4 16 L12 21 L 20 16"/>',
  '</g>',
  '</svg>'].
  join('');
};

namespace.LevelsExtension = LevelsExtension; // Makes it easier to get e.g. the version

LevelsExtension.LEVEL_CHANGED = "levelChanged";

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, LevelsExtension);

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.css":
/*!*****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.js":
/*!****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.js ***!
  \****************************************/
/*! exports provided: ListPanelEvents, ListPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return ListPanelEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return ListPanel; });

var av = Autodesk.Viewing;
var avu = Autodesk.Viewing.UI;


var ListPanelEvents = {

  /**
                                * Fired when clicking on an item. (not fired when setting current item per code)
                                *  @property {Object} item  - data item being selected.
                                */
  ITEM_SELECT: 'itemSelect',

  /**
                              * @property {Object} item - data item being selected.
                              */
  ITEM_MOUSE_ENTER: 'itemMouseEnter',
  ITEM_MOUSE_LEAVE: 'itemMouseLeave' };


function ListPanel(parentContainer, id, title, options) {

  avu.DockingPanel.call(this, parentContainer, id, title, options);

  av.EventDispatcher.prototype.apply(this);

  this.container.classList.add('list-panel');
  this.container.dockRight = true;
  this.createScrollContainer({ left: false, heightAdjustment: 65, marginTop: 0 });
}

ListPanel.prototype = Object.create(avu.DockingPanel.prototype);

// @param {Object[]} items - Array order defines display order top-down.
ListPanel.prototype.setItems = function (items) {

  this.buttons = [];
  this.items = items;

  // remove old list
  if (this.listDiv) {
    this.scrollContainer.removeChild(this.listDiv);
  }
  var _document = this.getDocument();
  this.listDiv = _document.createElement('div');
  this.listDiv.classList.add('itemList');

  this.scrollContainer.appendChild(this.listDiv);

  var scope = this;

  var createButton = function createButton(item) {

    var itemText = scope._getItemText ? scope._getItemText(item) : '<no item text>';

    var button = _document.createElement('div');
    button.classList.add('listItem');
    button.item = item;
    button.setAttribute('title', itemText);

    button.addEventListener('click', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_SELECT,
        item: item });

    });
    button.addEventListener('mouseenter', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_ENTER,
        item: item });

    });
    button.addEventListener('mouseleave', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_LEAVE,
        item: item });

    });

    var textSpan = _document.createElement('span');
    textSpan.innerHTML = itemText;
    textSpan.classList.add("text");

    // This container DIV is required to enable proper text fade-out for long texts.
    var textContainerDiv = _document.createElement('div');
    textContainerDiv.classList.add("textContainer");
    textContainerDiv.appendChild(textSpan);
    button.appendChild(textContainerDiv);

    var warnSpan = _document.createElement('span');
    warnSpan.classList.add("list-panel-item-warning");
    button.appendChild(warnSpan);
    button.warnSpan = warnSpan;

    var checkSpan = _document.createElement('span');
    checkSpan.classList.add("icon");
    button.appendChild(checkSpan);

    return button;
  };

  for (var index = 0; index < items.length; index++) {

    var item = items[index];
    var button = createButton(item);

    this.listDiv.appendChild(button);
    this.buttons.push(button);
  }

  this.updateItemStates();
};

ListPanel.prototype.updateItemStates = function () {

  if (!this.buttons) {
    return;
  }
  for (var i = 0; i < this.buttons.length; i++) {

    // set/unset checkmark
    var button = this.buttons[i];
    button.classList.remove("selected");
    if (this._isSelected && this._isSelected(button.item)) {
      button.classList.add("selected");
    }

    // set/unset warning symbol
    var warnText = this._getWarningText && this._getWarningText(button.item);
    button.warnSpan.style.visibility = warnText ? 'visible' : 'hidden';
    button.warnSpan.setAttribute('title', warnText || '');
  }
};

// Set functions to define how to handle each item
//  @param {function(item)} isSelected       - takes a list item (see setItems) and returns true for 'selected state'
//  @param {function(item)} getItemText      - returns the text to be displayed
//  @param {function(item)} [getWarningText] - Optional: Display a warning symbol. Function defines tooltip text.
ListPanel.prototype.setItemHandlers = function (isSelected, getItemText, getWarningText) {
  this._isSelected = isSelected;
  this._getItemText = getItemText;
  this._getWarningText = getWarningText;
  this.updateItemStates();
};

avu.ListPanelEvents = ListPanelEvents;
avu.ListPanel = ListPanel;

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, PolyBase, Polygon, Polyline, EdgeType, EllipseArcParams, Path, PolygonPath, PolylinePath, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeType", function() { return EdgeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcParams", function() { return EllipseArcParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonPath", function() { return PolygonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylinePath", function() { return PolylinePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var nextShapeId = 1;

var av = Autodesk.Viewing;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

var tmpVec3 = new THREE.Vector3();
var tmpVec3_2 = new THREE.Vector3();
var tmpBox2 = new THREE.Box2();

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,128)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,128)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Add all points to given bbox.
var addPointsToBBox = function addPointsToBBox(points, dstBox) {
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function () {
  function Shape() {var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    this.style = style;

    // assign unique id
    this.id = nextShapeId++;

    this.bbox = new THREE.Box2();
    this.bboxDirty = true;

    // Should be set by creator by something more descriptive.
    this.name = this.id.toString();
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.
  }, { key: "move", value: function move()
    /*dx, dy*/{return this;}

    // Apply a transform to each point. (assuming z=0)
    // @param {Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    }

    // Return bbox while making sure that it's up-to-date.
  }, { key: "getBBox", value: function getBBox() {
      this.updateBBox();
      return this.bbox;
    }

    // @param {string}  svg - e.g. '<path d="M 13,4 L 14,4"/>'
    // @param {Object}  [options]
    // @param {boolean} [options.forcePaths] - By default, paths without arcs are interpreted as Polygon resp. Polyline.
    //                                         This option ensures that the result is always a Path. This is important
    //                                         if you want to allow converting it into a path later.
  }, { key: "toSVG",



    // Convert to SVG style string, e.g., '<path d="M 13,4 L 14,4"/>'
    // See Svg.toSvg() comment for options.
    //
    // Note: The digits param is deprecated and only exists for legacy reasons. 
    //       Set digits via options.digits instead.
    value: function toSVG(options, digits) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvg(this, options, digits);
    }

    // Converts shape into a DOM element (usually a <path>).
    //  @param {Object} 
    //  @param {bool}   [options.exportStyle=true]
  }, { key: "createSvgShape", value: function createSvgShape(options) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvgElement(this, options);
    } }], [{ key: "fromSVG", value: function fromSVG(svg, options) {return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].fromSvg(svg, options);} }]);return Shape;}();


av.GlobalManagerMixin.call(Shape.prototype);

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);

  function PolyBase() {var _this;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolyBase).call(this, style));

    // Array of Array of points, each represented as an object {x, y}
    // By default, we start with a single loop/chain
    _this.loops = points ? [points] : [];

    // Set by derived classes
    _this.isClosed = undefined;return _this;
  }

  // For backward compatibility
  _createClass(PolyBase, [{ key: "getLoopCount", value: function getLoopCount()




    {
      return this.loops.length;
    } }, { key: "loopCount", value: function loopCount()

    {
      return this.loops.length;
    } }, { key: "isPolygon", value: function isPolygon()

    {return this.isClosed;} }, { key: "isPolyline", value: function isPolyline()
    {return !this.isClosed;} }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // get or create loop
      var loop = this.loops[loopIndex] || (this.loops[loopIndex] = []);

      // add point to loop
      var point = { x: x, y: y };
      loop.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      target = target || new THREE.Vector2();
      return target.copy(this.loops[loopIndex][index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.loops[loopIndex].splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var p = this.loops[loopIndex][index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.loops[loopIndex].splice(index, 0, p);
    } }, { key: "getVertexCount",











    // Returns 0 if a loop is empty or does not exist.
    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // Array may not exist yet if no vertices were added to the loop yet.
      var loop = this.loops[loopIndex];
      return loop ? loop.length : 0;
    }

    // Reset back to a single empty loop
  }, { key: "clear", value: function clear() {
      this.loops = [];
      this.modified();
    }

    // Enumerate all edges (a,b).
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {

      // get edge count
      var edgeCount = this.getEdgeCount();

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = this.nextIndex(i);

        // get points
        var a = this.getPoint(ai);
        var b = this.getPoint(bi);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb);
      return edgeIndex;
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];
        for (var i = 0; i < points.length; i++) {
          points[i].x += dx;
          points[i].y += dy;
        }
      }
      this.modified();
      return this;
    }

    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)
    // @param {THREE.Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          // set target to (x,y) * matrix
          var transformPoint = function transformPoint(x, y, target) {
            // convert to vec3, transform, and write back to target
            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);
            target.x = vec3.x;
            target.y = vec3.y;
            return target;
          };

          transformPoint(p.x, p.y, p);

          // transform Bezier control points
          if (this.isBezierArc(i, l)) {
            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);
            p.cp1x = cp.x;
            p.cp1y = cp.y;

            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);
            p.cp2x = cp.x;
            p.cp2y = cp.y;
          }

          // Transform ellipse arcs
          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)
          if (this.isEllipseArc(i, l)) {
            p.ellipseArcParams.applyMatrix4(matrix);
          }
        }
      }
      this.modified();
      return this;
    }

    // Copy a single loop from src poly and adds it to this one
    //  @param {PolyBase} srcPoly
    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src
  }, { key: "addLoop", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // copy loop points
      var srcLoop = srcPoly.loops[srcLoopIndex];
      var newLoop = cloneVectorArray(srcLoop);

      // get free loop index to store the new one
      var dstLoopIndex = this.nextFreeLoop();
      this.loops[dstLoopIndex] = newLoop;
      this.modified();

      return dstLoopIndex;
    } }, { key: "copy", value: function copy(

    srcPoly) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, srcPoly);

      this.isClosed = srcPoly.isClosed;

      // copy loops
      this.loops = [];
      for (var i = 0; i < srcPoly.getLoopCount(); i++) {
        this.addLoop(srcPoly, i);
      }
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.makeEmpty();
      for (var i = 0; i < this.loops.length; i++) {
        var loop = this.loops[i];
        if (loop) {
          addPointsToBBox(loop, this.bbox);
        }
      }
      return this.bbox;
    } }, { key: "indexValid", value: function indexValid(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return index >= 0 && index < this.getVertexCount(loopIndex);
    }

    // Returns -1 if there is no next Index    
  }, { key: "nextIndex", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle last vertex
      var isLast = index === this.getVertexCount(loopIndex) - 1;
      if (isLast) {
        // If closed, restart. Otherwise, there is no next index.
        return this.isClosed ? 0 : -1;
      }

      return index + 1;
    }

    // Returns -1 if there is no previous vertex index
  }, { key: "prevIndex", value: function prevIndex(index) {
      // Return -1 for invalid input
      if (!this.indexValid(index)) {
        return -1;
      }

      // Handle first vertex
      if (index === 0) {
        // if closed, continue at end. Otherwise, there is no previous index.
        return this.isClosed ? this.vertexCount - 1 : -1;
      }

      return index - 1;
    }

    // Returns index of the edge ending at the given vertex or -1 if it does not exist.
  }, { key: "edgeBeforeVertex", value: function edgeBeforeVertex(index) {
      return this.prevIndex(index);
    }

    // Returns index of the edge starting at the given vertex.
    // Returns -1 if index is the end vertex of a polyline.
  }, { key: "edgeAfterVertex", value: function edgeAfterVertex(index) {
      return this.edgeIndexValid(index) ? index : -1;
    }

    // Returns -1 if there is no previous edge.
  }, { key: "nextEdgeIndex", value: function nextEdgeIndex(edgeIndex) {
      // Check edgeIndex validity
      if (!this.edgeIndexValid(edgeIndex)) {
        return -1;
      }

      // Return -1 for last polyline edge
      if (!this.isClosed && edgeIndex === this.getEdgeCount() - 1) {
        return -1;
      }

      return this.nextIndex(edgeIndex);
    } }, { key: "prevEdgeIndex", value: function prevEdgeIndex(

    edgeIndex) {
      // Check edgeindex validity
      if (!this.edgeIndexValid(edgeIndex)) {
        return -1;
      }

      // Return -1 for first polyline edge
      if (!this.isClosed && edgeIndex === 0) {
        return -1;
      }

      return this.prevIndex(edgeIndex);
    } }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var edgeCount = this.getEdgeCount(loopIndex);
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    } }, { key: "prevEdgeExists", value: function prevEdgeExists(

    edgeIndex) {
      return this.edgeIndexValid(edgeIndex) && this.vertexCount > 2 && (edgeIndex > 0 || this.isClosed);
    } }, { key: "nextEdgeExists", value: function nextEdgeExists(

    index) {
      var isLastEdge = edgeIndex === this.vertexCount - 2;
      return this.edgeIndexValid(edgeIndex) && this.vertexCount > 2 && (!isLastEdge || this.isClosed);
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      this.getPoint(ia, outA);
      this.getPoint(ib, outB);
    } }, { key: "getEdgeDirection", value: function getEdgeDirection(

    edgeIndex, target) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      target = target || new THREE.Vector2();
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(this.points[ia], this.points[ib], target);
    } }, { key: "getEdgeLength", value: function getEdgeLength(

    edgeIndex) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      var a = this.points[ia];
      var b = this.points[ib];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.isClosed ? vertexCount : vertexCount - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    //
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(); i++) {
        this.getEdge(i, a, b);

        // apply optional measure transform
        if (measureTransform) {
          measureTransform.apply(a);
          measureTransform.apply(b);
        }

        sum += a.distanceTo(b);
      }
      return sum;
    }

    // Set vertices from THREE.Box2
  }, { key: "fromBox2", value: function fromBox2(box) {
      this.addPoint(box.min.x, box.min.y);
      this.addPoint(box.max.x, box.min.y);
      this.addPoint(box.max.x, box.max.y);
      this.addPoint(box.min.x, box.max.y);
      return this;
    }

    // Returns a point along an edge. Note that the edge may be an arc for Paths.
    //  @param {number} edgeIndex - A valid edgeIndex
    //  @param {number} t         - in [0,1]. t=0: startPoint, t=1: endPoint
    //  @param {Vector2} optionalTarget
  }, { key: "getPointOnEdge", value: function getPointOnEdge(edgeIndex, t, optionalTarget) {
      var target = optionalTarget || new THREE.Vector2();
      var p0 = this.points[edgeIndex];
      var p1 = this.points[this.nextIndex(edgeIndex)];
      return target.lerpVectors(p0, p1, t);
    }

    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, 
    // we assume an additional edge from end to start.
    // @returns {bool}
  }, { key: "isCCW", value: function isCCW() {
      return Autodesk.Extensions.CompGeom.polygonArea(this.points) > 0;
    }

    // Return 2D edge normal
  }, { key: "getLeftEdgeNormal", value: function getLeftEdgeNormal(edgeIndex, target) {
      target = target || new THREE.Vector2();

      // get start/end point of the edge
      var vi1 = edgeIndex;
      var vi2 = (edgeIndex + 1) % this.vertexCount;
      var v1 = this.points[vi1];
      var v2 = this.points[vi2];

      // get edge direction
      target.subVectors(v2, v1).normalize();

      // rotate by 90 degrees
      var tmp = target.x;
      target.x = -target.y;
      target.y = tmp;

      return target;
    }

    // Get edge normal facing outside wrt. to the outer loop. If the contour is not closed, we
    // assume an additional connection between endpoint and startpoint to defined "outside".
  }, { key: "getOuterNormal", value: function getOuterNormal(edgeIndex, target) {
      var normal = this.getLeftEdgeNormal(edgeIndex, target);
      return this.isCCW() ? normal.multiplyScalar(-1) : normal;
    }

    // Returns the first loopIndex >=0 that doesn't contain any points yet.
    //  @param {number}
  }, { key: "nextFreeLoop", value: function nextFreeLoop() {
      var isFree = function isFree(l) {return !l || !l.length;};
      var index = this.loops.findIndex(isFree);
      return index >= 0 ? index : this.loops.length;
    } }, { key: "points", get: function get() {// Create empty loop 0 if needed
      return this.loops[0] || (this.loops[0] = []);} }, { key: "length", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility
  }, { key: "vertexCount", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);
var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);

  function Polygon() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, points, style));
    _this2.isClosed = true;return _this2;
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it
    // is enclosed by an odd number of loops.
  }, { key: "hitTest", value: function hitTest(x, y) {
      if (!this.vertexCount) {
        return false;
      }

      // Compute number of loops that enclose (x,y)
      var rank = 0;
      for (var l = 0; l < this.loops.length; l++) {
        var loop = this.loops[l];
        if (!loop) {
          continue;
        }

        // set current loop as points
        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);

        // create dummy contour
        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
        var contour = [];
        for (var i = 0; i < loop.length; i++) {
          contour.push(i);
        }

        if (cp.pointInContour(x, y, contour)) {
          rank++;
        }
      }

      // Apply even-odd-rule
      return Boolean(rank & 1);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (this.points.length < 3) {
        return 0.0;
      }

      var area = 0.0;
      this.enumEdges(function (a, b) {
        // apply optional transform
        measureTransform && measureTransform.apply(a);
        measureTransform && measureTransform.apply(b);

        // sum up signed areas
        area += a.x * b.y - b.x * a.y;
      });

      return Math.abs(0.5 * area);
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);

  function Polyline() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, points, style));
    _this3.isClosed = false;return _this3;
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.vertexCount !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var EdgeType = {
  Line: 0, // Simple line segment
  Bezier: 1, // Cubic Bezier Arc
  Ellipse: 2 // Ellipse Arc
};


// Tmp objct for Ellipse Arcs. We need delayed initialization, 
// because Autodesk.Extensions.CompGeom might not be available yet at compile time.
var _tmpArc = null;
var getTmpArc = function getTmpArc() {
  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();
  return _tmpArc;
};

var tmpVec = new THREE.Vector2();

// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
//  @param {number}                         loopIndex - must be a valid loop index in path
var runLoop = function runLoop(ctx, path, loopIndex) {

  var points = path.loops[loopIndex];
  if (!points || !points.length) {
    return;
  }

  ctx.moveTo(points[0].x, points[0].y);

  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {
    switch (pStart.arcType) {
      case EdgeType.Line:break;

      case EdgeType.Bezier:{
          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);
          return;
        }

      case EdgeType.Ellipse:{
          var params = pStart.ellipseArcParams;
          var arc = path.exportEllipseArc(edgeIndex, getTmpArc(), loopIndex);

          // ignore arcs with NaN values
          if (!arc.isValid()) {
            break;
          }

          if (ctx.ellipseArcTo) {
            // Support SolidDef Path2D
            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);
          } else {
            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.
            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);
          }

          return;
        }}

    ctx.lineTo(pEnd.x, pEnd.y);
  };

  for (var i = 1; i < points.length; i += 1) {
    // The segment start point defines the type (line or arc)
    var prev = points[i - 1];
    var p = points[i];

    processSegment(prev, p, i - 1);
  }

  if (path.isClosed) {
    // add closing segment
    var pLast = points[points.length - 1];
    var pFirst = points[0];
    processSegment(pLast, pFirst, points.length - 1);

    ctx.closePath();
  }
};

// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
var runPath = function runPath(ctx, path) {
  for (var i = 0; i < path.loopCount(); i++) {
    runLoop(ctx, path, i);
  }
};

// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon
//  @param {LmvCanvasContext}      ctx
//  @param {Polyline|Polygon|Path} path
//  @param {Style}                 [overrideStyle]
var drawPath = function drawPath(ctx, path, overrideStyle) {

  if (!path.vertexCount) {
    return;
  }

  var style = overrideStyle || path.style;

  ctx.dbId = path.id;
  ctx.lineStyle = style.lineStyle;
  ctx.isScreenSpace = style.isScreenSpace;

  ctx.beginPath();

  // Run moveTo/lineTo/... commands on context
  runPath(ctx, path);

  var c = ctx.canvasContext;

  // Draw fill for closed paths
  if (path.isClosed) {

    c.fillStyle = style.fillColor;
    c.globalAlpha = style.fillAlpha;

    ctx.fill();
  }

  // draw lines
  c.strokeStyle = style.lineColor;
  c.globalAlpha = style.lineAlpha;
  c.lineWidth = style.lineWidth;

  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
  // For human eyes the line width is then the same width.
  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

  ctx.stroke();

  // restore default values
  ctx.dbId = -1;
  ctx.lineStyle = 0;
  ctx.isScreenSpace = false;
};

// SVG compatible ellipse arc params
// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
var EllipseArcParams = /*#__PURE__*/function () {

  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);
    // {number} Radius along x-axis
    this.rx = 0;

    // {number} Radius along y-axis
    this.ry = 0;

    // {number} ccw rotation of x/y-axes in degrees
    this.rotation = 0;

    // {bool} whether to use shorter or longer path around ellipse.
    this.largeArcFlag = false;

    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.
    this.sweepFlag = false;
  }_createClass(EllipseArcParams, [{ key: "copy", value: function copy(

    src) {
      this.rx = src.rx;
      this.ry = src.ry;
      this.rotation = src.rotation;
      this.largeArcFlag = src.largeArcFlag;
      this.sweepFlag = src.sweepFlag;
      return this;
    } }, { key: "clone", value: function clone()
    {
      return new EllipseArcParams().copy(this);
    }

    // @param {number} angle - counterclockwise in degrees
  }, { key: "rotate", value: function rotate(angle) {

      this.rotation += angle;

      // Normalize angle to keep within [0,360]
      this.rotation -= Math.trunc(this.rotation / 360) * 360;
    } }, { key: "scale", value: function scale(

    factor) {
      this.rx *= factor;
      this.ry *= factor;
    }

    // updates arc params according to a given transform.
    // Note: Transforming ellipse arcs is currently only supported for 
    //       simple transforms like translation, rotation, and uniform scaling.
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      // apply transform to x-axis direction
      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);
      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);
      var axis = tmpVec3.sub(tmpVec3_2);

      // obtain rotation angle and scale (assuming uniform scaling)
      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));
      var scale = axis.length();

      // update ellipse params
      this.rotate(rotAngle);
      this.scale(scale);

      // If a transform changes the orientation, we have to invert sweepFlag and rotation param
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].changesOrientation(matrix)) {
        this.sweepFlag = !this.sweepFlag;
        this.rotation = 360.0 - this.rotation;
      }
    } }]);return EllipseArcParams;}();


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);

  function Path(points) {var _this4;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, points, style));

    // If true, the path is automatically closed and can be filled.
    _this4.isClosed = isClosed;return _this4;
  }

  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   
  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.
  // @param {Vector2} newA, newB - edge vertices after modification
  _createClass(Path, [{ key: "_updateEllipseArcParams", value: function _updateEllipseArcParams(edgeIndex, newA, newB) {

      var params = this.points[edgeIndex].ellipseArcParams;

      // compute angle by which the edge was rotated
      var oldDir = this.getEdgeDirection(edgeIndex);
      var newDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(newA, newB);
      var dAngle = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].angleBetweenDirections(newDir, oldDir);

      params.rotate(THREE.Math.radToDeg(dAngle));

      // get scale factor applied to the edge
      var oldLength = this.getEdgeLength(edgeIndex);
      var newLength = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].distance2D(newA, newB); // also works for simple {x,y} pairs
      var scale = newLength / oldLength;

      // scale ellipse radii (if scaling is valid)
      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work
      if (scaleValid) {
        params.scale(scale);
      }
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {

      var p = this.points[index];

      var pNew = tmpVec.set(x, y);

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Update ellipse arc starting at p
      if (this.isEllipseArc(index)) {
        // next point must exist if index is a valid ellipse-arc edge.
        var pNext = this.points[this.nextIndex(index)];
        this._updateEllipseArcParams(index, pNew, pNext);
      }

      // Update arc params of segment ending at p
      // Note: For polylines, this edge does not exist for index==0
      var prevEdge = this.edgeBeforeVertex(index);
      if (this.edgeIndexValid(prevEdge)) {

        // get previous vertex
        var pPrev = this.points[prevEdge];

        // Update bezier control point
        if (this.isBezierArc(prevEdge)) {
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }

        // Update ellipse arc
        if (this.isEllipseArc(prevEdge)) {
          this._updateEllipseArcParams(prevEdge, pPrev, pNew);
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "getEdgeType", value: function getEdgeType(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = this.loops[loopIndex][segmentIndex].arcType;
      return type ? type : EdgeType.Line;
    }

    // Change segment into a cubic Bezier arc.
    // First and last control point are already given by the vertex positions.
    //
    //  @param {number} segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {number} cp1x, cp1y - Control point for start tangent
    //  @param {number} cp2x, cp2y - Control point for end tangent
    //  @param 
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y) {var loopIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

      var p = this.loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Bezier;
      p.cp1x = cp1x;
      p.cp1y = cp1y;
      p.cp2x = cp2x;
      p.cp2y = cp2y;

      this.modified();
    }

    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.
    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
    //
    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {EllipseArcParams} arcParams 
  }, { key: "setEllipseArc", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var p = this.loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Ellipse;
      p.ellipseArcParams = arcParams.clone();

      this.modified();
    }

    // @param {number}           segmentIndex - must be a valid ellipse-arc edge
    // @param {EllipseArcParams} target
    // @returns {EllipseArcParams}
  }, { key: "getEllipseArcParams", value: function getEllipseArcParams(segmentIndex, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      // Find params
      var p = this.loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;

      // Return a copy if found, otherwise undefined.
      return srcParams && (target || new EllipseArcParams()).copy(srcParams);
    }

    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.
    //  @param {number}     edgeIndex     - must be an ellipse arc
    //  @param {EllipseArc} [target]      - optional
    //  @param {number}     [loopIndex=0] - loopIndex
    //  @returns {EllipseArc}
  }, { key: "exportEllipseArc", value: function exportEllipseArc(edgeIndex, target) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var points = this.loops[loopIndex];

      // get start/end points
      var nextIndex = this.nextIndex(edgeIndex, loopIndex);
      var pStart = points[edgeIndex];
      var pEnd = points[nextIndex];
      var params = pStart.ellipseArcParams;

      var arc = target || new EllipseArc();
      arc.setFromSvgArc(
      params.rx,
      params.ry,
      params.rotation,
      params.largeArcFlag,
      params.sweepFlag,
      pStart,
      pEnd);

      return arc;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this.loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;
    } }, { key: "isEllipseArc", value: function isEllipseArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this.loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;
    } }, { key: "isArc", value: function isArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);
    }

    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.
    // Only allowed for Bezier arcs. Result is not normalized.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getStartTangent", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var target = outTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];
      target.x = p.cp1x - p.x;
      target.y = p.cp1y - p.y;
      return target;
    }

    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getEndTangent", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var target = outTarget || new THREE.Vector2();
      var endVertex = this.nextIndex(segmentIndex);

      // get start/end point of the segment
      var pStart = this.points[segmentIndex];
      var pEnd = this.points[endVertex];
      target.x = pStart.cp2x - pEnd.x;
      target.y = pStart.cp2y - pEnd.y;
      return target;
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setStartTangent", value: function setStartTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      p.cp1x = p.x + tangent.x;
      p.cp1y = p.y + tangent.y;
      this.modified();
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setEndTangent", value: function setEndTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      var pEnd = this.points[this.nextIndex(segmentIndex)];
      p.cp2x = pEnd.x + tangent.x;
      p.cp2y = pEnd.y + tangent.y;
      this.modified();
    }

    // Change Bezier or Ellipse arc back to simple line segment
  }, { key: "removeArc", value: function removeArc(segmentIndex) {
      var p = this.points[segmentIndex];

      if (p.arcType === EdgeType.Bezier) {
        p.cp1x = undefined;
        p.cp1y = undefined;
        p.cp2x = undefined;
        p.cp2y = undefined;
      }

      if (p.ellipseArcParams) p.ellipseArcParams = undefined;

      // reset type
      p.arcType = EdgeType.Line;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
    // @param {Vector2} [target]
    // @param {number}  [loopIndex]
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex, optionalTarget) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var result = optionalTarget || new THREE.Vector2();
      var p = this.loops[loopIndex][segmentIndex];

      if (ctrlPointIndex === 1) {
        result.x = p.cp1x;
        result.y = p.cp1y;
      } else {
        result.x = p.cp2x;
        result.y = p.cp2y;
      }
      return result;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {
      var p = this.points[segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // Sample path into a Polygon or Polyline.
    //  @returns {Polygon|Polyline}
  }, { key: "toPoly", value: function toPoly() {var _this5 = this;

      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(
      l) {

        // Extents of the full path. Used to determine sample density: 
        // Finer sampling for arcs that are large wrt. to the full path.
        _this5.updateBBox();
        var sz = _this5.bbox.size().length();

        // Build up a polygon from path commands
        var ctx = {
          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},
          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},
          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {

            // get last added point
            var last = poly.points[poly.vertexCount - 1];

            // sample arc into lineTo() segments
            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz);
          },
          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {

            // determine tesselation params
            var tessParams = this.tessParams || Autodesk.Extensions.CompGeom.DefaultTessParams;
            var maxSegments = tessParams.numIterations;
            var minSegmentLength = tessParams.minSegLenFraction * sz;

            // tesselate arc
            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);
            arc.tesselate(ctx, maxSegments, minSegmentLength);
          },
          closePath: function closePath() {} // Polygon is closed anyway.
        };
        runLoop(ctx, _this5, l);};for (var l = 0; l < this.loops.length; l++) {_loop(l);
      }
      return poly;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      // Compute bbox of all vertices
      _get(_getPrototypeOf(Path.prototype), "computeBBox", this).call(this);

      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control
      // points. Therefore, we can simply add the control points to the bbox.
      //
      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.
      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.
      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
      var cp = new THREE.Vector2();
      for (var l = 0; l < this.getLoopCount(); l++) {
        for (var i = 0; i < this.getVertexCount(l); i++) {

          if (this.isBezierArc(i, l)) {
            // add control point 1
            this.getControlPoint(i, 1, cp, l);
            this.bbox.expandByPoint(cp);

            // add control point 2
            this.getControlPoint(i, 2, cp, l);
            this.bbox.expandByPoint(cp);
          } else
          if (this.isEllipseArc(i)) {
            var arc = this.exportEllipseArc(i, getTmpArc(), l);
            this.bbox.union(arc.computeBBox(tmpBox2));
          }
        }
      }
    } }, { key: "hitTest", value: function hitTest(

    x, y, hitRadius) {
      var poly = this.toPoly();
      return poly.hitTest(x, y, hitRadius);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    }

    // @param {Path} srcPath
  }, { key: "addLoop", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var dstLoopIndex = _get(_getPrototypeOf(Path.prototype), "addLoop", this).call(this, srcPath, srcLoopIndex);

      var srcPoints = srcPath.loops[srcLoopIndex];
      var dstPoints = this.loops[dstLoopIndex];

      // Copy extra information for arcs
      for (var i = 0; i < srcPoints.length; i++) {
        var type = srcPath.getEdgeType(i, srcLoopIndex);

        // Line segments are fully handled by the base class already
        if (type === EdgeType.Line) {
          continue;
        }

        var src = srcPoints[i];
        var dst = dstPoints[i];

        dst.arcType = src.arcType;

        switch (type) {
          case EdgeType.Bezier:{
              // copy control points
              dst.cp1x = src.cp1x;
              dst.cp1y = src.cp1y;
              dst.cp2x = src.cp2x;
              dst.cp2y = src.cp2y;
              break;
            }
          case EdgeType.Ellipse:{
              // copy arc params
              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();
              break;
            }}

      }
      return this;
    } }, { key: "move", value: function move(

    dx, dy) {
      _get(_getPrototypeOf(Path.prototype), "move", this).call(this, dx, dy);

      // Move affected control points as well
      for (var l = 0; l < this.loops.length; l++) {
        var points = this.loops[l];
        for (var i = 0; i < points.length; i++) {

          if (!this.isBezierArc(i, l)) {
            continue;
          }

          var p = points[i];
          p.cp1x += dx;
          p.cp1y += dy;
          p.cp2x += dx;
          p.cp2y += dy;
        }
      }
      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.

      this.modified();
      return this;
    } }, { key: "getArea", value: function getArea(

    measureTransform) {
      if (!this.isClosed) {
        return undefined;
      }

      var poly = this.toPoly();
      return poly.getArea(measureTransform);
    } }, { key: "getLength", value: function getLength(

    measureTransform) {
      var poly = this.toPoly();
      return poly.getLength(measureTransform);
    }

    // Get point on segment. This refines the implementation 
    // of PolyBase by supporting arc segments.
  }, { key: "getPointOnEdge", value: function getPointOnEdge(segmentIndex, t, optionalTarget) {

      var type = this.getEdgeType(segmentIndex);
      switch (type) {
        case EdgeType.Line:break;
        case EdgeType.Bezier:{
            // get segment start/end
            var a = this.points[segmentIndex];
            var b = this.points[this.nextIndex(segmentIndex)];

            var result = optionalTarget || new THREE.Vector2();
            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, result);
          }
        case EdgeType.Ellipse:{
            var arc = this.exportEllipseArc(segmentIndex, getTmpArc());

            // ignore arcs with NaN values
            if (!arc.isValid()) {
              break;
            }
            return arc.getPoint(t, optionalTarget);
          }
        default:avp.logger.error('unexpected edge type');}


      return _get(_getPrototypeOf(Path.prototype), "getPointOnEdge", this).call(this, segmentIndex, t, optionalTarget);
    }

    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    
    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
  }, { key: "runPathCommands", value: function runPathCommands(ctx) {
      runPath(ctx, this);
    } }]);return Path;}(PolyBase);


// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.
var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);
  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _possibleConstructorReturn(this, _getPrototypeOf(PolygonPath).call(this,
    points, true, style));
  }return PolygonPath;}(Path);
;

var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);
  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _possibleConstructorReturn(this, _getPrototypeOf(PolylinePath).call(this,
    points, false, style));
  }return PolylinePath;}(Path);
;

var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this6;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, style));

    _this6.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this6.polygon.id = _this6.id;

    _this6.centerX = centerX;
    _this6.centerY = centerY;
    _this6.radius = radius;
    _this6.tessSegments = tessSegments;

    _this6.needsUpdate = true;return _this6;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this7;_classCallCheck(this, ShapeWrapper);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeWrapper).call(this));
    _this7.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this7), 'bbox', {
      get: function get() {return _this7.shape.bbox;},
      set: function set(bbox) {_this7.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'id', {
      get: function get() {return _this7.shape.id;},
      set: function set(id) {_this7.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'bboxDirty', {
      get: function get() {return _this7.shape.bboxDirty;},
      set: function set(dirty) {_this7.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this7), 'name', {
      get: function get() {return _this7.shape.name;},
      set: function set(name) {_this7.shape.name = name;} });return _this7;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });
var tmpVec2d = new THREE.Vector2();
var tmpVec2d2 = new THREE.Vector2();

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

//  @param {Vector2} dir1, dir2           - No normalization required.
//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// see isPointOnEdge
var isPointOnLine = function isPointOnLine(p, a, b, precision) {
  return isPointOnEdge(p, a, b, precision, false);
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

// same as p1.distanceTo(p2), but working for any {x,y} object.
var distance2D = function distance2D(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Checks if a matrix changes the orientation.
//  @param {Matrix4} matrix
var changesOrientation = function changesOrientation(matrix) {
  return matrix.determinant() < 0;
};

// Compute a matrix that transforms fromBox into toBox.
//
//  @param {Box2}    fromBox
//  @param {Box2}    toBox
//  @param {Object}  [options]
//  @param {bool}    [options.flipY]           - include y-axis flip
//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)
//  @param {Matrix4} [target]
var getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();
  var fromSize = fromBox.size(tmpVec2d);
  var toSize = toBox.size(tmpVec2d2);

  // compute scale   
  var sx = toSize.x / fromSize.x;
  var sy = toSize.y / fromSize.y;

  // preserveAspect
  if (options.preserveAspect) {
    sx = Math.min(sx, sy);
    sy = sx;
  }

  // anchor is the point of fromBox that will be mapped to toBox.min
  var anchorX = fromBox.min.x;
  var anchorY = fromBox.min.y;

  // apply optional y-flip
  if (options.flipY) {
    sy *= -1;
    anchorY = fromBox.max.y;
  }

  // compute translation: after scaling, anchor should move to toBox.min
  var tx = -sx * anchorX + toBox.min.x;
  var ty = -sy * anchorY + toBox.min.y;

  // Create (scale + translate)-matrix.
  var matrix = target.makeScale(sx, sy, 1.0);
  matrix.elements[12] = tx;
  matrix.elements[13] = ty;

  return matrix;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  isPointOnLine: isPointOnLine,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear,
  distance2D: distance2D,
  changesOrientation: changesOrientation,
  getFitToBoxTransform: getFitToBoxTransform };

/***/ }),

/***/ "./extensions/Edit2D/Svg.js":
/*!**********************************!*\
  !*** ./extensions/Edit2D/Svg.js ***!
  \**********************************/
/*! exports provided: Svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}


var domParser = null;

// SVG (de)serialization for EditShapes

// Url of XML-Namespace for SVG
var SvgNs = "http://www.w3.org/2000/svg";

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var domToCircle = function domToCircle(circleNode) {

  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {
    throw 'No attributes available on the <circle/> node';
  }
  var circle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]();
  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {
    var attr = circleNode.attributes[i];
    switch (attr.name) {
      case 'cx':
        circle.centerX = parseFloat(attr.value);
        break;
      case 'cy':
        circle.centerY = parseFloat(attr.value);
        break;
      case 'r':
        circle.radius = parseFloat(attr.value);
        break;}

  }
  return circle;
};

var circleToSvg = function circleToSvg(circle) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;var stylePostFix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  return "<circle cx=\"".concat(limitDigits(circle.centerX, digits), "\" cy=\"").concat(limitDigits(circle.centerY, digits), "\" r=\"").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, "\"/>");
};

var domToPath = function domToPath(pathNode, forcePaths) {

  var d = pathNode.getAttribute('d');
  if (!d) {
    return;
  }var _parsePath =

  parsePath(d),points = _parsePath.points,isPolygon = _parsePath.isPolygon;

  if (forcePaths || points.find(function (p) {return p.arcType !== undefined;})) {
    var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"](points, isPolygon);
    return path;
  } else
  if (isPolygon) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"](points);
  }
  return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"](points);
};

var parsePath = function parsePath(svgPath) {
  // split at all chars but keep the char using positive look ahead
  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
  // results into list with glyph with position array:
  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);
  var validChars = "MLHVCZA";

  var previousPoint = { x: 0, y: 0 };
  var newPoint;
  var points = [];
  var isPolygon = false;

  for (var i = 0; i < pointStrings.length; i++) {

    var pointString = pointStrings[i];
    if (validChars.indexOf(pointString[0]) === -1) {
      throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);
    }
    var value = pointString.substring(1);
    switch (pointString[0]) {
      case 'M':
      case 'L':
        var coords = value.split(',');
        newPoint = { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };
        if (pointString[0] === 'M') {
          // remove the initial 0,0 point
          points.shift();
        }
        break;
      case 'H':
        newPoint = { x: parseFloat(value), y: previousPoint.y };
        break;
      case 'V':
        newPoint = { x: previousPoint.x, y: parseFloat(value) };
        break;
      case 'C':
        var bezierCoords = value.split(',');
        newPoint = { x: parseFloat(bezierCoords[4]), y: parseFloat(bezierCoords[5]) };
        previousPoint.arcType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier;
        previousPoint.cp1x = parseFloat(bezierCoords[0]);
        previousPoint.cp1y = parseFloat(bezierCoords[1]);
        previousPoint.cp2x = parseFloat(bezierCoords[2]);
        previousPoint.cp2y = parseFloat(bezierCoords[3]);
        break;
      case 'A':
        var src = value.split(',');
        newPoint = { x: parseFloat(src[5]), y: parseFloat(src[6]) };
        previousPoint.arcType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse;

        // read ellipse params.
        var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
        params.rx = parseFloat(src[0]);
        params.ry = parseFloat(src[1]);
        params.rotation = parseFloat(src[2]);
        params.largeArcFlag = Boolean(parseFloat(src[3]));
        params.sweepFlag = Boolean(parseFloat(src[4]));

        previousPoint.ellipseArcParams = params;
        break;
      case 'Z':
        // we are done
        isPolygon = true;
        continue;}

    previousPoint = newPoint;
    points.push(newPoint);
  }

  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
  var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(points[0], points[points.length - 1], 0);
  if (!delta) {
    points.pop(); // remove the duplicate last point which the same as the first point.
  }

  return { points: points, isPolygon: isPolygon };
};

var pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!path.vertexCount) {
    return [];
  }

  var svgPath = [];
  svgPath.push("M ".concat(limitDigits(path.points[0].x, digits), ",").concat(limitDigits(path.points[0].y, digits)));
  for (var i = 1; i < path.points.length; i += 1) {

    // The segment start point defines the type (line or arc)
    var prev = path.points[i - 1];
    var p = path.points[i];
    var value = void 0;

    switch (prev.arcType) {

      case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:
        var par = prev.ellipseArcParams;
        var largeArc = par.largeArcFlag ? 1 : 0;
        var sweep = par.sweepFlag ? 1 : 0;

        value = "A ".concat(par.rx, ",").concat(par.ry, ",").concat(par.rotation, ",").concat(largeArc, ",").concat(sweep, ",").concat(p.x, ",").concat(p.y);
        break;

      case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:
        value = "C ".concat(limitDigits(prev.cp1x, digits), ",").concat(limitDigits(prev.cp1y, digits), ",").concat(limitDigits(prev.cp2x, digits), ",").concat(limitDigits(prev.cp2y, digits), ",").concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
        break;

      default:
        {
          // skip empty/duplicate points
          var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(prev, p, digits);
          if (!delta) {
            continue;
          }

          if (Math.abs(delta.x) <= precision) {
            value = "V ".concat(limitDigits(p.y, digits));
          } else if (Math.abs(delta.y) <= precision) {
            value = "H ".concat(limitDigits(p.x, digits));
          } else {
            value = "L ".concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
          }
        }}

    svgPath.push(value);
  }

  if (path.isClosed) {
    // close path
    var pLast = path.points[path.points.length - 1];
    if (pLast.arcType === _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier) {
      var pFirst = path.points[0];
      var _value = "C ".concat(limitDigits(pLast.cp1x, digits), ",").concat(limitDigits(pLast.cp1y, digits), ",").concat(limitDigits(pLast.cp2x, digits), ",").concat(limitDigits(pLast.cp2y, digits), ",").concat(limitDigits(pFirst.x, digits), ",").concat(limitDigits(pFirst.y, digits));
      svgPath.push(_value);
    }
    svgPath.push('Z');
  }

  return svgPath;
};

var polyToSvgPath = function polyToSvgPath(poly) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!poly.vertexCount) {
    return;
  }

  var previousIndex = 0;
  var reduceToPath = function reduceToPath(result, current, index, list) {
    if (!index) {
      result.push("M ".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits)));
      return result;
    }

    var prefix, value;
    var previous = list[previousIndex];
    var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(previous, current, digits);
    // skip empty/duplicate points
    if (!delta) {
      return result;
    }
    if (Math.abs(delta.x) <= precision) {
      prefix = 'V';
      value = limitDigits(current.y, digits);
    } else if (Math.abs(delta.y) <= precision) {
      prefix = 'H';
      value = limitDigits(current.x, digits);
    } else {
      prefix = 'L';
      value = "".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits));
    }
    result.push("".concat(prefix, " ").concat(value));
    previousIndex = index;
    return result;
  };

  var path = poly.points.reduce(reduceToPath, []);
  if (poly.isPolygon()) {
    path.push('Z');
  }
  return path;
};

// Extract dictionary of SVG style attributes from Edit2D style
//  @param {Style} style
//  @returns {Object}
var getSvgStyleAttributes = function getSvgStyleAttributes(style) {

  var target = {};
  target["stroke"] = style.lineColor;
  target["fill"] = style.fillColor;
  target["stroke-width"] = style.lineWidth;

  // omit opacities if they are 1 (default)
  if (style.lineAlpha != 1) target["stroke-opacity"] = style.lineAlpha;
  if (style.fillAlpha != 1) target["fill-opacity"] = style.fillAlpha;

  return target;
};

// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it
// to other attributes, it contains a preceding space. 
// Example: ' stroke="rgb(0,0,0)" fill="rgb(0,0,255)" ... '
var getAttributePostFix = function getAttributePostFix(attribs) {
  var str = '';
  for (var key in attribs) {
    str += " ".concat(key, "=\"").concat(attribs[key], "\"");
  }
  return str;
};

// Apply all given attributes to a Dom Element
var applyAttributes = function applyAttributes(domElement, attribs) {
  for (var key in attribs) {
    domElement.setAttribute(key, attribs[key]);
  }
};

// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),
// style attributes are only exported if specified in options.
//
// @param {Shape} shape
// @param {Object} [options]
// @param {number} [options.precision=0]       - accuracy for unifying duplicate points 
// @param {number} [options.digis=0]           - number of digits for number strings 
// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes
//
// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.
var toSvg = function toSvg(shape, options) {

  var precision = options && options.precision || 0;
  var digits = options && options.digits || null; // means no limitation of digits
  var exportStyle = options && options.exportStyle || false;

  // add style params if wanted
  var stylePostfix = '';
  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    stylePostfix = getAttributePostFix(attribs);
  }

  // Legacy: Keep old code using that still passes precision/digits separately
  // Todo: Remove this when checked with clients.
  if (_typeof(options) !== 'object') {
    if (typeof arguments[1] == 'number') precision = arguments[1];
    if (typeof arguments[2] == 'number') digits = arguments[2];
  }

  if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]) {
    return circleToSvg(shape, precision, digits, stylePostfix);
  }

  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  // PolyBase and Path are translated to SVG Path
  var path = pathToSvgPath(shape, precision, digits);

  return "<path d=\"".concat(path.join(' '), "\"").concat(stylePostfix, "/>");
};

// see toSvg for options.
var createSvgShape = function createSvgShape(shape, options) {
  var precision = options && options.precision || 0;
  var digits = options && options.digits || 0;
  var exportStyle = options && options.exportStyle || true;

  // Todo: support circles and other shapes if anyone needs it.
  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  var path = document.createElementNS(SvgNs, 'path');
  path.setAttribute('d', pathToSvgPath(shape, precision, digits));

  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    applyAttributes(path, attribs);
  }

  return path;
};

// @param {string}  svg - e.g. '<path d="M 13.882,4.8592 L 14.6757,4.738"/>'
// @param {Object}  [options]
// @param {boolean} [options.forcePaths] - By default, paths without arcs are interpreted as Polygon resp. Polyline.
//                                         This option ensures that the result is always a Path. This is important
//                                         if you want to allow converting it into a path later.
var fromSvg = function fromSvg(svg, options) {
  if (!svg) {
    return;
  }

  // init on first use
  domParser = domParser || new DOMParser();

  var dom = domParser.parseFromString(svg, 'application/xml');

  var forcePaths = options && options.forcePaths;

  if (dom.childNodes.length !== 1) {
    throw 'Function does only support svg with a single element: path, circle';
  }
  var node = dom.firstChild;
  if (node.nodeName === 'circle') {
    return domToCircle(node);
  } else
  if (node.nodeName === 'path') {
    return domToPath(node, forcePaths);
  }

  throw "Unsupported svg node type: ".concat(node.nodeName);
};

// Converts several shapes to an SVG element.
//  @param {Object} [options]
//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.
//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.
// see toSvg() for other options
var createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // get summed box of all shapes
  var sumBox = new THREE.Box2();
  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});

  var srcBox = options.srcBox || sumBox;
  var dstBox = options.dstBox || sumBox;

  // Note that we always have to swap y-axis, because the y-axis direction is flipped when 
  // converting 2D world coords in LMV to SVG.
  var scaleOptions = {
    preserveAspect: true,
    flipY: true };

  var tf = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getFitToBoxTransform(srcBox, dstBox, scaleOptions);

  // get required size of svg
  var width = dstBox.max.x - dstBox.min.x;
  var height = dstBox.max.y - dstBox.min.y;

  // create svg root element      
  var svg = document.createElementNS(SvgNs, 'svg');
  svg.setAttribute('height', width);
  svg.setAttribute('width', height);

  // rescale & convert each shape
  shapes.forEach(function (shape) {
    var scaledShape = shape.clone().applyMatrix4(tf);
    var path = createSvgShape(scaledShape, options);
    svg.appendChild(path);
  });

  return svg;
};

var Svg = {
  toSvg: toSvg,
  fromSvg: fromSvg,
  createSvgShape: createSvgShape,
  createSvgElement: createSvgElement };

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss":
/*!************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Avatar/Avatar.scss ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".avatar-widget {\n  width: 0px;\n  height: 0px;\n  top: 0px;\n  left: 0px;\n  position: absolute;\n  transition: opacity 0.7s;\n  opacity: 0;\n  z-index: 1;\n  pointer-events: none; }\n  .avatar-widget.visible {\n    opacity: 0.7;\n    pointer-events: all; }\n\n.avatar-frustum {\n  border-left: 20px solid transparent;\n  border-right: 20px solid transparent;\n  border-top: 40px solid #3590e9;\n  border-radius: 50%;\n  opacity: 0.4;\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  transform-origin: bottom center;\n  cursor: crosshair; }\n  .avatar-frustum.touch {\n    border-left: 40px solid transparent;\n    border-right: 40px solid transparent;\n    border-top: 80px solid #3590e9; }\n\n.avatar-position-fill {\n  width: 10px;\n  height: 10px;\n  /* Move circle center to the tip of the frustum shape */\n  left: 15px;\n  /* = (avatarFrustum.border-left - width/2)  */\n  top: 35px;\n  /* = (avatarFrustum.border-top  - height/2) */\n  position: absolute;\n  border-radius: 50%;\n  background-color: #3590e9;\n  box-shadow: 0px 0px 0px 2px #fff; }\n  .avatar-position-fill.touch {\n    /* Move circle center to the tip of the frustum shape */\n    left: 35px;\n    /* = (avatarFrustum.border-left - width/2)  */\n    top: 75px;\n    /* = (avatarFrustum.border-top  - height/2) */ }\n\n.avatar-position-hitarea {\n  position: absolute;\n  width: 15px;\n  height: 15px;\n  left: 5px;\n  /* avatar-position-fill.width/2 */\n  top: 5px;\n  /* avatar-position-fill.height/2 */\n  border-radius: 50px;\n  transform: translate(-50%, -50%);\n  cursor: grab; }\n  .avatar-position-hitarea.touch {\n    width: 50px;\n    height: 50px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.canvas-bookmark.adsk-button, .clustered-canvas-bookmark.adsk-button, .declustered-canvas-bookmark.adsk-button {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  border-style: none !important;\n  /* Avoid border on button-hover */\n  color: white;\n  margin: none;\n  padding: 0px;\n  transition: visibility 0.5s, opacity 0.5s;\n  opacity: 0;\n  visibility: hidden; }\n\n.canvas-bookmark.adsk-button {\n  width: 22px;\n  height: 22px; }\n\n.clustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px; }\n\n.declustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px;\n  color: lightgrey; }\n\n.canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n\n.clustered-canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".camera-selector {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid #0696D7;\n  border-radius: 50%;\n  transform-origin: bottom center;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1; }\n\n.camera-selector-position {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: #0696D7;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1;\n  transform: scale(1, 1);\n  transition: transform 3s ease-in; }\n\n.camera-selector-position--teleporting {\n  transform: scale(0, 0); }\n\n.camera-selector-background {\n  width: 200px;\n  height: 200px;\n  background-color: #0696D7;\n  opacity: 0.2;\n  position: absolute;\n  pointer-events: none;\n  z-index: 0;\n  transform: translate(-100px, -100px);\n  border-radius: 50%; }\n\n/* mimic issues UI guidance for now as it was the only extension, featuring guidance so far */\n.dropme-guidenace-ui {\n  display: flex;\n  position: absolute;\n  left: 50%;\n  top: 20px;\n  padding: 10px 20px;\n  transform: translate(-50%, 0);\n  align-items: center;\n  border: 1px solid #9ec8f6;\n  border-radius: 4px;\n  background-color: #edf5fd;\n  color: #039be5;\n  font-size: 12px;\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.25);\n  opacity: 1;\n  z-index: 999;\n  overflow-y: hidden; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.minimap3D {\n  width: 0px;\n  height: 0px;\n  right: 10px;\n  top: 10px;\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  transition: visibility 0.7s, opacity 0.7s;\n  opacity: 0;\n  visibility: hidden;\n  background: rgba(255, 255, 255, 0.4);\n  /* For side-by-side mode: Make sure that text selection highlighting is disabled on Minimap. Otherwise, fast dragging of the player will\n       color the whole map in blue */\n  user-select: none;\n  border-radius: 4px;\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.4); }\n\n.minimap3D.paddedForToolbar {\n  right: 70px; }\n\n.minimapScrollArea {\n  width: 100%;\n  height: 100%;\n  position: relative; }\n\n/* Show map left-aligned and without margin */\n.minimap3D.side-by-side {\n  right: 0px;\n  top: 0px;\n  box-sizing: border-box;\n  box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);\n  z-index: 1;\n  overflow-x: hidden; }\n\n.minimap3D.side-by-side.left-2d-view {\n  border-left: none;\n  border-right: solid 2px #979797;\n  left: 0px; }\n\n.minimap3D.visible {\n  opacity: 1;\n  visibility: visible; }\n\n/* Container for floor image + floor name */\n.mapContainer {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  opacity: 1; }\n\n.mapImage {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  pointer-events: none; }\n\n/* Display floor name at top left */\n.floorNameLabel {\n  z-index: 2;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  opacity: 0.99;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin: 4px;\n  border-radius: 5px; }\n\n.floorNameLabel.dark {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(50, 50, 50, 0.8); }\n\n.floorNameLabel.light {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(255, 255, 255, 0.85);\n  box-shadow: none; }\n\n.floorText {\n  margin: 5px 5px 5px 5px;\n  color: black;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden; }\n\n.floorText.dark {\n  padding: 0px 15px;\n  color: #FFFFFF;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n.floorText.light {\n  padding: 0px 15px;\n  color: #000;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n/* Div with text and progressbar - replaces the map image if map computation is running */\n.minimap-placeholder {\n  left: 0px;\n  top: 0px;\n  position: absolute;\n  background-color: rgba(255, 255, 255, 0.5);\n  opacity: 1; }\n\n.minimap-progressWidget {\n  transform: translate(0, -50%);\n  left: 0px;\n  top: 50%;\n  position: relative;\n  height: fit-content;\n  width: calc(100% - 60px);\n  margin-left: 30px;\n  margin-right: 30px; }\n\n.minimap-progressText {\n  color: black;\n  text-align: left;\n  position: relative; }\n\n.minimap-progress {\n  z-index: 10;\n  width: 100%; }\n\n.map-button-bar {\n  z-Index: 2;\n  right: 0px;\n  top: 0px;\n  position: absolute;\n  right: 100%;\n  /* Dock left to mapWidget */\n  display: flex;\n  flex-direction: column;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin-right: 4px;\n  margin-top: 0px;\n  /* Toolbar is vertically aligned to the upper mapWidget boundary. This is okay, because the mapWidget already has some margin from the canvas boundary. */\n  border-radius: 5px; }\n\n/* In side-by-side, the upper mapWidget edge is matched with the upper canvas edge. So, we add some marigin - otherwise the toolbar would be \"glued\" to the upper canvas edge. */\n.map-button-bar.side-by-side {\n  margin-top: 4px; }\n\n.map-button-bar.side-by-side.left-2d-view {\n  right: 0px; }\n\n.sheetmap-thumbnail {\n  position: absolute;\n  overflow: hidden; }\n\n.side-by-side .minimap-header {\n  border-radius: 0; }\n\n.minimap-header {\n  background: #ffffff;\n  display: flex;\n  position: initial;\n  align-items: center;\n  justify-content: flex-end;\n  border-radius: 4px 4px 0 0;\n  width: 100%;\n  z-index: 4;\n  -moz-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\n  -webkit-box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5);\n  box-shadow: 0px 2px 4px -2px rgba(0, 0, 0, 0.5); }\n\n.minimap-title {\n  font-size: 14px;\n  text-align: left;\n  text-align-last: left;\n  margin-right: 12px;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.minimap-dropdown-wrapper {\n  cursor: pointer;\n  outline: none;\n  white-space: nowrap;\n  flex-grow: 1;\n  display: flex;\n  align-items: center;\n  padding: 0 5px 0 15px;\n  overflow: hidden;\n  margin-right: auto; }\n\n.minimap-dropdown-wrapper:after {\n  content: \"\";\n  border-width: 6px 5px 0 5px;\n  border-style: solid;\n  border-color: #819099 transparent; }\n\n.minimap-dropdown {\n  position: absolute;\n  top: 40px;\n  left: 5px;\n  max-height: 120px;\n  margin: 0;\n  width: 90%;\n  background: #ffffff;\n  list-style: none;\n  opacity: 0;\n  pointer-events: none;\n  overflow: scroll;\n  overflow-x: hidden;\n  border-radius: 3px;\n  z-index: 10;\n  box-shadow: 0px 1px 7px rgba(0, 0, 0, 0.3); }\n\n.minimap-dropdown li {\n  display: block;\n  color: #222222;\n  text-decoration: none;\n  border-left: 5px;\n  padding: 8px 8px 8px 20px;\n  font-size: 14px;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.minimap-dropdown li.active {\n  background: #eef0f2; }\n\n.minimap-dropdown li:hover {\n  background: #f8f9fa; }\n\n.minimap-dropdown.active {\n  opacity: 1;\n  pointer-events: auto;\n  padding: 0 0 10px 0; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".list-panel {\n  width: 260px;\n  min-width: 260px;\n  height: 260px;\n  min-height: 260px;\n  top: 180px;\n  left: 220px;\n  border-color: transparent; }\n\n.list-panel .itemList {\n  width: 100%;\n  display: flex;\n  flex-direction: column; }\n\n.list-panel .listItem {\n  display: flex;\n  justify-content: space-between;\n  text-align: left;\n  line-height: 35px;\n  background-color: rgba(0, 0, 0, 0);\n  border-style: none;\n  font-family: \"ArtifaktElement\", \"Helvetica Neue\", \"Segoe UI Semilight\", sans-serif;\n  padding: 0 15px; }\n\n.adsk-viewing-viewer.dark-theme .listItem {\n  color: #f3f7fb; }\n\n.adsk-viewing-viewer.light-theme .list-panel .listItem:hover {\n  background-color: rgba(10, 19, 28, 0.2); }\n\n.adsk-viewing-viewer.dark-theme .list-panel .listItem:hover {\n  background-color: #4a555b; }\n\n.list-panel .listItem:focus {\n  outline: none; }\n\n.list-panel .listItem.selected {\n  color: deepskyblue;\n  border-style: none; }\n\n.list-panel .listItem .textContainer {\n  -webkit-mask-image: linear-gradient(to left, transparent, black 1em);\n  mask-image: linear-gradient(to left, transparent, black 1em);\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%; }\n\n.list-panel .listItem .icon {\n  width: 24px; }\n\n.list-panel .listItem.selected .icon::before {\n  content: '\\2713';\n  margin-left: 8px; }\n\n.list-panel-item-warning {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDggOCc+PHBhdGggZmlsbD0nIzZiNzg3ZicgZD0nTTMuMDkgMGMtLjA2IDAtLjEuMDQtLjEzLjA5bC0yLjk0IDYuODFjLS4wMi4wNS0uMDMuMTMtLjAzLjE5di44MWMwIC4wNS4wNC4wOS4wOS4wOWg2LjgxYy4wNSAwIC4wOS0uMDQuMDktLjA5di0uODFjMC0uMDUtLjAxLS4xNC0uMDMtLjE5bC0yLjk0LTYuODFjLS4wMi0uMDUtLjA3LS4wOS0uMTMtLjA5aC0uODF6bS0uMDkgM2gxdjJoLTF2LTJ6bTAgM2gxdjFoLTF2LTF6JyAvPjwvc3ZnPg==\");\n  width: 24px;\n  height: 24px;\n  margin-left: auto;\n  margin-top: auto;\n  margin-bottom: auto; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./res/locales/cs/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/cs/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"cs\",\"@@context\":\"Rozen Minimap3D\",\"Show large map\":\"Zobrazit velkou mapu\",\"Show small map\":\"Zobrazit malou mapu\",\"Show sheet\":\"Zobrazit list\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Natn listu...\",\"Loading models...\":\"Natn model...\"}");

/***/ }),

/***/ "./res/locales/da/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/da/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"da\",\"@@context\":\"Minimap3D-udvidelse\",\"Show large map\":\"Vis stort kort\",\"Show small map\":\"Vis lille kort\",\"Show sheet\":\"Vis ark\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Indlser ark...\",\"Loading models...\":\"Indlser modeller...\"}");

/***/ }),

/***/ "./res/locales/de/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/de/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"de\",\"@@context\":\"Minimap3D-Erweiterung\",\"Show large map\":\"Groe Karte anzeigen\",\"Show small map\":\"Kleine Karte anzeigen\",\"Show sheet\":\"Plan anzeigen\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Plan wird geladen...\",\"Loading models...\":\"Modelle werden geladen...\"}");

/***/ }),

/***/ "./res/locales/en/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/en/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"en\",\"@@context\":\"Minimap3D Extension\",\"Show large map\":\"Show large map\",\"Show small map\":\"Show small map\",\"Show sheet\":\"Show sheet\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Loading sheet...\",\"Loading models...\":\"Loading models...\"}");

/***/ }),

/***/ "./res/locales/es/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/es/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"es\",\"@@context\":\"Extensin de minimapa 3D\",\"Show large map\":\"Mostrar mapa grande\",\"Show small map\":\"Mostrar mapa pequeo\",\"Show sheet\":\"Mostrar plano\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Cargando plano...\",\"Loading models...\":\"Cargando modelos...\"}");

/***/ }),

/***/ "./res/locales/fr-CA/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/fr-CA/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr-CA\",\"@@context\":\"Extension Minimap3D\",\"Show large map\":\"Afficher la grande carte\",\"Show small map\":\"Afficher la petite carte\",\"Show sheet\":\"Afficher la feuille\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Chargement de la feuille...\",\"Loading models...\":\"Chargement des modles...\"}");

/***/ }),

/***/ "./res/locales/fr/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/fr/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"fr\",\"@@context\":\"Extension Minimap3D\",\"Show large map\":\"Afficher une grande carte\",\"Show small map\":\"Afficher une petite carte\",\"Show sheet\":\"Afficher une feuille\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Chargement de la feuille\",\"Loading models...\":\"Chargement des modles\"}");

/***/ }),

/***/ "./res/locales/it/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/it/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"it\",\"@@context\":\"Estensione Minimap3D\",\"Show large map\":\"Mostra mappa di grandi dimensioni\",\"Show small map\":\"Mostra mappa di piccole dimensioni\",\"Show sheet\":\"Mostra foglio\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Caricamento foglio in corso...\",\"Loading models...\":\"Caricamento modelli in corso...\"}");

/***/ }),

/***/ "./res/locales/ja/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ja/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ja\",\"@@context\":\"Minimap3D Extension\",\"Show large map\":\"\",\"Show small map\":\"\",\"Show sheet\":\"\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"...\",\"Loading models...\":\"...\"}");

/***/ }),

/***/ "./res/locales/ko/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ko/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ko\",\"@@context\":\"Minip3D  \",\"Show large map\":\"  \",\"Show small map\":\"  \",\"Show sheet\":\" \",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"  ...\",\"Loading models...\":\"  ...\"}");

/***/ }),

/***/ "./res/locales/nl/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/nl/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"nl\",\"@@context\":\"Minimap3D-extensie\",\"Show large map\":\"Grote kaart weergeven\",\"Show small map\":\"Kleine kaart weergeven\",\"Show sheet\":\"Blad weergeven\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Blad laden...\",\"Loading models...\":\"Modellen laden...\"}");

/***/ }),

/***/ "./res/locales/pl/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/pl/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pl\",\"@@context\":\"Rozszerzenie Minimap3D\",\"Show large map\":\"Poka du map\",\"Show small map\":\"Poka ma map\",\"Show sheet\":\"Poka arkusz\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Wczytywanie arkusza...\",\"Loading models...\":\"Wczytywanie modeli...\"}");

/***/ }),

/***/ "./res/locales/pt-BR/nobundle-minimap3D.loc.json":
/*!*******************************************************!*\
  !*** ./res/locales/pt-BR/nobundle-minimap3D.loc.json ***!
  \*******************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"pt\",\"@@context\":\"Extenso Minimap3D\",\"Show large map\":\"Mostrar mapa grande\",\"Show small map\":\"Mostrar mapa pequeno\",\"Show sheet\":\"Mostrar folha\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Carregando folha...\",\"Loading models...\":\"Carregando modelos...\"}");

/***/ }),

/***/ "./res/locales/ru/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/ru/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"ru\",\"@@context\":\" Minimap3D\",\"Show large map\":\"  \",\"Show small map\":\"  \",\"Show sheet\":\" \",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\" ...\",\"Loading models...\":\" ...\"}");

/***/ }),

/***/ "./res/locales/sv/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/sv/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"sv\",\"@@context\":\"Minimap3D-tillgg\",\"Show large map\":\"Visa stor karta\",\"Show small map\":\"Visa liten karta\",\"Show sheet\":\"Visa blad\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Lser in blad...\",\"Loading models...\":\"Lser in modeller...\"}");

/***/ }),

/***/ "./res/locales/tr/nobundle-minimap3D.loc.json":
/*!****************************************************!*\
  !*** ./res/locales/tr/nobundle-minimap3D.loc.json ***!
  \****************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"tr\",\"@@context\":\"Minimap3D Uzants\",\"Show large map\":\"Byk haritay gster\",\"Show small map\":\"Kk haritay gster\",\"Show sheet\":\"Sayfay gster\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"Sayfa ykleniyor...\",\"Loading models...\":\"Model ykleniyor...\"}");

/***/ }),

/***/ "./res/locales/zh-HANS/nobundle-minimap3D.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANS/nobundle-minimap3D.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hans\",\"@@context\":\"Minimap3D \",\"Show large map\":\"\",\"Show small map\":\"\",\"Show sheet\":\"\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"...\",\"Loading models...\":\"...\"}");

/***/ }),

/***/ "./res/locales/zh-HANT/nobundle-minimap3D.loc.json":
/*!*********************************************************!*\
  !*** ./res/locales/zh-HANT/nobundle-minimap3D.loc.json ***!
  \*********************************************************/
/*! exports provided: @@locale, @@context, Show large map, Show small map, Show sheet, Hide sheet, Loading sheet..., Loading models..., default */
/***/ (function(module) {

module.exports = JSON.parse("{\"@@locale\":\"zh-Hant\",\"@@context\":\"Minimap3D \",\"Show large map\":\"\",\"Show small map\":\"\",\"Show sheet\":\"\",\"Hide sheet\":\"Hide sheet\",\"Loading sheet...\":\"...\",\"Loading models...\":\"...\"}");

/***/ }),

/***/ "./src/application/ProgressState.js":
/*!******************************************!*\
  !*** ./src/application/ProgressState.js ***!
  \******************************************/
/*! exports provided: ProgressState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProgressState", function() { return ProgressState; });
var ProgressState = {
  ROOT_LOADED: 0,
  LOADING: 1,
  RENDERING: 2 };

/***/ }),

/***/ "./src/file-loaders/main/Empty2DModelLoader.js":
/*!*****************************************************!*\
  !*** ./src/file-loaders/main/Empty2DModelLoader.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Empty2DModelLoader; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Empty2DModelLoader - Loader for an empty 2D scene.
var Empty2DModelLoader = /*#__PURE__*/function () {
  function Empty2DModelLoader(viewer3DImpl) {_classCallCheck(this, Empty2DModelLoader);
    this.viewer3DImpl = viewer3DImpl;
  }_createClass(Empty2DModelLoader, [{ key: "loadFile", value: function loadFile(

    url) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};var onDone = arguments.length > 2 ? arguments[2] : undefined;var onWorkerStart = arguments.length > 3 ? arguments[3] : undefined;
      var width = options.width || 100;
      var height = options.height || 100;

      onWorkerStart && onWorkerStart();

      this.svf = {
        is2d: true,
        viewports: [],
        layersMap: { "0": 0 },
        layerCount: 1,
        bbox: new THREE.Box3(new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(width, height, 0)),
        fragments: {
          length: 1,
          fragId2dbId: [0],
          transforms: new Float32Array(12),
          boxes: [0, 0, 0, width, height, 0] },

        loadOptions: {
          bubbleNode: new Autodesk.Viewing.BubbleNode({
            urn: 'Dummy_urn',
            guid: 'Dummy_guid' }) },


        metadata: {
          page_dimensions: {
            page_width: width,
            page_height: height,
            logical_width: width,
            logical_height: height,
            logical_offset_x: 0,
            logical_offset_y: 0,
            page_units: "inch" } },


        strings: [],
        stringDbIds: [],
        loadDone: true };


      var model = new Autodesk.Viewing.Model(this.svf);

      model.initialize();
      model.loader = this;
      this.model = model;
      onDone(null, model);
      this.viewer3DImpl.api.dispatchEvent({ type: Autodesk.Viewing.MODEL_ROOT_LOADED_EVENT, svf: this.svf, model: model });
      this.viewer3DImpl.onLoadComplete(model);
    } }, { key: "dtor", value: function dtor()

    {} }, { key: "is2d", value: function is2d()
    {return true;} }, { key: "is3d", value: function is3d()
    {return false;} }]);return Empty2DModelLoader;}();

/***/ }),

/***/ "./src/wgs/scene/SceneMath.js":
/*!************************************!*\
  !*** ./src/wgs/scene/SceneMath.js ***!
  \************************************/
/*! exports provided: SceneMath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneMath", function() { return SceneMath; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);




var normals = [
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0),
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0),
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1),
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-1, 0, 0),
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, -1, 0),
new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, -1)];


var plane = new three__WEBPACK_IMPORTED_MODULE_0__["Plane"]();

// Returns an array of vector4 values that describe the cutplanes needed to apply a given sectionBox
function box2CutPlanes(box, transform) {

  var planeVecs = [];

  for (var i = 0; i < normals.length; i++) {

    plane.normal.copy(normals[i]);
    var onPlane = i < 3 ? box.max : box.min;
    plane.constant = -plane.normal.dot(onPlane);

    if (transform) {
      plane.applyMatrix4(transform);
    }

    planeVecs.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector4"](plane.normal.x, plane.normal.y, plane.normal.z, plane.constant));
  }

  return planeVecs;
}

// Compute pixels per unit parameter for 2D materials.
//  @param {Camera}  camera
//  @param {bool}    is2d
//  @param {Box3}    worldBox      - worldBox of all visible geometry
//  @param {number}  deviceHeight  - canvas height * pixelRatio
//  @param {Vector4} [cutPlane]    - Optional: A cutplane in 3D containg 2D geometry. If specified, its camera distance is
//                                   considered to determine pixelsPerUnit.
//  @param {Vector3} [modelBox]    - Only for 2D: The min-plane of this box is assumed as ground plane
function getPixelsPerUnit(camera, is2d, worldBox, deviceHeight, cutPlane, modelBox) {
  var distance, pixelsPerUnit;

  if (is2d) {

    //Here we base pixel scale on the point at the center of the view.
    //However, this might not always be the most appropriate point,
    //e.g. at oblique angles or when the drawing is off to one side.
    //It might make more sense to base the scale on the distance of the
    //camera to the nearest part of the world bounding box, which requires
    //a more generic ray-aabb test.
    var worldUp = 'z'; // in 2d, world-up is aways Z
    var groundPt = intersectGroundViewport(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1), camera, worldUp, modelBox);

    if (groundPt)
    distance = camera.position.distanceTo(groundPt);else

    distance = camera.position.distanceTo(worldBox.center()); //degenerate case: camera direction is parallel to the ground plane

    //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
    //so here we don't need separate code path for ortho.
    pixelsPerUnit = deviceHeight / (2 * distance * Math.tan(three__WEBPACK_IMPORTED_MODULE_0__["Math"].degToRad(camera.fov * 0.5)));
  } else {

    var pt;
    if (cutPlane) {
      var p = cutPlane;

      var dir = camera.target.clone().sub(camera.position).normalize();
      var denominator = dir.dot(p);

      if (denominator === 0)
      pt = worldBox.center();else
      {
        var t = -(camera.position.clone().dot(p) + p.w) / denominator;
        pt = worldBox.clampPoint(dir.multiplyScalar(t).add(camera.position));
      }
    } else {
      pt = worldBox.center();
    }

    distance = camera.position.distanceTo(pt);

    //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
    //so here we don't need separate code path for ortho.
    pixelsPerUnit = deviceHeight / (2 * distance * Math.tan(three__WEBPACK_IMPORTED_MODULE_0__["Math"].degToRad(camera.fov * 0.5)));
  }

  return pixelsPerUnit;
}

// Note: The camera world matrix must be up-to-date
//  @param {Vec3d}  vpVec         - ray direction in viewport coords
//  @param {Camera} camera
//  @param {string} worldUp       - main axis of up-vector, i.e., "x", "y", or "z".
//  @param {bool}   is2d          - In 2d, worldUp setting is ignored and we always use "z".
//  @param {Box3}   modelBox      - Used to derive min-elevation (where ground is assumed)
function intersectGroundViewport(vpVec, camera, worldUpName, modelBox) {

  var vector = vpVec;

  // set two vectors with opposing z values
  vector.z = -1.0;
  var end = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](vector.x, vector.y, 1.0);
  vector = vector.unproject(camera);
  end = end.unproject(camera);

  // find direction from vector to end
  end.sub(vector).normalize();

  var dir = end;

  //Is the direction parallel to the ground plane?
  //Then we fail.
  if (Math.abs(dir[worldUpName]) < 1e-6)
  return null;

  var rayOrigin;
  if (camera.isPerspective) {
    rayOrigin = camera.position;
  } else
  {
    rayOrigin = vector;
  }

  var baseElev = modelBox ? modelBox.min[worldUpName] : 0;
  var distance = (baseElev - rayOrigin[worldUpName]) / dir[worldUpName];

  //2D drawing, intersect the plane
  dir.multiplyScalar(distance);
  dir.add(rayOrigin);

  return dir;
}


/**
   * Returns a new matrix that transforms points from the loaded 2D model
   * into a normalized coordinate space [0..1].
   *
   * @param {THREE.Box3} bbox - Optional - Compute the normalizing matrix according to the given bounding box.
   *
   * @returns {THREE.Matrix4}
   * @private
   */
function getNormalizingMatrix(model, bbox) {

  bbox = bbox || model.getData().bbox;

  var trans = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
  trans.makeTranslation(-bbox.min.x, -bbox.min.y, -bbox.min.z);

  var delta = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0).subVectors(bbox.max, bbox.min);
  var scale = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
  scale.makeScale(1 / delta.x, 1 / delta.y, 1);

  var res = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
  res.multiplyMatrices(scale, trans);
  return res;
}



var SceneMath = {
  box2CutPlanes: box2CutPlanes,
  getPixelsPerUnit: getPixelsPerUnit,
  intersectGroundViewport: intersectGroundViewport,
  getNormalizingMatrix: getNormalizingMatrix };

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = THREE;

/***/ })

/******/ });
//# sourceMappingURL=AEC.js.map