/*!
 * LMV v7.8.0
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.AEC =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/AEC/LibraryExports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!**********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./CanvasBookmark.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmark.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CanvasBookmarkExtension; });
/* harmony import */ var _CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasBookmarkIcons.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js");
/* harmony import */ var _CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CreateFrustumShape.js */ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js");
/* harmony import */ var _HCluster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HCluster.js */ "./extensions/AEC/CanvasBookmark/HCluster.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing,avp = av.Private,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.CanvasBookmarkExtension';

var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';





var VISIBILITY_PROP = 'canvasBookmarks';

// Name of the overlay scene that we use graphics overlays (frustum shapes)
var OverlayName = 'CanvasBookmark_Extension_Overlay';
var CutPlaneSetName = 'CanvasBookmark_CutPlanes';

// Interpolate between two given Matrix4 transforms. Note that this requires the transforms
// to be invertible combinations of pos/rotate/scale.
var lerpTransforms = function () {
  var startPos = new THREE.Vector3();
  var endPos = new THREE.Vector3();
  var startScale = new THREE.Vector3();
  var endScale = new THREE.Vector3();
  var startRotate = new THREE.Quaternion();
  var endRotate = new THREE.Quaternion();

  var pos = new THREE.Vector3();
  var scale = new THREE.Vector3();
  var rotate = new THREE.Quaternion();

  return function (startMatrix, endMatrix, t, dstTransform) {
    startMatrix.decompose(startPos, startRotate, startScale);
    endMatrix.decompose(endPos, endRotate, endScale);

    pos.lerpVectors(startPos, endPos, t);
    scale.lerpVectors(startScale, endScale, t);
    THREE.Quaternion.slerp(startRotate, endRotate, rotate, t);

    dstTransform.compose(pos, rotate, scale);

    return dstTransform;
  };
}();

// Interpolates between two bboxes. t is in [0,1]
var lerpBoxes = function lerpBoxes(startBox, endBox, t, dstBox) {
  dstBox.min.lerpVectors(startBox.min, endBox.min, t);
  dstBox.max.lerpVectors(startBox.max, endBox.max, t);
  lerpTransforms(startBox.transform, endBox.transform, t, dstBox.transform);
};

// Clone Box3 with attached transform
var cloneBox = function cloneBox(srcBox) {
  var box = srcBox.clone();
  box.transform = srcBox.transform ? srcBox.transform.clone() : new THREE.Matrix4();
  return box;
};

var setButtonVisible = function setButtonVisible(button, value) {
  requestAnimationFrame(function () {
    if (value) {
      button.container.classList.add('visible');
    } else
    {
      button.container.classList.remove('visible');
    }
  });
};var


CanvasBookmarkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(CanvasBookmarkExtension, _av$Extension);
  function CanvasBookmarkExtension(viewer, options) {var _this;_classCallCheck(this, CanvasBookmarkExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasBookmarkExtension).call(this, viewer, options));

    _this.viewer = viewer;

    _this.bookmarks = [];
    _this.clusteredBookmarks = [];

    _this.camera = _this.viewer.navigation.getCamera();
    _this.cameraMovedCB = _this.onCameraMoved.bind(_assertThisInitialized(_this));
    _this.onVisibilityChangedCB = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));

    // SectionBox animations
    _this.sectionBox = null; // SectionBox as defined by currently hovered bookmark (not changed during anims)
    _this.activeSectionBox = null; // Latest applied SectionBox
    _this.animStartSectionBox = null; // Used only during cutplane animations
    _this.animEndSectionBox = null; // Usually equal to this.sectionBox, but this.sectionBox may be null while animEndSectionBox is always valid during an animation
    _this.sectionBoxAnim = null; // AnimControl - only existing during animations

    // bookmarks visibility logic
    _this.changeBookmarksVisibility = _this.changeBookmarksVisibility.bind(_assertThisInitialized(_this));
    _this.changeBookmarksVisibilityTimeout = null;

    _this._clusteringEnabled = _this.options.clusterfck !== undefined;
    _this._clusteringThreshold = _this.options.clusteringThreshold || 110; // threshold is (icon_width * 5), depends on "THREE.Vector3.distanceTo()"

    // bookmarks clustering
    if (_this._clusteringEnabled) {
      _this.hcluster = new _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _this.options.clusterfck,
      function (b1, b2) {
        var _b1 = new THREE.Vector2(b1.currentPosProjected.x, b1.currentPosProjected.y);
        var _b2 = new THREE.Vector2(b2.currentPosProjected.x, b2.currentPosProjected.y);
        return _b2.distanceTo(_b1);
      },
      _this._clusteringThreshold);

    }

    _this._filterOutInvisibleBookmark = _this._filterOutInvisibleBookmark.bind(_assertThisInitialized(_this));

    _this.levelChangedCB = _this.onLevelChanged.bind(_assertThisInitialized(_this));

    _this.extensionLoadedCB = _this.onExtensionLoaded.bind(_assertThisInitialized(_this));return _this;
  }_createClass(CanvasBookmarkExtension, [{ key: "setBookmarksVisible", value: function setBookmarksVisible(

    visible) {
      this.bookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      this.clusteredBookmarks.forEach(function (b) {return setButtonVisible(b.marker, visible);});
      if (!visible) {
        this.stopGhosting();
      }
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }

      this.setBookmarksVisible(visible);

      if (visible) {
        this.updateBookmarkPositions();
      }
    } }, { key: "isVisible", value: function isVisible()

    {
      return this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);
    } }, { key: "onCameraMoved", value: function onCameraMoved()

    {
      this.setBookmarksVisible(false);
      this.debounceBookmarksVisibility();
    } }, { key: "createTooltip", value: function createTooltip(

    button, geomNode) {
      button.setToolTip(geomNode.name());
      button._toolTipElement.innerHTML = "<b>".concat(geomNode.name(), "</b>");
    } }, { key: "flyToBookmark", value: function flyToBookmark(

    bookmark) {
      var dstView = {
        position: bookmark.pos,
        target: bookmark.target,
        up: bookmark.up };

      this.anim = avp.flyToView(this.viewer, dstView, 1.0);
    }

    // geomNode is a BubbleNode of type GEOMETRY_NODE
  }, { key: "createBookmark", value: function createBookmark(geomNode) {var _this2 = this;

      // extract camera data (TODO: Add generic utility function to BubbleNode to read camera)
      var camera = geomNode.extractCamera();
      if (!camera) {
        return;
      }

      var pos = camera.position;
      var target = camera.target;

      // Consider refPointTransform:
      //    cameras are in local Revit coordinates. To support georeferencing, we apply the refPointTransform
      //    from aecModelData and finally subtract the viewer geoOffset
      var root = geomNode.getRootNode();
      var tfMatrix = root.extractRefPointTransform();

      if (this.options.globalOffset && tfMatrix) {

        // apply refPointTransform and globalOffset to pos and target
        pos.applyMatrix4(tfMatrix);
        pos.sub(this.options.globalOffset);
        target.applyMatrix4(tfMatrix);
        target.sub(this.options.globalOffset);
      }

      var dir = new THREE.Vector3(target.x - pos.x, target.y - pos.y, target.z - pos.z).normalize();
      var up = new THREE.Vector3(0, 0, 1);

      // IDs cannot start with numbers and have whitespaces
      var button = new Autodesk.Viewing.UI.Button("b-".concat(geomNode.name().replace(/\s/g, '')));

      // Configure style (TODO: Should move to css class or specified by client app)
      button.container.classList.add('canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createCameraIcon"])();
      setButtonVisible(button, this.isVisible());

      this.createTooltip(button, geomNode);

      this.viewer.container.appendChild(button.container);

      var buttonSize = button.getDimensions();

      var sectionBox = this.findSectionBox(geomNode, geomNode.name());
      var sectionBoxCenter = sectionBox ? sectionBox.center().applyMatrix4(sectionBox.transform) : null;

      var bookmark = {
        marker: button,
        pos: sectionBox ? sectionBoxCenter : pos,
        cameraPos: pos,
        dir: dir,
        up: up,
        target: target,
        name: geomNode.name(),

        // position within the marker that should be centered
        anchorX: buttonSize.width / 2,
        anchorY: buttonSize.height / 2,

        fadeValue: 0.0,
        hovered: false,
        bubbleNode: geomNode,

        clustered: false };


      button.container.addEventListener('mouseenter', function () {_this2.onBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this2.onBookmarkMouseLeave(bookmark);});

      button.addEventListener(avu.Button.Event.CLICK, function () {
        // pass to custom handler
        if (_this2.options && _this2.options.onBookmark) {
          _this2.options.onBookmark(bookmark.bubbleNode, camera);
        }
      });

      return bookmark;
    } }, { key: "createClusteredBookmark", value: function createClusteredBookmark(

    flattenCluster, id, visible) {var _this3 = this;
      var button = new Autodesk.Viewing.UI.Button(id);

      button.container.classList.add('clustered-canvas-bookmark');
      button.container.innerHTML = Object(_CanvasBookmarkIcons_js__WEBPACK_IMPORTED_MODULE_0__["createClusteredCameraIcon"])();

      setButtonVisible(button, this.isVisible() && visible);

      this.viewer.container.appendChild(button.container);

      var res = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].ComputeMeanValueForFlattenCluster(flattenCluster);

      var bookmark = {
        marker: button,
        name: id,

        pos: res.center3D,
        currentPosProjected: res.center2D,

        cluster: flattenCluster,

        fadeValue: 0.0,
        hovered: false,

        folded: true };


      button.container.addEventListener('mouseenter', function () {_this3.onClusteredBookmarkMouseEnter(bookmark);});
      button.container.addEventListener('mouseleave', function () {_this3.onClusteredBookmarkMouseLeave(bookmark);});
      button.addEventListener(avu.Button.Event.CLICK, function () {_this3.onClusteredBookmarkClicked(bookmark);});

      bookmark.marker.container.style.transform = "translate(".concat(res.center2D.x, "px, ").concat(res.center2D.y, "px)");
      this.clusteredBookmarks.push(bookmark);
    } }, { key: "deleteBookmark", value: function deleteBookmark(

    bookmark) {
      this.viewer.container.removeChild(bookmark.marker.container);
      this.hideFrustumShape(bookmark);
    } }, { key: "clearBookmarks", value: function clearBookmarks()

    {var _this4 = this;
      // Cancel any outdated anims or cutplanes
      this.stopSectionBoxAnim();
      this.applySectionBox();

      this.bookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.bookmarks = [];

      this.clusteredBookmarks.forEach(function (bm) {
        _this4.deleteBookmark(bm);
      });
      this.clusteredBookmarks = [];
    } }, { key: "resetBookmarks", value: function resetBookmarks(

    geomNodes) {var _this5 = this;

      this.clearBookmarks();
      if (!geomNodes) {
        return;
      }

      //The bookmarks make use of AECModelData, so we have to make sure we have that loaded.
      av.Document.getAecModelData(geomNodes).then(function () {

        for (var i = 0; i < geomNodes.length; i++) {
          var geomNode = geomNodes[i];
          var bookmark = _this5.createBookmark(geomNode);
          if (bookmark) {
            _this5.bookmarks.push(bookmark);
          }
        }

        _this5.bookmarkData = geomNodes;

        _this5.updateBookmarkPositions();
      });
    }

    // Create bookmarks with correct positions for the current geoOffset
  }, { key: "resetGlobalOffset", value: function resetGlobalOffset(globalOffset) {
      this.options.globalOffset = globalOffset;
      this.resetBookmarks(this.bookmarkData);
    } }, { key: "showFrustumShape", value: function showFrustumShape(

    bookmark) {
      if (bookmark.frustumShape) {
        return;
      }

      bookmark.frustumShape = Object(_CreateFrustumShape_js__WEBPACK_IMPORTED_MODULE_1__["createFrustumShape"])(bookmark.cameraPos, bookmark.dir);
      this.viewer.impl.addOverlay(OverlayName, bookmark.frustumShape);

      bookmark.frustumShape.name = bookmark.bubbleNode.name();

      // Make LMV recompute near/far plane, so that the frustum shape is considered
      // TODO: It would be easier if LMV would do that automatically, but it
      //       updates the camera only when rendering the scene.
      //       => Clarify if we can generally change that.
      this.viewer.impl.updateCameraMatrices();
    } }, { key: "hideFrustumShape", value: function hideFrustumShape(

    bookmark) {
      if (!bookmark.frustumShape) {
        return;
      }

      this.viewer.impl.removeOverlay(OverlayName, bookmark.frustumShape);
      bookmark.frustumShape = null;
    }

    // Controls the frustum fading. fadeValue is in [0,1]
  }, { key: "setFrustumFadeValue", value: function setFrustumFadeValue(bookmark, fadeValue) {
      bookmark.fadeValue = fadeValue;
      if (bookmark.frustumShape) {
        bookmark.frustumShape.setFadeValue(fadeValue);
      }
    }

    // Update fading of the frustum shape based on elpased time in ms.
  }, { key: "updateFrustumShapeFading", value: function updateFrustumShapeFading(bookmark, elapsed) {
      var FadeInDurationMs = 500;
      var FadeOutDurationMs = 500;

      var fadingIn = bookmark.hovered && bookmark.fadeValue < 1.0;
      var fadingOut = !bookmark.hovered && bookmark.fadeValue > 0.0;

      if (!fadingIn && !fadingOut) {
        return;
      }

      // compute amount of fading change (1.0 = full fade)
      var fadeInDelta = elapsed / FadeInDurationMs;
      var fadeOutDelta = elapsed / FadeOutDurationMs;
      var newValue = bookmark.fadeValue + (fadingIn ? fadeInDelta : -fadeOutDelta);

      newValue = THREE.Math.clamp(newValue, 0, 1);
      this.setFrustumFadeValue(bookmark, newValue);

      // HACK: Use css fade instead
      if (bookmark.marker && bookmark.marker._toolTipElement) {
        bookmark.marker._toolTipElement.style.opacity = Math.min(1, 3 * newValue);
      }

      // remove frustums if not used anymore
      if (!bookmark.hovered && bookmark.fadeValue === 0) {
        this.hideFrustumShape(bookmark);
      }

      this.viewer.impl.invalidate(false, false, true);
    } }, { key: "requestTimer", value: function requestTimer()

    {var _this6 = this;
      var _window = this.getWindow();
      this.timerId = _window.requestAnimationFrame(function () {return _this6.onTimer();});
    } }, { key: "onTimer", value: function onTimer()

    {var _this7 = this;
      // get elapsed time in ms
      var curTime = performance.now();
      var elapsed = curTime - this.lastTime;
      this.lastTime = curTime;

      this.bookmarks.forEach(function (bookmark) {
        _this7.updateFrustumShapeFading(bookmark, elapsed);
      });

      this.requestTimer();
    }

    // Returns an oriented box (THREE.Box3() + attached Matrix4 box.transform)
  }, { key: "findSectionBox", value: function findSectionBox(bubbleNode, name) {
      var viewNode = bubbleNode.search({ type: 'view' });

      if (!viewNode.length || viewNode[0].data.name !== name)
      return null;

      var sb = viewNode[0].data.sectionBox;
      var sbt = viewNode[0].data.sectionBoxTransform;

      if (!sb || !sbt)
      return null;

      var sbTransformMatrix = new THREE.Matrix4().fromArray([
      sbt[0], sbt[1], sbt[2], sbt[3],
      sbt[4], sbt[5], sbt[6], sbt[7],
      sbt[8], sbt[9], sbt[10], sbt[11],
      sbt[12], sbt[13], sbt[14], sbt[15]]);


      var box = new THREE.Box3();
      box.min.set(sb[0], sb[1], sb[2]);
      box.max.set(sb[3], sb[4], sb[5]);
      box.transform = new THREE.Matrix4();

      var tf = bubbleNode.getRootNode().getAecModelData().refPointTransformation;
      if (this.options.globalOffset && tf) {
        var offset = this.options.globalOffset;

        var geoTransformMatrix = av.BubbleNode.readMatrixFromArray12(tf);

        // Apply sectionBox rotation (if any), geoRefTransform, and finally the viewer offset.
        // Note that matrices must be multiplied in reverse order.
        box.transform.makeTranslation(-offset.x, -offset.y, -offset.z);
        box.transform.multiply(geoTransformMatrix);
        box.transform.multiply(sbTransformMatrix);
      }

      return box;
    }

    // The overlay scene contains the frustum shapes and is always visible by default. We only hide it temporarily
    // when baking an image for showin ghost floors
  }, { key: "setOverlaySceneVisible", value: function setOverlaySceneVisible(visible) {
      // Overlay may be null if this is currently unloaded
      var overlay = this.viewer.impl.overlayScenes[OverlayName];
      var scene = overlay && overlay.scene;
      if (scene) {
        scene.visible = visible;
      }
    } }, { key: "getFadeExtension", value: function getFadeExtension()

    {
      return this.viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Render models without SectionBox into fading target
  }, { key: "showGhosting", value: function showGhosting() {var _this8 = this;
      // Ghosting is an optional effect that requires the CrossFade extension. If we don't have it,
      // we omit ghosting, i.e., only apply the cutplanes for SectionBox previous.
      var fadeExt = this.getFadeExtension();
      if (!fadeExt) {
        return;
      }

      // Take control over CrossFade effect. Purpose is to avoid conflicts with other effects based on CrossFade. E.g., if we are
      // still showing ghost-floors from LevelsExtension, LevelsExtension will properly clean them up first.
      fadeExt.acquireControl('CanvasBookmarks', function () {return _this8.stopGhosting();});

      // If possible, reuse baked ghosting image from previous bookmark
      if (!this.ghostingActive) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName); // disable current SectionBox
        this.setOverlaySceneVisible(false); // make sure that we don't bake Frustum shapes into the screenshot
        fadeExt.renderFadingImage(0); // render snapshot into fading target
        this.applySectionBox(this.activeSectionBox); // recover current SectionBox
        this.setOverlaySceneVisible(true); // show overlay scene again (We don't hide it anywhere else, otherwise we would need to save/restore visibility state)
        this.ghostingActive = true;
      } else {
        // Reuse ghosting from before - just make sure that no fadeOut anim is in-progress
        this.stopGhostFadeOut();
      }
      fadeExt.setCrossFadeOpacity(0, 0.3); // overlay full model with ghost opacity
    } }, { key: "stopGhosting", value: function stopGhosting()

    {
      if (this.ghostingActive) {
        this.stopGhostFadeOut();
        var fadeExt = this.getFadeExtension();
        fadeExt && fadeExt.releaseFadingImage(0);
        this.ghostingActive = false;
      }
    } }, { key: "stopGhostFadeOut", value: function stopGhostFadeOut()

    {
      // skip fade-out animation if in progress
      if (this.ghostFadeAnim) {
        this.ghostFadeAnim.skip();
        this.ghostFadeAnim = null;
      }
    }

    // Fade-out cross-fade target containing the ghosted environment
  }, { key: "fadeOutGhosting", value: function fadeOutGhosting() {
      var fadeExt = this.getFadeExtension();
      if (!this.ghostingActive || !fadeExt) {
        // No ghosting active => nothing to do
        return;
      }

      var ghostAlpha = fadeExt.getCrossFadeOpacity(0);
      this.ghostFadeAnim = avp.fadeValue(ghostAlpha, 0.0, 0.5, function (t) {return fadeExt.setCrossFadeOpacity(0, t);});
    } }, { key: "onBookmarkMouseEnter", value: function onBookmarkMouseEnter(

    bookmark) {
      var sectionBox = this.findSectionBox(bookmark.bubbleNode, bookmark.name);
      if (sectionBox) {
        this.showGhosting();
        this.animateToSectionBox(sectionBox);
      }

      this.showFrustumShape(bookmark);
      bookmark.hovered = true;
    } }, { key: "onBookmarkMouseLeave", value: function onBookmarkMouseLeave(

    bookmark) {
      this.animateToSectionBox(null);
      this.fadeOutGhosting();
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkMouseEnter", value: function onClusteredBookmarkMouseEnter(

    bookmark) {
      bookmark.hovered = true;
    } }, { key: "onClusteredBookmarkMouseLeave", value: function onClusteredBookmarkMouseLeave(

    bookmark) {
      bookmark.hovered = false;
    } }, { key: "onClusteredBookmarkClicked", value: function onClusteredBookmarkClicked(

    bookmark) {
      // TODO:
      //   - Zoom + zoom level computation
      //   - "Too many" clustered bookmarks -> (n+1) icon should be "..."

      if (bookmark.folded) {
        var _rotate = function _rotate(vector, center, angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);

          var x = vector.x - center.x;
          var y = vector.y - center.y;

          vector.x = x * c - y * s + center.x;
          vector.y = x * s + y * c + center.y;
        };

        var n = bookmark.cluster.length;
        var alpha = Math.round(360.0 / n);

        var center = new THREE.Vector2(bookmark.currentPosProjected.x, bookmark.currentPosProjected.y);

        var start = new THREE.Vector2(center.x, center.y + 35);

        for (var i = 0; i < n; ++i) {
          var bm = bookmark.cluster[i];

          var current = start.clone();
          _rotate(current, center, i * alpha * Math.PI / 180.0);

          bm.currentPosProjected.x = current.x;
          bm.currentPosProjected.y = current.y;

          bm.marker.container.style.transform = "translate(".concat(current.x, "px, ").concat(current.y, "px)");
          setButtonVisible(bm.marker, true);
        }

        bookmark.marker.container.classList.add('declustered-canvas-bookmark');
      } else
      {
        bookmark.cluster.forEach(function (bm) {
          setButtonVisible(bm.marker, false);
        });

        bookmark.marker.container.classList.remove('declustered-canvas-bookmark');
      }

      bookmark.folded = !bookmark.folded;
    } }, { key: "debounceBookmarksVisibility", value: function debounceBookmarksVisibility()

    {
      if (this.changeBookmarksVisibilityTimeout) {
        clearTimeout(this.changeBookmarksVisibilityTimeout);
      }

      this.changeBookmarksVisibilityTimeout = setTimeout(this.changeBookmarksVisibility, 100);
    } }, { key: "changeBookmarksVisibility", value: function changeBookmarksVisibility()

    {
      this.updateBookmarkPositions();
    } }, { key: "updateBookmarkPositions", value: function updateBookmarkPositions()

    {var _this9 = this;
      if (!this.isVisible()) {
        return;
      }

      this.bookmarks.forEach(function (bookmark) {
        // Use cropBox center (if available) or camera position to choose label position
        var sBox = bookmark.bubbleNode.sectionBox;
        var pos3D = sBox ? sBox.center() : bookmark.pos;

        bookmark.currentPos3D = pos3D;

        // In-canvas coordinates
        var pos2D = _this9.project(pos3D);
        pos2D.x -= bookmark.anchorX;
        pos2D.y -= bookmark.anchorY;

        bookmark.currentPosProjected = new THREE.Vector3(pos2D.x, pos2D.y, pos2D.z);
        bookmark.marker.container.style.transform = "translate(".concat(pos2D.x, "px, ").concat(pos2D.y, "px)");
      });

      var clusters = this._clusteringEnabled ? this.hcluster.createClusters(this.bookmarks) : [];
      this.updateClusteredBookmarks(clusters);
    } }, { key: "updateClusteredBookmarks", value: function updateClusteredBookmarks(

    clusters) {var _this10 = this;
      // delete all "cluster" bookmarks since we create them all the time (by design), hiding will not really work
      this.clusteredBookmarks.forEach(function (bookmark) {
        _this10.deleteBookmark(bookmark);
      });
      this.clusteredBookmarks = [];

      // hide all bookmarks and reset "clustered" state
      this.bookmarks.forEach(function (bookmark) {
        setButtonVisible(bookmark.marker, false);
      });

      var floorSelector = this._getFloorSelector();
      var currentLevel = floorSelector && floorSelector.currentFloor;
      if (currentLevel !== undefined) {
        return;
      }

      var visibleBookamrks = this.bookmarks.filter(this._filterOutInvisibleBookmark);
      visibleBookamrks.forEach(function (bookmark) {
        bookmark.clustered = false;
        setButtonVisible(bookmark.marker, true);
      });

      for (var i = 0; i < clusters.length; i++) {
        var c = clusters[i];

        if (c.size > 1) {(function () {
            var flCluster = _HCluster_js__WEBPACK_IMPORTED_MODULE_2__["default"].FlattenCluster(c);

            var clusterBmVisible = false;
            flCluster.forEach(function (bookmark) {
              bookmark.clustered = true;
              if (!clusterBmVisible && bookmark.marker.isVisible()) {
                // if one of the included bookmarks is visible, mark the cluster bookmark as visible one
                clusterBmVisible = true;
              }
              // now, mark the included bookmark as invisible one
              setButtonVisible(bookmark.marker, false);
            });

            // IDs cannot start with some number
            _this10.createClusteredBookmark(flCluster, "c-".concat(flCluster[0].bubbleNode.data.viewableID), clusterBmVisible);})();
        }
      }
    } }, { key: "project", value: function project(

    position) {
      var containerBounds = this.viewer.navigation.getScreenViewport();
      var p = new THREE.Vector3().copy(position);

      var matrix = new THREE.Matrix4();
      matrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);

      p.applyProjection(matrix);

      return new THREE.Vector3(
      Math.round((p.x + 1) / 2 * containerBounds.width),
      Math.round((-p.y + 1) / 2 * containerBounds.height),
      p.z);

    } }, { key: "load", value: function load()

    {

      this.viewer.prefs.add(VISIBILITY_PROP, true);

      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.addEventListener(Autodesk.AEC.FloorSelector.CURRENT_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.addEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // handle the case when this extension is loaded after LevelsExtension is loaded,
      // without making this extension known to LevelsExtension
      this.updateBookmarkPositions();

      this.viewer.impl.createOverlayScene(OverlayName);

      // trigger timer-calls for fading animations
      this.lastTime = performance.now();
      this.requestTimer();

      if (!this.updateSettingsPanel) {
        //We need to connect this to an event that happens after the settings panel has been
        //create by the load sequence. The toolbar created event is serving that purpose.
        this.updateSettingsPanel = this.configureSettings.bind(this);
        this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
      }

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.clearBookmarks();

      this.viewer.impl.removeOverlayScene(OverlayName);

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);

      var floorSelector = this._getFloorSelector();
      if (floorSelector) {
        floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.CURRENT_FLOOR_CHANGED, this.levelChangedCB);
      }

      this.viewer.removeEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadedCB);

      // Stop timer for position updates
      if (this.timerId) {
        var _window = this.getWindow();
        _window.cancelAnimationFrame(this.timerId);
        this.timerId = null;
      }

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      return true;
    } }, { key: "applySectionBox", value: function applySectionBox(

    box) {
      this.activeSectionBox = box;

      // No box => clear cutplanes
      if (!box) {
        this.viewer.impl.setCutPlaneSet(CutPlaneSetName);
        return;
      }

      var planes = avp.SceneMath.box2CutPlanes(box, box.transform);
      this.viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // get bbox of all visible models
  }, { key: "getModelBox", value: function getModelBox() {
      var mq = this.viewer.impl.modelQueue();
      var models = mq.getModels();

      var box = new THREE.Box3();
      for (var i = 0; i < models.length; i++) {
        box.union(models[i].getBoundingBox());
      }

      return box;
    } }, { key: "stopSectionBoxAnim", value: function stopSectionBoxAnim()

    {
      if (this.sectionBoxAnim) {
        this.sectionBoxAnim.stop();
        this.sectionBoxAnim = null;
      }
    } }, { key: "animateToSectionBox", value: function animateToSectionBox(

    newBox) {var _this11 = this;
      // Nothing to animate
      if (!newBox && !this.activeSectionBox) {
        return;
      }

      // Don't allow overlapping animations
      this.stopSectionBoxAnim();

      var CutPlaneAnimInSeconds = 0.5;

      // Start at latest SectionBox state or with the whole model
      this.animStartBox = this.activeSectionBox ? cloneBox(this.activeSectionBox) : cloneBox(this.getModelBox());
      this.animEndBox = newBox ? cloneBox(newBox) : cloneBox(this.getModelBox());

      // Set target box
      this.sectionBox = newBox;

      // interpolated box used during anim
      var tmpBox = new THREE.Box3();
      tmpBox.transform = new THREE.Matrix4();

      var onUpdate = function onUpdate(t) {
        t = avp.smootherStep(t);
        lerpBoxes(_this11.animStartBox, _this11.animEndBox, t, tmpBox);
        _this11.applySectionBox(tmpBox);
      };

      var onFinished = function onFinished() {
        _this11.applySectionBox(_this11.sectionBox);
        _this11.sectionBoxAnim = null;
      };

      this.sectionBoxAnim = avp.fadeValue(0, 1, CutPlaneAnimInSeconds, onUpdate, onFinished);
    } }, { key: "enableClustering", value: function enableClustering(

    value) {
      if (this._clusteringEnabled !== value) {
        this._clusteringEnabled = value;
        this.updateClusteredBookmarks([]);
      }
    } }, { key: "setClusteringThreshold", value: function setClusteringThreshold(

    value) {
      if (this._clusteringThreshold !== value) {
        this._clusteringThreshold = value;
        this.hcluster.setThreshold(value);
        this.updateClusteredBookmarks([]);
      }
    } }, { key: "_filterOutInvisibleBookmark", value: function _filterOutInvisibleBookmark(

    bm) {
      var vp = this.viewer.navigation.getScreenViewport();

      if (bm.currentPosProjected.x < 0 || bm.currentPosProjected.x > vp.width) {
        return false;
      }

      if (bm.currentPosProjected.y < 0 || bm.currentPosProjected.y > vp.height) {
        return false;
      }

      var viewingDirection = this.camera.target.clone().sub(this.camera.position);
      var bookmarkDirection = bm.pos.clone().sub(this.camera.position);
      return viewingDirection.dot(bookmarkDirection) > 0;
    } }, { key: "onLevelChanged", value: function onLevelChanged()

    /*event*/{
      this.updateBookmarkPositions();
    } }, { key: "onExtensionLoaded", value: function onExtensionLoaded(

    event) {
      if (event.extensionId === LEVEL_EXT) {
        this.updateBookmarkPositions();
      }
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return;

      var panel = this.viewer.getSettingsPanel(true);

      if (!panel.is3dMode)
      return;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "Location Icons");

      // add toggle to the hypermodeling tab of the viewer settings
      if (panel && !panel.showLocationIconsChkBoxId) {
        panel.showLocationIconsChkBoxId = panel.addCheckbox(
        navTab,
        "Show location icons",
        "Toggles availability of the location icons when looking at the project model",
        true,
        this.onVisibilityChangedCB,
        VISIBILITY_PROP);

      }
    } }, { key: "_getFloorSelector", value: function _getFloorSelector()

    {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      return levelExt && levelExt.floorSelector;
    } }]);return CanvasBookmarkExtension;}(av.Extension);



namespace.CanvasBookmarkExtension = CanvasBookmarkExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CanvasBookmarkExtension);

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js":
/*!**************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CanvasBookmarkIcons.js ***!
  \**************************************************************/
/*! exports provided: createCameraIcon, createClusteredCameraIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCameraIcon", function() { return createCameraIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createClusteredCameraIcon", function() { return createClusteredCameraIcon; });

function createCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 114 114">',
  '<defs>',
  '<path id="camera-view-icon-3-with-shadow-v3-b" d="M60.934065,73.4602645 C54.1164768,73.4602645 48.5886781,67.9324658 48.5886781,61.1148776 C48.5886781,54.2963836 54.1164768,48.7694907 60.934065,48.7694907 C67.752559,48.7694907 73.2803577,54.2963836 73.2803577,61.1148776 C73.2803577,67.9324658 67.752559,73.4602645 60.934065,73.4602645 M78.7230158,42.834104 C77.2575106,42.9581919 75.7711731,42.808743 74.2984219,42.8748628 C73.4714712,42.9119986 72.9388896,42.637556 72.4470667,41.9817922 C70.947143,39.9827997 69.3693246,38.0417751 67.8621549,36.0491228 C67.287003,35.2873862 66.5959149,34.9939228 65.6521223,35.0029804 C62.0046628,35.0355874 58.354486,35.0401161 54.7070265,35.0002631 C53.7097946,34.9893941 53.0033088,35.3145587 52.4046073,36.1116196 C50.9028721,38.1088007 49.382116,40.0951128 47.7852769,42.0171165 C47.4311283,42.4437253 46.748192,42.7707014 46.1884378,42.8187062 C44.8515493,42.9346424 43.4974514,42.855842 41.9640149,42.855842 C41.9640149,42.2091358 41.9929989,41.6520989 41.9576746,41.0995907 C41.8897433,40.036239 41.3046281,39.4293858 40.2331246,39.4112707 C38.5112919,39.381381 36.7894591,39.3759465 35.0676263,39.4130822 C33.9934056,39.4366318 33.4291227,40.057977 33.3892696,41.1303863 C33.3693431,41.6557219 33.3856466,42.1819632 33.3856466,42.8078372 C31.121269,42.9074698 29.8523117,44.2289606 29,46.07941 L29,75.8722796 C30.0434252,78.4165343 31.9636175,79.1737422 34.6482636,79.1583444 C49.3911736,79.0686751 64.1340835,79.0713923 78.8769935,79.1556272 C81.5299383,79.1710249 83.372236,78.3377339 84.4011692,75.8722796 L84.4011692,46.07941 C83.3332887,43.5523646 81.4058504,42.6067605 78.7230158,42.834104"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-a" width="125.3%" height="131.7%" x="-12.6%" y="-11.3%" filterUnits="objectBoundingBox">',
  '<feOffset dy="2" in="SourceAlpha" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '<path id="camera-view-icon-3-with-shadow-v3-d" d="M104.440851,57.2204256 C104.440851,83.2997158 83.2997158,104.440851 57.2204256,104.440851 C31.1411354,104.440851 10,83.2997158 10,57.2204256 C10,31.1411354 31.1411354,10 57.2204256,10 C83.2997158,10 104.440851,31.1411354 104.440851,57.2204256 Z"/>',
  '<filter id="camera-view-icon-3-with-shadow-v3-c" width="125.5%" height="125.5%" x="-12.8%" y="-10.6%" filterUnits="objectBoundingBox">',
  '<feMorphology in="SourceAlpha" operator="dilate" radius="5.045" result="shadowSpreadOuter1"/>',
  '<feOffset dy="2" in="shadowSpreadOuter1" result="shadowOffsetOuter1"/>',
  '<feMorphology in="SourceAlpha" radius="5.045" result="shadowInner"/>',
  '<feOffset dy="2" in="shadowInner" result="shadowInner"/>',
  '<feComposite in="shadowOffsetOuter1" in2="shadowInner" operator="out" result="shadowOffsetOuter1"/>',
  '<feGaussianBlur in="shadowOffsetOuter1" result="shadowBlurOuter1" stdDeviation="2"/>',
  '<feColorMatrix in="shadowBlurOuter1" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0  0 0 0 0.1 0"/>',
  '</filter>',
  '</defs>',
  '<g fill="none" fill-rule="evenodd">',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-a)" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<use fill="currentColor" xlink:href="#camera-view-icon-3-with-shadow-v3-b"/>',
  '<g>',
  '<use fill="#000" filter="url(#camera-view-icon-3-with-shadow-v3-c)" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '<use stroke="currentColor" stroke-width="10.09" xlink:href="#camera-view-icon-3-with-shadow-v3-d"/>',
  '</g>',
  '</g>',
  '</svg>'].
  join('');
}

function createClusteredCameraIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 652 598">',
  '<path fill="currentColor" d="M254.7,94.3A157.6,157.6,0,1,0,412.3,251.9,157.6,157.6,0,0,0,254.7,94.3ZM173.6,281.4a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,173.6,281.4Zm86.6,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,260.2,281.4Zm86.7,0a24.2,24.2,0,1,1,23.9-24.2A23.8,23.8,0,0,1,346.9,281.4Z"/>',
  '<circle fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="42.87px" cx="256" cy="256" r="221.5" transform="translate(-101.8 200.6) rotate(-36.2)"/>',
  '</svg>'].
  join('');
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/CreateFrustumShape.js":
/*!*************************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/CreateFrustumShape.js ***!
  \*************************************************************/
/*! exports provided: createFrustumShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFrustumShape", function() { return createFrustumShape; });


// Returns a THREE.Scene to represent the camera frustum
function createFrustumShape(pos, dir) {
  // The frustum shape is a symbol to explain pos and dir - not the exact frustum.
  var FovVert = 17;
  var FovHor = 17;

  // Frustum shape/outline opacity when fully faded in
  var FrustumOpacity = 0.05;
  var LineOpacity = 1.0;

  var radians = THREE.Math.degToRad;
  var dx = Math.sin(radians(FovHor));
  var dy = Math.sin(radians(FovVert));

  // compute z in a way that the results are normalized
  var dz = Math.sqrt(1 - dx * dx - dy * dy);

  // compute directions for the 4 frustum-corners
  var bottomLeft = new THREE.Vector3(-dx, -dy, dz);

  var bottomRight = new THREE.Vector3(dx, -dy, dz);
  var topLeft = new THREE.Vector3(-dx, dy, dz);
  var topRight = new THREE.Vector3(dx, dy, dz);

  // create mesh vertices: 4 corners + origin
  var vertices = new Float32Array([
  bottomLeft.x, bottomLeft.y, bottomLeft.z,
  bottomRight.x, bottomRight.y, bottomRight.z,
  topLeft.x, topLeft.y, topLeft.z,
  topRight.x, topRight.y, topRight.z,
  0, 0, 0]);


  var bl = 0;
  var br = 1;
  var tl = 2;
  var tr = 3;
  var p0 = 4; // index of camera position vertex

  var indices = new Uint32Array([
  p0, br, bl, // bottom face
  p0, tr, br, // right face
  p0, tl, tr, // top face
  p0, bl, tl, // left face
  bl, br, tr, // far face lower tri
  bl, tr, tl // face face upper tri
  ]);

  // Extract vertices to non-indexed, so that we can compute face-normals
  var vertsNonIndexed = new Float32Array(3 * indices.length);
  for (var i = 0; i < indices.length; i++) {
    var index = indices[i];
    vertsNonIndexed[3 * i] = vertices[3 * index];
    vertsNonIndexed[3 * i + 1] = vertices[3 * index + 1];
    vertsNonIndexed[3 * i + 2] = vertices[3 * index + 2];
  }

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(vertsNonIndexed, 3));

  geometry.computeVertexNormals();

  var material = new THREE.MeshPhongMaterial({
    color: 0x5050FF,
    transparent: true,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending });


  var mesh = new THREE.Mesh(geometry, material);

  // create frustum lines
  var lineIndices = new Uint32Array([
  p0, bl,
  p0, br,
  p0, tr,
  p0, tl,
  bl, br,
  br, tr,
  tr, tl,
  tl, bl]);


  var lineGeom = new THREE.BufferGeometry();
  lineGeom.addAttribute('index', new THREE.BufferAttribute(lineIndices, 1));
  lineGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  lineGeom.isLines = true;

  var lineMaterial = new THREE.LineBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    side: THREE.DoubleSide,
    opacity: 0.0, // will change with fade-in
    depthTest: false,
    depthWrite: false,
    blending: THREE.NoBlending // NOTE: Overlay target is blended anyway. So, using blend here would blend with black.
  });

  var lineMesh = new THREE.Mesh(lineGeom, lineMaterial);

  // Create THREE Scene and add meshes
  var scene = new THREE.Scene();
  scene.add(mesh);
  scene.add(lineMesh);

  // Workaround: Tag geometry as visible - otherwise it is skipped by computeObjectBounds (see Viewer3DImpl).
  // TODO: My guess is that this is a bug in LMV. Once we know for sure that it doesn't break anything
  //       we should change it in LMV instead and don't need to set this manually anymore.
  geometry.visible = true;
  lineGeom.visible = true;

  // Makes it more debugger-friendly (allow you to recognize this shape within LMV)
  mesh.name = 'FrustumGizmo';

  // Set frustum shape size
  // TODO: Consider smarter way to determine size, e.g. consider model units or model box
  var size = 50;
  scene.scale.set(size, size, size);

  // move tip of the frustum to camera position
  scene.position.copy(pos);

  // orient frustum shape to look towards camera direction
  var origin = new THREE.Vector3(0, 0, 0);
  var up = new THREE.Vector3(0, 0, 1);
  var invDir = new THREE.Vector3(-dir.x, -dir.y, -dir.z); // lookat directions in THREE are defined 'towards' an object
  var rotationMatrix = new THREE.Matrix4().lookAt(origin, invDir, up);
  scene.rotation.setFromRotationMatrix(rotationMatrix);

  // Just disable culling - it's not worth to care about computing BoundingSpheres etc.
  scene.frustumCulled = false;
  mesh.frustumCulled = false;
  lineMesh.frustumCulled = false;

  // Attach function to control overall opacity (fadeValue is in [0,1])
  scene.setFadeValue = function (fadeValue) {
    material.opacity = FrustumOpacity * fadeValue;
    lineMaterial.opacity = LineOpacity * fadeValue;
  };

  return scene;
}

/***/ }),

/***/ "./extensions/AEC/CanvasBookmark/HCluster.js":
/*!***************************************************!*\
  !*** ./extensions/AEC/CanvasBookmark/HCluster.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HCluster; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var

HCluster = /*#__PURE__*/function () {_createClass(HCluster, null, [{ key: "FlattenCluster", value: function FlattenCluster(
    c) {var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (c.value) {
        values.push(c.value);
      } else
      {
        HCluster.FlattenCluster(c.left, values);
        HCluster.FlattenCluster(c.right, values);
      }

      return values;
    } }, { key: "ComputeMeanValueForFlattenCluster", value: function ComputeMeanValueForFlattenCluster(

    c) {
      var bbox2D = new THREE.Box3();
      var bbox3D = new THREE.Box3();

      c.forEach(function (b) {
        bbox2D.expandByPoint(b.currentPosProjected);
        bbox3D.expandByPoint(b.currentPos3D);
      });

      return {
        center2D: bbox2D.center(),
        center3D: bbox3D.center() };

    } }]);

  function HCluster(clusterfck, distanceFunc) {var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;_classCallCheck(this, HCluster);
    this._clusterfck = clusterfck;
    this.setDistanceFuncAndThreshold(distanceFunc, threshold);
  }_createClass(HCluster, [{ key: "setDistanceFuncAndThreshold", value: function setDistanceFuncAndThreshold(

    distanceFunc) {var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      this._distanceFunc = distanceFunc;
      this._threshold = threshold;
    } }, { key: "setThreshold", value: function setThreshold(

    threshold) {
      this._threshold = threshold;
    } }, { key: "createClusters", value: function createClusters(

    clusterItems) {
      var clusters = this._clusterfck.hcluster(clusterItems, this._distanceFunc, this._clusterfck.AVERAGE_LINKAGE, this._threshold);
      //console.log(clusters);

      return clusters;
    } }]);return HCluster;}();

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.css":
/*!******************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.css ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./DropMe.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMe.js":
/*!*****************************************!*\
  !*** ./extensions/AEC/DropMe/DropMe.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeExtension; });
/* harmony import */ var _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DropMeTool.js */ "./extensions/AEC/DropMe/DropMeTool.js");
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var av = Autodesk.Viewing,avu = Autodesk.Viewing.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.DropMeExtension';var

DropMeExtension = /*#__PURE__*/function (_av$Extension) {_inherits(DropMeExtension, _av$Extension);
  function DropMeExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { teleportOnRelease: true };_classCallCheck(this, DropMeExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropMeExtension).call(this, viewer, options));
    _this.teleportOnRelease = options.teleportOnRelease; // teleportOnRelease used by default, not used on mobile apps.
    _this.viewer = viewer;
    _this._onModelLoaded = _this._onModelLoaded.bind(_assertThisInitialized(_this));
    _this._deactivateTool = _this._deactivateTool.bind(_assertThisInitialized(_this));
    _this.onDropOverride = null;
    _this.options = options;
    _this.options.triggerDeactivate = _this._deactivateTool;
    _this.options.isSupportedViewport = DropMeExtension.IsSupportedViewport;
    _this.toggleIndex = options.toggleIndex || 0; // at which position at the toolbar to toggle DropMe button
    _this.enableGuidance = options.enableGuidance || false;
    _this.dropMeTool = new _DropMeTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](viewer, function () {var _this2;return (_this2 = _this)._onDrop.apply(_this2, arguments);}, _this.options);return _this;
  }_createClass(DropMeExtension, [{ key: "load", value: function load()

    {
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
      if (this.viewer.model) {
        this._initUI(this.viewer.model);
      }
      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._onModelLoaded);
      this.viewer.toolController.setIsLocked(false);
      this._deactivateTool();
      this._destroyUI();
      return true;
    } }, { key: "setOnDrop", value: function setOnDrop(

    cb) {
      this.onDropOverride = cb;
    } }, { key: "_destroyUI", value: function _destroyUI()

    {
      this._showDrop(false);

      if (this.dropMeButton) {
        this.dropMeButton.removeFromParent();
        this.dropMeButton = null;
      }
    } }, { key: "_onDrop", value: function _onDrop(

    pos, dir, mode) {
      // after drop action had been triggered, we need to deactivate tool as we are transitioning into another view.
      if (this.teleportOnRelease) {
        this.viewer.toolController.setIsLocked(false);
        this._deactivateTool();
      }

      console.log("DropMe: 3D camera position is ".concat(JSON.stringify(pos)));
      console.log("DropMe: 3D camera direction is ".concat(JSON.stringify(dir)));

      if (this.onDropOverride) {
        this.onDropOverride(pos, dir, mode);
      } else if (this.options.onDrop) {
        this.options.onDrop(pos, dir, mode);
      } else {
        console.warn('DropMe: No onDrop callback specified ');
      }
    } }, { key: "_onModelLoaded", value: function _onModelLoaded(

    event) {
      if (!this.uiInitialized) {
        this._initUI(event.model);
      } else {
        this._updateUI(event.model);
      }
    } }, { key: "_deactivateTool", value: function _deactivateTool()

    {
      // UI might not be initialized yet. E.g., this can happen if the extensionUnload happens
      // before a model was added. In this case, dropMeButton and guidance UI will not exist anyway.
      if (this.uiInitialized) {
        this._showGuidenaceUI(false);
        this.dropMeButton.setState(avu.Button.State.INACTIVE);
      }
      this.viewer.toolController.deactivateTool('drop-me');
    } }, { key: "isSupportedModel", value: function isSupportedModel(

    model) {
      var is2dAEC = model && model.isAEC && model.isAEC() && model.is2d() && !model.isPdf();
      if (!is2dAEC) {
        return false;
      }

      if (!model.getDocumentNode()) {
        return false;
      }

      var viewports = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].findViewportsOnSheet(model);

      // Here we are just checking whether it makes sense to start working with this model by checking that
      // at least one viewport is fine
      return viewports.length && viewports.find(DropMeExtension.IsSupportedViewport);
    } }, { key: "_updateUI", value: function _updateUI(











    model) {
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();
      if (!toolbar) {
        return;
      }

      this.dropMeButton.removeFromParent();

      var modelTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);
      modelTools.addControl(this.dropMeButton, { index: this.toggleIndex });
      this._showDrop(this.isSupportedModel(model));
    } }, { key: "_initUI", value: function _initUI(

    model) {var _this3 = this;
      // There is no need for this function when getToolbar doesn't exist (headless viewer).
      var toolbar = this.viewer.getToolbar && this.viewer.getToolbar();

      if (!toolbar) {
        return;
      }

      this.dropMeButton = new avu.Button('drop-me-icon');
      this.dropMeButton.icon.innerHTML = createDropMeIcon();

      this._updateUI(model);
      this.dropMeButton.onClick = function () {
        if (_this3.dropMeTool.active) {
          _this3._deactivateTool();
        } else {
          _this3.dropMeButton.setState(avu.Button.State.ACTIVE);
          // TODO: when we activate tool we might want to forbid interaction with other tools
          _this3.viewer.toolController.activateTool('drop-me');
          _this3._showGuidenaceUI();
        }
      };
      this.uiInitialized = true;
    } }, { key: "_showGuidenaceUI", value: function _showGuidenaceUI()

    {var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.enableGuidance)
      return;

      if (show) {
        var _document = this.getDocument();
        this.guidenaceUI = _document.createElement('div');
        this.guidenaceUI.className = 'dropme-guidenace-ui';
        this.guidenaceUI.innerHTML = Autodesk.Viewing.i18n.translate('Click on a location to ground yourself, then select a camera direction');
        this.viewer.container.appendChild(this.guidenaceUI);
      } else {
        if (this.viewer.container.contains(this.guidenaceUI)) {
          this.viewer.container.removeChild(this.guidenaceUI);
        }
      }
    } }, { key: "_showDrop", value: function _showDrop(

    value) {
      if (!this.dropMeButton) {
        return;
      }

      var toolbar = this.viewer.getToolbar();
      var modelTools = toolbar.getControl(av.TOOLBAR.NAVTOOLSID);

      if (modelTools && !this.container) {
        this.dropMeButton.setState(value ? avu.Button.State.INACTIVE : avu.Button.State.DISABLED);
      }
      var supportedTooltip = Autodesk.Viewing.i18n.translate('Click a 2D location to view that space in 3D');
      var unsupportedTooltip = Autodesk.Viewing.i18n.translate('Current view is not supported by Place Me');

      this.dropMeButton.setToolTip(value ? supportedTooltip : unsupportedTooltip);
    } }], [{ key: "IsSupportedViewport", value: function IsSupportedViewport(vp) {// For FloorPlans, we want to place the camera in pedestrian perspective. 
      // For this, we require to find a linked level to determine z-elevation.
      var hasLevelGuid = Boolean(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].getLinkedLevel(vp));var levelMissing = vp.viewType === 'FloorPlan' && !hasLevelGuid;return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].supports2DTo3DTransform(vp) && !levelMissing;} }]);return DropMeExtension;}(av.Extension);
var createDropMeIcon = function createDropMeIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">',
  '<g stroke="currentColor" fill="currentColor">',
  '<path d="M67,0c2.4.5,4.8.9,7.1,1.6C87.5,5.3,96.6,16.6,98,31a37.2,37.2,0,0,1-2.1,16.2c-4.7,13-23.6,48.1-31.6,58.2-.3-.2-.6-.3-.8-.5-11.1-17.6-21.9-35.4-30-54.7-4.6-10.9-4.6-21.7.6-32.3S47.5,2.6,58.3.7l3-.7ZM64,47A11.8,11.8,0,1,0,52.3,34.9,12,12,0,0,0,64,47Z"/>',
  '<path d="M12.8,103.4c1.4-8,6.9-12.3,14-14.6s12-2.9,18.1-4.2c1.1-.2,2.4.5,3.4,1.5-4.5,1.1-9.1,1.8-13.5,3.3a35,35,0,0,0-9.6,5c-4,3-4.3,7.5-.7,10.9a28.7,28.7,0,0,0,9.6,6.2,87.3,87.3,0,0,0,59.9.1,28.2,28.2,0,0,0,8.7-5.2c4.9-4.1,4.8-9.7-.8-12.8S90.7,89.3,85,87.3c-1.6-.6-3.4-.6-5.3-1.7,1.1-.4,2.2-1.2,3.2-1.1,7.8.9,15.5,2.2,22.6,6,12,6.4,13,17.9,2.1,26.1-8.1,6.1-17.6,8.5-27.4,10L69.1,128H59.2l-5.2-.7c-9.1-.8-18-2.6-26.4-6.5s-13.4-8.1-14.9-16.8Z"/>',
  '</g>',
  '</svg>'].
  join('');
};

namespace.DropMeExtension = DropMeExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, DropMeExtension);

/***/ }),

/***/ "./extensions/AEC/DropMe/DropMeTool.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/DropMe/DropMeTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DropMeTool; });
/* harmony import */ var _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewPortOverlay.js */ "./extensions/AEC/DropMe/ViewPortOverlay.js");
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}




var av = Autodesk.Viewing,avp = av.Private;
var GlobalManagerMixin = av.GlobalManagerMixin;

var DROPME_MODE = { auto: 'Auto', manual: 'Manual' };var

DropMeTool = /*#__PURE__*/function (_av$ToolInterface) {_inherits(DropMeTool, _av$ToolInterface);
  function DropMeTool(viewer, onDrop, options) {var _this;_classCallCheck(this, DropMeTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropMeTool).call(this));

    _this.names = ['drop-me'];
    _this.viewer = viewer;
    _this.setGlobalManager(_this.viewer.globalManager);
    _this.options = options;
    if (_this.options.teleportOnRelease === undefined) {
      _this.options.teleportOnRelease = true; // Set true by default
    }
    _this.viewer.toolController.registerTool(_assertThisInitialized(_this));
    _this.onDrop = onDrop;
    _this.active = false;
    _this._movedSinceFirstClick = false;
    _this.init();

    _this.cameraSelectionState = {
      pending: false,
      pos: null,
      target: null,
      inViewport: false,
      initialVp: null };


    _this.teleportationInProgress = 0;

    // 'False' indicates if the user has clicked a first time alredy to choose position, so that the
    // next click will determine view-direction and instantly invoke the transition.
    _this.isFirstClick = true;

    _this.viewPortOverlay = new _ViewPortOverlay_js__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer);
    _this.escapeHotkeyId = 'Autodesk.AEC.DropMeToolEsc';return _this;
  }_createClass(DropMeTool, [{ key: "init", value: function init()

    {var _this2 = this;

      this.activate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.setGestureParameter('drag', 'threshold', 0);
        }

        var hotkeys = [{
          keycodes: [
          Autodesk.Viewing.KeyCode.ESCAPE],

          onRelease: function onRelease() {return _this2.options.triggerDeactivate && _this2.options.triggerDeactivate();} }];

        _this2.viewer.getHotkeyManager().pushHotkeys(_this2.escapeHotkeyId, hotkeys);
        _this2.viewer.addEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(true);
        _this2.active = true;
      };

      this.deactivate = function () {
        var gestureHandler = _this2.viewer.toolController.getTool("gestures");
        if (gestureHandler) {
          gestureHandler.restoreGestureParameterDefault('drag', 'threshold');
        }

        _this2.viewer.getHotkeyManager().popHotkeys(_this2.escapeHotkeyId);
        _this2._cancelTeleportation();
        _this2._destroyCameraSelectorUi();
        _this2.viewer.removeEventListener(av.MODEL_ADDED_EVENT, _this2.options.triggerDeactivate);
        _this2.viewer.impl.pauseHighlight(false);
        _this2.active = false;
        _this2._movedSinceFirstClick = false;
      };

      this.handleButtonDown = function (event) {
        return true;
      };

      this.handleButtonUp = function (event) {
        if (!this._movedSinceFirstClick || this.isFirstClick) {
          return false;
        }
        return true;
      };

      this.handleSingleClick = function (e, isTouch) {
        if (_this2.isFirstClick) {
          var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);
          if (tmpres && tmpres.pos) {
            _this2.cameraSelectionState.pos = { x: e.canvasX, y: e.canvasY };
            _this2.cameraSelectionState.pending = true;
            _this2.cameraSelectionState.initialVp = tmpres.vp;

            _this2._createCameraSelectorUi(_this2.cameraSelectionState.pos);

            requestAnimationFrame(function () {
              // We should only trigger animation if mouse has not been moved since the first click.
              if (!_this2._movedSinceFirstClick)
              _this2.cameraSelectorPosition.classList.add('camera-selector-position--teleporting');
            });

            if (tmpres.vp.viewType !== 'Section' && !isTouch) {
              // while teleportation is pending this.handleMouseMove will move camera frustum
              _this2._scheduleTeleportation();

              // needed only for scheduled teleportation
              _this2.isFirstClick = false;
              _this2.cursor = 'none';
              _this2.getCursor();
            } else
            {
              _this2._runTeleportation(DROPME_MODE.auto);
            }
          }
        } else
        {
          if (_this2.options.teleportOnRelease) {
            _this2.teleport();
          }
        }

        // As expectation of single click is a teleportation to another view, we simply consume event and do not propogate it further
        return true;
      };

      this.teleport = function () {
        _this2.cameraSelectionState.target = { x: _this2.lastX, y: _this2.lastY };
        _this2._runTeleportation(DROPME_MODE.manual);
        _this2.isFirstClick = _this2.options.teleportOnRelease;
        _this2._movedSinceFirstClick = false;
        _this2._recoverCursor();
      };

      this.handleMouseMove = function (e) {
        if (!_this2.isFirstClick && !_this2._movedSinceFirstClick)
        _this2._movedSinceFirstClick = true;

        if (_this2.cursor)
        _this2._recoverCursor();

        var tmpres = _this2._get3DCameraPositionAndVp(e.canvasX, e.canvasY);

        if (_this2.cameraSelectionState.initialVp && !_this2.isFirstClick) {
          _this2._addVpOverlay(_this2.cameraSelectionState.initialVp);
        } else
        if (tmpres && tmpres.pos) {
          _this2._addVpOverlay(tmpres.vp);
        } else
        {
          _this2.viewPortOverlay.removeOverlay();
        }

        _this2.cameraSelectionState.inViewport = _this2.isFirstClick && tmpres && tmpres.pos || !_this2.isFirstClick;
        _this2.getCursor();

        if (!_this2.cameraSelectionState.pending) {
          return;
        }

        if (_this2.teleportationInProgress) {
          // cancel position animation
          _this2.cameraSelectorPosition.classList.remove('camera-selector-position--teleporting');
          clearTimeout(_this2.teleportationInProgress);
          _this2.teleportationInProgress = 0;
        }

        _this2.lastX = e.canvasX;
        _this2.lastY = e.canvasY;
        var dx = e.canvasX - _this2.cameraSelectionState.pos.x;
        var dy = e.canvasY - _this2.cameraSelectionState.pos.y;
        var angle = Math.atan2(dy, dx) * 180 / Math.PI;

        // In case the mouse moved:
        if (dx !== 0 || dy !== 0) {
          // atan measures the angle to the x-axis, but the frustum gizmo is originally aligned with y.
          angle += 90;
        }

        _this2.cameraSelector.style.transform = "rotate(".concat(angle, "deg)");

        if (!_this2.options.teleportOnRelease) {
          _this2.teleport();
        }

        //console.log(angle);
        return true;
      };

      this.handleSingleTap = function (event) {
        return this.handleSingleClick(event, true);
      };

      this.handleResize = function () {
        // As teleportation is going to be rather short interaction with a short-living UI, we just do not handle screen resize at all for now, but deactivate tool instead.
        _this2.options.triggerDeactivate && _this2.options.triggerDeactivate();
      };

      this.handleSingleTap = function (event, button) {
        if (_this2.isFirstClick) {
          _this2.handleSingleClick(event);
        } else {
          _this2.handleMouseMove(event);
        }
      };

      this.handleGesture = function (event) {
        switch (event.type) {
          case 'dragstart':
            break;
          case 'dragmove':
            return _this2.handleMouseMove(event, 0);
          case 'dragend':
            return true;
          case 'panmove':
          case 'panstart':
          case 'panend':
          case 'pinchmove':
          case 'pinchstart':
          case 'pinchend':
            return true;
          default:
            break;}


        return false;
      };
    } }, { key: "_recoverCursor", value: function _recoverCursor()

    {
      this.cursor = null;
      this.getCursor();
    } }, { key: "getCursor", value: function getCursor()

    {
      if (this.cursor)
      return this.cursor;
      return this.cameraSelectionState.inViewport ? 'cell' : 'default';
    } }, { key: "_addVpOverlay", value: function _addVpOverlay(

    vp) {
      this.viewPortOverlay.removeOverlay();
      var vpRect = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].getViewportBounds(vp, this.viewer.model.getUnitScale());
      var min = vpRect.min;
      var max = vpRect.max;
      this.viewPortOverlay.addOverlay(min.x, min.y, max.x, max.y);
    }

    // mode is only required for analytics purposes
  }, { key: "_runTeleportation", value: function _runTeleportation(mode) {
      this._mapToCameraPositionIn3D(mode);
      this._cancelTeleportation();
    } }, { key: "_scheduleTeleportation", value: function _scheduleTeleportation()

    {var _this3 = this;
      this.teleportationInProgress = setTimeout(function () {
        _this3._runTeleportation(DROPME_MODE.auto);
      }, 3000); // this timeout is alligned with coresponding rule of camera-selector-position css class
    } }, { key: "_cancelTeleportation", value: function _cancelTeleportation()

    {
      if (this.teleportationInProgress) {
        clearTimeout(this.teleportationInProgress);
        this.teleportationInProgress = 0;
      }
    } }, { key: "_createCameraSelectorUi", value: function _createCameraSelectorUi(

    pos) {
      //console.log(`camera position at ${pos.x}, ${pos.y}`);
      var _document = this.getDocument();
      this.cameraSelectorBackground = _document.createElement('div');
      this.cameraSelectorBackground.className = 'camera-selector-background';
      this.viewer.container.appendChild(this.cameraSelectorBackground);
      this.cameraSelectorBackground.style.top = "".concat(pos.y, "px");
      this.cameraSelectorBackground.style.left = "".concat(pos.x, "px");

      this.cameraSelectorPosition = _document.createElement('div');
      this.cameraSelectorPosition.className = 'camera-selector-position';
      this.viewer.container.appendChild(this.cameraSelectorPosition);
      this.cameraSelectorPosition.style.top = "".concat(pos.y - 10, "px");
      this.cameraSelectorPosition.style.left = "".concat(pos.x - 10, "px");

      this.cameraSelector = _document.createElement('div');
      this.cameraSelector.className = 'camera-selector';
      this.viewer.container.appendChild(this.cameraSelector);
      this.cameraSelector.style.top = "".concat(pos.y - 100, "px");
      this.cameraSelector.style.left = "".concat(pos.x - 50, "px");
    } }, { key: "_destroyCameraSelectorUi", value: function _destroyCameraSelectorUi()

    {
      if (this.viewer.container.contains(this.cameraSelector)) {
        this.viewer.container.removeChild(this.cameraSelector);
      }

      if (this.viewer.container.contains(this.cameraSelectorBackground)) {
        this.viewer.container.removeChild(this.cameraSelectorBackground);
      }

      if (this.viewer.container.contains(this.cameraSelectorPosition)) {
        this.viewer.container.removeChild(this.cameraSelectorPosition);
      }

      this.cameraSelectionState = {
        pending: false,
        pos: null,
        target: null,
        inViewport: false,
        initialVp: null };


      this.isFirstClick = true;

      this.viewPortOverlay.removeOverlay();
    }

    // Given F2D world coords (Vec3), this function returns the viewport that was hit.
  }, { key: "_findViewport", value: function _findViewport(f2dWorldPos) {
      var p2d = new THREE.Vector2(f2dWorldPos.x, f2dWorldPos.y);
      var sheet = this.viewer.model;
      return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].findViewportAtPoint(sheet, p2d, this.options.isSupportedViewport);
    } }, { key: "_mapToCameraPositionIn3DForFloorplan", value: function _mapToCameraPositionIn3DForFloorplan(

    pos, mode) {
      var posGeorefed = this._applyGeoRefTransform(pos);

      var dir = new THREE.Vector3(0.0, 1.0, 0.0);

      // in the case of not specified target, use north direction
      if (this.cameraSelectionState.target) {
        var x = this.cameraSelectionState.target.x;
        var y = this.cameraSelectionState.target.y;

        var resTarget = this._get3DCameraPositionAndVp(x, y, true);
        if (resTarget && resTarget.pos) {
          var targetGeorefed = this._applyGeoRefTransform(resTarget.pos);

          var dirX = targetGeorefed.x - posGeorefed.x;
          var dirY = targetGeorefed.y - posGeorefed.y;

          if (dirX !== 0 || dirY !== 0) {
            dir.setX(dirX).setY(dirY);
            dir.normalize();
          }
        }
      }

      // mimic natural looking direction which is not really parallel to the ground
      var rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
      dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

      this.onDrop(posGeorefed, dir, mode);
    } }, { key: "_mapToCameraPositionIn3DForSection", value: function _mapToCameraPositionIn3DForSection(

    pos, mode) {
      var posGeorefed = this._applyGeoRefTransform(pos);

      // by default we are looking into the north direction, in this case "into the screen"
      var dir = new THREE.Vector3(0.0, 1.0, 0.0);

      // mimic natural looking direction which is not really parallel to the ground
      var rotAxis = new THREE.Vector3(-dir.y, dir.x, 0.0);
      dir.applyAxisAngle(rotAxis, Math.PI / 18.0); // 10 degrees

      this.onDrop(posGeorefed, dir, mode);
    }

    // if we will come up with a good visualization widget for dir selection for "Section" views
    // the two methods "_mapToCameraPositionIn3DForFloorplan()" and "_mapToCameraPositionIn3DForSection()"
    // could be unified. we will still have two cases in "if (resTarget && resTarget.pos) {...}" code path
    //   1. FloorPlan: x,y - change, z - constant
    //   2. Section:   x - changes, y,z - constant
  }, { key: "_mapToCameraPositionIn3D", value: function _mapToCameraPositionIn3D() {var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DROPME_MODE.manual;
      var x = this.cameraSelectionState.pos.x;
      var y = this.cameraSelectionState.pos.y;
      var resPos = this._get3DCameraPositionAndVp(x, y);

      if (resPos && resPos.pos && resPos.vp) {
        if (resPos.vp.viewType === 'FloorPlan' || resPos.vp.viewType === 'EngineeringPlan' || resPos.vp.viewType === 'CeilingPlan') {
          this._mapToCameraPositionIn3DForFloorplan(resPos.pos, mode);
        } else
        if (resPos.vp.viewType === 'Section') {
          this._mapToCameraPositionIn3DForSection(resPos.pos, DROPME_MODE.auto);
        }
      }
    } }, { key: "_get3DCameraPositionAndVp", value: function _get3DCameraPositionAndVp(

    x, y) {var useInitialVp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var vpVec = this.viewer.impl.clientToViewport(x, y);
      var point = this.viewer.impl.intersectGroundViewport(vpVec);

      // if no viewport can be found for the current mouse position on a second click, try to use initial viewport
      var hitViewport = this._findViewport(point) || useInitialVp && this.cameraSelectionState.initialVp;
      if (!hitViewport) {
        // Clicked outside of the viewport
        // DropMe tool remains active and allows user to pick another point
        return null;
      }

      // Get aecData and unitScale for current sheet
      var model = this.viewer.model;
      var aec = model.getDocumentNode().getAecModelData();
      var sheetUnitScale = this.viewer.model.getUnitScale();

      // Apply 2D->3D transform to get 3D world coords
      var vpTransform = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].get2DTo3DMatrix(hitViewport, sheetUnitScale);
      var pWorld = point.clone().applyMatrix4(vpTransform);

      // Derive z from level metadata
      if (hitViewport.viewType === 'FloorPlan') {
        var level = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_1__["default"].findLevelForViewport(aec, hitViewport);
        if (level) {
          var avatarHeight = 5.74147; // 1.75m
          pWorld.z = level.elevation + avatarHeight;
          //console.log(pWorld.z);
        }
      }

      return {
        pos: pWorld,
        vp: hitViewport };

    } }, { key: "_applyGeoRefTransform", value: function _applyGeoRefTransform(

    pos) {
      var vec = pos.clone();

      // Skip refPoint transform if wanted
      if (this.options.useLocalModelCoords) {
        return vec;
      }
      // This extension requires AEC model data, so there should always be a refPoint tranform
      var root = this.viewer.model.getDocumentNode().getRootNode();
      var matrix = root.extractRefPointTransform();
      vec.applyMatrix4(matrix);

      return vec;
    } }]);return DropMeTool;}(av.ToolInterface);


GlobalManagerMixin.call(DropMeTool.prototype);

/***/ }),

/***/ "./extensions/AEC/DropMe/ViewPortOverlay.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/DropMe/ViewPortOverlay.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewPortOverlay; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing,avp = av.Private;var

ViewPortOverlay = /*#__PURE__*/function () {
  function ViewPortOverlay(viewer) {_classCallCheck(this, ViewPortOverlay);
    this.viewer = viewer;
    this.overlayName = 'DropMeViewPortOverlay';
  }_createClass(ViewPortOverlay, [{ key: "addOverlay", value: function addOverlay(

    xMin, yMin, xMax, yMax) {
      this.viewer.impl.createOverlayScene(this.overlayName);

      var mesh = this._createMesh(xMin, yMin, xMax, yMax);
      this.viewer.impl.addOverlay(this.overlayName, mesh);
    } }, { key: "removeOverlay", value: function removeOverlay()

    {
      this.viewer.impl.removeOverlayScene(this.overlayName);
    } }, { key: "_createMesh", value: function _createMesh(

    xMin, yMin, xMax, yMax) {
      var vpId = 0;
      var dbId = -1;
      var layer = 0;
      var borderColor = 0x99d79606;
      var lineWidth = 0.1;
      var totalDist = 0;

      var vbb = new avp.VertexBufferBuilder(false, undefined, 4);

      // add border
      vbb.addSegment(xMin, yMin, xMax, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMin, xMax, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMax, yMax, xMin, yMax, totalDist, lineWidth, borderColor, dbId, layer, vpId);
      vbb.addSegment(xMin, yMax, xMin, yMin, totalDist, lineWidth, borderColor, dbId, layer, vpId);

      var meshData = vbb.toMesh();
      var mdata = {
        mesh: meshData,
        is2d: true,
        packId: '0',
        meshIndex: 1 };


      avp.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      var materialParams = {
        skipEllipticals: true,
        skipCircles: true,
        skipTriangleGeoms: true,
        useInstancing: false };


      var matman = this.viewer.impl.matman();
      var matName = matman.create2DMaterial(this.viewer.impl.model, materialParams);
      var material = matman.findMaterial(this.viewer.impl.model, matName);

      var mesh = new THREE.Mesh(geom, material);
      return mesh;
    } }]);return ViewPortOverlay;}();

/***/ }),

/***/ "./extensions/AEC/LibraryExports.js":
/*!******************************************!*\
  !*** ./extensions/AEC/LibraryExports.js ***!
  \******************************************/
/*! exports provided: FloorSelector, ListPanel, ListPanelEvents, LevelsExtension, HyperlinkTracker, HyperlinkExtension, DropMeExtension, CanvasBookmarkExtension, MinimapTool, Minimap3DExtension, AecModelData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui/ListPanel.css */ "./extensions/AEC/ui/ListPanel.css");
/* harmony import */ var _ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ui_ListPanel_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DropMe/DropMe.css */ "./extensions/AEC/DropMe/DropMe.css");
/* harmony import */ var _DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_DropMe_DropMe_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.css */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.css");
/* harmony import */ var _CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CanvasBookmark_CanvasBookmark_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./levels/FloorSelector.js */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FloorSelector", function() { return _levels_FloorSelector_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./levels/LevelsExtension.js */ "./extensions/AEC/levels/LevelsExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LevelsExtension", function() { return _levels_LevelsExtension_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hyperlinks/HyperlinkTracker.js */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkTracker", function() { return _hyperlinks_HyperlinkTracker_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hyperlinks/HyperlinkExtension.js */ "./extensions/AEC/hyperlinks/HyperlinkExtension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HyperlinkExtension", function() { return _hyperlinks_HyperlinkExtension_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return _ui_ListPanel__WEBPACK_IMPORTED_MODULE_7__["ListPanelEvents"]; });

/* harmony import */ var _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DropMe/DropMe.js */ "./extensions/AEC/DropMe/DropMe.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DropMeExtension", function() { return _DropMe_DropMe_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./CanvasBookmark/CanvasBookmark.js */ "./extensions/AEC/CanvasBookmark/CanvasBookmark.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasBookmarkExtension", function() { return _CanvasBookmark_CanvasBookmark_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Minimap3D/Minimap3D.js */ "./extensions/AEC/Minimap3D/Minimap3D.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Minimap3DExtension", function() { return _Minimap3D_Minimap3D_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _Minimap3D_MinimapTool_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Minimap3D/MinimapTool.js */ "./extensions/AEC/Minimap3D/MinimapTool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MinimapTool", function() { return _Minimap3D_MinimapTool_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AecModelData", function() { return _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });



// Each one of these CSS imports gets injected into the HTML's headers inside its own <style>.

















/***/ }),

/***/ "./extensions/AEC/Minimap3D/FuzzyBox.js":
/*!**********************************************!*\
  !*** ./extensions/AEC/Minimap3D/FuzzyBox.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return fuzzyBox; });

// Sum of all fragment bbox centers, each weighted by bbox size
function centerOfMass(model) {

  var frags = model.getFragmentList();

  var box = new THREE.Box3();
  var center = new THREE.Vector3();
  var size = new THREE.Vector3();
  var total = new THREE.Vector3();
  var mass = 0;

  function processOneFragment(f) {

    // get bbox center
    frags.getWorldBounds(f, box);
    box.center(center);

    // sum centers weighted by bbox size
    var weight = box.size(size).length();
    total.add(center.multiplyScalar(weight));

    mass += weight;
  }

  for (var i = 0; i < frags.getCount(); i++) {
    processOneFragment(i);
  }

  total.multiplyScalar(1 / mass);
  return total;
}

// Computes bbox of all fragments, but excluding outliers.
function fuzzyBox(model, center, quantil) {

  center = center || centerOfMass(model);
  quantil = quantil || 0.75;

  var frags = model.getFragmentList();
  var fragBox = new THREE.Box3();

  // Compute distances of each frag bbox from center
  var fragInfos = [];
  for (var i = 0; i < frags.getCount(); i++) {

    // Skip any empty boxes
    frags.getWorldBounds(i, fragBox);
    if (fragBox.empty()) {
      continue;
    }

    // get fragBox->center distance
    var dist = fragBox.distanceToPoint(center);

    // If fragBox contains the center, use fragBox center.
    if (dist == 0) {
      dist = center.distanceTo(fragBox.center());
    }

    fragInfos.push({
      fragId: i,
      distance: dist });

  }

  // sort by increasing order    
  fragInfos.sort(function (a, b) {
    return a.distance - b.distance;
  });

  // union of all fragBoxes, excluding the ones with largest distance to center
  var box = new THREE.Box3();
  for (var i = 0; i < fragInfos.length * quantil; i++) {
    var fi = fragInfos[i];
    frags.getWorldBounds(fi.fragId, fragBox);
    box.union(fragBox);
  }
  return box;
}

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.css":
/*!************************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./Minimap3D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/Minimap3D/Minimap3D.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/Minimap3D/Minimap3D.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Minimap3DExtension; });
/* harmony import */ var _MinimapTool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapTool.js */ "./extensions/AEC/Minimap3D/MinimapTool.js");
/* harmony import */ var _SheetMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SheetMap.js */ "./extensions/AEC/Minimap3D/SheetMap.js");
/* harmony import */ var _MinimapToolbar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MinimapToolbar.js */ "./extensions/AEC/Minimap3D/MinimapToolbar.js");
/* harmony import */ var _FuzzyBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FuzzyBox.js */ "./extensions/AEC/Minimap3D/FuzzyBox.js");
/* harmony import */ var _SheetMapTransition_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SheetMapTransition.js */ "./extensions/AEC/Minimap3D/SheetMapTransition.js");
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Minimap3D.css */ "./extensions/AEC/Minimap3D/Minimap3D.css");
/* harmony import */ var _Minimap3D_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_Minimap3D_css__WEBPACK_IMPORTED_MODULE_6__);
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}








// eslint-disable-next-line no-unused-vars
 // IMPORTANT!!

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.Minimap3DExtension';

var LEVEL_EXT = 'Autodesk.AEC.LevelsExtension';
var BIMWALK_EXT = 'Autodesk.BimWalk';

var VISIBILITY_PROP = 'miniMap3D';

// index must be a valid FloorIndex
var getZRange = function getZRange(viewer, index) {

  // Check if we can get floor data
  var LevelExt = viewer.getExtension(LEVEL_EXT);
  var floor = LevelExt && LevelExt.floorSelector && LevelExt.floorSelector.floorData[index];

  // Cut everything above zMid of current floor
  var zMax = floor.zMin + 0.5 * (floor.zMax - floor.zMin);

  // Cut everything below zMid of the floor below
  // (Cutting below zMin keeps stairs to lower floors visible)
  var floorBelow = LevelExt.floorSelector.floorData[index - 1];
  var zMin = floorBelow ? 0.5 * (floorBelow.zMin + floorBelow.zMax) : floor.zMin;

  return { zMin: zMin, zMax: zMax };
};

// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var toPercent = function toPercent(val) {
  return val.toString() + '%';
};var

Minimap3DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Minimap3DExtension, _av$Extension);
  function Minimap3DExtension(viewer) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, Minimap3DExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Minimap3DExtension).call(this, viewer, options));
    _this.viewer = viewer;
    _this.camera = _this.viewer.navigation.getCamera();

    _this.trackUsage = options.trackUsage;
    _this.sideBySideOptions = options.sideBySideOptions || {};

    _this.cameraMovedCB = _this.onCameraMoved.bind(_assertThisInitialized(_this));
    _this.toolChangedCB = _this.onToolChanged.bind(_assertThisInitialized(_this));
    _this.geomLoadedCB = _this.onGeomLoaded.bind(_assertThisInitialized(_this));
    _this.onVisibilityChangedCB = _this.onVisibilityChanged.bind(_assertThisInitialized(_this));
    _this.viewerResizedCB = _this.onResize.bind(_assertThisInitialized(_this));
    _this.loadProgressCB = _this.onLoadProgress.bind(_assertThisInitialized(_this));
    _this.extensionLoadCB = _this.onExtensionLoaded.bind(_assertThisInitialized(_this));

    _this.levelChangedCB = _this.update.bind(_assertThisInitialized(_this)); // Level selection may change the current level
    _this.levelChangeListenerRegistered = false;

    _this.onTimerCB = _this.onTimer.bind(_assertThisInitialized(_this));

    // Used to sync mapModel with visible model. Not used if client sets the map model (options.useCustomModel)
    _this.visibleModelsChanged = _this.setDefaultMapModel.bind(_assertThisInitialized(_this));

    _this.draggingPlayerPosition = false;

    // The actual map resolution is chosen based on model bbox size in meters.
    _this.minMapImageSize = options.minMapImageSize || 300;
    _this.maxMapImageSize = options.maxMapImageSize || 2048;

    // Used to determine required map resolution
    _this.pixelsPerMeter = 10;

    // Map widget size
    _this.mapWidgetWidth = 300;
    _this.mapWidgetHeight = 300;

    // Map image size (may exceed mapWidget)
    _this.mapImageWidth = 300;
    _this.mapImageHeight = 300;

    // Map image size after applyign zoomScale
    _this.scaledImageWidth = 0;
    _this.scaledImageHeight = 0;

    // Params for choosing mapWidget size based on canvas size
    _this.relMapWidgetSizeLongEdge = 0.20; // Restrict to max 20% of the canvas along the longer axis with
    _this.relMapWidgetSizeShortEdge = 0.25; // Restrict to max 30% of the canvas along the shorter axis (more tolerance here, to keep map useful for widescreen)
    _this.minMapWidgetSize = 100; // if the map gets too small, we hide it.

    // Scale-factor in [minScale,1] for zoom-out. Auto-updated based on zoomLevel
    //  - Default: 1.0 (= full map resolution).
    //  - minScale is the smallest scale necessary to fit the whole map into the mapWidget
    _this.zoomScale = 1.0;

    // zoomLevel:
    //  0 = full resolution
    //  1 = Half resolution
    //  ...
    _this.targetZoomLevel = 0; // the one that we set directly
    _this.zoomLevel = 0; // animated to trace targetZoomLevel

    // params for smoothing zoom
    _this.zoomSpeed = 6.0; // zoom-levels per second
    _this.zoomAcc = 16.0; // zoom-levels per second^2
    _this.lastZoomSpeed = 0;

    // The visible section of the full map image is defined by
    //   min=(scrollPos.x, scrollXPos.y)
    //   max=(scrollPos.x + mapWidgetWidth, scrollPos.y + mapWidgetHeight)
    //
    // scroll positions are defined within the scaled mapImage, i.e. after scaling by zoomScale.
    _this.scrollPos = new THREE.Vector2();

    // The scrolling follows the player position and tries to bring it to the center. But it is filtered
    // by maxSpeed - otherwise it would suddenly jump after moving the playerposition.
    _this.targetScrollPos = new THREE.Vector2();

    _this.maxScrollSpeed = 500; // Maximum allowed scrollspeed in pixels per second
    _this.maxScrollAcc = 900; // Maximum allowed acceleration/deceleration in pixels/s^2

    // Track last applied scroll-speed (in ms) to restrict the acceleration.
    _this.lastScrollSpeed = 0;

    // Matrix to convert 3D model positions to relative coords on minimap (in [-1, 1]).
    // Will be set on minimap creation.
    _this.mapMatrix = new THREE.Matrix4();
    _this.mapMatrixInverse = new THREE.Matrix4();

    // guid of the level for which the current map is valid
    _this.currentLevelIndex = undefined;

    // flag to indicate if an (async) map update is in progress
    _this.updatingMap = false;

    // Indicates if widget is setup with a valid map
    _this.mapValid = false;

    // Map from levelIndex to LevelMap. A LevelMap contains...
    // { 
    //     imageUrl,
    //     width,
    //     height, 
    //     mapMatrix // Matrix4 from model to normalized map coords in [-1,1]^2
    // }
    _this.mapCache = {};

    _this.tool = new _MinimapTool_js__WEBPACK_IMPORTED_MODULE_0__["default"](_assertThisInitialized(_this), _this.trackUsage);

    // player-position in map-pixels. independent of scrolling
    _this.playerPos = new THREE.Vector2();
    _this.playerAngle = 0.0; // Clockwise rotation angle of view frustum div in radians (0 = up)
    _this.mapCenter = _this.playerPos; // Center target of the minimap. By default it's the player position. Can be changed when dragging the map.
    _this.lastCameraPos = _this.camera.position.clone();

    // The models from which we compute the map. By default, we use all visible ones
    _this.mapModels = null;

    // Used to suppress auto-scroll while we are dragging the player avatar on the map
    _this.autoScrollLocked = false;

    // Cache the fuzzy-box per model id
    _this.modelIdToFuzzyBox = [];

    // Only used for map updates
    _this.mapModelBox = new THREE.Box3();

    // Indicates that mapModels have been specified, but we are waiting for them to finish loading.
    _this.isLoading = false;

    // Display sheets using an own viewer instance
    _this.sheetMap = new _SheetMap_js__WEBPACK_IMPORTED_MODULE_1__["default"](_assertThisInitialized(_this));

    // Controls transitions to rotate/zoom when changing from main map to sheet overlay
    _this.sheetMapTransition = new _SheetMapTransition_js__WEBPACK_IMPORTED_MODULE_4__["default"](_assertThisInitialized(_this));

    _this.visible = false;

    // Toggles between auto-generated map image (false) and using a sheet as map
    _this.useSheet = false;

    // Toggle between..
    //  - Small map on top-right of the screen (false)
    //  - Large map that fills left half of the screen (true)
    _this.sideBySideEnabled = _this.sideBySideOptions.sideBySideDefault || false;

    // Indicates if layout is currently configured for side-by-side view
    // (always false when map is hidden, because viewer needs to be resized to full width then)
    _this.sideBySide = false;

    // Percent of viewer width that we reserve for minimap in side-by-side mode. 
    // E.g. 40 => Minimap gets 40%, Main canvas gets 60%
    _this.sideBySideSplit = _this.sideBySideOptions.sideBySideSplit || 40;

    // Used to track when all fading anims are finished
    _this.fadingWidgets = 0;

    // Clockwise map rotation angle in radians
    _this.mapRotationAngle = 0;

    // Indicates whether we are currently displaying the SheetMap as an overlay
    _this.sheetMapActive = false;

    _this.initWidgets();

    // For testing: Callbacks that will be notified once as soon as Minimap has reached stable state
    _this.waitingCallbacks = [];

    // If true, a UI animation is running that morphs from/to side-by-side mode
    _this.slidingInProgress = false;return _this;
  }_createClass(Minimap3DExtension, [{ key: "setMinimapVisible", value: function setMinimapVisible(

    visible) {var _this2 = this;

      this.visible = visible;

      // If the minimap widget is just showing a progress bar, we don't show the player avatar
      var isProgress = this.mapWidget.mapImage === this.placeholderDiv;

      // Trigger css anim. Note that doing this synchronously would skip the animation.
      var _window = this.getWindow();
      _window.requestAnimationFrame(function () {
        if (visible) {
          _this2.mapWidgetRoot.classList.add('visible');
          _this2.viewer.getExtension("Autodesk.ViewCubeUi", function (ext) {
            ext.displayViewCube(false, false);
          });
        } else {
          _this2.mapWidgetRoot.classList.remove('visible');
        }

        // Show player widget only if an actual map is displayed
        if (visible && !isProgress) {
          _this2.playerPositionWidget.classList.add('visible');
        } else {
          _this2.playerPositionWidget.classList.remove('visible');
        }
      });

      // Make sure that we reserve space for the minimap as soon as we start fade-in
      this.updateBimWalkInfoButtonPos();

      // Apply side-by-side layout immediately when starting to fade in. On fade-out, we
      // delay this until the fade-out transition is done (see transitionend-handler in initWidgets)
      if (visible) {
        this.updateSideBySide();
      }
    }

    // Check if minimap is enabled in viewer config. Note that this does not necessarily mean that it is visible,
    // e.g., BIMWalk may not be active.
  }, { key: "isEnabled", value: function isEnabled() {
      return this.viewer.prefs && this.viewer.prefs.get(VISIBILITY_PROP);
    } }, { key: "onVisibilityChanged", value: function onVisibilityChanged(

    visible) {
      if (this.viewer.prefs) {
        this.viewer.prefs.set(VISIBILITY_PROP, visible);
      }
      this.update();
    }

    // Placeholder widget is displayed when a map computation is in progress. It contains a text "Computing map for.." and a progress bar.
  }, { key: "initPlaceholderWidget", value: function initPlaceholderWidget() {

      var _document = this.getDocument();
      // Placeholder widget used if map computation is in progress
      this.placeholderDiv = _document.createElement('div');
      this.placeholderDiv.className = 'minimap-placeholder';
      this.placeholderDiv.style.width = toPixels(this.mapWidgetWidth);
      this.placeholderDiv.style.height = toPixels(this.mapWidgetHeight);

      // Vertically centered placeholder child containing text and progress bar
      var progressParent = _document.createElement('div');
      progressParent.className = 'minimap-progressWidget';
      this.placeholderDiv.appendChild(progressParent);

      // add progress text
      this.progressText = _document.createElement('div');
      this.progressText.className = 'minimap-progressText';
      progressParent.appendChild(this.progressText);

      // add progress bar
      this.progressDiv = _document.createElement('progress');
      this.progressDiv.className = 'minimap-progress';
      this.progressDiv.setAttribute('max', 100);
      progressParent.appendChild(this.progressDiv);
    } }, { key: "initWidgets", value: function initWidgets()

    {var _this3 = this;

      var _document = this.getDocument();

      // Root div for the minimap. This is only used for the toolbar: Since it is left outside the Minimap bounds, it cannot be inside the mapWidget directly,
      // because the mapWidget uses overflow:hidden to implement scrolling.
      this.mapWidgetRoot = _document.createElement('div');
      this.mapWidgetRoot.style.width = toPixels(this.mapWidgetWidth);
      this.mapWidgetRoot.style.height = toPixels(this.mapWidgetHeight);
      this.mapWidgetRoot.className = 'minimap3D';

      // Div showing the minimap
      this.mapWidget = _document.createElement('div');
      this.mapWidget.className = 'minimapScrollArea';
      this.mapWidgetRoot.appendChild(this.mapWidget);

      // Child-Div of MapWidget to represent current camera position and view direction on minimap (child of Minimap div)
      this.playerPositionWidget = _document.createElement('div');
      this.playerPositionWidget.className = 'player-widget';

      // It would be a bit simpler to add the player position widget to the mapImage - instead of the root mapWidget.
      // In this way, it would already inherit scrolling and map rotation.
      // 
      // But: We cannot do this due to the stacking order: We want to display the LMV instance (for sheet overlays)
      // between mapImage and playerWidget. 
      this.mapWidget.appendChild(this.playerPositionWidget);

      // Sub-widget to represent view direction in minimap
      this.playerFrustumWidget = _document.createElement('div');
      this.playerFrustumWidget.className = 'player-frustum';
      this.playerPositionWidget.appendChild(this.playerFrustumWidget);

      // By default, setting left/top to posX/posY would move the top-left corner of the frustum
      // widget to that position. We want to have the tip of the camera there.
      // Note that the offset may change depending on the border sizes in player-frustum css class.
      this.playerPositionWidget.anchorX = 20; // =.player-frustum.border-left
      this.playerPositionWidget.anchorY = 40; // =.player-frustum.border-top

      // Filled circle at camera position
      var filledCircle = _document.createElement('div');
      filledCircle.className = 'player-position-fill';
      this.playerPositionWidget.appendChild(filledCircle);
      this.playerPositionWidget.posCircle = filledCircle;

      // Hit area of the player position.
      var playerPositionHitArea = _document.createElement('div');
      playerPositionHitArea.className = 'player-position-hitarea';
      this.playerPositionWidget.posCircle.appendChild(playerPositionHitArea);
      this.playerPositionWidget.playerPositionHitArea = playerPositionHitArea;

      if (Autodesk.Viewing.isTouchDevice()) {
        playerPositionHitArea.classList.add('touch');
        this.playerFrustumWidget.classList.add('touch');
        this.playerPositionWidget.posCircle.classList.add('touch');
        this.playerPositionWidget.anchorX = 40; // =.player-frustum.border-left
        this.playerPositionWidget.anchorY = 80; // =.player-frustum.border-top
      }

      this.toolbar = new _MinimapToolbar_js__WEBPACK_IMPORTED_MODULE_2__["default"](this);

      this.initPlaceholderWidget();

      // hidden until level map is set
      this.setMinimapVisible(false);

      // Whenver the mapWidget finished fading in or out, we might need to re-adjust
      // the position of the annoying Info button of BimWalk to avoid overlapping.
      this.mapWidget.addEventListener('transitionend', function () {
        _this3.updateBimWalkInfoButtonPos();
        _this3.updateSideBySide();
      });

      this.initialized = true;
    } }, { key: "load", value: function load()

    {
      this.loaded = true;

      this.viewer.prefs.add(VISIBILITY_PROP, true);

      // choose widget size based on current canvas size
      this.updateMapSize();

      this.viewer.container.appendChild(this.mapWidgetRoot);

      var cache = this.getCache();

      // Note: Creating a viewer instance requires a parent widget with actual extents >0. Therefore, we must append mapWidget to
      //       viewer container first before we can init the sheet viewer.
      cache.viewer = this.sheetMap.initMapViewer(this.mapWidget, cache.viewer);
      this.tool.activate();

      this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);
      this.viewer.addEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedCB);
      this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.geomLoadedCB);
      this.viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this.viewerResizedCB);
      this.viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.loadProgressCB);
      this.viewer.addEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadCB);

      this.updateFloorSelectHandler();

      // Always compute the map from "current model" - unless the client app specifies the mapModel explicitly.
      if (!this.options.useCustomModel) {

        // If a 3D model added before loading the extension, use it right now.
        this.setDefaultMapModel();

        this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.visibleModelsChanged);
        this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this.visibleModelsChanged);
      }

      if (!this.updateSettingsPanel) {
        //We need to connect this to an event that happens after the settings panel has been
        //create by the load sequence. The toolbar created event is serving that purpose.
        this.updateSettingsPanel = this.configureSettings.bind(this);
        this.viewer.addEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
      }

      // Update scrolling on timer
      this.requestTimer();

      return true;
    } }, { key: "unload", value: function unload()

    {
      this.loaded = false;

      // Avoid crash in case the client app hijacked the mapWidget to add it somewhere else
      if (this.viewer.container.contains(this.mapWidgetRoot)) {
        this.viewer.container.removeChild(this.mapWidgetRoot);
      }

      this.tool.deactivate();

      this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this.cameraMovedCB);
      this.viewer.removeEventListener(av.TOOL_CHANGE_EVENT, this.toolChangedCB);
      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.geomLoadedCB);
      this.viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this.viewerResizedCB);
      this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.loadProgressCB);
      this.viewer.removeEventListener(av.EXTENSION_LOADED_EVENT, this.extensionLoadCB);

      this.updateFloorSelectHandler();

      if (!this.options.useCustomModel) {
        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.visibleModelsChanged);
        this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this.visibleModelsChanged);
      }

      if (this.updateSettingsPanel) {
        this.viewer.removeEventListener(av.TOOLBAR_CREATED_EVENT, this.updateSettingsPanel);
        this.updateSettingsPanel = null;
      }

      // Stop scrolling timer interrupts
      this.cancelTimer();

      // Make sure that we don't leak models
      return true;
    } }, { key: "onExtensionLoaded", value: function onExtensionLoaded(

    e) {
      if (e.extensionId === LEVEL_EXT) {
        this.updateFloorSelectHandler();
      }
    }

    // Make sure that we detect Floor-select events as long as Minimap and LevelsExt are both loaded.
  }, { key: "updateFloorSelectHandler", value: function updateFloorSelectHandler() {

      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      if (!levelExt) {
        // We will try again later on extension load
        return;
      }
      var registered = this.levelChangeListenerRegistered;
      if (!registered && this.loaded) {
        levelExt.floorSelector.addEventListener(Autodesk.AEC.FloorSelector.CURRENT_FLOOR_CHANGED, this.levelChangedCB);
        this.levelChangeListenerRegistered = true;
      } else if (registered && !this.loaded) {
        levelExt.floorSelector.removeEventListener(Autodesk.AEC.FloorSelector.CURRENT_FLOOR_CHANGED, this.levelChangedCB);
        this.levelChangeListenerRegistered = false;
      }
    }

    // Move/Rotate player-position widget according to player position and angle.
  }, { key: "updatePlayerWidget", value: function updatePlayerWidget() {

      // get position in pixels within the map widget
      var pos = this.playerPos.clone();
      this.mapPixelsToWidget(pos);

      var style = this.playerPositionWidget.style;
      style.left = toPixels(pos.x - this.playerPositionWidget.anchorX);
      style.top = toPixels(pos.y - this.playerPositionWidget.anchorY);

      // rotate frustum shape (+ consider map rotation)
      this.playerFrustumWidget.style.transform = "rotate(".concat(this.playerAngle + this.mapRotationAngle, "rad)");
    }

    // Adjust target scroll-position based on current player position
  }, { key: "computeTargetScrollPosition", value: function computeTargetScrollPosition() {

      // compute player position within scaled map
      var px = this.mapCenter.x * this.zoomScale;
      var py = this.mapCenter.y * this.zoomScale;

      // Try to scroll player into map center
      this.targetScrollPos.x = px - 0.5 * this.mapWidgetWidth;
      this.targetScrollPos.y = py - 0.5 * this.mapWidgetHeight;
    }

    // recompute this.playerPos and this.playerAngle according to current 3D camera
  }, { key: "computePlayerPosition", value: function computePlayerPosition() {

      // If this call happens during async map update, don't set player position.
      // Otherwise, it would just reflect the camera pos during map update.
      if (this.updatingMap) {
        return;
      }

      // convert camera pos to miniMap pix coords
      var pos3D = this.viewer.impl.camera.position;
      var pos2D = this.worldToMapPixels(pos3D);

      // convert camera target to miniMap
      var target3D = this.viewer.impl.camera.target;
      var target2D = this.worldToMapPixels(target3D);

      this.playerPos.copy(pos2D);
      this.playerAngle = this.computeAngle(pos2D, target2D);
    }

    // Apply scrolling using css
  }, { key: "applyScrolling", value: function applyScrolling() {
      // Note that mapImage may also exist, but just be the placeholder - which should not be scrolled.
      if (this.mapValid) {
        // set image size based on map resolution and zoomScale
        var style = this.mapWidget.mapImage.style;
        style.width = toPixels(this.scaledImageWidth);
        style.height = toPixels(this.scaledImageHeight);

        // set scroll position
        this.mapWidget.mapImage.style.left = toPixels(-this.scrollPos.x);
        this.mapWidget.mapImage.style.top = toPixels(-this.scrollPos.y);
      }

      // If we use a sheetmap, update camera accordingly
      if (this.sheetMap.ready) {
        this.sheetMap.syncCameraToMainMap();
      }
      this.updateRotation();
    }

    // Immediately set scrolling to target position (based on player pos)
  }, { key: "resetScrolling", value: function resetScrolling() {
      this.zoomLevel = this.targetZoomLevel; // skip any ongoing zoom-motion
      this.computeTargetScrollPosition();
      this.scrollPos.copy(this.targetScrollPos);
      this.applyScrolling();
    }

    // Adjust scrolling and player position widget based on current 3D camera
    //  @param {number} elapsed - elapsed time in seconds
  }, { key: "updateScrolling", value: function updateScrolling(elapsed) {

      // Compute scroll position to follow the player
      if (this.autoScrollLocked) {
        return;
      }

      this.computeTargetScrollPosition();

      // get vector and distance towards targetPos
      var delta = this.targetScrollPos.clone().sub(this.scrollPos);
      var dist = delta.length();

      if (this.scrollPos.equals(this.targetScrollPos)) {
        // Nothing to do
        return;
      }

      // If distance is below a pixel, don't waste time with invisible epsilon-scrolls.
      // Instead, just jump to exact target position. This faciliates testing and avoids unnecessary style updates.
      if (dist < 0.5) {

        // Make values match exactly when we stop scrolling.
        this.scrollPos.copy(this.targetScrollPos);

      } else {

        // apply scroll-speed limit
        var newDist = Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["motionSmoothing"])(dist, elapsed, this.maxScrollSpeed, this.lastScrollSpeed, this.maxScrollAcc);
        delta.multiplyScalar(newDist / dist);

        // move player pos
        this.scrollPos.add(delta);

        // track applied scroll speed
        if (elapsed) {
          this.lastScrollSpeed = newDist / elapsed;
        }
      }

      // Update player avatar (based on player pos + scroll position)
      this.updatePlayerWidget();
      this.applyScrolling();
    }

    // Returns true if all mapModels are ready for map rendering
  }, { key: "mapModelsReady", value: function mapModelsReady() {
      if (!this.mapModels) {
        return false;
      }

      for (var i = 0; i < this.mapModels.length; i++) {
        var model = this.mapModels[i];
        if (!model.isLoadDone()) {
          // We need to wait until model finished loading
          return false;
        }
      }
      return true;
    }

    // Returns a floor object {index, name}
  }, { key: "getCurrentLevel", value: function getCurrentLevel() {
      var levelExt = this.viewer.getExtension(LEVEL_EXT);
      if (!levelExt) {
        return;
      }

      // If a level is selected, use that one and ignore camera z
      var fs = levelExt.floorSelector;
      var level = fs.floorData[fs.currentFloor];
      if (level) {
        return level;
      }

      // No floor selected => determine based on camera z
      return levelExt._mapCameraToLevel();
    }

    // Make sure that sheetMap viewer instance shows the right sheet for the current level (if possible)
  }, { key: "updateSheetMap", value: function updateSheetMap() {var _this4 = this;

      // Don't animate between different maps as long as we are dragging the player-pos around.
      if (this.autoScrollLocked) {
        return;
      }

      // Choose for which level we want to display the map
      var level = this.getCurrentLevel();
      if (!level) {
        return;
      }

      // We need a main map first. Otherwise, we don't have the list of available sheetmaps 
      var mainMap = this.mapCache[level.index];
      if (!mainMap) {
        return;
      }

      // As long as no main map is shown, we cannot show an embedded sheet either.
      if (!this.mapValid) {
        return;
      }

      // get current camera pos. We use it to evaluate which map is suitable to keep it visible on the map.
      var pos3D = this.viewer.impl.camera.position;

      // Check if there is an active sheetmap for this floor.
      var sheetMapUsable = this.sheetMap.isUsable(pos3D, level.guid);
      var useCurrentSheetMap = this.useSheet && sheetMapUsable;

      // If sheetmap is wanted and not active yet, activate it.
      if (!this.sheetMapActive && useCurrentSheetMap) {
        this.sheetMapTransition.enterSheet();
        this.sheetMapActive = true;
        return;
      }

      // Deactivate sheetMap if outdated: E.g., if sheets were switched off or camera left the area supported by the sheet
      if (this.sheetMapActive && !useCurrentSheetMap) {
        this.sheetMapTransition.exitSheet();
        this.sheetMapActive = false;

        // Don't return here: we may still have to initialize another sheetmap
      }

      // If sheetMap is active and up-to-date, we are done
      if (useCurrentSheetMap && this.sheetMapActive) {
        return;
      }

      // If sheetMap neither wanted nor shown, we are done
      if (!this.useSheet && !this.sheetMapActive) {
        return;
      }

      // If sheetmap is already loading, wait for it to finish.
      // The loading sheet might be an outdated one. We could optimize this by making the loading interruptable.
      if (this.sheetMap.loading) {
        return;
      }

      // Current sheetmap cannot be used. Check if we find one.
      var newConfig = mainMap.sheetMaps.find(function (cfg) {return cfg.isUsable(pos3D, level.guid);});
      if (!newConfig) {
        // There is no sheetMap that we can use.
        return;
      }

      // Make sure that we don't let the thumbnail in the middle of a transition
      this.sheetMapTransition.onSheetWillChange();

      // Initialize new sheetMap and activate it when ready
      var onLoaded = function onLoaded() {
        _this4.update();
      };

      this.sheetMap.initMap(newConfig, onLoaded);
    }

    // Makes sure that map shows an image of the current level.
  }, { key: "updateMapImage", value: function updateMapImage() {

      // Avoid mapUpdate if another one is in progress, extension was unloaded, or model is not ready
      if (this.updatingMap || !this.loaded || !this.mapModelsReady()) {
        return;
      }

      // Choose for which level we want to display the map
      var level = this.getCurrentLevel();
      if (!level) {
        return;
      }

      // We can skip the update if the level didn't change (unless we are currently just showing a placeholder)
      var index = level.index;
      if (this.currentLevelIndex === index && this.mapValid) {
        // no map update needed
        return;
      }

      if (Number.isInteger(index)) {
        // set index only if defined
        this.currentLevelIndex = index;
      }

      // Create or activate map for that level
      var levelMap = this.mapCache[this.currentLevelIndex];
      if (levelMap) {
        // We visited that level before => reuse map image
        this.activateMap(levelMap, level.name);
      } else {
        this.createMinimap(this.currentLevelIndex, level.name, level.guid);
      }
    } }, { key: "bimWalkActive", value: function bimWalkActive()

    {
      // Minimap is only shown in first-person mode
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      return bimWalk && bimWalk.tool && bimWalk.tool.active;
    } }, { key: "updateMapCenter", value: function updateMapCenter()

    {
      if (this.updatingMap) {
        return;
      }

      // In case camera position has changed, update mapCenter in order to focus on the player again.
      // If the camera is outside the map range, always zoom out to full map
      if (this.widgetSizeChanged || this.lastCameraPos.distanceTo(this.camera.position) !== 0) {
        this.lastCameraPos = this.camera.position.clone();
        this.widgetSizeChanged = false;

        if (this.isOutside()) {
          this.setZoomLevel(this.getMinZoomLevel());
          this.mapCenter = this.playerPos.clone();
          this.mapCenter.x = 0.5 * this.mapWidgetWidth / this.zoomScale;
          this.mapCenter.y = 0.5 * this.mapWidgetHeight / this.zoomScale;
        } else {
          this.mapCenter = this.playerPos;
        }
      }
    } }, { key: "onCameraMoved", value: function onCameraMoved()

    {
      this.update();
    } }, { key: "update", value: function update()

    {var _this5 = this;
      if (this.slidingInProgress) {
        return;
      }

      var wasVisible = this.visible;

      if (!this.isEnabled() || !this.bimWalkActive()) {
        if (this.sideBySide) {
          var sideBySideSplitBackup = this.sideBySideSplit;
          this.slidingInProgress = true;

          this.setSideBySideSplit(0, function () {
            // Restore original sideBySideSplit value.
            _this5.sideBySideSplit = sideBySideSplitBackup;
            _this5.setMinimapVisible(false);

            // Wait until the camera is moved before setting slidingInProgress to false.
            // Otherwise, setSideBySideSplit will be called an unnecessary extra time.
            _this5.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, function () {
              _this5.slidingInProgress = false;
            }, { once: true });

          });
        } else {
          this.setMinimapVisible(false);
        }

        return;
      }

      if (this.isEnabled() && this.bimWalkActive() && !this.visible && this.sideBySideEnabled) {
        this.slidingInProgress = true;
        var _sideBySideSplitBackup = this.sideBySideSplit;
        this.sideBySideSplit = 0;

        this.setSideBySideSplit(_sideBySideSplitBackup, function () {
          _this5.slidingInProgress = false;
        });
      }

      // MapModels are required before we can show anything
      if (!this.mapModels) {
        this.setMinimapVisible(false);
        return;
      }

      // Generating the default map requires all models to be loaded first.
      // If geom is not loaded, wait until update() is triggered again by the geomLoad event
      if (!this.mapModelsReady()) {
        // We are waiting for models to load => show load progress.
        this.showLoadProgress();
        return;
      }

      this.updateMapImage();

      // Make sure that sheetMap is enabled/disabled and properly configured for current state
      // This must happen after updateMapImage(): Since sheetMaps are embedded into the main map,
      // clearing/changing the main map will remove the sheetMap again. So, we must make sure thtat the main map 
      // state is up-to-date first.
      this.updateSheetMap();

      this.updateMaxFloorTextWidth();

      // If we get here, we are not waiting for any model loading anymore.
      this.isLoading = false;

      this.updateMapCenter();
      this.setMinimapVisible(true);
      this.computePlayerPosition();
      this.updatePlayerWidget();
      this.applyScrolling();
      this.toolbar.update();

      // In theory, this happens in onTimer() later anyway. But it's cleaner and better testable to keep the rule
      // that after calling update(), the full state is updated. Without this, isAllDone() would sometimes miss that we are about to scroll,
      // just because the subsequent timer-event didn't happen yet.
      this.computeTargetScrollPosition();

      if (!wasVisible) {
        this.resetScrolling();
      }
    } }, { key: "onToolChanged", value: function onToolChanged(

    tool) {var _this6 = this;

      // we temporarily disable/enable BimWalk ourselves during map update
      if (this.updatingMap) {
        return;
      }

      if (!tool.toolName === 'bimwalk') {
        return;
      }

      // Note: Activating the map might trigger a map update. If this starts synchronously right now,
      //       some BIMWalk code after this event would affect the camera and switch it back to perspective.
      // TODO: Think about if there is a cleaner way to avoid tools from affecting the snapshots (without having to switch BIMWalk off)
      setTimeout(function () {return _this6.update();}, 10);
    } }, { key: "onGeomLoaded", value: function onGeomLoaded(

    e) {
      // If the mapModel just finished loading and minimap is wanted, make sure that we create & show it
      this.update();
    }

    // Sets the progress widget as current map
  }, { key: "showProgressWidget", value: function showProgressWidget() {

      // Do nothing if already visible
      var isShown = this.mapWidget.mapImage === this.placeholderDiv;
      if (isShown) {
        return;
      }

      // Remember previous mapImage (if any)
      this.clearMapImage();

      // Show placeholder
      this.mapWidget.appendChild(this.placeholderDiv);

      // fade-in placeholder
      this.placeholderDiv.style.opacity = 0.0;
      this.fadeWidgetOpacity(this.placeholderDiv, 1.0);
      this.updateProgressWidget(0);

      // Make placeholder the new mapImage - so that it will be replaced and faded once
      // the map image is ready
      this.mapWidget.mapImage = this.placeholderDiv;

      this.setMinimapVisible(true);
    } }, { key: "setProgressText", value: function setProgressText(

    text) {
      this.progressText.innerHTML = text;
    } }, { key: "updateProgressWidget", value: function updateProgressWidget(

    percent) {
      this.progressDiv.setAttribute('value', percent);
    }

    // Called if mapModels have been specified, but are still loading
  }, { key: "showLoadProgress", value: function showLoadProgress() {
      this.showProgressWidget();

      if (this.useSheet && this.sheetMap.loading) {

        // We display a sheet as soon as the root is loaded. For this step, there is
        // no progress tracking, but it usually shouldn't take long
        this.progressDiv.removeAttribute("value");
        this.setProgressText(Autodesk.Viewing.i18n.translate('Loading sheet...'));
      } else {
        // Setup determinate progress bar and initialize with current model load progress
        this.onLoadProgress();
        this.setProgressText(Autodesk.Viewing.i18n.translate('Loading models...'));
      }

      this.setMinimapVisible(true);
      this.isLoading = true;
    }

    // Compute percent of loaded fragments for all models that we are waiting for to compute the map
  }, { key: "getLoadProgress", value: function getLoadProgress() {
      var loaded = 0;
      var total = 0;
      var numModels = this.mapModels ? this.mapModels.length : 0;
      for (var i = 0; i < numModels; i++) {
        var model = this.mapModels[i];

        // Note: Progress tracking other formats would require some extra work here.
        if (!model.isOTG()) {
          continue;
        }

        var data = model.getData();
        loaded += data.fragsLoaded;
        total += data.metadata.stats.num_fragments;
      }
      return total ? Math.floor(100 * loaded / total) : 0;
    } }, { key: "onLoadProgress", value: function onLoadProgress()

    {
      // Progress events are only relevant while waiting for model load. 
      // Note sheet maps can be displayed without waiting for the model geometry.
      var canUseSheets = this.useSheet && this.sheetMap.initialized();
      if (!this.isLoading || canUseSheets) {
        return;
      }

      var progress = this.getLoadProgress();
      this.updateProgressWidget(progress);
    }

    // Fade out floor-label and remove it after fading
  }, { key: "clearFloorLabel", value: function clearFloorLabel() {var _this7 = this;
      var oldLabel = this.mapWidget.floorLabel;
      if (!oldLabel) {
        return;
      }

      this.mapWidget.floorLabel = null;

      this.fadeWidgetOpacity(oldLabel, 0.0, function () {
        _this7.mapWidget.removeChild(oldLabel);
      });
    }

    // Fade-out current map image (+ label) and removes it after fading
  }, { key: "clearMapImage", value: function clearMapImage() {var _this8 = this;

      // Hide sheetmap as well if a main map changes
      this.sheetMap.setVisible(false);
      this.sheetMapActive = false; // Remember that sheetMap was switched off so that it gets reactivated when needed next time

      this.clearFloorLabel();

      var oldImage = this.mapWidget.mapImage;
      if (!oldImage) {
        return;
      }

      this.mapWidget.mapImage = null;

      // Make sure that mapImage is removed after fadeout (if still not in use)
      var onFadeDone = function onFadeDone() {
        // Note: oldImage may be reused meanwhile (happens for placeholderDiv).
        // Adding the same child a second time has no effect, but we must not remove it in that case.
        var isActive = _this8.mapWidget.mapImage === oldImage;
        if (!isActive && _this8.mapWidget.contains(oldImage)) {
          _this8.mapWidget.removeChild(oldImage);
        }
      };

      // invoke fade-out
      this.fadeWidgetOpacity(oldImage, 0.0, onFadeDone);

      // update state flags: there is nothing to display
      this.mapValid = false;
    } }, { key: "fadeWidgetOpacity", value: function fadeWidgetOpacity(

    widget, targetValue, onFadeDone) {var _this9 = this;

      var FadeDuration = 0.7;

      if (widget.fadeAnim) {
        widget.fadeAnim.skip();
        widget.fadeAnim = null;
      }

      var startVal = widget.style.opacity;

      var onTimer = function onTimer(t) {
        t = avp.smootherStep(t);
        widget.style.opacity = avp.lerp(startVal, targetValue, t);
      };

      var onFadeEnd = function onFadeEnd() {
        _this9.fadingWidgets--;
        widget.fadeAnim = null;
        onFadeDone && onFadeDone();
      };

      // Indicate that fade-animation is active until anim ends
      this.fadingWidgets++;

      widget.fadeAnim = avp.fadeValue(0, 1, FadeDuration, onTimer, onFadeEnd);
    }

    // Create and show label to display floorName.
  }, { key: "createFloorLabel", value: function createFloorLabel(levelName) {
      if (this.options.hideFloorsLabel) {
        return;
      }

      var _document = this.getDocument();

      // attach floor name label to mapWidget
      var floorLabel = _document.createElement('div');
      floorLabel.className = 'floorNameLabel';
      this.mapWidget.appendChild(floorLabel);
      this.mapWidget.floorLabel = floorLabel;

      // add text to label
      var floorText = _document.createElement('div');
      floorText.className = 'floorText';
      floorText.textContent = levelName;
      floorLabel.appendChild(floorText);
      this.mapWidget.floorText = floorText;

      this.updateMaxFloorTextWidth();

      if (this.options.theme) {
        floorLabel.classList.add(this.options.theme);
        floorText.classList.add(this.options.theme);
      }
    }

    // @param {LevelMap} levelMap - Contains {imageUrl, width, height, mapMatrix} 
    // @param {string}   levelName
  }, { key: "activateMap", value: function activateMap(levelMap, levelName) {var _this10 = this;

      // Remove outdated image
      this.clearMapImage();

      // Set mapImageWidth/Height to available image resolution
      this.mapImageWidth = levelMap.width;
      this.mapImageHeight = levelMap.height;
      this.scaledImageWidth = this.zoomScale * this.mapImageWidth;
      this.scaledImageHeight = this.zoomScale * this.mapImageHeight;

      // Update mapMatrix for scrolling and player position
      this.mapMatrix.copy(levelMap.mapMatrix);
      this.mapMatrixInverse.getInverse(this.mapMatrix);

      // Create new div with map
      var _document = this.getDocument();
      this.mapWidget.mapImage = _document.createElement('div');
      this.mapWidget.mapImage.className = 'mapContainer';
      this.mapWidget.mapImage.innerHTML = "<img class=\"mapImage\" src=\"".concat(levelMap.imageUrl, "\">");
      this.mapWidget.mapImage.style.width = toPixels(this.scaledImageWidth);
      this.mapWidget.mapImage.style.height = toPixels(this.scaledImageHeight);
      this.mapWidget.appendChild(this.mapWidget.mapImage);

      // Get imageElement defined in innerHTML above.
      // It would be a bit easier to avoid the parent element and create mapWidget as image directly,
      // but this always failed to load the blobl url (not sure why).
      this.mapWidget.mapImage.imageElement = this.mapWidget.mapImage.children[0];

      // Adjust image-size to container element size, so that we can apply zoomScale on mapImage div
      this.mapWidget.mapImage.imageElement.style.width = '100%';
      this.mapWidget.mapImage.imageElement.style.height = '100%';

      // Create label for this map and show it
      this.createFloorLabel(levelName);

      // Fade-in new map image
      this.mapWidget.mapImage.style.opacity = 0;
      this.fadeWidgetOpacity(this.mapWidget.mapImage, 1.0);

      if (this.mapWidget.floorLabel) {
        this.fadeWidgetOpacity(this.mapWidget.floorLabel, 1.0);
      }

      this.mapValid = true;

      this.computePlayerPosition();
      this.resetScrolling();
      this.updatePlayerWidget();
      this.setMinimapVisible(true);

      // Add sheetmap thumbnails to mapImage div
      levelMap.sheetMaps.forEach(function (map) {return _this10.mapWidget.mapImage.appendChild(map.thumbnail.div);});
    } }, { key: "cancelMapUpdate", value: function cancelMapUpdate()

    {
      if (this.screenShotInProgress) {
        this.screenShotInProgress.stop();
        this.updatingMap = false;
      }
    } }, { key: "getFuzzyBox", value: function getFuzzyBox()

    {

      this.mapModelBox.makeEmpty();
      if (!this.mapModels) {
        return;
      }

      // sum up fuzzy boxes of all map models
      for (var i = 0; i < this.mapModels.length; i++) {

        var model = this.mapModels[i];

        // get bbox from cache if possible
        var bbox = this.modelIdToFuzzyBox[model.id];
        if (!bbox) {
          // compute fuzzybox and add it to cache
          bbox = Object(_FuzzyBox_js__WEBPACK_IMPORTED_MODULE_3__["default"])(model);
          this.modelIdToFuzzyBox[model.id] = bbox;
        }

        this.mapModelBox.union(bbox);
      }
      return this.mapModelBox;
    }

    // Create a map based on a (valid) level index from FloorSelector
  }, { key: "createMinimap", value: function createMinimap(levelIndex, levelName, levelGuid) {var _this11 = this;

      // Replace current map by progress widget
      this.showProgressWidget();
      this.setProgressText('Creating map for:<br><b>' + levelName);

      // Compute bbox of the region to be captured in the minimap
      var bbox = this.getFuzzyBox();

      // If there is nothing useful to show, just hide the minimap widget
      if (bbox.empty()) {
        this.setMinimapVisible(false);
        return;
      }

      var diag = bbox.size();

      // If multiple models are shown together, they must have identical unit scale. Therefore, we can get the scale from any model.
      var unitToMeter = this.mapModels[0].getUnitScale();

      // Expand map scope by a few meters of margin
      var marginInMeters = 1;
      var offset = 2 * marginInMeters / unitToMeter;
      diag.x += offset;
      diag.y += offset;

      // compute required resolution
      var resX = diag.x * unitToMeter * this.pixelsPerMeter;
      var resY = diag.y * unitToMeter * this.pixelsPerMeter;

      // Orthoscale must be set to the full world-space height that we want to capture.
      var orthoScale = diag.y;

      // If both width and height are below minMapSize, scale down to fill the mapWidget
      if (resX < this.minMapImageSize && resY < this.minMapImageSize) {
        var smallerSide = Math.min(resX, resY);
        var factor = this.minMapImageSize / smallerSide;
        resX *= factor;
        resY *= factor;
      }

      // If any of the sides exceeds max mapImageSize, scale down to keep them within
      var maxXY = Math.max(resX, resY);
      if (maxXY > this.maxMapImageSize) {
        var _factor = this.maxMapImageSize / maxXY;
        resX *= _factor;
        resY *= _factor;
      }

      // After the steps above, we know for sure that width and height are both within maxImageSize and
      // at least one (width or height) is >= minImageSize.
      // If only one of the two is too small, we have to change the aspect ratio and extend the world-space
      // map scope.
      if (resX < this.minMapImageSize) {
        // Adding pixels will also change the camera's aspect ratio => mapped scope will extended in x automatically
        resX = this.minMapImageSize;
      } else if (this.mapImageHeight < this.minMapImageSize) {
        // To extend mapped scope in y, we have to "zoom out" a bit. Just increasing image-height would increase the mapping
        // scale, so that we wouldn't capture the full x-extend of the map scope anymore.
        var oldHeight = this.mapImageHeight;
        resY = this.minMapImageSize;

        // This increases the camera frustum y-extend in world-space. Effect is:
        //  - Increase frustum along y-direction
        //  - Keep x-extent of camera frustum unaffected by modified camera aspect
        orthoScale *= resY / oldHeight;
      }

      // create new top-view camera
      var cam = new av.UnifiedCamera(resX, resY);
      var zRange = getZRange(this.viewer, levelIndex);
      Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["setTopView"])(cam, bbox, zRange.zMin, zRange.zMax, orthoScale);

      // Remember transform from model to map and back
      Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["compute3DTo2DMatrix"])(cam, this.mapMatrix);
      this.mapMatrixInverse.getInverse(this.mapMatrix);

      // Keep a copy of the mapMatrix to add to the cache when screenshot is done
      // Note that the actual map matrix might have changed until then.
      var mapMatrix = this.mapMatrix.clone();

      this.updatingMap = true;

      var onScreenshotDone = function onScreenshotDone(imageUrl) {

        _this11.updatingMap = false;
        _this11.screenShotInProgress = null;

        // Create sheetmap thumbnails to be embedded into the minimap
        var sheetMaps = _SheetMap_js__WEBPACK_IMPORTED_MODULE_1__["default"].createSheetMapConfigs(_this11.mapModels, levelGuid, _this11.mapMatrix, resX, resY);

        // add LevelMap to cache for later reuse
        _this11.mapCache[levelIndex] = {
          imageUrl: imageUrl,
          width: resX,
          height: resY,
          mapMatrix: mapMatrix, // Note that mapMatrix is always the right one - while this.mapMatrix might have changed meanwhile.
          sheetMaps: sheetMaps };


        // activate the new map (unless the user changed to another floor or to a sheet map meanwhile)
        _this11.update();

        // make sure that new sheetmap thumbnails are visible/hidden depending on whether sheetmaps are enabled
        _this11.updateThumbnailVisiblity();
      };

      // Use another polygon offset setting for the snapshot. Otherwise, edges are mostly missing in
      // ortho-vies exactly from above.
      //
      // TODO: It's some performance waste to do that back-and-forth change on all materials. It would be nice
      //       if we could find a more elegant solution here. E.g., setting polygonOffset on the lines instead - but
      //       this didn't seem to work.
      var mats = this.viewer.impl.getMaterials();
      var poEnabled;
      var poFactor;
      var poUnits;
      var applyCustomPolygonOffset = function applyCustomPolygonOffset() {
        // remember main polygonOffset settings
        poEnabled = mats.getPolygonOffsetOn();
        poFactor = mats.getPolygonOffsetFactor();
        poUnits = mats.getPolygonOffsetUnits();

        // apply custom polygon offset
        mats.togglePolygonOffset(true, 1.0, 5.0);
      };
      var revertCustomPolygonOffset = function revertCustomPolygonOffset() {
        // revert main-canvas polygonOffset
        mats.togglePolygonOffset(poEnabled, poFactor, poUnits);
      };

      // make empty map-space transparent
      var renderConfig = this.viewer.impl.renderer().getConfig();
      renderConfig.clearAlpha = 0.0;

      // Make sure that Minimap creation is not affected by current fragment modifications in main view (e.g. setting frags off or ghosted)
      var fragOptions = {
        isFragVisible: function isFragVisible() {return true;}, // force fragment ghosting off
        isFragOff: function isFragOff() {return false;} // avoid frags to be excluded
      };

      var options = {
        camera: cam,
        onProgress: function onProgress(percent) {return _this11.updateProgressWidget(percent);},
        beforeRender: applyCustomPolygonOffset,
        afterRender: revertCustomPolygonOffset,
        renderConfig: renderConfig,
        models: this.mapModels,
        fragOptions: fragOptions,
        excludeCutPlanes: true, // Make map content independent of current cutplane states, e.g. FloorSelector or SectionTool
        excludeThemingColors: true };

      this.screenShotInProgress = this.viewer.impl.getScreenShotProgressive(resX, resY, onScreenshotDone, options);
    }

    // Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
  }, { key: "worldToMapPixels", value: function worldToMapPixels(pos3D) {
      return Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["worldToMapPixels"])(pos3D, this.mapMatrix, this.mapImageWidth, this.mapImageHeight);
    }

    // Convert minimap pixel coords (+ world-z) to 3D world position. Minimap pixels are absolute, i.e. not affected by scrolling.
  }, { key: "mapPixelsToWorld", value: function mapPixelsToWorld(posX, posY, zWorld) {
      return Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["mapPixelsToWorld"])(posX, posY, zWorld, this.mapMatrixInverse, this.mapImageWidth, this.mapImageHeight);
    }

    // Compute rotation angle for camera view-cone on map.
    //  @param {THREE.Vector2} pos    - camera position     in minimap pixel space
    //  @param {THREE.Vector2} target - camera target point in minimap pixel space
    //  @returns {number}  Rotation angle in radians to transform a originally up-facing div located
    //                     in a way that it points towards (p2-p1).
  }, { key: "computeAngle", value: function computeAngle(pos, target) {
      var dx = target.x - pos.x;
      var dy = target.y - pos.y;
      var angle = Math.atan2(dy, dx);

      // atan measures the angle to the x-axis, but we want it to work for divs originally aligned with +y.
      angle += Math.PI / 2;

      return angle;
    }

    // Default behavior: Use the (first) visible 3D model for the map
  }, { key: "setDefaultMapModel", value: function setDefaultMapModel() {

      var models = this.viewer.getVisibleModels();
      var is3d = function is3d(m) {return m.is3d();};
      if (models && models.every(is3d)) {
        this.setMapModels(models);
      } else {
        this.setMapModels(null);
      }
    }

    // Set/Change model for which we generate the map
  }, { key: "setMapModels", value: function setMapModels(models) {var _this12 = this;

      // If the models are the same, there is nothing to do
      if (!models && !this.mapModels) {
        return;
      }

      // Model count is usually small enough, otherwise we would need to avoid O(modelCount^2) here.
      var modelKnown = function modelKnown(m) {return _this12.mapModels.indexOf(m) >= 0;};
      if (models && this.mapModels && models.length === this.mapModels.length && models.every(modelKnown)) {
        return;
      }

      // We don't want to distinguish null and empty array, so we always set null if there is no model.
      // Note that we better copy the array than sharing them - to make sure that they are not changed outside our control.
      this.mapModels = models && models.length ? models.slice() : null;

      // Cancel any running map creation if the model changed
      this.cancelMapUpdate();

      // Clear cached maps and invalidate current one
      this.mapCache = {};
      this.sheetMap.clearSheetCache();
      this.mapValid = false;
      this.update();
    } }, { key: "configureSettings", value: function configureSettings()

    {

      //Is it a GUI viewer or not?
      if (!this.viewer.getSettingsPanel)
      return;

      var panel = this.viewer.getSettingsPanel(true);

      if (!panel.is3dMode)
      return;

      var navTab = av.Extensions.ViewerSettingTab.Navigation;
      panel.addLabel(navTab, "3D Mini-map");

      // add toggle to the hypermodeling tab of the viewer settings
      if (!panel.showMinimapChkBoxId) {
        panel.showMinimapChkBoxId = panel.addCheckbox(
        navTab,
        "Show 3D mini-map",
        "Toggles availability of the 3D mini-map when using first person mode",
        true,
        this.onVisibilityChangedCB,
        VISIBILITY_PROP);

      }
    } }, { key: "requestTimer", value: function requestTimer()

    {
      var _window = this.getWindow();
      this.animTimerId = _window.requestAnimationFrame(this.onTimerCB);
    } }, { key: "cancelTimer", value: function cancelTimer()

    {
      var _window = this.getWindow();
      _window.cancelAnimationFrame(this.animTimerId);
    } }, { key: "onTimer", value: function onTimer()

    {
      // get elapsed time in seconds
      var curTime = performance.now();
      var elapsed = curTime - this.lastTimer;
      this.lastTimer = curTime;

      // get time in seconds and restrict it (if we got no events for a while)
      elapsed = Math.min(elapsed || 0, 1000);
      elapsed /= 1000;

      this.updateZoomScale(elapsed);
      this.updateScrolling(elapsed);

      this.requestTimer();

      // Trigger notification if target scrollPos is reached and all other time-dependent stuff is finished.
      if (this.isAllDone()) {
        this.waitingCallbacks.forEach(function (p) {return p();});
        this.waitingCallbacks.length = 0;
      }
    } }, { key: "setZoomScale", value: function setZoomScale(

    scale) {

      // Compute scroll position to follow the player
      if (this.autoScrollLocked) {
        return;
      }

      var oldScale = this.zoomScale;
      this.zoomScale = scale;

      // update scaled image size
      this.scaledImageWidth = this.mapImageWidth * this.zoomScale;
      this.scaledImageHeight = this.mapImageHeight * this.zoomScale;

      // recompute target scroll position based on player position
      this.computeTargetScrollPosition();

      var zoomOut = scale < oldScale;
      if (zoomOut) {
        var focusX = this.mapCenter.x;
        var focusY = this.mapCenter.y;

        // compute previous player position relative to widget
        var px = focusX * oldScale - this.scrollPos.x;
        var py = focusY * oldScale - this.scrollPos.y;

        // compute new scroll position in a way that the relative player-widget position keeps the same
        this.scrollPos.x = focusX * this.zoomScale - px;
        this.scrollPos.y = focusY * this.zoomScale - py;
      } else {
        // zoom-in: We choose a sub-region of the currently visible map region. We choose it in a way that
        // it gets as close to the targetScrollPos as possible.

        // compute region within the zoomed-in map that corresponds to the previously visible one.
        var rescale = scale / oldScale;
        var regionMinX = this.scrollPos.x * rescale;
        var regionMinY = this.scrollPos.y * rescale;
        var regionWidth = this.mapWidgetWidth * rescale;
        var regionHeight = this.mapWidgetHeight * rescale;

        // compute max-scroll position to keep within that region
        var maxScrollX = regionMinX + regionWidth - this.mapWidgetWidth;
        var maxScrollY = regionMinY + regionHeight - this.mapWidgetHeight;

        // Zoom directly to target position - but clamp against the region above
        this.scrollPos.copy(this.targetScrollPos);
        this.scrollPos.x = THREE.Math.clamp(this.scrollPos.x, regionMinX, maxScrollX);
        this.scrollPos.y = THREE.Math.clamp(this.scrollPos.y, regionMinY, maxScrollY);
      }

      // update affected widgets
      this.updatePlayerWidget();
      this.applyScrolling();
    }

    // compute min zoomScale so that we stop zoom-out when whole mapImage fits into the widget
  }, { key: "getMinZoomLevel", value: function getMinZoomLevel() {
      var minScaleX = this.mapWidgetWidth / this.mapImageWidth;
      var minScaleY = this.mapWidgetHeight / this.mapImageHeight;
      return Math.log2(Math.min(minScaleX, minScaleY));
    } }, { key: "getMaxZoomLevel", value: function getMaxZoomLevel()

    {
      // zoomLevel of 0 corresponds to zoomScale 2^0 = 1 => maximum available map resolution.
      // Allow 8x more zoom if we are within a sheetMap. These are vector graphics, so we don't care for resolution.
      // Note: We could make this smarter by using the 2D/3D transform to determine some maximum sheet-pixel per world-meter value
      return this.sheetMapActive ? 3 : 0;
    } }, { key: "setZoomLevel", value: function setZoomLevel(

    value, useTransition) {
      this.targetZoomLevel = value;

      // By default, we will smoothly move towards the target zoomlevel. If this is not
      // wanted, we apply the target value immediately.
      if (!useTransition) {
        this.zoomLevel = this.targetZoomLevel;

        // Stop immediately and avoid smoothing from producing NAN values due to infinite speed
        this.lastZoomSpeed = 0;

        // Apply scale immediately
        this.setZoomScale(Math.pow(2, this.zoomLevel));
      }
    }

    // animate zoom-scale to smoothly follow current targetZoomLevel
  }, { key: "updateZoomScale", value: function updateZoomScale(elapsed) {

      var delta = this.targetZoomLevel - this.zoomLevel;

      // Skip if there is no change needed
      if (delta === 0) {
        return;
      }

      // remember zoom-direction
      var zoomOut = delta > 0;

      // Temporarily drop sign, so that we can assume positive values for smoothing
      delta = Math.abs(delta);

      // If difference between zoomLevel and targetZoomLevel is hardly noticeable, stop
      // zooming and set value exactly, so that the result is more deterministic.
      if (delta < 0.001) {
        this.zoomLevel = this.targetZoomLevel;
      } else {
        // apply smoothing
        delta = Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["motionSmoothing"])(delta, elapsed, this.zoomSpeed, this.lastZoomSpeed, this.zoomAcc);

        if (elapsed) {
          this.lastZoomSpeed = delta / elapsed;
        }

        // apply delta to zoomLevel
        this.zoomLevel += delta * (zoomOut ? 1 : -1);
      }

      // update zoomScale accordingly
      this.setZoomScale(Math.pow(2, this.zoomLevel));
    } }, { key: "updateMaxFloorTextWidth", value: function updateMaxFloorTextWidth()

    {
      if (this.mapWidget.floorText) {
        var padding = this.sideBySide ? 130 : 50;
        this.mapWidget.floorText.style.maxWidth = "".concat(parseInt(this.mapWidget.style.width) - padding, "px");
      }
    } }, { key: "setWidgetSize", value: function setWidgetSize(

    w, h) {
      this.mapWidgetWidth = w;
      this.mapWidgetHeight = h;

      var wStr = toPixels(w);
      var hStr = toPixels(h);
      this.placeholderDiv.style.width = wStr;
      this.placeholderDiv.style.height = hStr;
      this.mapWidgetRoot.style.width = wStr;
      this.mapWidgetRoot.style.height = hStr;

      // Make sure that the LMV instance for sheet maps is kept in sync
      this.sheetMap.onResize();
      this.widgetSizeChanged = true;
      this.update();
    }

    // Update mapWidget size based on canvas size
  }, { key: "updateMapSize", value: function updateMapSize() {
      var canvasWidth = this.viewer.container.clientWidth;
      var canvasHeight = this.viewer.container.clientHeight;

      var width, height;
      if (this.sideBySide) {
        // Fill x percent of the parent widget (x = sideBySideSplit)
        if (this.verticalSideBySide) {
          width = canvasWidth;
          height = canvasHeight * (this.sideBySideSplit / (100 - this.sideBySideSplit));
        } else {
          width = canvasWidth * (this.sideBySideSplit / (100 - this.sideBySideSplit));
          height = canvasHeight;
        }
      } else {
        // Default mode: Small map on top-right of the screen
        var longEdge = Math.max(canvasWidth, canvasHeight);
        var shortEdge = Math.min(canvasWidth, canvasHeight);

        // Restrict mapSize to not exceed a certain percentage of canvas width/height
        width = Math.min(this.relMapWidgetSizeLongEdge * longEdge, this.relMapWidgetSizeShortEdge * shortEdge);
        height = width;
      }
      this.setWidgetSize(width, height);
    } }, { key: "onResize", value: function onResize()

    {
      if (this.sideBySide) {
        var containerBounds = this.viewer.container.parentElement.getBoundingClientRect();

        if (!this.lastContainerBounds || this.lastContainerBounds.width !== containerBounds.width && this.lastContainerBounds.height !== containerBounds.height) {
          this.lastContainerBounds = containerBounds;
          this.updateSideBySide(true);

          return;
        }
      }

      this.updateMapSize();
    }

    // Relocate BimWalk info button to avoid overlap with Map widget
  }, { key: "updateBimWalkInfoButtonPos", value: function updateBimWalkInfoButtonPos() {
      var bimWalk = this.viewer.getExtension(BIMWALK_EXT);
      var button = bimWalk && bimWalk.getInfoButton();
      if (!button) {
        return;
      }

      // If the infor icon is hidden, we don't need all the mess. Hopefully this will get the default
      // state if others remove the info button as well
      if (bimWalk.options.disableBimWalkInfoIcon) {
        return;
      }

      // Force buttons within the map - otherwise they would overlap with the info button.
      this.toolbar.mapButtonBar.style.right = '0px';
      this.toolbar.mapButtonBar.style.marginTop = '4px'; // within the map, we always need the margin, even in side-by-side

      // Only reserve space minimap is visible or about to fade in.
      var _window = this.getWindow();
      var style = _window.getComputedStyle(this.mapWidget);
      var visible = this.visible || style.opacity > 0;
      var reservedWidth = visible ? this.mapWidgetWidth : 0;

      // Shifting the info button is not needed in side-by-side mode,
      // because the map widget is outside the viewer canvas in this case.
      if (this.sideBySide) {
        reservedWidth = 0;
      }

      // Includes space between InfoButton and MapWidget + Space between MapWidget and right canvas boundary
      var Margin = 20;
      var right = reservedWidth + Margin;
      button.style.right = toPixels(right);
    } }, { key: "isOutside", value: function isOutside()

    {
      return !this.mapPixelValid(this.playerPos.x, this.playerPos.y);
    } }, { key: "mapPixelValid", value: function mapPixelValid(

    x, y) {
      return x >= 0 && y >= 0 && x < this.mapImageWidth && y < this.mapImageHeight;
    }

    // Toggle between auto-generated map image and sheets. Note that sheets may not be available for a level.
    // In this case, we fall back to the default map.
  }, { key: "setSheetMapEnabled", value: function setSheetMapEnabled(enabled) {
      this.useSheet = enabled;
      this.update();
      this.updateThumbnailVisiblity();
    } }, { key: "setSideBySideEnabled", value: function setSideBySideEnabled(

    enabled) {
      this.sideBySideEnabled = enabled;
      this.updateSideBySide();
    }

    // Makes sure that all sheetmap thumbnails are visible/hidden depending on whether sheetmaps are enabled
  }, { key: "updateThumbnailVisiblity", value: function updateThumbnailVisiblity() {
      for (var key in this.mapCache) {
        var map = this.mapCache[key];
        var sheetMaps = map.sheetMaps;
        for (var i = 0; i < sheetMaps.length; i++) {
          var sheetMap = sheetMaps[i];
          var opacity = this.useSheet ? _SheetMap_js__WEBPACK_IMPORTED_MODULE_1__["default"].OverlayOpacity : 0.0;
          this.fadeWidgetOpacity(sheetMap.thumbnail.div, opacity);
        }
      }
    } }, { key: "setSideBySideSplit", value: function setSideBySideSplit(

    value, onDone) {var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !this.sideBySideOptions.animateSideBySideMode;
      if (immediate) {
        this.sideBySideSplit = value;
        this.updateSideBySide(true);
        this.updateBimWalkInfoButtonPos();
        onDone && onDone();
      } else {
        this.animateSideBySideSplit(value, onDone);
      }
    } }, { key: "animateSideBySideSplit", value: function animateSideBySideSplit(

    targetValue, onSlideDone) {var _this13 = this;
      var FadeDuration = 0.2;

      var startVal = this.sideBySideSplit;

      var onTimer = function onTimer(t) {
        t = avp.smootherStep(t);
        _this13.sideBySideSplit = avp.lerp(startVal, targetValue, t);
        _this13.updateSideBySide(true);
        _this13.updateBimWalkInfoButtonPos();
      };

      var onSlideEnd = function onSlideEnd() {
        onSlideDone && onSlideDone();
      };

      avp.fadeValue(0, 1, FadeDuration, onTimer, onSlideEnd);
    }

    // Make sure that side-by-side layout is activated if and only if minimap is visible
  }, { key: "updateSideBySide", value: function updateSideBySide(force) {

      var wasSideBySide = this.sideBySide;
      this.sideBySide = this.visible && this.sideBySideEnabled;
      if (!force && wasSideBySide === this.sideBySide) {
        return;
      }

      if (this.sideBySide) {
        var containerBounds = this.viewer.container.parentElement.getBoundingClientRect();

        // Insert widget into parent of main viewer (this also removes it from viewer.container)
        var parent = this.viewer.container.parentElement;
        parent.appendChild(this.mapWidgetRoot);

        this.mapWidgetRoot.classList.add('side-by-side');

        if (containerBounds.width >= containerBounds.height) {
          // reduce width of main viewer to leave space for minimap on the right
          this.viewer.container.style.width = (100 - this.sideBySideSplit).toString() + "%";
          this.viewer.container.style.height = '100%';

          if (this.sideBySideOptions.left2DView) {
            this.viewer.container.style.left = this.sideBySideSplit.toString() + "%";
          } else {
            this.viewer.container.style.right = this.sideBySideSplit.toString() + "%";
          }

          this.viewer.container.style.top = '0px';

          if (this.sideBySideOptions.left2DView) {
            this.mapWidgetRoot.classList.add('left-2d-view');
          }

          this.verticalSideBySide = false;
          this.setRotation(0);
        } else {
          this.viewer.container.style.width = '100%';
          this.viewer.container.style.height = (100 - this.sideBySideSplit).toString() + "%";
          this.viewer.container.style.top = this.sideBySideSplit.toString() + "%";
          this.viewer.container.style.left = '0px';
          this.viewer.container.style.right = 'initial';

          this.verticalSideBySide = true;
          this.setRotation(Math.PI / 2);
        }

        if (this.sideBySideOptions.onSideBySideUpdated) {
          this.sideBySideOptions.onSideBySideUpdated(this.sideBySideSplit);
        }
      } else {

        // Move minimap back into viewer container (as overlay)
        this.viewer.container.appendChild(this.mapWidgetRoot);

        // resize main viewer back to 100% and move it back to the left
        this.viewer.container.style.width = "100%";
        this.viewer.container.style.height = "100%";
        this.viewer.container.style.left = "0%";
        this.viewer.container.style.top = "0%";

        this.mapWidgetRoot.classList.remove('side-by-side');
        this.mapWidgetRoot.classList.remove('left-2d-view');

        this.setRotation(0);
      }

      // keep canvas/camera in-sync, because we changed container size
      this.viewer.resize();

      this.updateMapSize();
      this.resetScrolling();
    }

    // Check if a sheetmap is available for current level
  }, { key: "sheetMapsAvailable", value: function sheetMapsAvailable() {
      var level = this.getCurrentLevel();
      var map = level && this.mapCache[level.index];
      return map && map.sheetMaps && map.sheetMaps.length;
    } }, { key: "animationActive", value: function animationActive()

    {
      var zooming = Math.abs(this.zoomLevel - this.targetZoomLevel) > 1.e-9;
      var delta = this.targetScrollPos.clone().sub(this.scrollPos);
      var dist = delta.length();
      var scrolling = dist >= 0.5;
      var fading = this.fadingWidgets > 0;
      var sheetAnim = this.sheetMapTransition.isRunning();
      return zooming || scrolling || fading || sheetAnim;
    }

    // Set rotation angle (clockwise in radians)
  }, { key: "setRotation", value: function setRotation(angle) {
      this.mapRotationAngle = angle;
      this.updateRotation();
    } }, { key: "updateRotation", value: function updateRotation()

    {

      var mapImage = this.mapWidget.mapImage;
      if (!mapImage || !this.mapValid) {
        // If mapValid is false, mapImage is just the placeholder to show load progress - which shouldn't be rotated.
        return;
      }

      // get widget center point within the unrotated main map
      var px = this.scrollPos.x + 0.5 * this.mapWidgetWidth;
      var py = this.scrollPos.y + 0.5 * this.mapWidgetHeight;

      // convert to percent values relative to mapImage. Note px is in scaled mapPixels, i.e.
      // after applying zoomScale.
      px *= 100 / this.scaledImageWidth;
      py *= 100 / this.scaledImageHeight;

      // Use player position as location center
      mapImage.style.transformOrigin = toPercent(px) + ' ' + toPercent(py);

      // apply rotation angle
      var rotString = 'rotate(' + this.mapRotationAngle.toString() + 'rad)';
      mapImage.style.transform = rotString;
    }

    // Compute widget center point - which we use as map rotation center.
  }, { key: "getWidgetCenter", value: function getWidgetCenter() {
      return new THREE.Vector2(
      (this.scrollPos.x + 0.5 * this.mapWidgetWidth) / this.zoomScale,
      (this.scrollPos.y + 0.5 * this.mapWidgetHeight) / this.zoomScale);

    }

    // @param {Vector2} p - transformed in-place from widget pixels to map image pixels
    //                      widget pixel origin is at top-left, i.e., y-axis points down (compatible to mouse events)
  }, { key: "widgetToMapPixels", value: function widgetToMapPixels(p) {

      // revert scroll-position offset
      p.x += this.scrollPos.x;
      p.y += this.scrollPos.y;

      // revert zoom-scale, so that result is in full-resolution map pixels
      p.x /= this.zoomScale;
      p.y /= this.zoomScale;

      // If the map is not rotated, (x,y) are now valid mapImage pixels coords

      // rotate p around widget center
      //
      // Since the map is clockwise rotated by mapRotationAngle, the visible area inside this
      // map has counterclockwise rotated by this angle.
      var widgetCenter = this.getWidgetCenter();
      Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["rotateAround"])(p, widgetCenter, -this.mapRotationAngle);
    }

    // @param {Vector2} p - point in map-pixel space:             Value range is [0, 0] x [mapImageWidth, mapImageHeight]
    // Converts p to a relative pixel-position in the map widget: Value range is [0, 0] x [mapWidgetWidth, mapWidgetHeight]
  }, { key: "mapPixelsToWidget", value: function mapPixelsToWidget(p) {

      var widgetCenter = this.getWidgetCenter();
      Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_5__["rotateAround"])(p, widgetCenter, this.mapRotationAngle);

      // apply zoom-scale
      p.x *= this.zoomScale;
      p.y *= this.zoomScale;

      // apply scrolling
      p.x -= this.scrollPos.x;
      p.y -= this.scrollPos.y;
    }

    // Returns true if minimap is in a stable state for the current camera.
    // This means that all models are loaded, the map image is created,
    // no animation is in progress, sheetmap loaded etc.
  }, { key: "isAllDone", value: function isAllDone() {

      // Are we about to switch the map to another level?
      var pendingLevelChange = this.currentLevelIndex === this.getCurrentLevel();

      // Did we reach the desired scroll position already?
      var isScrolling = !this.scrollPos.equals(this.targetScrollPos);

      // Zooming may happen based on mouse-wheel or due to automatic zoom in/out for sheetMaps
      var isZooming = this.zoomLevel !== this.targetZoomLevel || this.sheetMapTransition.isRunning();

      // TODO: We do not consider widget fading yet. In case we are going to use UI snapshots, this
      //       will be needed as well. By adding a waitFor() to AnimControl and use fadeWidget also for the main widget.

      return (
        this.mapModelsReady() && // ...not waiting for models to load
        !this.updatingMap && // ...not rendering a map image
        !this.sheetMap.loading && // ...not waiting for a sheetMap to load
        !pendingLevelChange && // ...displaying the right level already
        !this.slidingInProgress && // ...not within a UI transition from/to side-by-side
        !this.tool.flyToAnimRunning() && // ...not within a fly-to animation due to a dblClick
        !isScrolling && !isZooming);

    }

    // Returns a promise that resolves as soon as isAllDone() returns true.
  }, { key: "waitForAllDone", value: function waitForAllDone() {var _this14 = this;

      // Make sure that minimap is aware of latest changes, e.g., if BimWalk has switched on/off since last update.
      this.update();

      if (this.isAllDone()) {
        return Promise.resolve();
      }
      return new Promise(function (resolve) {
        _this14.waitingCallbacks.push(resolve);
      });
    } }]);return Minimap3DExtension;}(av.Extension);


namespace.Minimap3DExtension = Minimap3DExtension;

Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Minimap3DExtension);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapMath.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapMath.js ***!
  \*************************************************/
/*! exports provided: worldToMapPixels, mapPixelsToWorld, posIsInsideMap, setCameraFromFrustumCorners, setTopView, compute3DTo2DMatrix, motionSmoothing, rotateAround, expandToSquare, boundsToUnitQuad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "worldToMapPixels", function() { return worldToMapPixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPixelsToWorld", function() { return mapPixelsToWorld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "posIsInsideMap", function() { return posIsInsideMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCameraFromFrustumCorners", function() { return setCameraFromFrustumCorners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTopView", function() { return setTopView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compute3DTo2DMatrix", function() { return compute3DTo2DMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "motionSmoothing", function() { return motionSmoothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAround", function() { return rotateAround; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandToSquare", function() { return expandToSquare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsToUnitQuad", function() { return boundsToUnitQuad; });
// Utility functions used by Minimap


// Transform 3D model position to pixel-space position on full MiniMap. Indepdent of scroll-position.
var worldToMapPixels = function worldToMapPixels(pos3D, mapMatrix, mapWidth, mapHeight) {
  var p = pos3D.clone().applyProjection(mapMatrix);
  var res = new THREE.Vector2(
  (p.x + 1) / 2 * mapWidth,
  (-p.y + 1) / 2 * mapHeight);

  return res;
};

var mapPixelsToWorld = function mapPixelsToWorld(posX, posY, zWorld, mapMatrixInv, mapWidth, mapHeight) {
  // convert pixels to normalized viewport coords in [-1,1]
  var vx = 2 * (posX / mapWidth) - 1.0;
  var vy = 2 * (posY / mapHeight) - 1.0;

  // Beware of the annoying y-flip
  var p = new THREE.Vector3(vx, -vy, 0.0).applyProjection(mapMatrixInv);
  p.z = zWorld;
  return p;
};

// Checks whether the given 3D position would appear inside the map for the given mapMatrix.
//  @param {Vector3} pos3D
//  @param {Matrix4} mapMatrix
//  @returns {bool}
var _tmpVec = null;
var posIsInsideMap = function posIsInsideMap(pos3D, mapMatrix) {

  _tmpVec = _tmpVec || new THREE.Vector3();

  // Compute position in map space [-1, 1] that we would get when using this map
  var mapPos = _tmpVec.copy(pos3D).applyProjection(mapMatrix);

  // Check if camera position is inside
  return Math.abs(mapPos.x) < 1.0 && Math.abs(mapPos.y) < 1.0;
};

// Configures the ortho-camera from given 3 points, so that:
//  p0: appears at lower-left corner
//  p1: appears at lower-right corner
//  p2: appears at upper-left corner
//
// We assume that camera target.z is already set and on the sheet-plane level
var setCameraFromFrustumCorners = function setCameraFromFrustumCorners(camera, p0, p1, p2) {

  // up-vector: p2-p0
  camera.up.x = p2.x - p0.x;
  camera.up.y = p2.y - p0.y;

  // position
  camera.position.x = 0.5 * (p1.x + p2.x);
  camera.position.y = 0.5 * (p1.y + p2.y);

  var frustumHeight = camera.up.length();

  // normalize up-vector
  camera.up.multiplyScalar(1.0 / frustumHeight);

  // For LMV ortho-cameras...
  // - The vertical frustum height is identical with the orthoScale 
  // - The orthoScale is determined by the distance between position and target
  // - For sheets, the view direction is always -z and zoom is manipulated by changing pos.z while having a constant target.z
  // Therefore, we obtain the desired frustum height by:
  var targetDist = frustumHeight;
  camera.position.z = camera.target.z + targetDist;

  // keep horizontal target position in sync
  camera.target.x = camera.position.x;
  camera.target.y = camera.position.y;

  // This updates the camera quaternion. Without this, modifying the up-vector would not have any effect.
  Autodesk.Viewing.Navigation.prototype.orient(camera, camera.target, camera.position, camera.up);
};

var setTopView = function setTopView(camera, bbox, zMin, zMax, orthoScale) {

  var center = THREE.Box3.prototype.center.call(bbox);

  // set camera pos to upper face center
  camera.position.copy(center);
  camera.position.z = zMax;

  // target distance defines orthoScale, which finally
  // defines the height of the orthoCam frustum in world-space
  camera.target.copy(camera.position);
  camera.target.z -= orthoScale;
  camera.isPerspective = false;

  // set up-vector for view from top
  camera.up.set(0, 1, 0);
  camera.worldup.set(0, 1, 0);

  // Configure near/far to see only zMin/zMax range
  camera.near = 0;
  camera.far = zMax - zMin;

  // This makes sure that compute3DTo2DMatrix() produces always the same resuts, no matter whether we do it before or after rendering.
  camera.updateCameraMatrices();
};

// Computes a Matrix4 that transforms from 3D model position to
// normalized viewport coords ([-1,1]^2) on the minimap.
var compute3DTo2DMatrix = function compute3DTo2DMatrix(camera, dstMatrix) {
  dstMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
};

// Helper function to smoothen movement of scroll position and zoomScale.
//  @param {number} dist      - distance to move to reach target directly. Must be >=0.
//  @param {number} elapsed   - elapsed time in seconds
//  @param {number} maxSpeed  - maximum allowed distance units per second
//  @param {number} lastSpeed - motion speed according to last cycle (delta / elapsed)
//  @param {number} acc       - acceleration speed (in distance units per s^2)
//  @returns {number} Result is a distance <=dist, which is slowed down if needed for smoother movement.
var motionSmoothing = function motionSmoothing(dist, elapsed, maxSpeed, lastSpeed, acc) {

  // Limit max scroll speed and avoid too sudden acceleration compared to last cycle
  var speed = Math.min(maxSpeed, lastSpeed + acc * elapsed);

  // Slow down with constant deceleration when approaching the target position:
  //
  //   With a constant acceleration a for a time of t seconds, we have:
  //     speed    = t*a
  //     distance = 0.5 * a * t^2
  //
  // To scroll a given distance d with constant acceleration a, the time needed is:
  //   t = sqrt(2*d / a)
  //
  // The speed reached at that point is:
  //   s = a * sqrt(2*d / a)
  //
  // Therefore, s as given above gives us the speed that we must have if distance d
  // to the target if we want to stop at the target given a constant deceleration of a.
  var slowDownSpeed = acc * Math.sqrt(2 * dist / acc);
  speed = Math.min(slowDownSpeed, speed);

  // restrict distance based on computed speed limit
  var maxDist = speed * elapsed;
  return Math.min(dist, maxDist);
};

// Rotates p around the center point. Works for Vector3 in xy too.
//  @param {Vector2} p
//  @param {Vector2} center
//  @param {number}  angle  - counterclockwise angle in radians
var rotateAround = function rotateAround(p, center, angle) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  var x = p.x - center.x;
  var y = p.y - center.y;

  p.x = x * c - y * s + center.x;
  p.y = x * s + y * c + center.y;
};

// Expands rect in-place by expanding the smallest axis around the center.
//  @param {Box2} rect
var expandToSquare = function expandToSquare(rect) {

  // determine scale factor from max-axis of sheet bounds
  var diag = rect.size();
  var center = rect.center();

  var radius = 0.5 * Math.max(diag.x, diag.y);

  rect.min.set(center.x - radius, center.y - radius);
  rect.max.set(center.x + radius, center.y + radius);
};

// Rescales a point p within srcBounds to [0.1]^2. Works in-place.
//  @param {Vector2} p
//  @param {Box2} srcBounds
var boundsToUnitQuad = function boundsToUnitQuad(p, srcBounds) {
  var diagX = srcBounds.max.x - srcBounds.min.x;
  var diagY = srcBounds.max.y - srcBounds.min.y;

  p.x -= srcBounds.min.x;
  p.y -= srcBounds.min.y;

  p.x /= diagX;
  p.y /= diagY;
};



/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapTool.js":
/*!*************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapTool.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapTool; });
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var GlobalManagerMixin = Autodesk.Viewing.GlobalManagerMixin;

var zAxis = new THREE.Vector3(0, 0, 1);


// Implements interaction to move player position and view direction in the Minimap
var MinimapTool = /*#__PURE__*/function () {
  function MinimapTool(parent) {var trackUsage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;_classCallCheck(this, MinimapTool);
    this.parent = parent;
    this.setGlobalManager(this.parent.globalManager);

    this.trackUsage = trackUsage;
    this.avatarInteractionTracked = false;
    this.zoomTracked = false;

    this.dragDirectionStart = this.dragDirectionStart.bind(this);
    this.dragDirectionMove = this.dragDirectionMove.bind(this);
    this.dragDirectionEnd = this.dragDirectionEnd.bind(this);

    this.dragPositionStart = this.dragPositionStart.bind(this);
    this.dragPositionMove = this.dragPositionMove.bind(this);
    this.dragPositionEnd = this.dragPositionEnd.bind(this);

    this.dragMapStart = this.dragMapStart.bind(this);
    this.dragMapMove = this.dragMapMove.bind(this);
    this.dragMapEnd = this.dragMapEnd.bind(this);

    this.onWheel = this.onWheel.bind(this);
    this.onDblClick = this.onDblClick.bind(this);

    this.handleGesture = this.handleGesture.bind(this);

    // when dragging view direction, we lastAngle stores the angle between +y and the line from playerPos to last mouse position.
    this.lastAngle = undefined;

    // Zoom-factor change per mouse-wheel delta
    this.zoomSensitivity = 0.05;

    // In order to prevent multiple navigation events simultaneously, on each event-start dragLock should be set.
    // At most cased event.stopPropagation would be enough, but because we mix DOM events and Hammer.js - it's not stopping the propagation entirely.
    this.dragLock = false;

    // Time in seconds for flyTo animations used on dblClick.
    this.flyToTime = 1.0;
    this.flyToAnim = null; // {AnimControl}
  }_createClass(MinimapTool, [{ key: "onWheel", value: function onWheel(

    e) {
      if (this.parent.animationActive()) {
        return;
      }

      // TODO: Use ToolController or consider annoying browser differences
      var delta = e.wheelDelta / 40;

      // modify zoomScale
      var zoomLevelNew = this.parent.targetZoomLevel + delta * this.zoomSensitivity;

      // zoomLevel of 0 corresponds to zoomScale 2^0 = 1 => maximum available map resolution.
      var zoomLevelMax = this.parent.getMaxZoomLevel();

      // clamp against valid zoom range
      var zoomLevelMin = this.parent.getMinZoomLevel();
      zoomLevelNew = THREE.Math.clamp(zoomLevelNew, zoomLevelMin, zoomLevelMax);

      // Stop here if there is no change. (e.g., when trying to zoomIn more when already at maxZoon)
      if (zoomLevelNew === this.parent.targetZoomLevel) {
        return;
      }

      // Get map position under mouse (before changing zoom)
      var zoomTargetPosBefore = this.getMapPosition(e);

      this.parent.setZoomLevel(zoomLevelNew, false);

      if (!this.dragLock) {

        // Goal here is that zoomTargetPos keeps under mouse after zoom as well.
        // For this, we adjust the mapCenter of the Minimap.

        // Apply position immediately.
        this.parent.resetScrolling();

        // Get map position under mouse (after changing zoom)
        var zoomTargetPosAfter = this.getMapPosition(e);

        // Compute correction offset: How far do we have to shift the map to move it back to zoomTargetPosBefore
        var offset = zoomTargetPosBefore.clone().sub(zoomTargetPosAfter);

        // Shift the map center accordingly. This shifts the position under mouse by the same amount.
        this.parent.mapCenter = this.parent.mapCenter.clone().add(offset);

        // We just shifted the map center, so we have to reset scrolling again.
        this.parent.resetScrolling();
      }

      if (!this.zoomTracked) {
        this.zoomTracked = true;
        this.trackUsage && this.trackUsage({
          zoom_tracked: true });

      }

      e.stopPropagation();
      e.preventDefault();
    } }, { key: "activate", value: function activate()

    {
      this.parent.playerPositionWidget.playerPositionHitArea.addEventListener('mousedown', this.dragPositionStart);
      this.parent.playerPositionWidget.playerPositionHitArea.addEventListener('touchstart', this.dragPositionStart);
      this.parent.playerPositionWidget.addEventListener('mousedown', this.dragDirectionStart);
      this.parent.playerPositionWidget.addEventListener('touchstart', this.dragDirectionStart);
      this.parent.mapWidget.addEventListener('mousedown', this.dragMapStart);
      this.parent.mapWidget.addEventListener('wheel', this.onWheel);
      this.parent.mapWidget.addEventListener('dblclick', this.onDblClick);

      if (Autodesk.Viewing.isTouchDevice()) {
        this.hammer = new Autodesk.Viewing.Hammer.Manager(this.parent.mapWidget, {
          recognizers: [
          Autodesk.Viewing.GestureRecognizers.drag,
          Autodesk.Viewing.GestureRecognizers.doubletap,
          Autodesk.Viewing.GestureRecognizers.pinch],

          handlePointerEventMouse: false,
          inputClass: Autodesk.Viewing.isIE11 ? Autodesk.Viewing.Hammer.PointerEventInput : Autodesk.Viewing.Hammer.TouchInput });


        this.hammer.get('pinch').recognizeWith([this.hammer.get('drag')]);
        this.hammer.on('pinchstart pinchmove pinchend', this.handleGesture);
        this.hammer.on('dragstart dragmove dragend', this.handleGesture);
        this.hammer.on('doubletap', this.onDblClick);
      }
    } }, { key: "deactivate", value: function deactivate()

    {
      this.parent.playerPositionWidget.playerPositionHitArea.removeEventListener('mousedown', this.dragPositionStart);
      this.parent.playerPositionWidget.playerPositionHitArea.removeEventListener('touchend', this.dragPositionStart);
      this.parent.playerPositionWidget.removeEventListener('mousedown', this.dragDirectionStart);
      this.parent.playerPositionWidget.removeEventListener('touchstart', this.dragDirectionStart);
      this.parent.mapWidget.removeEventListener('mousedown', this.dragMapStart);
      this.parent.mapWidget.removeEventListener('wheel', this.onWheel);
      this.parent.mapWidget.removeEventListener('dblclick', this.onDblClick);

      this.hammer && this.hammer.destroy();

      this.dragPositionEnd();
      this.dragDirectionEnd();
      this.dragMapEnd();
    }

    // Get the distance between the two fingers, relative to the map's size.
    // Used in order to measure how much we want to zoom - based on the pinch length and the map's dimensions.
  }, { key: "getNormalizedPointersDistance", value: function getNormalizedPointersDistance(event) {
      if (event.pointers[0] && event.pointers[1]) {
        var dx = (event.pointers[1].clientX - event.pointers[0].clientX) / this.parent.mapWidgetWidth;
        var dy = (event.pointers[1].clientY - event.pointers[0].clientY) / this.parent.mapWidgetHeight;
        return Math.sqrt(dx * dx + dy * dy);
      }

      return 0;
    } }, { key: "setMeanPoint", value: function setMeanPoint(

    event) {
      if (event.pointers[0] && event.pointers[1]) {
        event.clientX = (event.pointers[1].clientX + event.pointers[0].clientX) / 2;
        event.clientY = (event.pointers[1].clientY + event.pointers[0].clientY) / 2;
      }
    } }, { key: "handleGesture", value: function handleGesture(

    e) {
      if (this.dragLock && this.dragType !== 'map') {
        return;
      }

      this.convertEventHammerToMouse(e);
      this.setMeanPoint(e);

      var dist = this.getNormalizedPointersDistance(e) * 3000;
      e.wheelDelta = dist - (this.lastPinchDistance || 0);
      this.lastPinchDistance = dist;

      switch (e.type) {
        case 'dragstart':
          this.dragMapStart(e);
          break;
        case 'dragmove':
          this.dragMapMove(e);
          break;
        case 'dragend':
          this.dragMapEnd(e);
          break;
        case 'pinchstart':
          this.lastDragMapPoint = null;
          this.dragMapStart(e);
          this.lastDragMapPoint = this.getMapPosition(e, true);
          break;
        case 'pinchmove':
          this.dragMapMove(e);
          this.onWheel(e);
          this.lastDragMapPoint = this.getMapPosition(e, true);
          break;
        case 'pinchend':
          this.dragMapEnd(e);
          this.onWheel(e);
          break;
        default:
          break;}

    }

    // Convert event client coords to absolute (=zoom and scroll-independent) pixel-coords on the map.
  }, { key: "getMapPosition", value: function getMapPosition(e, ignoreScrollPos) {
      // get minimap pixel coords
      var clientRect = this.parent.mapWidget.getBoundingClientRect();

      if (e.type.contains('touch')) {
        e.clientX = e.touches[0].pageX;
        e.clientY = e.touches[0].pageY;
      }

      // get position within map widget
      var p = new THREE.Vector2(e.clientX - clientRect.left, e.clientY - clientRect.top);

      // transform point to mapImage pixels
      if (ignoreScrollPos) {
        p.x /= this.parent.zoomScale;
        p.y /= this.parent.zoomScale;
      } else {
        this.parent.widgetToMapPixels(p);
      }

      return p;
    } }, { key: "dragMapStart", value: function dragMapStart(

    e) {
      if (this.dragLock) {
        return;
      }

      if (this.parent.animationActive()) {
        return;
      }

      this.dragType = 'map';

      this.addWindowEventListener('mousemove', this.dragMapMove);
      this.addWindowEventListener('mouseup', this.dragMapEnd);

      this.lastDragMapPoint = this.getMapPosition(e, true);
      this.parent.mapCenter = this.parent.mapCenter.clone();

      this.dragLock = true;
      e.stopPropagation();
      e.preventDefault();
    } }, { key: "dragMapMove", value: function dragMapMove(

    e) {
      if (this.dragLock && this.dragType !== 'map') {
        return;
      }

      var currentPoint = this.getMapPosition(e, true);

      if (this.lastDragMapPoint) {
        var p = this.lastDragMapPoint.sub(currentPoint);
        Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["rotateAround"])(p, { x: 0, y: 0 }, -this.parent.mapRotationAngle);
        this.parent.mapCenter.add(p);
      }

      this.lastDragMapPoint = currentPoint;

      // Apply dragging immediately.
      this.parent.resetScrolling();

      this.parent.update();

      e.stopPropagation();
    } }, { key: "dragMapEnd", value: function dragMapEnd(

    e) {
      if (this.dragLock && this.dragType !== 'map') {
        return;
      }

      this.removeWindowEventListener('mousemove', this.dragMapMove);
      this.removeWindowEventListener('mouseup', this.dragMapEnd);

      this.lastDragMapPoint = null;

      this.parent.update();

      this.dragLock = false;
      e && e.stopPropagation();
    } }, { key: "dragPositionStart", value: function dragPositionStart(

    e) {
      if (this.dragLock) {
        return;
      }

      this.dragType = 'position';

      this.addWindowEventListener('mousemove', this.dragPositionMove);
      this.addWindowEventListener('mouseup', this.dragPositionEnd);
      this.addWindowEventListener('touchmove', this.dragPositionMove);
      this.addWindowEventListener('touchend', this.dragPositionEnd);

      // Make sure that map doesn't scroll/follow while we are moving the avatar
      this.parent.autoScrollLocked = true;

      this.dragLock = true;
      e.stopPropagation();
      e.preventDefault();
    } }, { key: "dragPositionMove", value: function dragPositionMove(

    e) {
      if (this.dragLock && this.dragType !== 'position') {
        return;
      }

      // get minimap pixel coords
      var _this$getMapPosition = this.getMapPosition(e),x = _this$getMapPosition.x,y = _this$getMapPosition.y;

      // clamp x/y to map extent => avoid dragging out of the map
      x = THREE.Math.clamp(x, 0, this.parent.mapImageWidth);
      y = THREE.Math.clamp(y, 0, this.parent.mapImageHeight);

      var camera = this.parent.viewer.impl.camera;

      // keep z the same as before
      var zWorld = camera.position.z;

      // save current pos
      var oldPosition = camera.position.clone();

      var pos3D = this.parent.mapPixelsToWorld(x, y, zWorld);

      // move camera to new 3D position
      camera.position.copy(pos3D);

      // apply delta to the target vector
      var delta = camera.position.clone().sub(oldPosition);

      camera.target.add(delta);
      camera.target.z = zWorld;

      this.parent.viewer.impl.invalidate(true, true, true);
      this.parent.viewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      e.stopPropagation();
    } }, { key: "dragPositionEnd", value: function dragPositionEnd(

    e) {
      if (this.dragLock && this.dragType !== 'position') {
        return;
      }

      this.parent.autoScrollLocked = false;

      this.removeWindowEventListener('mousemove', this.dragPositionMove);
      this.removeWindowEventListener('mouseup', this.dragPositionEnd);
      this.removeWindowEventListener('touchmove', this.dragPositionMove);
      this.removeWindowEventListener('touchend', this.dragPositionEnd);

      if (!this.avatarInteractionTracked) {
        this.avatarInteractionTracked = true;
        this.trackUsage && this.trackUsage({
          avatar_interaction_tracked: true });

      }

      // If we dragged onto a sheet, we can now trigger the transtion to it.
      this.parent.update();

      this.dragLock = false;

      e && e.stopPropagation();
    } }, { key: "dragDirectionStart", value: function dragDirectionStart(

    e) {
      if (this.dragLock) {
        return;
      }

      this.dragType = 'direction';

      // remember angle between north and (playerPos, mousePos) at dragStart
      var p1 = this.parent.playerPos;
      var p2 = this.getMapPosition(e);
      this.lastAngle = this.parent.computeAngle(p1, p2);

      this.addWindowEventListener('mousemove', this.dragDirectionMove);
      this.addWindowEventListener('mouseup', this.dragDirectionEnd);
      this.addWindowEventListener('touchmove', this.dragDirectionMove);
      this.addWindowEventListener('touchend', this.dragDirectionEnd);

      this.dragLock = true;
      e.stopPropagation();
      e.preventDefault();
    } }, { key: "dragDirectionMove", value: function dragDirectionMove(

    e) {
      if (this.dragLock && this.dragType !== 'direction') {
        return;
      }

      // compute current angle
      var p1 = this.parent.playerPos;
      var p2 = this.getMapPosition(e);
      var newAngle = this.parent.computeAngle(p1, p2);
      var delta = this.lastAngle - newAngle;

      // apply delta to view direction
      var camera = this.parent.viewer.impl.camera;
      var viewVec = camera.target.clone().sub(camera.position);
      viewVec.applyAxisAngle(zAxis, delta);
      viewVec.add(camera.position);
      camera.target.copy(viewVec);

      this.parent.viewer.impl.syncCamera();
      this.parent.viewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

      this.lastAngle = newAngle;

      e.stopPropagation();
    } }, { key: "dragDirectionEnd", value: function dragDirectionEnd(

    e) {
      if (this.dragLock && this.dragType !== 'direction') {
        return;
      }

      this.removeWindowEventListener('mousemove', this.dragDirectionMove);
      this.removeWindowEventListener('mouseup', this.dragDirectionEnd);
      this.removeWindowEventListener('touchmove', this.dragDirectionMove);
      this.removeWindowEventListener('touch', this.dragDirectionEnd);

      this.dragLock = false;
      e && e.stopPropagation();
    } }, { key: "onDblClick", value: function onDblClick(

    e) {
      this.convertEventHammerToMouse(e);

      // get minimap pixel coords
      var _this$getMapPosition2 = this.getMapPosition(e),x = _this$getMapPosition2.x,y = _this$getMapPosition2.y;

      // Only do something if either image map or sheet map is shown
      var mapShown = this.parent.mapValid || this.parent.useSheet && this.parent.sheetMap.ready;
      if (!mapShown || !this.parent.mapPixelValid(x, y)) {
        return;
      }

      // preserve camera-direction
      var camera = this.parent.viewer.impl.camera;
      var dir = camera.getWorldDirection();

      // when coming from an overview perspective, we don't want to just see the ground afterwards
      dir.z = Math.max(dir.z, 0.0);

      // choose z based on current level
      var level = this.parent.getCurrentLevel();
      var model = this.parent.mapModels && this.parent.mapModels[0];
      if (!level || !model) {
        return;
      }

      // determine avatar height - considering model unit scale (visible models must always have compatible units)
      // TODO: We should unify avatar height code in PlaceMe, Minimap, and BimWalk
      var avatarHeight = 1.7 / model.getUnitScale(); // 1.7m
      var zWorld = level.zMin + avatarHeight;

      // Should usually not happen unless level data is weird for some reason
      if (!isFinite(zWorld)) {
        return;
      }

      // Compute new camera position
      var pos3D = this.parent.mapPixelsToWorld(x, y, zWorld);
      var target = pos3D.clone().add(dir);
      var dstView = {
        position: pos3D,
        target: target,
        up: camera.up };


      var wasOutside = this.parent.isOutside();
      if (wasOutside) {
        // Immediately move to target position. When coming from outside (e.g. overview perspective),
        // a transition would need to fly very fast and potentially through several walls.
        // So, it would need some extra work to make it look good. Since the minimap already gives
        // a clue on where you are, we just jump there directly for this case.
        camera.position.copy(pos3D);
        camera.target.copy(pos3D).add(dir);
        this.parent.viewer.impl.invalidate(true, true, true);
        this.parent.viewer.dispatchEvent({ type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: camera });

        // zoom-in map to target position
        this.parent.targetZoomLevel = 0;
      } else {
        // Use flight transition to new position
        this.flyToAnim = Autodesk.Viewing.Private.flyToView(this.parent.viewer, dstView, this.flyToTime);
      }

      e.stopPropagation();
      e.preventDefault();
    } }, { key: "flyToAnimRunning", value: function flyToAnimRunning()

    {
      return this.flyToAnim && this.flyToAnim.isRunning;
    } }, { key: "convertEventHammerToMouse", value: function convertEventHammerToMouse(

    event) {
      if (event.pointers) {
        event.clientX = event.pointers[0].clientX;
        event.clientY = event.pointers[0].clientY;
      }
    } }]);return MinimapTool;}();


GlobalManagerMixin.call(MinimapTool.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/MinimapToolbar.js":
/*!****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/MinimapToolbar.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MinimapToolbar; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;
var avu = av.UI;

var GlobalManagerMixin = av.GlobalManagerMixin;var

MinimapToolbar = /*#__PURE__*/function () {

  function MinimapToolbar(parent) {_classCallCheck(this, MinimapToolbar);

    this.parent = parent;
    this.setGlobalManager(parent.globalManager);

    var _document = this.getDocument();
    // Create container element with vertically aligned buttons
    this.mapButtonBar = _document.createElement('div');
    this.mapButtonBar.classList.add('map-button-bar');
    parent.mapWidgetRoot.appendChild(this.mapButtonBar);

    // This is necessary to keep buttons working in side-by-side mode. 
    // E.g., button hover border color is specified in theme styles.
    this.mapButtonBar.classList.add('adsk-viewing-viewer');
    this.mapButtonBar.classList.add(parent.viewer.theme);

    // Create toggle to switch between small map and side-by-side map
    this.sideBySideButton = new avu.Button("Minimap_SideBySide");
    this.sideBySideButton.setGlobalManager(this.globalManager);
    this.sideBySideButton.onClick = function () {return parent.setSideBySideEnabled(!parent.sideBySideEnabled);};
    this.sideBySideButton.icon.innerHTML = createMapExpandIcon();
    this.mapButtonBar.appendChild(this.sideBySideButton.container);

    // Create alternative icon that we show in expanded mode
    this.shrinkIcon = _document.createElement('div');
    this.shrinkIcon.innerHTML = createMapShrinkIcon();
    this.sideBySideButton.container.appendChild(this.shrinkIcon);

    // Create toggle to switch between default map and sheets 
    this.sheetModeButton = new avu.Button("Minimap_SheetMode");
    this.sheetModeButton.setGlobalManager(this.globalManager);
    this.sheetModeButton.onClick = function () {return parent.setSheetMapEnabled(!parent.useSheet);};
    this.sheetModeButton.icon.innerHTML = createSheetMapIcon();
    this.mapButtonBar.appendChild(this.sheetModeButton.container);

    // Some customizations for LMV buttons
    var adjustButtonStyle = function adjustButtonStyle(button) {

      //Default LMV buttons are too large for the minimap 
      button.container.style.width = '17px';
      button.container.style.height = '17px';

      // The icon class adds a top-padding of 3 which broke the centering of the button.
      button.icon.classList.remove('adsk-button-icon');

      // Show tooltips left of the buttons and vertically centered. 
      // The default behavior would place the tooltip outside of canvas and minimap, 
      // so that they would not be visible.
      button.setToolTip(""); // Init tooltip element
      var tts = button._toolTipElement.style;
      tts.bottom = '6.5px';
      tts.top = 'auto';
      tts.left = 'auto';
      tts.right = '130%';
      tts.zIndex = 3;
    };

    adjustButtonStyle(this.sideBySideButton);
    adjustButtonStyle(this.sheetModeButton);

    // Hide toolbar by default - unless activated by feature flag
    if (!this.parent.options.enableSheetMapAndSideBySide) {
      this.mapButtonBar.style.display = "none";
    }

    this.sheetModeButton.icon.style.display = "inline";
    // Set icons and tooltips
    this.update();
  }_createClass(MinimapToolbar, [{ key: "setSideBySideButtonDisabled", value: function setSideBySideButtonDisabled(

    disable) {
      this.parent.options.sideBySideButtonDisabled = disable;
    } }, { key: "update", value: function update()

    {
      // Show expand/collapse icon depending on current state
      this.shrinkIcon.style.display = this.parent.sideBySideEnabled ? "inline" : "none";
      this.sideBySideButton.icon.style.display = this.parent.sideBySideEnabled ? "none" : "inline";

      // Disable sheetNode button if no sheet is available
      var sheetAvailable = this.parent.sheetMapsAvailable();
      var state = sheetAvailable ? this.parent.useSheet ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE : avu.Button.State.DISABLED;
      this.sheetModeButton.setState(state);
      this.sideBySideButton.setState(this.parent.options.sideBySideButtonDisabled ? avu.Button.State.DISABLED : avu.Button.State.INACTIVE);

      // Set tooltips based on current states
      var Expand = Autodesk.Viewing.i18n.translate('Show large map');
      var Shrink = Autodesk.Viewing.i18n.translate('Show small map');
      var ShowSheets = Autodesk.Viewing.i18n.translate('Show sheet');
      var NoSheets = Autodesk.Viewing.i18n.translate('No sheets available');

      this.sideBySideButton.setToolTip(this.parent.sideBySideEnabled ? Shrink : Expand);
      this.sheetModeButton.setToolTip(sheetAvailable ? ShowSheets : NoSheets);

      if (this.parent.sideBySideEnabled) {
        this.mapButtonBar.classList.add('side-by-side');

        if (this.parent.sideBySideOptions.left2DView) {
          this.mapButtonBar.classList.add('left-2d-view');
        }
      } else {
        this.mapButtonBar.classList.remove('side-by-side');
      }
    } }]);return MinimapToolbar;}();


GlobalManagerMixin.call(MinimapToolbar.prototype);

var createSheetMapIcon = function createSheetMapIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 70 61">',
  '<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">',
  '<rect id="Rectangle" stroke="#000000" stroke-width="3" x="51.5" y="41.5" width="1" height="7"></rect>',
  '<rect id="Rectangle-Copy" stroke="#000000" stroke-width="3" x="51.5" y="28.5" width="1" height="7"></rect>',
  '<rect id="Rectangle-Copy-2" stroke="#000000" stroke-width="3" x="51.5" y="11.5" width="1" height="10"></rect>',
  '<rect id="Rectangle-Copy-3" stroke="#000000" stroke-width="3" x="58.5" y="11.5" width="1" height="17"></rect>',
  '<rect id="Rectangle-Copy-4" stroke="#000000" stroke-width="3" x="58.5" y="35.5" width="1" height="3"></rect>',
  '<rect id="Rectangle-Copy-5" stroke="#000000" stroke-width="3" x="58.5" y="45.5" width="1" height="3"></rect>',
  '<path d="M11.5,11.5 L11.5,28.5 L29.5,28.5 L29.5,48.5 L44.5,48.5 L44.5,11.5 L11.5,11.5 Z" id="Path-3" stroke="#000000" stroke-width="3"></path>',
  '<path d="M11.5,35.5 L11.5,45.5 L23.5,45.5 L23.5,35.5 L11.5,35.5 Z" id="Path-3" stroke="#000000" stroke-width="3"></path>',
  '<path d="M3,3 L3,57 L67,57 L67,3 L3,3 Z" id="Path-3" stroke="#000000" stroke-width="6"></path>',
  '</g>',
  '</svg>'].
  join('');
};

var createMapExpandIcon = function createMapExpandIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 70 70">',
  '<g fill-rule="evenodd">',
  '<polygon points="9.013 5.28 21.779 5.28 21.779 0 0 0 0 21.779 5.28 21.779 5.28 9.013 23.363 27.097 27.097 23.363"/>',
  '<polygon points="27.097 46.637 23.363 42.903 5.28 60.987 5.28 48.221 0 48.221 0 70 21.779 70 21.779 64.72 9.013 64.72"/>',
  '<polygon points="48.221 0 48.221 5.28 60.987 5.28 42.903 23.363 46.637 27.097 64.72 9.013 64.72 21.779 70 21.779 70 0"/>',
  '<polygon points="64.72 48.221 64.72 60.987 46.637 42.903 42.903 46.637 60.987 64.72 48.221 64.72 48.221 70 70 70 70 48.221"/>',
  '</g>',
  '</svg>'].
  join('');
};

var createMapShrinkIcon = function createMapShrinkIcon() {
  return [
  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 70 70">',
  '<g fill-rule="evenodd">',
  '<polygon points="9.013 5.28 21.779 5.28 21.779 0 0 0 0 21.779 5.28 21.779 5.28 9.013 23.363 27.097 27.097 23.363" transform="rotate(180 13.548 13.548)"/>',
  '<polygon points="27.097 46.637 23.363 42.903 5.28 60.987 5.28 48.221 0 48.221 0 70 21.779 70 21.779 64.72 9.013 64.72" transform="rotate(180 13.548 56.452)"/>',
  '<polygon points="48.221 0 48.221 5.28 60.987 5.28 42.903 23.363 46.637 27.097 64.72 9.013 64.72 21.779 70 21.779 70 0" transform="rotate(180 56.452 13.548)"/>',
  '<polygon points="64.72 48.221 64.72 60.987 46.637 42.903 42.903 46.637 60.987 64.72 48.221 64.72 48.221 70 70 70 70 48.221" transform="rotate(180 56.452 56.452)"/>',
  '</g>',
  '</svg>'].
  join('');
};

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetMap.js":
/*!**********************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetMap.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMap; });
/* harmony import */ var _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/AecModelData.js */ "./extensions/AEC/common/AecModelData.js");
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
/* harmony import */ var _SheetThumbnail_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SheetThumbnail.js */ "./extensions/AEC/Minimap3D/SheetThumbnail.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} //
// SheetMap is used by Minimap in order to display a sheet in an own viewer instance - instead of a pre-rendered image containg the automatically generated map.
//





var av = Autodesk.Viewing;var

SheetMapConfig = /*#__PURE__*/function () {
  function SheetMapConfig(sheetNode, viewport, mapMatrix, levelGuid) {_classCallCheck(this, SheetMapConfig);

    // {av.BubbleNode}
    this.sheetNode = sheetNode;

    // {object}: viewport on the sheet, as obtained from AecModelData
    this.viewport = viewport;

    // {Matrix4} transforms from 3D world coords to sheetmap coords in [-1,1]^2
    this.mapMatrix = mapMatrix;
    this.mapMatrixInv = new THREE.Matrix4().getInverse(mapMatrix);

    // {string}
    this.levelGuid = levelGuid;

    // {SheetMapThumbnail}
    this.thumbnail = undefined;
  }_createClass(SheetMapConfig, [{ key: "isUsable", value: function isUsable(

    pos3D, levelGuid) {
      return this.levelGuid === levelGuid && Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["posIsInsideMap"])(pos3D, this.mapMatrix);
    } }]);return SheetMapConfig;}();


// Size large thumbnails that we create from snapshots for transitions
var ThumbnailSize = 1000;var

SheetMap = /*#__PURE__*/function () {

  // @param {Minimap} parent
  function SheetMap(parent) {_classCallCheck(this, SheetMap);

    // Viewer instance to show render the sheet within the map
    this.mapViewer = null;

    this.sheetRegion = null; // Box2: Rectangular viewport region on the sheet that we use as map content

    // Set to true if a sheet has loaded and prepared for map use
    this.ready = false;

    // Indicates that initMap() has been called, but sheet loading didn't finish yet.
    this.loading = false;

    // levelGuid for which the map is configured
    this.levelGuid = null;

    // All sheets in memory, indexed by sheetNode-id
    this.sheetCache = []; // string -> av.Model

    // Config used for last sheet setup (only valid if a sheet is active)
    this.config = null; // {SheetMapConfig}

    this.visible = false;

    this.tmpMatrix = new THREE.Matrix4();
    this.tmpVec = new THREE.Vector3();

    // {Minimap}
    this.parent = parent;
  }_createClass(SheetMap, [{ key: "initMapViewer", value: function initMapViewer(

    parentWidget, mapViewer) {
      if (!mapViewer) {
        var _window = av.getGlobal();
        // Keep NOP_VIEWER hack alive: NOP_VIEWER should still point to the main viewer instance
        var mainViewer = _window.NOP_VIEWER;

        mapViewer = new Autodesk.Viewing.Viewer3D(parentWidget, {});
        mapViewer.initialize();

        _window.NOP_VIEWER = mainViewer;

        var style = mapViewer.container.style;
        style.zIndex = 1; // On top of main map, but not occluding the player widget
        style.opacity = 0.0; // Viewer is initally fully transparent, but is faded in during transition
        style.pointerEvents = "none"; // Avoid viewer from capturing events. Otherwise, they wouldn't reach Minimap widget
        style.width = "100%"; // Align with full size of map widget
        style.height = "100%";

      } else {
        // If viewer already exists, we just need to make sure it has the updated client container.
        parentWidget.appendChild(mapViewer.container);
      }

      this.mapViewer = mapViewer;

      // Hide until a map is initialized
      this.setVisible(false);

      return mapViewer;
    } }, { key: "clearSheetCache", value: function clearSheetCache()

    {
      if (!this.mapViewer) {
        return;
      }
      this.sheetCache = [];
      this.mapViewer.impl.unloadCurrentModel();
      this.ready = false;
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (this.mapViewer) {
        this.mapViewer.container.style.visibility = visible ? "visible" : "hidden";
        this.visible = visible;
      }
    }

    // Sets 4 cutplanes in sheet viewer that restricts the sheet to the viewport that we are currently using.
  }, { key: "cropToViewport", value: function cropToViewport() {

      // A cutplane cp = (nx, ny, nz, c) 
      // excludes all points p with dot(v, n) + c > 0.0.
      // That is...
      //  - the normal points to the excluded half-space.
      //  - For a point (x,y) on the plane, we get the constant
      //    as c = -dot(p, n).
      var lower = new THREE.Vector4(0, -1, 0, this.sheetRegion.min.y);
      var upper = new THREE.Vector4(0, 1, 0, -this.sheetRegion.max.y);
      var left = new THREE.Vector4(-1, 0, 0, this.sheetRegion.min.x);
      var right = new THREE.Vector4(1, 0, 0, -this.sheetRegion.max.x);

      var cutPlanes = [lower, upper, left, right];

      this.mapViewer.impl.setCutPlaneSet("SheetRegion", cutPlanes);
    } }, { key: "clearCutPlanes", value: function clearCutPlanes()

    {
      this.mapViewer.impl.setCutPlaneSet("SheetRegion", []);
    }

    // Computes a mapMatrix based on a viewport on a sheet. The matrix transforms from 3D model coordinates to 
    // normalized map coords in [-1,1]^2.
    //  @param {Object} viewport - Viewport data obtained from AECModelData.json    
    //  @param {av.Model} model  - A currently visible 3D model of the Revit document for which we found the sheet.
    //  @param {THREE.Matrix4}   - Optional target to avoid matrix alloc.
    //  @returns THREE.Matrix4
  }, { key: "clearMap", value: function clearMap()




































    {
      this.levelGuid = undefined;
      this.loading = false;
      this.ready = false;
      this.config = null;

      this.setVisible(false);
      this.clearCutPlanes();

      // unload current model
      var sheet = this.mapViewer.model;
      if (sheet) {
        this.mapViewer.hideModel(sheet.id);
      } else {
        // TODO: Stop loader if in progress
      }
    }

    // Finds all viewports associated with the given floor.
    //  @param {av.Model[]} mapModels - All models in which we search for sheets
    //  @param {string}     levelGuid
    //  @returns {SheetMapConfig[]} Sheetmap configurations for all viewports found for that floor
  }, { key: "findMap",






































    // Given visible models, current floor and camera position in 3D, this function searches for a viewport
    // that contains this position. 
    //  @param {av.Model[]} Currently visible models
    //  @param {string} levelGuid
    //  @returns {Object|undefined } If a suitable viewport is found, it returns
    //                              { 
    //                                  viewport,  // The viewport object from AECModelData
    //                                  sheetNode, // BubbleNode of the sheet containing this viewport
    //                                  mapMatrix  // Transforms from 3D model coords to coords on the map (in [-1,1])
    //                              }.
    value: function findMap(mapModels, levelGuid, pos3D) {

      // {SheetMapConfig[]}
      var maps = SheetMap.findMaps(mapModels, levelGuid);
      var inside = function inside(map) {return Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["posIsInsideMap"])(pos3D, map.mapMatrix);};
      return maps.find(inside);
    } }, { key: "refineThumbnail", value: function refineThumbnail(

    model, mapConfig) {

      // Make sure that we do the screenshot only once per sheetMap
      if (mapConfig.thumbnailRefined) {
        return;
      }
      mapConfig.thumbnailRefined = true;

      // Align camera to capture the whole sheet
      var box = model.getBoundingBox();

      // We want to create a thumbnail that matches the ones from DerivativeService. To make it harder, the boundingBox is slightly
      // different from the model box, because it is enlarged in x/y by a shadow. Therefore, we must adjust the values using the viewbox
      // values from manifest.
      var node = model.getDocumentNode();
      var view = node.search({ type: "view" })[0];
      var values = view && view.getViewBox();
      if (values) {
        // We cannot use set here, because the box returned by model.getBoundingBox() just contain {x,y,z} objects.
        box.min.x = values[0];
        box.min.y = values[1];
        box.max.x = values[2];
        box.max.y = values[3];
      }

      // Setup camera for the snapshot
      var camera = new Autodesk.Viewing.UnifiedCamera(ThumbnailSize, ThumbnailSize);
      var is2d = true;
      camera.setViewFromBox(box, is2d);

      var onScreenshotDone = function onScreenshotDone(imageUrl) {
        //window.open(imageUrl);

        // Replace low-res thumbnail by higher-resolution snapshot
        mapConfig.thumbnail.refineImage(imageUrl);
      };

      var options = {
        camera: camera };

      this.screenShotInProgress = this.mapViewer.impl.getScreenShotProgressive(ThumbnailSize, ThumbnailSize, onScreenshotDone, options);
    }

    // Initialize sheet map for given level.
    //
    //  @param {SheetMapConfig} mapConfig 
    //  @param {function(Matrix4)} onDone    - Called with mapMatrix when sheet is ready
  }, { key: "initMap", value: function initMap(mapConfig, onDone) {var _this = this;

      // Clear previous sheet (if any)
      this.clearMap();

      this.loading = true;
      this.config = mapConfig;

      // When sheet loading is finished, create snapshot
      var onSheetGeomLoaded = function onSheetGeomLoaded(model) {

        // add sheet to cache 
        _this.sheetCache[mapConfig.sheetNode.id] = model;

        // Don't activate sheet if sheetMap has changed meanwhile
        if (mapConfig !== _this.config) {
          return;
        }

        // Compute viewport rectangle in sheet-coords
        var sheetUnitScale = model.getUnitScale();
        _this.sheetRegion = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].getViewportBounds(mapConfig.viewport, sheetUnitScale);

        // Configure cutplanes, so that mapViewer only shows the viewport that we are actually using
        _this.cropToViewport();

        // It's important to do this 
        _this.refineThumbnail(model, mapConfig);

        // Let minimap know that this SheetMap is ready to use
        _this.loading = false;
        _this.ready = true;
        onDone();
      };

      // For now, we simply use the first (viewport, sheet, model3D) candidate that we find. Finally, we may let the 
      // user decide which one to use - or invent some smarter heuristics.
      this.mapMatrix = mapConfig.mapMatrix;
      this.config = mapConfig;

      // Compute mapMatrix as soon as sheet is loaded
      var onSheetMapReady = function onSheetMapReady(model) {

        // Wait for sheet geometry, so that we can do a screenshot
        if (model.isLoadDone()) {
          onSheetGeomLoaded(model);
        } else {
          // Wait for sheet geometry of this model
          var geomLoadCB = function geomLoadCB(e) {

            if (e.model !== model) {
              return;
            }

            onSheetGeomLoaded(model);
            _this.mapViewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, geomLoadCB);
          };

          _this.mapViewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, geomLoadCB);
        }
      };

      // Check if sheet is already in memory
      var model = this.sheetCache[mapConfig.sheetNode.id];
      if (model) {
        // get sheet from cache
        this.mapViewer.showModel(model.id);
        onSheetMapReady(model);
      } else {
        // Load sheet and activate when available
        var onError = function onError(error) {
          console.error("Failed to load sheet for minimap: ", mapConfig.sheetNode.name(), ": ", error);
        };

        // Load sheet
        var doc = mapConfig.sheetNode.getRootNode().getDocument();
        this.mapViewer.loadDocumentNode(doc, mapConfig.sheetNode)["catch"](
        onError).
        then(onSheetMapReady);
      }
    }

    // Returns true if a sheetmap is ready to use and properly initialized for the given camera position and level
  }, { key: "isUsable", value: function isUsable(pos3D, levelGuid) {
      return this.ready && this.config.isUsable(pos3D, levelGuid);
    } }, { key: "onResize", value: function onResize()

    {
      if (this.mapViewer) {
        this.mapViewer.resize();
      }
    }

    // Returns width/height aspect of the sheet region. 
    // Only valid if a map has been setup.
  }, { key: "getAspectRatio", value: function getAspectRatio() {
      var w = this.sheetRegion.max.x - this.sheetRegion.min.x;
      var h = this.sheetRegion.max.y - this.sheetRegion.min.y;
      return w / h;
    } }, { key: "initialized", value: function initialized()

    {
      return this.loading || this.ready;
    }

    // Transforms a point p from widget coords to render coordinates on the current sheet.
    // @param {Vector2} p - in pixels relative to the mapWidget
  }, { key: "widgetToSheet", value: function widgetToSheet(p) {

      // Convert to pixel-coords on the main map image
      this.parent.widgetToMapPixels(p);

      // Convert to 3D world coords
      var p3D = this.parent.mapPixelsToWorld(p.x, p.y, 0.0);

      // map to sheetMap coords in [0,1]^2
      p3D.applyMatrix4(this.config.mapMatrix);

      // rescale from [-1,1]^2 to [0,1]^2
      p3D.x = (p3D.x + 1) / 2;
      p3D.y = (p3D.y + 1) / 2;

      // use p3D as viewport coords within sheetRegion
      var srWidth = this.sheetRegion.max.x - this.sheetRegion.min.x;
      var srHeight = this.sheetRegion.max.y - this.sheetRegion.min.y;
      p.x = this.sheetRegion.min.x + srWidth * p3D.x;
      p.y = this.sheetRegion.min.y + srHeight * p3D.y;
    }

    // Sets the LMV camera in a way that the sheet appears to be "embedded" into the main map.
  }, { key: "syncCameraToMainMap", value: function syncCameraToMainMap() {

      // widget extents
      var ww = this.parent.mapWidgetWidth;
      var wh = this.parent.mapWidgetHeight;

      // get 3 corner points of the map widget
      var p0 = new THREE.Vector2(0, wh); // lower-left corner 
      var p1 = new THREE.Vector2(ww, wh); // lower-right corner
      var p2 = new THREE.Vector2(0, 0); // upper-left corner 

      // convert them to sheet coords
      this.widgetToSheet(p0);
      this.widgetToSheet(p1);
      this.widgetToSheet(p2);

      // Use them to align sheet camera
      var camera = this.mapViewer.impl.camera;
      Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_1__["setCameraFromFrustumCorners"])(camera, p0, p1, p2);

      this.mapViewer.impl.invalidate(true, true);
    }

    // Creates sheetmap configurations for all sheetMaps that are found on the current floor.
    //  @param {av.Model[]} mapModels - models in which we search for viewports/sheets
    //  @param {string}     levelGuid
    //  @param {Matrix4}    mainMapMatrix - map matrix of the main map showing the whole floor
    //  @param {number}     mainMapWidth, mainMapHeight - Resolution of main map image 
    //  @returns {SheetMapConfig[]} 
  }], [{ key: "computeMapMatrix", value: function computeMapMatrix(vp, model3D, optionalTarget) {// We map from model coords via sheet coords to finally [-1,1]^2.
      //
      // The functions getViewportBounds() and get3DTo2DMatrix() work in sheet-space, so that they require
      // the sheetUnitScale - which we don't know before loading the sheet.
      //
      // But, since we finally map the viewport to [-1,1] anyway, a uniform scaling of the sheet has no impact on 
      // the final map matrix anyway. So we can assume a dummy unitScale of 1.0 here.
      var DummyUnitScale = 1.0;var sheetRegion = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].getViewportBounds(vp, DummyUnitScale); // Create matrix to map sheetRegion to [-1,1]^2
      var sheetToMap = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].remapRectangle(sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // from: SheetRegion
      -1, -1, 1, 1 // to: [0,1]^2
      );var modelToSheet = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].get3DTo2DMatrix(vp, DummyUnitScale);var mapMatrix = new THREE.Matrix4().multiplyMatrices(sheetToMap, modelToSheet); // Note that placementWithOffset may be null if globalOffset is (0,0,0) and there is no placement transform
      if (model3D.myData.placementWithOffset) {// The mapMatrix computed so far maps local model coordinates to map coordinates. 
        // Finally, we want to map from local LMV coordinates. Therefore, the final transform
        // must revert any load-time transforms first.
        var lmvToModel = optionalTarget || new THREE.Matrix4();lmvToModel.getInverse(model3D.myData.placementWithOffset); // The lmvToModel matrix must be applied first. For this, we post-multiply it to the mapMatrix.
        mapMatrix.multiply(lmvToModel);}return mapMatrix;} }, { key: "findMaps", value: function findMaps(mapModels, levelGuid) {// Find all viewports that would be suitable as a floor map. 
      var result = [];for (var i = 0; i < mapModels.length; i++) {// Find viewports for levelGuid in the document of mapModel[i]
        var model = mapModels[i];var aec = model.getDocumentNode().getAecModelData();var modelViewports = aec && _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findViewportsForLevel(aec, levelGuid).filter(_common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].supports2DTo3DTransform);if (!modelViewports) {// Skip models that don't provide AecModelData
          continue;} // get doc root containing the model
        var root = model.getDocumentNode().getRootNode(); // For each viewport...
        for (var j = 0; j < modelViewports.length; j++) {var viewport = modelViewports[j]; // Check if we find a BubbleNode for the sheet containing it
          var sheetNode = _common_AecModelData_js__WEBPACK_IMPORTED_MODULE_0__["default"].findSheetForViewport(root, viewport);if (!sheetNode) {continue;} // Compute mapMatrix for this viewport
          var mapMatrix = SheetMap.computeMapMatrix(viewport, model, this.tmpMatrix); // We found a candidate (viewport, sheet) pair
          result.push(new SheetMapConfig(sheetNode, viewport, mapMatrix, levelGuid));}}return result;} }, { key: "createSheetMapConfigs", value: function createSheetMapConfigs(mapModels, levelGuid, mainMapMatrix, mainMapWidth, mainMapHeight) {var maps = SheetMap.findMaps(mapModels, levelGuid);var result = [];for (var i = 0; i < maps.length; i++) {var map = maps[i]; // create & attach thumbnail
        // only map configs with a "view" child should be added, otherwise it won't contain a viewbox.
        if (map.sheetNode.search({ type: 'view' }).length > 0) {map.thumbnail = new _SheetThumbnail_js__WEBPACK_IMPORTED_MODULE_2__["default"](map, mainMapMatrix, mainMapWidth, mainMapHeight);result.push(map);}}return result;} }]);return SheetMap;}(); // Opacity used for embedded viewer instance and sheetMap thumbnails
SheetMap.OverlayOpacity = 0.5;

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetMapTransition.js":
/*!********************************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetMapTransition.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMapTransition; });
/* harmony import */ var _SheetMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SheetMap.js */ "./extensions/AEC/Minimap3D/SheetMap.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;
var avp = av.Private;

var GlobalManagerMixin = av.GlobalManagerMixin;

var readOpacity = function readOpacity(div) {
  // Note that just using div.style.opacity may be "", i.e., is not always helpful.
  var _document = div.ownerDocument;
  var _window = _document.defaultView || _document.parentWindow;
  var style = _window.getComputedStyle(div);
  return parseFloat(style.opacity);
};

// A SheetMapTransition morphs smoothly from main map of a level to a single sheetmap.
var SheetMapTransition = /*#__PURE__*/function () {

  function SheetMapTransition(minimap) {_classCallCheck(this, SheetMapTransition);

    this.setGlobalManager(minimap.globalManager);
    this.minimap = minimap;
    this.sheetMap = minimap.sheetMap;

    // Start/End values for all params controlled by this transition. They are set on anim start.
    this.angleStart = undefined;
    this.angleEnd = undefined;
    this.zoomLevelStart = undefined;
    this.zoomLevelEnd = undefined;
    this.viewerOpacityStart = undefined;
    this.viewerOpacityEnd = undefined;
    this.thumbnailOpacityStart = undefined;
    this.thumbnailOpacityEnd = undefined;

    // If transition is running, this flag determines whether we are zooming into sheet or back to the main map
    this.zoomingIn = false;

    // Time for a transition in seconds
    this.animTime = 2;
  }

  // Stops running transition (if any). Note that all values (rotation etc.) will remain in the current intermediate state.
  _createClass(SheetMapTransition, [{ key: "stop", value: function stop() {
      if (this.anim) {
        this.anim.stop();
      }
    } }, { key: "isRunning", value: function isRunning()

    {
      return this.anim && this.anim.isRunning;
    }

    // Returns true if a zoomIn is in progress
  }, { key: "isZoomingIn", value: function isZoomingIn() {
      return this.zoomingIn && this.anim && this.anim.isRunning;
    }

    // Returns true if a zoomOut is in progres
  }, { key: "isZoomingOut", value: function isZoomingOut() {
      return !this.zoomingIn && this.anim && this.anim.isRunning;
    } }, { key: "enterSheet", value: function enterSheet()

    {var _this = this;
      // If we are already zooming in, do nothing
      if (this.isZoomingIn()) {
        return;
      }
      // Make sure that we don't overlap with a previous zoomOut
      this.stop();

      this.zoomIn = true;

      // At the end of the transition, we want to align the map so that the sheet is aligned with the mapWidget.
      // Therefore, we apply the inverse rotation to the whole map.
      this.startAngle = this.minimap.mapRotationAngle;
      this.endAngle = -this.minimap.sheetMap.config.thumbnail.angle;

      // Zoom-in to see full sheet height
      this.zoomLevelStart = this.minimap.zoomLevel;
      this.zoomLevelEnd = this.getTargetZoomLevel();

      // Fade-in viewer
      this.viewerOpacityStart = readOpacity(this.minimap.sheetMap.mapViewer.container);
      this.viewerOpacityEnd = _SheetMap_js__WEBPACK_IMPORTED_MODULE_0__["default"].OverlayOpacity;

      // Fade-out thumbnail
      this.thumbnailOpacityStart = readOpacity(this.minimap.sheetMap.config.thumbnail.div);
      this.thumbnailOpacityEnd = 0;

      this.anim = avp.fadeValue(0, 1, this.animTime, function (t) {return _this.update(t);});

      this.sheetMap.setVisible(true);
    } }, { key: "exitSheet", value: function exitSheet()

    {var _this2 = this;
      // If we are already zooming out, do nothing
      if (this.isZoomingOut()) {
        return;
      }

      // Make sure that we don't overlap with a previous zoomIn
      this.stop();

      this.zoomIn = false;

      // Rotate back to main-map default orientation
      this.startAngle = this.minimap.mapRotationAngle;
      this.endAngle = 0;

      // Zoom-out to see a bit more of the surrounding main map
      this.zoomLevelStart = this.minimap.zoomLevel;
      this.zoomLevelEnd = 0.5 * this.minimap.zoomLevel;

      // Fade-out viewer
      this.viewerOpacityStart = readOpacity(this.sheetMap.mapViewer.container);
      this.viewerOpacityEnd = 0;

      // Fade-out thumbnail
      this.thumbnailOpacityStart = readOpacity(this.sheetMap.config.thumbnail.div);
      this.thumbnailOpacityEnd = _SheetMap_js__WEBPACK_IMPORTED_MODULE_0__["default"].OverlayOpacity;

      var onFinished = function onFinished() {
        _this2.sheetMap.setVisible(false);
      };

      this.anim = avp.fadeValue(0, 1, this.animTime, function (t) {return _this2.update(t);}, onFinished);
    }

    // Computes the zoomLevel that we use when "zooming into" this sheet thumbnail.
    // After zooming into a sheet, the map is aligned in a way that...
    //  - player widget is at the center
    //  - full vertical extent of the sheet is visible
    // @returns {number}
  }, { key: "getTargetZoomLevel", value: function getTargetZoomLevel() {

      var pos3D = this.minimap.viewer.impl.camera.position;

      // get sheetmap matrix
      var sheetMapMatrix = this.sheetMap.config.mapMatrix;
      var sheetMapMatrixInv = this.sheetMap.config.mapMatrixInv;

      // wdiget height
      var mapWidgetHeight = this.minimap.mapWidgetHeight;

      // Compute playerPos in sheetmap space
      var p = pos3D.clone().applyMatrix4(sheetMapMatrix);

      // Compute distance of p from upper and lower edge - and their max value dMax
      var d1 = Math.abs(p.y);
      var d2 = Math.abs(1.0 - p.y);
      var dMax = Math.max(d1, d2);

      // Compute points on sheetmap that we want to project to top center and bottom center of the widget
      var pBottom = p.clone();
      var pTop = p.clone();
      pBottom.y -= dMax;
      pTop.y += dMax;

      // Project both points to main map pixel coords
      pBottom.applyMatrix4(sheetMapMatrixInv);
      pTop.applyMatrix4(sheetMapMatrixInv);
      pBottom = this.minimap.worldToMapPixels(pBottom);
      pTop = this.minimap.worldToMapPixels(pTop);

      // Compute distance between pTop and pBottom in main map pixel-space.
      var dist = pBottom.distanceTo(pTop);

      // Compute zoomScale for which 'dist' is scaled to the widget height
      var zoomScale = mapWidgetHeight / dist;
      var zoomLevel = Math.log2(zoomScale);
      return zoomLevel;
    }

    // Update animation state while transition is running.
    //  @param {number} t - given in unit time (0=start, 1=end)
  }, { key: "update", value: function update(t) {

      t = avp.smootherStep(t);

      var angle = avp.lerp(this.startAngle, this.endAngle, t);
      var zoomLevel = avp.lerp(this.zoomLevelStart, this.zoomLevelEnd, t);

      // apply zoomLevel
      this.minimap.setZoomLevel(zoomLevel);
      this.minimap.setRotation(angle);

      // Keep sheet camera in-sync. This would usually happen on next timer-event.
      // But it makes it easier to test if the camera keeps consistent.
      this.sheetMap.syncCameraToMainMap();

      var viewerOpacity = avp.lerp(this.viewerOpacityStart, this.viewerOpacityEnd, t);
      var thumbnailOpacity = avp.lerp(this.thumbnailOpacityStart, this.thumbnailOpacityEnd, t);

      // Fade thumbnail to actual viewer instance
      this.sheetMap.mapViewer.container.style.opacity = viewerOpacity;

      // If sheets were disabled meanwhile, just continue zoom-out, but don't fade-in thumbnail opacity anymore.
      // Otherwise, it would conflict with fading all thumbnails out when switching sheets off.
      if (this.minimap.useSheet) {
        this.sheetMap.config.thumbnail.div.style.opacity = thumbnailOpacity;
      }
    }

    // When changing from one sheet directly into another one, we have to make sure that
    // the sheet thumbnail of the previous one gets full opacity again.
  }, { key: "onSheetWillChange", value: function onSheetWillChange() {
      this.stop();
      if (this.minimap.useSheet && this.sheetMap.config) {
        this.sheetMap.config.thumbnail.div.style.opacity = _SheetMap_js__WEBPACK_IMPORTED_MODULE_0__["default"].OverlayOpacity;
      }
    } }]);return SheetMapTransition;}();


GlobalManagerMixin.call(SheetMapTransition.prototype);

/***/ }),

/***/ "./extensions/AEC/Minimap3D/SheetThumbnail.js":
/*!****************************************************!*\
  !*** ./extensions/AEC/Minimap3D/SheetThumbnail.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SheetMapThumbnail; });
/* harmony import */ var _MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MinimapMath.js */ "./extensions/AEC/Minimap3D/MinimapMath.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;

// Convert number to css percent-value.
// E.g. 30 => "30 percent"
var toPercent = function toPercent(val) {
  return val.toString() + '%';
};

var getThumbnailCropRegion = function getThumbnailCropRegion(sheetNode, viewport) {

  // Actually, we shouldn't care about sheetUnitScale here. We only
  // need it because Revit extractor gives us viewport bounds and sheet bounds in different coordinate systems. 
  // Unfortunately, we have to guess the sheetUnitScale here, because we cannot load all sheets first just to get the unitScale.
  //
  // TODO: If we provide the viewport boundary in sheet coordinates in Revit extractor, we don't need this hack anymore.
  var sheetUnitScale = 0.0254;

  // get viewport bounds in sheet coords (usually inches)    
  var viewportBounds = Autodesk.AEC.AecModelData.getViewportBounds(viewport, sheetUnitScale);

  // get sheet bounds 
  var viewNode = sheetNode.search({ type: 'view' })[0];

  if (!viewNode) {
    return null;
  }

  var viewBoxValues = viewNode.getViewBox();
  var sheetBox = new THREE.Box2();
  sheetBox.min.set(viewBoxValues[0], viewBoxValues[1]);
  sheetBox.max.set(viewBoxValues[2], viewBoxValues[3]);

  // Thumbnails are squared and contain empty pixels to expand the rectangle to a square.
  // Therefore, the are whole thumbnail image does not match the sheet bounds exactly,
  // but actually corresponds to the square containing it.
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["expandToSquare"])(sheetBox);

  // map from sheetBox to thumbnail pixels
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.min, sheetBox);
  Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["boundsToUnitQuad"])(viewportBounds.max, sheetBox);

  return viewportBounds;
};


// Transforms a given div in a way that...
//  - Lower-left  corner is mapped to p0
//  - Lower-Right corner is mapped to p1
//  - Upper-left  corner is mapped to p2
//
// @param {Object}        div                       - div element to be placed within its parent div
// @param {THREE.Vector2} p0, p1, p2                - Points within parent div. All coords are in pixels with pixel-origin at lower left.
// @param {number}        parentWidth, parentHeight - Extents of parent widget (used to finally convert pixels to percent)
// @returns {float} angle                           - clockwise rotation angle in radians.
var transformQuad = function transformQuad(div, p0, p1, p2, parentWidth, parentHeight) {

  // Note: It's important to work in pixels (not percent) here. Otherwise, we would introduce a distortion depending on aspect ratio.
  var width = p1.distanceTo(p0);
  var height = p2.distanceTo(p0);
  var left = p0.x;
  var bottom = p0.y;

  // Compute rotation angle. Note that we must take the negative, 
  // because css rotate() rotates clockwise
  var angle = -Math.atan2(p1.y - p0.y, p1.x - p0.x);

  // configure pos and scale
  div.style.width = toPercent(width * 100 / parentWidth);
  div.style.height = toPercent(height * 100 / parentHeight);
  div.style.left = toPercent(left * 100 / parentWidth);
  div.style.bottom = toPercent(bottom * 100 / parentHeight);

  // rotate around lower-left corner.
  div.style.transformOrigin = '0% 100%';
  div.style.transform = 'rotate(' + angle.toString() + 'rad)';

  return angle;
};

// Creates a div containing the thumbnail of a given sheet node as an image element.
//  @param {av.BubbleNode} sheetNode
//  @returns {Object|undefined} An div element containing the thumnbail image
var createThumbnail = function createThumbnail(sheetNode) {

  var _document = av.getGlobal().document;
  var thumbnail = _document.createElement('div');

  // Get thumbnail url
  var root = sheetNode.getRootNode();
  var doc = root.getDocument();
  var url = doc.getThumbnailPath(sheetNode.data, 400, 400);

  // add thumbnail image
  thumbnail.innerHTML = "<img class=\"mapImage\" src=\"".concat(url, "\" crossOrigin=\"use-credentials\" position:><img class=\"mapImage\" src=\"\" style=\"opacity: 0\">");

  // make image element accessable
  thumbnail.preImage = thumbnail.children[0]; // low-res thumbnail that we use until we have something better
  thumbnail.image = thumbnail.children[1]; // high-res thumbnail that we create ourselves

  thumbnail.className = 'sheetmap-thumbnail';
  return thumbnail;
};

// Applies css styling on image element, so that the given cropRegion fits the parent div
//
// @param {Box2}  cropRegion - in [0,1]^2, relative to the full image
// @param {Image} image      - html image element
var cropImage = function cropImage(image, cropRegion) {

  // compute size of crop region (relative to full image)
  var cropWidth = cropRegion.max.x - cropRegion.min.x;
  var cropHeight = cropRegion.max.y - cropRegion.min.y;

  // Compute shift to bring upper-left corner of the cropRegion to (0,0).
  // Values are relative to the parent div - whose size is adjusted to the 
  // cropRegion
  var left = -cropRegion.min.x / cropWidth;
  var top = (cropRegion.max.y - 1) / cropHeight;

  // Compute image size relative to parent div: The image must be larger than 
  // the parent div (which corresponds to size 1.0 here)
  // We want to achieve parentDivWidth = cropWidth * imageWidth.
  var width = 1.0 / cropWidth;
  var height = 1.0 / cropHeight;

  // Apply all values in percent
  image.style.left = toPercent(100 * left);
  image.style.top = toPercent(100 * top);
  image.style.width = toPercent(100 * width);
  image.style.height = toPercent(100 * height);
};

// Sheetmap thumbnails are embedded in the minimap to display for which regions inside the minimap a sheetmap is available. 
// A sheetmap thumbnail is a sheet thumbnail that is cropped down to a single viewport and embedded into the main map.
var SheetMapThumbnail = /*#__PURE__*/function () {

  // @param {av.BubbleNode} sheetNode
  // @param {SheetMapConfig} sheetMapConfig - Config object for the sheet to be represented by this thumbnail
  // @param {Matrix4}        mainMapMatrix  - transforms from 3D world coords to main map coords in [-1,1]^2
  // @param {number}         mainMapWidth, mainMapHeight - Resolution of main map image
  function SheetMapThumbnail(sheetMapConfig, mainMapMatrix, mainMapWidth, mainMapHeight) {_classCallCheck(this, SheetMapThumbnail);

    // create div containing the thumbnail image
    this.div = createThumbnail(sheetMapConfig.sheetNode);var

    sheetNode = sheetMapConfig.sheetNode,viewport = sheetMapConfig.viewport,mapMatrixInv = sheetMapConfig.mapMatrixInv;

    // Crop thumbnail to the viewport we want to display. 
    // Crop region is relative to image size, i.e., in [0,1]^2
    var cropRegion = getThumbnailCropRegion(sheetNode, viewport);
    cropImage(this.div.preImage, cropRegion);
    cropImage(this.div.image, cropRegion);

    // Compute positions of the 3 corners of the sheetmap in 3D world coords
    var p0 = new THREE.Vector3(-1, -1, 0).applyMatrix4(mapMatrixInv);
    var p1 = new THREE.Vector3(1, -1, 0).applyMatrix4(mapMatrixInv);
    var p2 = new THREE.Vector3(-1, 1, 0).applyMatrix4(mapMatrixInv);

    // Convert points to main map-pixel coords
    p0 = Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["worldToMapPixels"])(p0, mainMapMatrix, mainMapWidth, mainMapHeight);
    p1 = Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["worldToMapPixels"])(p1, mainMapMatrix, mainMapWidth, mainMapHeight);
    p2 = Object(_MinimapMath_js__WEBPACK_IMPORTED_MODULE_0__["worldToMapPixels"])(p2, mainMapMatrix, mainMapWidth, mainMapHeight);

    // In map-pixel space, the y-axis points down. For configuring the div,
    // we want to have the y-axis point up.
    p0.y = mainMapHeight - p0.y;
    p1.y = mainMapHeight - p1.y;
    p2.y = mainMapHeight - p2.y;

    // Place/Scale/Rotate thumbnail in a way that..
    //  - lower-left  is mapped to p0
    //  - lower-right is mapped to p1
    //  - upper-left  is mapeed to p2
    // Returns the clockwise rotation angle in radians
    this.angle = transformQuad(this.div, p0, p1, p2, mainMapWidth, mainMapHeight);
  }

  // Update thumbnail image as soon as we have a screenshot with better resolution
  _createClass(SheetMapThumbnail, [{ key: "refineImage", value: function refineImage(url) {var _this = this;
      this.div.image.src = url;

      // Fade-in refined image on top of the other one. Note that the thumbnail opacity is controlled on the parent div,
      // so there is no conflict and we can simply set opacity 1.0 when done.
      var setOpacity = function setOpacity(t) {return _this.div.image.style.opacity = t;};

      // Remove low-res image when done
      var onDone = function onDone() {return _this.div.removeChild(_this.div.preImage);};

      Autodesk.Viewing.Private.fadeValue(0, 1, 1.0, setOpacity, onDone);
    } }]);return SheetMapThumbnail;}();

/***/ }),

/***/ "./extensions/AEC/common/AecModelData.js":
/*!***********************************************!*\
  !*** ./extensions/AEC/common/AecModelData.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
// Utility functions to work with AEC-specific model data. These are stored in a separate JSON file AECModelData.json. 
// Currently only available for Revit files.
//

var namespace = AutodeskNamespace('Autodesk.AEC');

// Computes a Matrix4 that maps the 'from' rectangle to the 'to' rectangle in xy.
var remapRectangle = function remapRectangle(
xMinFrom, yMinFrom, xMaxFrom, yMaxFrom,
xMinTo, yMinTo, xMaxTo, yMaxTo)
{
  var scaleX = (xMaxTo - xMinTo) / (xMaxFrom - xMinFrom);
  var scaleY = (yMaxTo - yMinTo) / (yMaxFrom - yMinFrom);

  // Note that the translation component of the matrix works on the scaled values.
  // The scaling alone would map xMinFrom to scaleX * xMinFrom. We want 
  // to map it to xMinTo instead. (analog for y)
  var offsetX = xMinTo - scaleX * xMinFrom;
  var offsetY = yMinTo - scaleY * yMinFrom;

  // Create Matrix4 that applies both
  var matrix = new THREE.Matrix4();
  matrix.elements[0] = scaleX;
  matrix.elements[5] = scaleY;
  matrix.elements[12] = offsetX;
  matrix.elements[13] = offsetY;
  return matrix;
};

// Returns the 2D bbox of a viewport on a sheet.
// 
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
// @returns {THREE.Box2|null}
var getViewportBounds = function getViewportBounds(vp, sheetUnitScale) {

  // viewport region in foot as array (6 floats)
  var values = vp.geometryViewportRegion;
  if (!values) {
    return null;
  }

  // Convert from foot to sheet units (usually inches)
  var FootToMeter = 0.3048;
  var MeterToSheetUnits = 1.0 / sheetUnitScale;
  var scale = FootToMeter * MeterToSheetUnits;

  // The viewport region returned by Revit is incorrect. It's enlarged by an offset of 0.01 ft.
  // We remove that offset before scaling. 
  // See https://thebuildingcoder.typepad.com/blog/2010/09/view-location-on-sheet.html (search for 0.01 in that page)
  var boundsCorrection = 0.01;

  var res = new THREE.Box2();
  res.min.x = (values[0] + boundsCorrection) * scale;
  res.min.y = (values[1] + boundsCorrection) * scale;
  res.max.x = (values[3] - boundsCorrection) * scale;
  res.max.y = (values[4] - boundsCorrection) * scale;
  return res;
};

// Handle available view rotation modes in Revit
// If a view was rotated in Revit, this swapped/inverted some viewport axes. We must revert this modification when transforming back to world coords.
// This function returns a Matrix4 that performs this rotation on an input vector p in normalized viewport coords (in [0,1])
//
//  @param {number} viewRotationType - as read from AECModelData. Enum value in {0,1,2}. see Revit API doc:
//                                     http://www.revitapidocs.com/2018/abd81744-b44a-e578-cb62-3cc40a334acc.htm
//  @returns {THREE.Vector2/3} Copy of vpCoords with swapped/inverted axes according to viewport rotation
var getInverseViewportRotation = function getInverseViewportRotation(viewRotationType) {

  var matrix = new THREE.Matrix4();
  switch (viewRotationType) {
    // No rotation => done
    case 0:return matrix;

    // Revit view was rotated by 90 degrees clockwise => Rotate by 90 degrees ccw
    case 1:{
        // Note that a rotation would actually mean result.x = -y. But, we just revert the effect the rotation effect on the
        // viewport axes here. I.e., input and output are in [0,1]. For this, swapping an axis means taking 1.0-value, not just the negative.
        // Therefore, the desired effect of the matrix is:
        //
        //  (x, y) => (1-y, x)
        //
        // Note the memory layout of THREE matrices is column-major.

        // out.x = (1-y)
        matrix.elements[0] = 0; //  0 * in.x
        matrix.elements[4] = -1; // -1 * in.y
        matrix.elements[12] = 1; // + 1

        // out.y = x
        matrix.elements[1] = 1; // 1 * in.x
        matrix.elements[5] = 0; // 0 * in.y

        break;
      }

    // Revit view was rotated 90 degrees counterclockwise => Rotate by 90 degrees cw
    case 2:{
        // Desired transform here is:
        //
        // (x, y) => (y, 1-x)

        // out.x = y
        matrix.elements[0] = 0; // 0 * in.x
        matrix.elements[4] = 1; // 1 * in.y

        // out.y = (1-x)
        matrix.elements[1] = -1; //    -in.x
        matrix.elements[5] = 0; // 0 * in.y
        matrix.elements[13] = 1; // + 1

        break;
      }
    default:console.warn('Unexpected enum value for view rotation: ', viewRotationType);}

  return matrix;
};

// Compute matrix to convert 2D sheet coords within the given viewport to 3D model coordinates.
//
// @param {Object} vp             - Viewport data as read from AECModelData
// @param {number} sheetUnitScale - UnitScale of the sheet containing the viewport, e.g., 0.0254 if the sheet unit is inches. See Model.getUnitScale().
//
// @returns {THREE.Matrix4|null} May return null if a viewport does not support a 2D/3D transform.
//
// Note: Not all viewports provide A 2D/3D transform is not provided by all This feature is only available for a subset of  viewports. 
var get2DTo3DMatrix = function get2DTo3DMatrix(vp, sheetUnitScale) {

  // Viewport bbox on sheet (Box2)
  var sheetRegion = getViewportBounds(vp, sheetUnitScale);

  // SectionBox (Box3 + Matrix4): Oriented box in 3D world coords. Represents the volume
  // that is mapped to the sheet.
  var sectionBox = vp.sectionBox;
  var sectionBoxTransform = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(sectionBox.transform);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var sheetToViewport = remapRectangle(
  sheetRegion.min.x, sheetRegion.min.y, sheetRegion.max.x, sheetRegion.max.y, // ...from viewport rectangle in sheet coordinates
  0, 0, 1, 1 // ...to [0,1] 
  );

  // Consider Revit viewport rotation. Result keeps within viewport coords ([0,1]^2)
  var vpRotationInv = getInverseViewportRotation(vp.viewportRotation);

  // Compute matrix that maps from sheet xy coords to normalized viewport coords in [0,1]^2
  var viewportToSectionBox = remapRectangle(
  0, 0, 1, 1, // ...from normalized viewport coords
  sectionBox.min.x, sectionBox.min.y, sectionBox.max.x, sectionBox.max.y // ...to the xy-extent of the untransformed SectionBox
  );

  // Finally, apply the sectionBoxTransform to obtain world coords. Note that matrix products must be done in reverse order.
  return sectionBoxTransform.
  multiply(viewportToSectionBox).
  multiply(vpRotationInv).
  multiply(sheetToViewport);
};

// Compute matrix to convert 3D model coords to 2D sheet coords within a given viewport. See get2Dto3DMatrix().
var get3DTo2DMatrix = function get3DTo2DMatrix(vp, sheetUnitScale) {
  var matrix = get2DTo3DMatrix(vp, sheetUnitScale);
  matrix.getInverse(matrix);
  return matrix;
};

// Find Sheet BubbleNode containing the given viewport.
//
//  @params {av.BubbleNode} root - root node of a manifest in which we search for sheets
//  @params {Object}        vp   - Viewport as obtained from AecModelData.json file (aecData.viewports)
//  @returns {av.BubbleNode[]|undefined} BubbleNode of the sheet containing the viewport (if any).
var findSheetForViewport = function findSheetForViewport(root, vp) {
  var sheetNodes = root.search(Autodesk.Viewing.BubbleNode.SHEET_NODE);
  var linkedByVp = function linkedByVp(node) {return node.guid() === vp.sheetGuid;};
  return sheetNodes.find(linkedByVp);
};

// Find all viewports on a given sheet. The sheet can be specified as model or BubbleNode.
// Note that not all viewports support 2D/3D transform.
//
//  @param {av.BubbleNode|av.Model} sheet
var findViewportsOnSheet = function findViewportsOnSheet(sheet) {

  // get aecModelData from model or node
  var isNode = sheet instanceof Autodesk.Viewing.BubbleNode;
  var sheetNode = isNode ? sheet : sheet.getDocumentNode();
  var aec = sheetNode.getAecModelData();
  if (!aec || !aec.viewports) {
    return [];
  }

  // Find viewports linking the sheet guid
  return aec.viewports.filter(function (vp) {return vp.sheetGuid === sheetNode.guid();});
};

// Given a sheet and a point on that sheet, this function returns the viewport containing it.
// If multiple viewports overlap, we choose the one where (x,y) is "most inside", i.e., 
// where the distance from the viewport edges is largest.
//
//  @param {av.Model}         sheet
//  @param {Vector2}          point            - Point in sheet world-coords.
//  @param {function(Object)} [viewportFilter] - Option to exclude certain viewports
//
//  @returns {Object|undefined} 
var findViewportAtPoint = function findViewportAtPoint(sheet, point) {var viewportFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  // Find sheets linking this sheet
  var viewports = findViewportsOnSheet(sheet);

  // Apply option filter
  if (viewportFilter) {
    viewports = viewports.filter(viewportFilter);
  }

  // Couple each viewport with viewport bounds 
  viewports = viewports.map(function (vp) {
    return {
      viewport: vp,
      bounds: getViewportBounds(vp, sheet.getUnitScale()) };

  });

  // Reduce to viewports containing the given point
  var containsPoint = function containsPoint(vp) {
    return vp.bounds && vp.bounds.containsPoint(point);
  };
  viewports = viewports.filter(containsPoint);

  // Point may be outside of all viewports
  if (!viewports.length) {
    return;
  }

  // Viewports may overlap. For this case, we need a heuristic metric
  // to choose the best match. For this, we use the
  // distance to the viewport boundary edges.
  var distanceFromEdge = function distanceFromEdge(box, p) {
    return Math.min(
    Math.min(p.x - box.min.x, box.max.x - p.x),
    Math.min(p.y - box.min.y, box.max.y - p.y));

  };

  // Pick the viewport that minimizes distanceFromEdge
  var getBestMatch = function getBestMatch(vp1, vp2) {
    var d1 = distanceFromEdge(vp1.bounds, point);
    var d2 = distanceFromEdge(vp2.bounds, point);
    return d2 > d1 ? vp2 : vp1;
  };
  return viewports.reduce(getBestMatch).viewport;
};

// Get guid of the level shown by a viewport (may be null, e.g. for SectionViews)
//  @param {Object} vp - viewport object from aecModelData
//  @returns {string|undefined} levelGuid
var getLinkedLevel = function getLinkedLevel(vp) {

  // Viewports come directly from aecModelData json and do not always reference a level. 
  // So, we should not crash if anything is null here.
  var viewRange = vp.extensions && vp.extensions.viewRange;
  var cutPlane = viewRange && viewRange.cutPlane;
  return cutPlane && cutPlane.levelGuid;
};

// Find all viewports in the document that link the level indicated by levelGuid
//
// @param {Object} aecData   - as obtained from AECModelData.json
// @param {string} levelGuid
// @retuns {Object[]} Array of viewport data objects
var findViewportsForLevel = function findViewportsForLevel(aecData, levelGuid) {

  // Find viewports that links this level
  var viewports = aecData.viewports || [];

  var matchesLevel = function matchesLevel(vp) {
    var vpLevelGuid = getLinkedLevel(vp);
    return vpLevelGuid === levelGuid;
  };
  return viewports.filter(matchesLevel);
};

// Find level in aecModelData that links the given viewport.
//
// @param {Object} aecData - as obtained from AECModelData.json
// @param {Object} viewport object
// @retuns {Object|undefined} level object from aecModelData
var findLevelForViewport = function findLevelForViewport(aecData, viewport) {
  var levelGuid = getLinkedLevel(viewport);

  // Search for a level with this levelGuid
  var hasLevelGuid = function hasLevelGuid(level) {return level.guid === levelGuid;};
  return levelGuid && aecData.levels.find(hasLevelGuid);
};

// Checks if a viewport provides all required information to compute a 2D/3D transform.
//  @param {Object} vp - vieport data object as obtained from AecModelData.json
var supports2DTo3DTransform = function supports2DTo3DTransform(vp) {

  // Viewport types for which we know that we get valid transform data.
  // For 'Section', it worked for some examples, but wasn't reliably enough to enable it by default yet.
  var supportedTypes = ['FloorPlan', 'CeilingPlan', 'EngineeringPlan'];

  return Boolean(supportedTypes.includes(vp.viewType) &&
  vp.sectionBox &&
  vp.geometryViewportRegion && // We need the viewport outline that corresponds 1:1 with the view sectionBox (excluding labels etc.)
  vp.isCropBoxActive && // If this checkbox is off in Revit, the sectionBox information is not relialbe
  !vp.hasBreaks && // A view in Revit may be split into separate parts using "View breaks". This is not supported yet.
  !vp.extensions.hasRegions); // The 2D/3D transform may actually vary within a single view. We currently don't get the required data to support this.
};

var AecModelData = {
  get2DTo3DMatrix: get2DTo3DMatrix,
  get3DTo2DMatrix: get3DTo2DMatrix,
  getViewportBounds: getViewportBounds,
  remapRectangle: remapRectangle,
  findSheetForViewport: findSheetForViewport,
  findViewportsForLevel: findViewportsForLevel,
  supports2DTo3DTransform: supports2DTo3DTransform,
  getLinkedLevel: getLinkedLevel,
  findViewportsOnSheet: findViewportsOnSheet,
  findViewportAtPoint: findViewportAtPoint,
  findLevelForViewport: findLevelForViewport };


/* harmony default export */ __webpack_exports__["default"] = (AecModelData);

namespace.AecModelData = AecModelData;

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkExtension.js":
/*!*********************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkExtension.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkExtension; });
/* harmony import */ var _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HyperlinkTracker */ "./extensions/AEC/hyperlinks/HyperlinkTracker.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.HyperlinkExtension';


// Hyperlink extension which will display hyperlinks in 2D sheets to other sheets
//  @param {Number} options.rootBubbleNode Root bubble node of model
//  @callback options.loadViewableCb Will be called in case a hyperlink is clicked with bubble node of the sheet and
//      the total number of hyperlinks present in the sheet
//  @callback options.hyperlinksAddedCb Will be called each time hyperlinks have been added to a sheet with the id of
//      the model and the total number of hyperlinks present in the sheet
var HyperlinkExtension = /*#__PURE__*/function (_av$Extension) {_inherits(HyperlinkExtension, _av$Extension);
  function HyperlinkExtension(viewer, options) {var _this;_classCallCheck(this, HyperlinkExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(HyperlinkExtension).call(this, viewer, options));

    _this.hyperlinkTracker = new _HyperlinkTracker__WEBPACK_IMPORTED_MODULE_0__["default"](_this.viewer, _this.options.rootBubbleNode,
    _this.options.loadViewableCb, _this.options.hyperlinksAddedCb);return _this;
  }_createClass(HyperlinkExtension, [{ key: "load", value: function load()

    {
      this.viewer.toolController.activateTool('hyperlink-tracker');
      return true;
    } }, { key: "unload", value: function unload()

    {
      this.viewer.toolController.deactivateTool('hyperlink-tracker');
      return true;
    } }]);return HyperlinkExtension;}(av.Extension);


namespace.HyperlinkExtension = HyperlinkExtension;
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, HyperlinkExtension);

/***/ }),

/***/ "./extensions/AEC/hyperlinks/HyperlinkTracker.js":
/*!*******************************************************!*\
  !*** ./extensions/AEC/hyperlinks/HyperlinkTracker.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HyperlinkTracker; });

//A tool that:
//Implements heuristically derived hyperlinks from text geometries in F2D drawings (and mouse hover support for hyperlinks)
//Taken from Fluent POC:
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L273
// https://git.autodesk.com/fluent/lmv-ui/blob/master/app/scripts/tools/mouse-tracker.js#L171




var av = Autodesk.Viewing,
avp = Autodesk.Viewing.Private;

function HyperlinkTracker(viewer, rootBubbleNode, loadViewableCb, hyperlinksAddedCb) {
  av.ToolInterface.call(this);
  this.names = ['hyperlink-tracker'];
  viewer.toolController.registerTool(this);

  var _viewer = viewer;
  var _loadViewableCb = loadViewableCb;
  var _hyperlinksAddedCb = hyperlinksAddedCb;
  var _idRead = [0, 0];
  var _linkMaps = {};
  var _dbId = 0;
  var _lastX, _lastY;
  var _mouseMoved = false;
  var _isDragging = false;

  this.update = function () {
    if (!_isDragging) {
      if (_mouseMoved) {
        var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
        _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);
        _mouseMoved = false;
      }
    } else {
      _dbId = 0;
    }
    return false;
  };

  function getCurrentModel() {
    var mq = _viewer.impl.modelQueue();
    var visibleModels = mq.getModels();

    return visibleModels.length === 1 ? visibleModels[0] : undefined;
  }

  function getCurrentLinkMap() {
    var linkMap = _linkMaps[_idRead[1]];

    //Fallback for when a single model is loaded and the Model ID buffer is not working
    if (!linkMap) {
      var cm = getCurrentModel();
      if (cm) {
        linkMap = _linkMaps[cm.id];
      }
    }

    return linkMap;
  }

  function isLinkMapValid(map) {
    return map && Object.keys(map).length > 0;
  }

  this.handleSingleClick = function () {
    if (!_viewer.model || !_viewer.model.is2d())
    return;

    var vp = _viewer.impl.clientToViewport(_lastX, _lastY);
    _dbId = _viewer.impl.renderer().idAtPixel(vp.x, vp.y, _idRead);

    var linkMap = getCurrentLinkMap();

    var linkNode = isLinkMapValid(linkMap) ? linkMap[_dbId] : null;

    if (linkNode) {
      _loadViewableCb(linkNode, linkMap.numHyperlinks);
      return true;
    }

    return false;
  };

  this.handleButtonDown = function (event) {
    _isDragging = true;
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    return false;
  };

  this.handleButtonUp = function () {
    _isDragging = false;
    return false;
  };

  this.handleMouseMove = function (event) {
    _lastX = event.canvasX;
    _lastY = event.canvasY;
    _mouseMoved = true;
    return false;
  };

  function addRenderBox(vbb, f2d, stringIndex, modelScale) {
    var i4 = 4 * stringIndex;

    var miny = f2d.stringBoxes[i4 + 1];
    var maxy = f2d.stringBoxes[i4 + 3];
    var border = (maxy - miny) * 0.2;
    miny = miny - border;
    maxy = maxy + border;
    var minx = f2d.stringBoxes[i4] - border;
    var maxx = f2d.stringBoxes[i4 + 2] + border;

    var dbId = f2d.stringDbIds[stringIndex];
    var vbase = vbb.vcount;

    var linkFillColor = 0x77bfbb3f;
    vbb.addVertexPolytriangle(minx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, miny, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(maxx, maxy, linkFillColor, dbId, 0, 0);
    vbb.addVertexPolytriangle(minx, maxy, linkFillColor, dbId, 0, 0);

    vbb.addIndices([0, 1, 2, 0, 2, 3], vbase);

    vbb.addSegment(minx, miny, maxx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, miny, maxx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(maxx, maxy, minx, maxy, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
    vbb.addSegment(minx, maxy, minx, miny, 0, -2 * modelScale, linkFillColor | 0xff000000, dbId, 0, 0, 0);
  }

  function addLinkBoxMesh(model, vbb) {
    var fragId = model.getFragmentList().vizmeshes.length;
    var mdata = { mesh: vbb.toMesh(), is2d: true, packId: '0', meshIndex: fragId };
    avp.BufferGeometryUtils.meshToGeometry(mdata);

    var matman = _viewer.impl.matman();
    var materialId = matman.create2DMaterial(model, {});
    var m = _viewer.impl.setupMesh(model, mdata.geometry, materialId, model.getData().loadOptions.placementTransform);
    model.activateFragment(fragId, m);
    return fragId;
  }

  function removeLinkBoxMesh(model, fragId) {
    // get link box mesh
    var fragList = model.getFragmentList();
    var mesh = fragList.vizmeshes[fragId];

    // Dispose geometry. MaterialManager will take care of the material dispose on model unload. 
    // We don't dispose material here because it may be shared with other fragments of the model.
    mesh.geometry.dispose();

    delete fragList.vizmeshes[fragId];
  }

  function initializeHyperlinks(model) {
    if (!model || !model.is2d()) {
      return;
    }

    // Check if this model has been initialized already
    var linkMap = _linkMaps[model.id];
    if (linkMap) {
      return;
    }

    // find all sheets of the same document
    var node = model.getDocumentNode();
    var root = node && node.getRootNode();
    var sheets = root && root.search({ role: '2d', type: 'geometry' });
    if (!sheets || !sheets.length) {
      return;
    }

    linkMap = _linkMaps[model.id] = {};

    var currentSheetBasePath = '';
    if (model.myData) {
      currentSheetBasePath = model.myData.basePath;
    }

    var getSheetUrn = function getSheetUrn(sheet) {
      var resourceType = 'resource';
      if (sheet.children) {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
          for (var _iterator = sheet.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var child = _step.value;
            if (child.type() === resourceType) {
              var urn = child.urn();
              if (urn) {
                // We remove the primaryGraphics.f2d part from the urn
                var elements = urn.split('/');
                elements.pop();
                return elements.join('/');
              }
            }
          }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator["return"] != null) {_iterator["return"]();}} finally {if (_didIteratorError) {throw _iteratorError;}}}
      }
      return null;
    };

    var sheetIds = sheets.map(function (s) {
      var sheetUrn = getSheetUrn(s);
      //exclude current sheet, i. e. no links to self
      if (currentSheetBasePath.indexOf(sheetUrn) === -1) {
        var split = s.name().split(' ');
        var sheetName = split[0];
        if (sheetName.length > 2) {
          return sheetName;
        }
      }
      return '';
    });

    //while finding hyperlink strings, we will also
    //create a geometry buffer containing all their bboxes
    //so we can render with their IDs.
    linkMap.numHyperlinks = 0;
    var vbb = new avp.VertexBufferBuilder();
    var modelScale = 1.0 / (model.getData().loadOptions.modelScale || 1);
    var f2d = model.getData();
    for (var i = 0; i < f2d.strings.length; i++) {

      var idx = sheetIds.indexOf(f2d.strings[i]);

      if (idx >= 0) {
        linkMap[f2d.stringDbIds[i]] = sheets[idx];

        addRenderBox(vbb, f2d, i, modelScale);
        linkMap.numHyperlinks++;
      }
    }

    linkMap.boxFragId = addLinkBoxMesh(model, vbb);

    if (_hyperlinksAddedCb) {
      _hyperlinksAddedCb(e.model.id, linkMap.numHyperlinks);
    }
  }

  function onGeomLoaded(e) {
    initializeHyperlinks(e.model);
  }

  // Execute cb for all sheets that are (completely) in memory
  function forAllSheetsInMemory(cb) {
    var allModels = _viewer.getVisibleModels().concat(_viewer.getHiddenModels());
    for (var i = 0; i < allModels.length; i++) {
      var model = allModels[i];
      if (model.is2d() && model.isLoadDone()) {
        cb(model);
      }
    }
  }

  function removeHyperlinks() {

    // Keep _linkMaps consistent with models: We don't want to leak dead box meshes in the models.
    // Therefore, we remove them from all models in memory
    forAllSheetsInMemory(function (model) {
      var linkMap = _linkMaps[model.id];
      if (linkMap) {
        removeLinkBoxMesh(model, linkMap.boxFragId);
      }
    });

    _linkMaps = {};

    // make sure that removed hyperlink quads are not visible anymore
    _viewer.impl.invalidate(true, true);
  }

  this.activate = function () {

    // Make sure that we don't forget to init hyperlinks if the geom-load event has already happened
    forAllSheetsInMemory(function (model) {
      initializeHyperlinks(model);
    });

    _viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);

    // make sure that added hyperlink quads appear instantly
    _viewer.impl.invalidate(true, true);
  };

  this.deactivate = function () {
    _viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, onGeomLoaded);
    removeHyperlinks();
  };

  // Show a hand cursor, if the cursor is close to a hyperlink
  this.getCursor = function () {
    var linkMap = getCurrentLinkMap();

    if (_dbId < -1 && isLinkMapValid(linkMap) && linkMap[_dbId]) {
      return 'pointer';
    }

    return null;
  };
}

var namespace = AutodeskNamespace('Autodesk.AEC');
namespace.HyperlinkTracker = HyperlinkTracker;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelector.js":
/*!************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelector.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelector; });
/* harmony import */ var _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelectorFilter.js */ "./extensions/AEC/levels/FloorSelectorFilter.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var av = Autodesk.Viewing;
var avp = Autodesk.Viewing.Private;
var namespace = AutodeskNamespace('Autodesk.AEC');


// FloorSelector provides graphics effects to be used by UI for floor selection.
//
// This includes:
//
//  - Setting cutplanes accordingly when a floor is selected.
//
//  - Animated transitions if the selected floor changes.
//
//  - Applying mouse-over highlighting of floors - to be used when hovering over a floor button
//
//  - "Ghost-Floors": By default, we render selected floors only. If the mouse enters the floor panel, we
//     also fade-in the other floors, but with strongly reduced opacity. (+ fade-out on mouse leave)
//
//
// How to use it:
//
//  1. Create a FloorSelector by passing the viewer to the ctor.
//
//  2. Before using the FloorSelector, you have to provide floor data that you get from the Revit metadata
//     json file. (see setFloorData comment)
//
//  3. Connect events for hovering over floor selector UI panel:
//     - Connect mouseover  to floorSelector.enterHoverMode()
//     - Connect mouseleave to floorSelector.existHoverMode()
//
//  4. Connect events for hovering over floor selection buttons: For each floor button...
//     - Connect mouseover  to floorSelector.rollOverFloor(floorIndex) - floorIndex must be the index into the floor array (see setFloorData)
//     - Connect mouseleave to floorSelector.rollOverFloor()
//
//  5. Connect floor selection button: For each floor button,
//     connect button mousedown to floorSelector.selectFloor(floorIndex, true)
//
//  6. If the set of visible models has changed
//
//  7. When discarding the FloorSelector (while keeping the Viewer alive), call FloorSelector dtor.
//
// How to enable the optional filtering of objects by dbIds per model provided by the AECModelData.json on level selection?
//
//  1. You have to provide floor filter data containing a Map of dbIds per model. The key has to be the model version URN (see setFloorFilterData).
//
//     Example on how to set the floor filter data:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// How to control the calculated lower level boundary value by defining the levelHeightFactor factor? The factor is multiplied with the level height
// and added to the level minZ value. This newly calculated minZ value defines the lower level boundary used to filter the Floor and Ceiling elements.
//
//     Example on how to set the floor filter data with a levelHeightFactor:
//
//     const modelsDbIds = new Map();
//     modelsDbIds.set(model, [1, 2, 3, 4]);
//     var floorFilterData = {
//         modelsDbIds: modelsDbIds,
//         levelHeightFactor: 0.6 // Allowed values have to be within 0-1.
//     };
//
//     floorSelector.setFloorFilterData(floorFilterData);
//
// Technical requirements/restrictions to be aware of:
//
//  - Cross-Fading Support: FloorSelector uses LMV render target fading for some effects. For this, it activates
//    cross-fading support in LMV (if not active already). This requires 2 extra color targets, i.e.
//    consumes some additional GPU-side memory.
//
//  - Camera Movement: The camera should not be moving while using the floor selector.
//    This is because we partially use static images for the fading effects.
//    If the user moves the camera, we instantly switch off the ghost floors.
//
//  - SAO opacity: FloorSelector needs to temporarily hide SAO. For this, we have to overwrite SAO opacity
//    and recover it later. This requires that the SAO opacity is not changed in the meantime
//    while using the FloorSelector. Otherwise, it will cause a warning and may cause visual
//    artifacts.



// Time in seconds to fade in/out ghosted floors when hovering over the floor selector panel
var GhostFloorFadingTime = 0.5;

// Opacity for ghost floors when fade-in is finished.
var MaxGhostFloorOpacity = 0.2;

// These should actually be infinity and -infinity, but since the values are passed to a shader,
// we have to use large finite values instead. Setting as cutplane elevations actually corresponds to
// switching cutplanes off. But, changes the number of cutplanes triggers expesnive shader recompiles.
var MaxZLimit = 1e20;
var MinZLimit = -MaxZLimit;

// Internally used enum values for state management
var FloorRenderMode = {

  // mouse is hovering over a floor button
  Hovering: 0,

  // new floor has been selected and anim is running
  Transition: 1,

  // default rendering
  Off: 2 };


// Reserved floor-index constant to select all floors at once.
var AllFloors = -1;
var NoFloor = undefined;

// Used for setCutPlane calls to lmv. This ensures that FloorSelector controls its own cutplanes,
// which is independent of other cutplane changes like from SectionTool.
var CutPlaneSetName = 'Autodesk.AEC.FloorSelector';var

FloorSelector = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelector(viewer) {_classCallCheck(this, FloorSelector);

    av.EventDispatcher.prototype.apply(this);

    this._viewer = viewer;
    this._renderer = viewer.impl.renderer();

    // Make sure that ghost-floors are switched off as soon as the user starts navigating.
    // This is needed because the selected floor is just a static image when ghost-floors are shown.
    this._cameraMovedCB = this._interruptFading.bind(this);
    viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);

    // Stop panel-hover effect on viewer-resize: Ghost-floors use a static image overlay that becomes unusable
    // if the target size changes.
    this._viewerResizeCB = this._onViewerResized.bind(this);
    viewer.addEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);

    // If SAO is switched off, we have to switch off roll-over highlighting too.
    this._renderOptionsChangedCB = this._onRenderOptionsChanged.bind(this);
    viewer.addEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);

    // callback for the floor selection filtering
    this._floorSelectionFilterToBeUpdated = this._runFloorSelectorFilterEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
    viewer.addEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);

    // callback for the unloading of disabled models
    this._modelUnloadingCB = this._runModelUnloadingEventHandler.bind(this);
    viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);

    // {Object[]} Contains the floor data. see setFloorData() comment.
    this._floors = [];

    // current state (hover/transition/off)
    this._currentMode = FloorRenderMode.Off;
    this._hovering = false; // used to track hovering state while in transition mode

    // current floor section (if cutplanes are active)
    this._floorSectionMin = undefined;
    this._floorSectionMax = undefined;

    // Determine z-range for "all-floors"
    // We determine that dynamically from the currently visible models.
    // Note that we need this value also for cutplane transitions - so we cannot
    // simply choose something arbitrarily far outside.
    this._zMinAllModels = undefined;
    this._zMaxAllModels = undefined;

    // {AnimControl} Needed to interrupt a running cutplane animation (see moveFloors)
    this._floorAnim = null;

    // {AnimControl} Needed to interrupt a runnign fade-in/out anim for ghost-floors
    this._fadeAnim = null;

    // Opacity of the render target that shows floors that are currently not selected ("ghost floors")
    // Always 0.0 if the extra target for ghost floors is not used.
    this._ghostFloorOpacity = 0.0;

    this._currentMode = FloorRenderMode.Off;

    // {number|undefined} index of selected floor (or undefined if no floor is selected)
    this._currentFloor = undefined;

    // We render ghost-floors without AO, because AO cannot be smoothly faded out with them.
    // To activate AO, we need to 'backup' the current AO opacity and recover it later.
    this._aoVisible = true;
    this._aoOpacity = undefined; // if ao is blocked, we store the original ao opacity here to recover it later.

    this._floorSelectorFilter = new _FloorSelectorFilter_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._viewer);
    this._floorFilterData = undefined;

    // Indicates if we are currently using mouse-over highlighting for a floor.
    this._floorRollOverActive = false;

    // If disabled, make sure that cutplanes keep unset. This is needed to avoid side-effects on 2D views.
    this.enabled = true;

    // Maximum time in ms that we allow for rendering offline images for fading effects.
    // By default (undefined), we use the frameBudget of regular rendering.
    this.offscreenRenderBudget = undefined;
  }_createClass(FloorSelector, [{ key: "dtor", value: function dtor()

    {
      if (this._viewer) {
        this._viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._cameraMovedCB);
        this._viewer.removeEventListener(av.VIEWER_RESIZE_EVENT, this._viewerResizeCB);
        this._viewer.removeEventListener(av.RENDER_OPTION_CHANGED_EVENT, this._renderOptionsChangedCB);
        this._viewer.removeEventListener(av.OBJECT_TREE_CREATED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._floorSelectionFilterToBeUpdated);
        this._viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this._modelUnloadingCB);
        this._viewer = null;
      }
    }

    // -----------------
    // --- Main API ----
    // -----------------

    // Before selecting any floors, setFloorData() must be called to provide the elevation ranges
    // of all available floors.
    //  @param {Object[]} floors - data about available floors, each item f must contain two finite floats f.zMin < f.zMax
  }, { key: "resetState",









    // sets back level isolation, selection filter and the floors.
    value: function resetState() {
      // we have to clear the settings
      this._floors = [];
      this._selectFloor(NoFloor);
      this._clearFloorSection();
      this._floorSelectorFilter.clearFilter();
    }

    // Before any objects can be filtered using the FloorSelectorFilter, setFloorFilterData() must be called to
    // provide the array of Floor and Ceiling dbIds per model.
    //  @param {Object[]} floorFilterData - A floor filter data object containing an array of dbIds per model.
  }, { key: "enterHoverMode",







    // Fades in the ghost-floors.
    // Triggered when floor selection begins, i.e., mouse is entering floor selector panel.
    value: function enterHoverMode() {

      // make sure that the ghosted floors are in a static image,
      // so that we can move the solid floor
      if (this._currentMode !== FloorRenderMode.Transition) {
        this._setMode(FloorRenderMode.Hovering);
      }

      // track hovering state - so that we can recover it after transitions
      this._hovering = true;
    }

    // Fades out the ghost floors.
    // Triggered when floor selection ends, i.e., mouse is leaving the floor selector panel.
  }, { key: "exitHoverMode", value: function exitHoverMode() {

      // If a floor-transition is running, we only track the hover state and
      // set the mode when the transition has finished.
      if (this._currentMode !== FloorRenderMode.Transition) {
        this._setMode(FloorRenderMode.Off);
      }
      this._hovering = false;

      // make sure that no spatial filter for mouse-over highlight is set anymore, so that we don't
      // have side-effects on subsequent object selection.
      this._setSpatialFilterForRollOver();
    } }, { key: "_getFadeExtension", value: function _getFadeExtension()

    {
      return this._viewer.getExtension('Autodesk.CrossFadeEffects');
    }

    // Ghosted display of inactive floors on panel hover is only supported if CrossFadeEffects extension is loaded
  }, { key: "_ghostFloorsEnabled", value: function _ghostFloorsEnabled() {
      return Boolean(this._getFadeExtension());
    }

    // Select for which floor rollOver highlighting is shown.
    //   @param {number} [floorIndex] must be either
    //                                a) a valid index into this.floors
    //                                b) a reserved constant (FloorSelector.AllFloors or FloorSelector.NoFloor)
  }, { key: "rollOverFloor", value: function rollOverFloor(floorIndex) {

      // If we don't show ghost-floors, roll-over highlighting does not make much sense if only 1 floor is visible anyway.
      // It just looks confusing, because occasionally it would only be visible for the selected floor and some parts of others
      // that overlap the z-range a bit.
      var enabled = this._ghostFloorsEnabled() || this._currentFloor === NoFloor;

      // rollOver highlight is only possible if SAO is enabled and supported.
      var supported = this._renderer.spatialFilterForRollOverSupported();
      if (floorIndex === undefined || !supported || !enabled) {

        // switch off floor highlight
        this._setSpatialFilterForRollOver();
        this._renderer.rolloverObjectId(0);
        return;
      }

      // Activate roll-over highlighting for all objects
      this._renderer.rolloverObjectId(1);

      // restrict highlighting to floor range unless all floors are selected.
      this._setSpatialFilterForRollOver(floorIndex);

      // TODO: Clarify why this call is needed. It should actually not required to re-render here.
      this._viewer.impl.invalidate(false, true, true);
    }

    // Sets the currently visible floor.
    //  @param {number}   [floorIndex]    A valid index into the floor data array (see setFloors) selects a single floor.
    //                                    FloorSelector.NoFloor discards the floor selection => all floors visible.
    //  @param {bool}     [useTransition] If true, a short animation is used to morph between previous and new floor
    //  returns false in case no selection cannot be performed
  }, { key: "selectFloor", value: function selectFloor(floorIndex, useTransition) {

      if (!this.floorSelectionValid(floorIndex)) {
        return;
      }

      if (useTransition) {
        this._moveToFloor(floorIndex);
      } else {
        this._selectFloor(floorIndex);
      }

      this._runFloorSelectorFilter();

      // If no ghosting is used, we disable rollOver highlighting if only a single floor is visible.
      if (!this._ghostFloorsEnabled()) {
        this.rollOverFloor();
      }

      this.fireEvent({ type: FloorSelector.CURRENT_FLOOR_CHANGED, levelIndex: floorIndex });
    }

    // Gets the index of the current selected floor or FloorSelector.NoFloor
  }, { key: "floorSelectionValid",



    // Returns whether a floorSelection can be performed with the specified floor
    // checks for valid value, whether floorData is available, the floor is already selected
    // and whether the floor is within the expected range.
    value: function floorSelectionValid() {var newFloor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NoFloor;
      // force boolean
      return !!((Number.isInteger(newFloor) || newFloor === NoFloor) && // not a valid value
      this.floorData && this.floorData.length !== 0 // has no floor data
      && this.currentFloor !== newFloor // newFloor floor is not selected
      && (newFloor === NoFloor ||
      newFloor >= 0 || this.floorData.length > newFloor)); // new floor is in range;
    }

    // returns true if a dbId is either hidden by FloorSelectorFilter or fully outside the cutplanes
  }, { key: "isVisible", value: function isVisible(model, dbId) {

      // reused tmp variable
      if (!this._tmpNodeBox) {
        this._tmpNodeBox = new Float32Array(6);
      }

      // Determine zMin/zMax to ceck against. We could use _floorSectionMin/Max. But this would
      // make this function depending on current animation state. Since we don't want to do permanent
      // filter-updates during animations, we use currentFloor instead, which represents the target state - independent of animations.
      var floor = this._floors[this._currentFloor];
      if (floor === NoFloor) {
        // No floor selected => Nothing hidden
        return true;
      }

      var instanceTree = model.getInstanceTree();
      if (!instanceTree) {
        // If there is not instance tree, FloorSelectorFilter would have warned already if a floor was selected.
        return true;
      }

      // get zMin/zMax for this node
      var nodeBox = this._tmpNodeBox;
      instanceTree.getNodeBox(dbId, nodeBox);
      var nodeBoxZMin = nodeBox[2];
      var nodeBoxZMax = nodeBox[5];

      // Node is hidden if...
      //  a) outside the level's cutplanes, or
      //  b) hidden by levels filter
      var outsideCutplane = nodeBoxZMin > floor.zMax || nodeBoxZMax < floor.zMin;
      return !outsideCutplane && this._floorSelectorFilter.isVisible(model, dbId);
    } }, { key: "setEnabled", value: function setEnabled(

    enabled) {
      this.enabled = enabled;
      this._applySelectedFloorSection();
    }

    // ------------------------
    // --- Internal methods ---
    // ------------------------
  }, { key: "_stopFloorAnim", value: function _stopFloorAnim()
    {
      if (this._floorAnim) {
        this._floorAnim.stop();
        this._floorAnim = null;
      }
    } }, { key: "_stopFadeAnim", value: function _stopFadeAnim()

    {
      if (this._fadeAnim) {
        this._fadeAnim.stop();
        this._fadeAnim = null;
      }
    } }, { key: "_leaveHoverMode", value: function _leaveHoverMode()

    {

      var fadeExt = this._getFadeExtension();
      if (!fadeExt) {
        // Nothing todo if ghosting effect is not used.
        return;
      }

      // release any baked images
      fadeExt.releaseFadingImage(0);
      fadeExt.releaseFadingImage(1);

      // make sure that model is rendered into default color target
      fadeExt.setModelTargetIndexForAll(undefined);

      // apply cutplanes according to currently selected floor
      this._applySelectedFloorSection();

      // we are now rendering real floors again,
      // so that we can switch SAO on again.
      this._setAOVisible(true);
    }

    // When rendering ghost-floors, the static part is always a static image.
    // Therefore, we have to skip the fading if the user moves the camera.
  }, { key: "_interruptFading", value: function _interruptFading() {

      // If we just left hover-mode, but the floors did not finish to fade out yet,
      // stop the anim and finish it immediately.
      if (!this._hovering && this._fadeAnim && this._fadeAnim.isRunning) {
        this._stopFadeAnim();
        this._leaveHoverMode();
      }
    } }, { key: "_onViewerResized", value: function _onViewerResized()

    {
      // Stop any image-based hovering effects immedately, because the baked ghost-floor image has incorrect size now.
      this._stopFadeAnim();
      this._leaveHoverMode();

      // Restart hovering effect if mouse is still on the panel. Now using the new render target size.
      if (this._hovering) {
        this.enterHoverMode();
      }
    } }, { key: "_onRenderOptionsChanged", value: function _onRenderOptionsChanged()

    {
      // Make sure that we stop using roll-over-floor highlight if the depth
      // target is not available anymore.
      if (this._floorRollOverActive && !this._renderer.spatialFilterForRollOverSupported()) {
        this.rollOverFloor();
      }
    }

    // Get array of all visible models
  }, { key: "_getVisibleModels", value: function _getVisibleModels() {
      var mq = this._viewer.impl.modelQueue();
      return mq.getModels();
    }

    // Updates min/max limits for cutplane z-level, based on the bboxes of all visible models
  }, { key: "_updateZLimits", value: function _updateZLimits() {
      var models = this._getVisibleModels();

      this._zMinAllModels = MaxZLimit;
      this._zMaxAllModels = MinZLimit;
      for (var i = 0; i < models.length; i++) {
        var model = models[i];
        var box = model.getBoundingBox();

        this._zMinAllModels = Math.min(box.min.z, this._zMinAllModels);
        this._zMaxAllModels = Math.max(box.max.z, this._zMaxAllModels);
      }

      // make sure the range is valid also when no models are available
      if (this._zMinAllModels > this._zMaxAllModels) {
        this._zMinAllModels = MinZLimit;
        this._zMaxAllModels = MaxZLimit;
      }
    } }, { key: "_setAOVisible", value: function _setAOVisible(

    visible) {
      if (visible === this._aoVisible) {
        return;
      }
      this._aoVisible = visible;

      var blendPass = this._renderer.getBlendPass();

      var newOpacity = 0.0;
      if (!visible) {
        // ao switched off => backup original ao opacity
        this._aoOpacity = blendPass.uniforms['aoOpacity'].value;
      } else {

        // Opacity should be 0. Any other value indicates that it has been changed from
        // outside while ao was hidden by floor selector.
        var curOpacity = blendPass.uniforms['aoOpacity'].value;
        if (curOpacity !== 0.0) {
          console.warn('ao opacity should not be changed while FloorSelector is in use.');
        }

        // ao switched on => recover original ao opacity
        newOpacity = this._aoOpacity;
      }

      this._renderer.setAOOptions(this._renderer.getAORadius(), this._renderer.getAOIntensity(), newOpacity);
    }

    // @param {number} val - float in [0,1]
  }, { key: "_setGhostFloorOpactiy", value: function _setGhostFloorOpactiy(val) {

      // ghost-floors are always rendered into extra target 1
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.setCrossFadeOpacity(1, this._ghostFloorOpacity);

      this._ghostFloorOpacity = val;

    }

    // Apply/Remove spatial filter that restricts rollOver highlighting to a single floor
    //  @param {number} If floorIndex is a valid index into this.floors, highlighting is restricted to that floor.
    //                  Otherwise, the spatial filter is switched off.
  }, { key: "_setSpatialFilterForRollOver", value: function _setSpatialFilterForRollOver(floorIndex) {

      var filter = undefined;
      var floor = this._floors[floorIndex];

      var createSpatialFilter = function createSpatialFilter(zMin, zMax) {
        // Define filter to restrict rollOver highlighting to floor elevation range
        return 'bool spatialFilter(vec3 worldPos) { return (worldPos.z >= float(' + zMin + ') && worldPos.z <= float(' + zMax + ')); }';
      };

      if (floor) {
        filter = createSpatialFilter(floor.zMin, floor.zMax);
      } else if (floorIndex === FloorSelector.AllFloors) {
        filter = createSpatialFilter(this._zMinAllModels, this._zMaxAllModels);
      }

      this._renderer.setSpatialFilterForRollOver(filter);

      // If spatial filter is defined, make sure that ghost floors are always rendered to depth target.
      // Otherwise, the spatial filter for roll-over highlighting does not work.
      var fadeExt = this._getFadeExtension();
      fadeExt && fadeExt.crossFade.setSaoHeuristicEnabled(!filter);

      this._floorRollOverActive = !!filter;
    } }, { key: "_applyFloorSection", value: function _applyFloorSection(

    zMin, zMax) {

      // Do not allow any cutplane when disabled
      if (!this.enabled) {
        this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
        return;
      }

      // reset the defined z values to the minimum in case the value is not specified
      if (!Number.isFinite(zMin)) {
        zMin = MinZLimit;
      }
      if (!Number.isFinite(zMax)) {
        zMax = MaxZLimit;
      }


      var planes = [new THREE.Vector4(0, 0, -1, zMin), new THREE.Vector4(0, 0, 1, -zMax)];
      this._viewer.impl.setCutPlaneSet(CutPlaneSetName, planes);
    }

    // Set cut plane according to currently selected floor
  }, { key: "_applySelectedFloorSection", value: function _applySelectedFloorSection() {

      // If no floor section is active, set cutplanes to maximum range.
      // Doing this instead of clearing them avoids the repeated shader recompile
      var zMin = this._floorSectionMin !== undefined ? this._floorSectionMin : MinZLimit;
      var zMax = this._floorSectionMax !== undefined ? this._floorSectionMax : MaxZLimit;
      this._applyFloorSection(zMin, zMax);
    } }, { key: "_setFloorSection", value: function _setFloorSection(

    minElev, maxElev) {
      this._floorSectionMin = isNaN(minElev) ? undefined : minElev;
      this._floorSectionMax = isNaN(maxElev) ? undefined : maxElev;
      this._applySelectedFloorSection();
    }

    // Temporarily disable floor section cut planes. This is needed to render ghost floors.
  }, { key: "_clearFloorSection", value: function _clearFloorSection() {
      // Changing the number of cutplanes would cause a shader recompile.
      // To avoid that, we set dummy cutplanes instead.
      this._updateZLimits();
      this._applyFloorSection();
    } }, { key: "_setMode", value: function _setMode(

    mode) {var _this = this;

      if (mode === this._currentMode) {
        return;
      }
      this._currentMode = mode;

      if (mode === FloorRenderMode.Hovering) {

        var fadeExt = this._getFadeExtension();
        if (fadeExt) {

          // Take control over CrossFade effect.
          // NOTE: As long as the mouse is hovering over the LevelsPanel, we assume that no one else overtakes the crossFade effect. If the mouse leaves the LevelsPanel
          //       the ghost-floors a fading out. If the fading is needed for something else at that time, we skip the fading and drop the ghost floors immediately.
          fadeExt.acquireControl('FloorSelector', function () {return _this._interruptFading();});

          // Render snapshot of selected floors into target 0
          fadeExt.setModelTargetIndexForAll(undefined); // render to main target
          this._applySelectedFloorSection(); // set cutplanes according to selected floor
          this._renderer.rolloverObjectId(0); // keep mouse-over highlighting out of the snapshot
          this._setAOVisible(true); // Make sure that the selected floors are rendered with AO
          fadeExt.renderFadingImage(0, this.offscreenRenderBudget); // render static snapshot of selected floors into extra target 0

          // show this snapshot at full opacity
          fadeExt.setCrossFadeOpacity(0, 1.0);

          // Render remaining floors...
          this._clearFloorSection();

          // ..into target 1
          fadeExt.setModelTargetIndexForAll(1);

          // before starting to fade-in the ghost-floors,
          // hide SAO. Otherwise, SAO of the ghost
          // floors would pop in at fade start.
          this._setAOVisible(false);

          // stop any prior fade-anim
          this._stopFadeAnim();

          // fade-in ghost floors (starting at the prior opacity)
          var onTimer = this._setGhostFloorOpactiy.bind(this);
          this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, MaxGhostFloorOpacity, GhostFloorFadingTime, onTimer);
        }
      } else if (mode === FloorRenderMode.Transition) {

        // protect ghost floors from clear
        var _fadeExt = this._getFadeExtension();
        if (_fadeExt) {
          _fadeExt.setClearEnabled(1, false);

          // render into target 0 again
          _fadeExt.setClearEnabled(0, true);
          _fadeExt.setModelTargetIndexForAll(0);

          // make sure that target 0 has full opacity to make sure that floor keeps visible after moving to target 0
          _fadeExt.setCrossFadeOpacity(0, 1.0);
        }

        // reactivate AO
        this._setAOVisible(true);

        // Render selected/moving floor...
        this._applySelectedFloorSection();

      } else if (mode === FloorRenderMode.Off) {

        // stop any prior fade-anim
        this._stopFadeAnim();

        // fade-out ghost floors (starting at current opacity)
        var _onTimer = this._setGhostFloorOpactiy.bind(this);
        var onFinished = this._leaveHoverMode.bind(this);
        this._fadeAnim = avp.fadeValue(this._ghostFloorOpacity, 0.0, GhostFloorFadingTime, _onTimer, onFinished);
      }
    } }, { key: "_moveToFloor", value: function _moveToFloor(

    floorIndex) {var _this2 = this;

      this._currentFloor = floorIndex;

      this._setMode(FloorRenderMode.Transition);

      var floor = this._floors[floorIndex];

      this._updateZLimits();

      var minElevStart = this._floorSectionMin === undefined ? this._zMinAllModels : this._floorSectionMin;
      var maxElevStart = this._floorSectionMax === undefined ? this._zMaxAllModels : this._floorSectionMax;
      var minElevEnd = floor ? floor.zMin : this._zMinAllModels;
      var maxElevEnd = floor ? floor.zMax : this._zMaxAllModels;

      var updateCutPlanes = function updateCutPlanes(unitTime) {
        var t = avp.smootherStep(unitTime);
        var minElev = avp.lerp(minElevStart, minElevEnd, t);
        var maxElev = avp.lerp(maxElevStart, maxElevEnd, t);

        _this2._setFloorSection(minElev, maxElev);

        // fade-out mouse over while animating
        var blendPass = _this2._renderer.getBlendPass();
        var uniform = blendPass.uniforms['highlightIntensity'];
        uniform.value = Math.min(uniform.value, 1.0 - t);
      };

      var onAnimEnd = function onAnimEnd() {
        // leave transition mode to hovering or off
        var mode = _this2._hovering ? FloorRenderMode.Hovering : FloorRenderMode.Off;
        _this2._setMode(mode);
      };

      // If another floor anim is in running, stop it first.
      this._stopFloorAnim();

      this._floorAnim = avp.fadeValue(0.0, 1.0, 0.5, updateCutPlanes, onAnimEnd);
    } }, { key: "_selectFloor", value: function _selectFloor(

    floorIndex) {

      // Make sure that a previous anim does not overwrite the cutplanes again.
      this._stopFloorAnim();

      this._currentFloor = floorIndex;

      // Note that zMin/zMax may also be undefined if no floor is selected
      var floor = this._floors[floorIndex];

      // Set min/maxElev from floor or set both to undefined (for 'no floor selected')
      var minElev = floor ? floor.zMin : undefined;
      var maxElev = floor ? floor.zMax : undefined;

      this._setFloorSection(minElev, maxElev);
    } }, { key: "_runFloorSelectorFilter", value: function _runFloorSelectorFilter()

    {
      // Make sure all previously hidden objects are set to visible again.
      this._floorSelectorFilter.clearFilter();

      if (this._floorFilterData && this._currentFloor !== undefined) {
        var floor = this._floors[this._currentFloor];
        this._floorSelectorFilter.filter(this._floorFilterData, floor);
      }
    } }, { key: "_runFloorSelectorFilterEventHandler", value: function _runFloorSelectorFilterEventHandler(

    event) {
      var model = event.model;

      if (!model.isObjectTreeLoaded()) {
        return;
      }
      if (!(this._floorFilterData && this._currentFloor !== undefined)) {
        // Handles the case when a level was deactivated while the model was not visible.
        // When activating again the model, we need to make sure that the previously
        // filtered elements are set to visible again.
        this._floorSelectorFilter.clearFilter();
        return;
      }
      this._runFloorSelectorFilter();
    } }, { key: "_runModelUnloadingEventHandler", value: function _runModelUnloadingEventHandler(

    event) {
      if (this._floorFilterData && this._currentFloor !== undefined) {
        this._floorSelectorFilter.unhideModel(event.model);
      }
    } }, { key: "floorData", get: function get() {return this._floors;}, set: function set(floors) {// always reset the floor selector when floors data changes to avoid inconstancy
      this.resetState();this._floors = Array.isArray(floors) ? floors : [];} }, { key: "floorFilterData", get: function get() {return this._floorFilterData;}, set: function set(floorFilterData) {this._floorFilterData = floorFilterData;} }, { key: "currentFloor", get: function get() {return this._currentFloor;} }]);return FloorSelector;}();


FloorSelector.AllFloors = AllFloors;
FloorSelector.NoFloor = NoFloor;

FloorSelector.CURRENT_FLOOR_CHANGED = "currentFloorChanged";

namespace.FloorSelector = FloorSelector;

/***/ }),

/***/ "./extensions/AEC/levels/FloorSelectorFilter.js":
/*!******************************************************!*\
  !*** ./extensions/AEC/levels/FloorSelectorFilter.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FloorSelectorFilter; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var namespace = AutodeskNamespace('Autodesk.AEC');

// The FloorSelectorFilter provides functionality to additionally apply object filtering
// by dbIds on level selection.
//
var
FloorSelectorFilter = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  function FloorSelectorFilter(viewer) {_classCallCheck(this, FloorSelectorFilter);
    this._viewer = viewer;
    // Contains all dbIds per model used to un-hide the objects whenever another level gets selected.
    this._dbIdsToUnhide = new Map();
    this._cache = {};
  }

  // Filter all elements by dbIds on level selection.
  //  @param {Object}   floorFilterData   - A floor filter data object containing all dbIds per model and an optional level height factor.
  //  @param {Object}   floor             - A floor.
  _createClass(FloorSelectorFilter, [{ key: "filter", value: function filter(floorFilterData, floor) {var _this = this;
      if (!floorFilterData) {
        throw new Error('floorFilterData cannot be undefined.');
      }
      if (!(floorFilterData.modelsDbIds instanceof Map)) {
        throw new Error('floorFilterData.modelsDbIds has to be a Map.');
      }
      if (!floor) {
        throw new Error('floor cannot be undefined.');
      }

      // Get the level height factor and also do some basic number checks.
      var levelHeightFactor = this._getLevelHeightFactor(floorFilterData.levelHeightFactor);

      // All Floor and Ceiling db ids per model to hide.
      var modelsDbIds = floorFilterData.modelsDbIds;

      // Do nothing in case no db ids are set.
      if (!this._hasModelDbIds(modelsDbIds)) {
        return;
      }

      var minZ = floor.zMin;
      var maxZ = floor.zMax;

      // Calculate the new minZ/maxZ values of the level boundary used to spatially filter the Floor and
      // Ceiling elements.
      // 1. The lower boundary value (zMin) is moved up by the factor of the level height, because the Ceiling
      //    elements we want to filter are located in the upper part of the level.
      // 2. The upper boundary value (zMax) is moved up by 10% of the level height, because in some models
      //    this helps to also remove floors which would be still shown otherwise.
      var newMinZ = minZ + (maxZ - minZ) * levelHeightFactor;
      var newMaxZ = maxZ + (maxZ - minZ) * 0.1;

      // Setup cache for each floor.
      if (!this._cache[floor.name]) {
        this._cache[floor.name] = {};
      }

      var modelQueue = this._viewer.impl.modelQueue();
      var models = modelQueue.getModels();var _loop2 = function _loop2(

      m, l) {
        var model = models[m];

        if (!model.visibilityManager) {
          console.warn("The VisibilityManager of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "break";
        }

        // Try to get the db ids for a specific level and model from the cache.
        if (_this._cache[floor.name][model.id]) {
          var cachedDbIds = _this._cache[floor.name][model.id];
          if (cachedDbIds.size > 0) {
            _this.hideDbIds(model, cachedDbIds);
          }
          return "continue";
        }

        var instanceTree = model.getInstanceTree();
        if (!instanceTree) {
          console.warn("The instanceTree of the model with ID = ".concat(model.id, " is not yet initialized."));
          return "continue";
        }

        var dbIdsToHide = new Set();
        var dbIds = modelsDbIds.get(model.id);
        if (!dbIds) {
          return "continue";
        }

        dbIds.forEach(function (dbId) {
          var nodeBox = new Float32Array(6);
          instanceTree.getNodeBox(dbId, nodeBox);

          var nodeBoxMinZ = nodeBox[2];
          var nodeBoxMaxZ = nodeBox[5];

          if (nodeBoxMinZ >= newMinZ && nodeBoxMinZ <= newMaxZ ||
          nodeBoxMaxZ >= newMinZ && nodeBoxMaxZ <= newMaxZ ||
          nodeBoxMinZ <= newMinZ && nodeBoxMaxZ >= newMaxZ) {
            dbIdsToHide.add(dbId);
          }
        });

        if (dbIdsToHide.size > 0) {
          _this.hideDbIds(model, dbIdsToHide);
        }

        _this._cache[floor.name][model.id] = dbIdsToHide;};_loop: for (var m = 0, l = models.length; m < l; m++) {var _ret = _loop2(m, l);switch (_ret) {case "break":break _loop;case "continue":continue;}
      }
    } }, { key: "hideDbIds", value: function hideDbIds(

    model, dbIds) {
      if (!model.visibilityManager) {
        return;
      }

      dbIds.forEach(function (id) {
        model.visibilityManager.setNodeOff(id, true);
      });

      // Collect all dbIds per model, so we can un-hide them later on again.
      if (this._dbIdsToUnhide.has(model)) {
        var _dbIds = this._dbIdsToUnhide.get(model);var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
          for (var _iterator = _dbIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var dbId = _step.value;
            _dbIds.add(dbId);
          }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator["return"] != null) {_iterator["return"]();}} finally {if (_didIteratorError) {throw _iteratorError;}}}
      } else {
        this._dbIdsToUnhide.set(model, dbIds);
      }
    }

    // Un-hides all objects (using the dbId) per model.
  }, { key: "clearFilter", value: function clearFilter() {
      if (this._dbIdsToUnhide.size === 0) {
        return;
      }

      this._dbIdsToUnhide.forEach(function (dbIds, model) {
        // Handles the case when the model is not visible and the level isolation is deactivated.
        if (!model.visibilityManager) {
          return;
        }

        dbIds.forEach(function (id) {
          model.visibilityManager.setNodeOff(id, false);
        });

        // Only remove the model dbIds if they are successfully set to visible.
        this._dbIdsToUnhide["delete"](model);
      }.bind(this));
    }

    // Un-hides only one model. It's all we can do, as the model.visibilityManager is null,
    // that is we can not call setNodeOff function again
  }, { key: "unhideModel", value: function unhideModel(model) {
      this._dbIdsToUnhide["delete"](model);
    } }, { key: "_hasModelDbIds", value: function _hasModelDbIds(

    modelsDbIds) {

      if (modelsDbIds.size === 0) {
        return false;
      }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {

        for (var _iterator2 = modelsDbIds.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var dbIds = _step2.value;
          if (dbIds && dbIds.length > 0) {
            return true;
          }
        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {_iterator2["return"]();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}

      return false;
    } }, { key: "_getLevelHeightFactor", value: function _getLevelHeightFactor(

    levelHeightFactor) {
      if (levelHeightFactor === undefined) {
        // Return default factor.
        return 0.5;
      }

      if (typeof levelHeightFactor !== 'number') {
        throw new Error('floorFilterData.levelHeightFactor has to be a number');
      }
      if (levelHeightFactor < 0 || levelHeightFactor >= 1) {
        throw new Error('floorFilterData.levelHeightFactor has to be a number between 0-1.');
      }

      return levelHeightFactor;
    }

    // Hides all dbIds in a model that are currently expected to be hidden. 
  }, { key: "reApplyFilter", value: function reApplyFilter(model) {
      var dbIds = this._dbIdsToUnhide.get(model);
      var visMan = model.visibilityManager;
      if (!dbIds || !visMan) {
        return;
      }

      dbIds.forEach(function (id) {
        visMan.setNodeOff(id, true);
      });
    } }, { key: "isVisible", value: function isVisible(

    model, dbId) {
      var dbIds = this._dbIdsToUnhide.get(model);
      return !dbIds || !dbIds.has(dbId);
    } }]);return FloorSelectorFilter;}();


namespace.FloorSelectorFilter = FloorSelectorFilter;

/***/ }),

/***/ "./extensions/AEC/levels/LevelUtils.js":
/*!*********************************************!*\
  !*** ./extensions/AEC/levels/LevelUtils.js ***!
  \*********************************************/
/*! exports provided: transformLevelsByMatrix, transformLevels, modelToLevels, aecModelDataToLevels, chooseMainModel, modelDataOccluders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevelsByMatrix", function() { return transformLevelsByMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformLevels", function() { return transformLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelToLevels", function() { return modelToLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aecModelDataToLevels", function() { return aecModelDataToLevels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseMainModel", function() { return chooseMainModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modelDataOccluders", function() { return modelDataOccluders; });

function getProjectElevation(level) {
  var ext = level.extension;

  if (ext && ext.hasOwnProperty('projectElevation'))
  return ext.projectElevation;

  return level.elevation;
}

function transformLevelsByMatrix(levels, refPointTransformation) {

  var v = new THREE.Vector3();
  var transformByMatrix = function transformByMatrix(value) {
    v.set(0, 0, value);
    v.applyMatrix4(refPointTransformation);
    return v.z;
  };

  levels.forEach(function (currentLevel) {
    currentLevel.zMin = transformByMatrix(currentLevel.zMin);
    currentLevel.zMax = transformByMatrix(currentLevel.zMax);
  });
}


// transform is given as 12 floats
function transformLevels(levels, refPointTransformation) {
  if (!refPointTransformation)
  return;

  // get transform as THREE.Matrix4
  var matrix = Autodesk.Viewing.BubbleNode.readMatrixFromArray12(refPointTransformation);
  transformLevelsByMatrix(levels, matrix);
}

function modelToLevels(model) {

  var bubbleNode = model.getDocumentNode();
  var modelData = bubbleNode.getAecModelData();

  if (!modelData || !modelData.levels || !modelData.levels.length) {
    return [];
  }

  return aecModelDataToLevels(modelData);
}

function aecModelDataToLevels(aecModelData, placementTf) {
  // levels are sorted ascending

  // we have to handle the building story flag of a Revit level
  // filter out all Revit levels which do not have building story set to true
  var filteredLevels = aecModelData.levels.filter(function (l) {
    var ext = l.extension;

    if (!ext)
    return true;

    //So.... if it has no buildingStory property, it's a building story...
    if (!ext.hasOwnProperty('buildingStory'))
    return true;

    return ext.buildingStory;
  });

  var levels = [];

  var count = filteredLevels.length;
  filteredLevels.forEach(function (currentLevel, index) {

    var nextElevation = undefined;
    if (index + 1 < count) {
      nextElevation = getProjectElevation(filteredLevels[index + 1]);
    } else
    {
      // for the topmost floor, we must use its height to determine the next boundary
      var topLevel = filteredLevels[filteredLevels.length - 1];
      var topLevelElevation = getProjectElevation(topLevel);
      nextElevation = topLevelElevation + topLevel.height;
    }

    //Explanation from design-collaboration repo:
    // Hint: the idea to move the level zMin value an inch down is to make sure that the
    // end-user can also see the bottom floor. Otherwise in some cases the floor would just
    // be cut-away by the floor selection. This value was defined after experimenting with
    // several models and maybe needs adjustment in the future.
    var zOffsetHack = 1 / 12;

    levels.push({
      index: levels.length,
      name: currentLevel.name,
      zMin: getProjectElevation(currentLevel) - zOffsetHack,
      zMax: nextElevation,
      guid: currentLevel.guid });

  });

  // If the model is known, use its attached transform. This variant works with any loadOptions. 
  if (placementTf) {
    transformLevelsByMatrix(levels, placementTf);
  } else {
    // If the model is not known, we assume that no zOffset is applied. This is only
    // true when using applyRefPoint=true and a gobalOffset with z=0.
    transformLevels(levels, aecModelData.refPointTransformation);
  }
  return levels;
}

function chooseMainModel(viewer) {

  var models = viewer.impl.modelQueue().getModels();
  var mainModel = null;
  var mainModelSize = -1;
  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();

    if (!bubbleNode)
    return;

    var aecModelData = bubbleNode.getAecModelData();

    if (!aecModelData)
    return;

    if (bubbleNode.data.size > mainModelSize) {
      mainModel = model;
      mainModelSize = bubbleNode.data.size;
    } else if (!bubbleNode.data.size && mainModelSize === -1) {
      mainModel = model;
      mainModelSize = 0;
    }
  });
  return mainModel;
}

function modelDataOccluders(viewer) {

  var models = viewer.impl.modelQueue().getModels();

  var occludersPerModel = new Map();

  models.forEach(function (model) {

    if (model.is2d())
    return;

    var bubbleNode = model.getDocumentNode();
    if (!bubbleNode)
    return;
    var aecModelData = bubbleNode.getAecModelData();
    if (!aecModelData)
    return;

    occludersPerModel.set(model.id, aecModelData.levelOccluderIds);
  });

  return { modelsDbIds: occludersPerModel };
}

/***/ }),

/***/ "./extensions/AEC/levels/LevelsExtension.js":
/*!**************************************************!*\
  !*** ./extensions/AEC/levels/LevelsExtension.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelsExtension; });
/* harmony import */ var _FloorSelector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FloorSelector */ "./extensions/AEC/levels/FloorSelector.js");
/* harmony import */ var _LevelUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LevelUtils */ "./extensions/AEC/levels/LevelUtils.js");
/* harmony import */ var _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/ListPanel */ "./extensions/AEC/ui/ListPanel.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}

var av = Autodesk.Viewing,avu = av.UI;
var namespace = AutodeskNamespace('Autodesk.AEC');
var myExtensionName = 'Autodesk.AEC.LevelsExtension';





// Options:
//   @param {bool} [autoDetectAecModelData = true]
//         Level selection requires data about existing floors. By default (true), these are extracted automatically:
//          - For a single model, we get them by calling getAecModelData() on the document node.
//          - If multiple models with aecModelData are visible, we choose the largest one to define the levels.
//
//         If set to false, an application can (and has to) call setAecModelData() explicitly instead.
var LevelsExtension = /*#__PURE__*/function (_av$Extension) {_inherits(LevelsExtension, _av$Extension);
  function LevelsExtension(viewer, options) {var _this;_classCallCheck(this, LevelsExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(LevelsExtension).call(this, viewer, options));

    _this.container = _this.options.panelUIContainers && _this.options.panelUIContainers.levelsPanel;

    _this._onCameraMoved = _this._onCameraMoved.bind(_assertThisInitialized(_this));
    _this._onMove = undefined;

    _this._subscribedForLocationUpdates = false;
    _this._currentLevel = undefined;return _this;
  }_createClass(LevelsExtension, [{ key: "setOnCameraMove", value: function setOnCameraMove(

    func) {
      if (!this._subscribedForLocationUpdates && func) {
        this.viewer.addEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
        this._subscribedForLocationUpdates = true;
        this._onMove = func;
      } else if (!func) {
        this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
        this._subscribedForLocationUpdates = false;
        this._onMove = null;
        this._currentLevel = null;
      }
    } }, { key: "_onCameraMoved", value: function _onCameraMoved()

    {
      if (!this._onMove) {
        return;
      }
      var currentLevel = this._mapCameraToLevel();

      if (!currentLevel)
      return;

      if (!this._currentLevel || currentLevel.guid !== this._currentLevel.guid) {
        this._currentLevel = currentLevel;
        this._onMove(currentLevel);
      }
    } }, { key: "_mapCameraToLevel", value: function _mapCameraToLevel()

    {
      var floors = this.floorSelector.floorData;
      if (!floors.length) {
        return;
      }

      var currentElevation = this.viewer.impl.camera.position.z;

      if (currentElevation < floors[0].zMin) {
        return floors[0];
      } else
      if (currentElevation > floors[floors.length - 1].zMax) {
        return floors[floors.length - 1];
      } else
      {
        return floors.find(function (f) {return f.zMin <= currentElevation && f.zMax >= currentElevation;});
      }
    } }, { key: "onToolbarCreated", value: function onToolbarCreated()

    {

      if (this.container) {
        //Add our button to the toolbar if host app did not ask to render UI in some other place
        return;
      }

      // Add levelsButton to modelTools. 
      // We can safely assume toolbar to exis, because onToolbarCreated() is only called if 
      // 1. GuiViewer is used and 2. the toolbar is ready.
      var toolbar = this.viewer.getToolbar();
      var modelTools = toolbar.getControl(av.TOOLBAR.MODELTOOLSID);
      if (modelTools) {
        modelTools.addControl(this.levelsButton);
      }
    } }, { key: "_createUI", value: function _createUI()

    {var _this2 = this;

      this.levelsButton = new avu.Button("toolbar-levelsTool");
      this.levelsButton.setToolTip('Levels');
      this.levelsButton.icon.innerHTML = createLevelsIcon();

      this.levelsPanel = new _ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanel"](this.container || this.viewer.container, 'LevelsPanel-' + this.viewer.id, 'Levels');
      this.levelsPanel.setGlobalManager(this.globalManager);

      if (!this.container) {
        // This ensures that the Panel keeps visible within the viewer canvas on resize.
        this.viewer.addPanel && this.viewer.addPanel(this.levelsPanel);
      }


      // Keep button-state consistent when pressing panel close
      this.levelsPanel.addVisibilityListener(function (visible) {
        _this2.levelsButton.setState(visible ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);
      });

      // allow client app to be notified on panel close
      this.levelsPanel.closer.addEventListener('click', function () {
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(false);
        }
      });

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_ENTER, function (event) {

        var levelIndex = event.item.index;

        // Selecting an already selected level again will unselect => i.e. all Floors will be shown.
        // Correspondingly, we trigger rollover highlighting for all floors when hovering over the selected level.
        if (levelIndex === _this2.floorSelector.currentFloor) {
          levelIndex = _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].AllFloors;
        }

        _this2.floorSelector.rollOverFloor(levelIndex);
        _this2.hoveredFloor = levelIndex;
      });

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_MOUSE_LEAVE, function (event) {
        if (_this2.hoveredFloor === event.item.index) {
          _this2.hoveredFloor = undefined;
          _this2.floorSelector.rollOverFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor);
        }
      });

      this.levelsPanel.addEventListener(_ui_ListPanel__WEBPACK_IMPORTED_MODULE_2__["ListPanelEvents"].ITEM_SELECT, function (event) {
        // on item selected
        var levelIndex = event.item.index !== _this2.floorSelector.currentFloor ? event.item.index : undefined;
        _this2.floorSelector.selectFloor(levelIndex, true);
      });

      // Handle hovering over panel
      this.levelsPanel.container.addEventListener("mouseenter", function () {return _this2.floorSelector.enterHoverMode();});
      this.levelsPanel.container.addEventListener("mouseleave", function () {return _this2.floorSelector.exitHoverMode();});

      // Keep selected item in-sync with selected Floor
      this.floorSelector.addEventListener(
      _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].CURRENT_FLOOR_CHANGED,
      function () {return _this2.levelsPanel.updateItemStates();});


      this.levelsPanel.setItemHandlers(
      function (item) {return item.index === _this2.floorSelector.currentFloor;},
      function (item) {return item.text;});


      // Connect levelsButton
      this.levelsButton.onClick = function () {
        var visible = !_this2.levelsPanel.isVisible();
        _this2.levelsPanel.setVisible(visible);

        // allow client app to be notified
        if (_this2.onPanelVisibilityToggled) {
          _this2.onPanelVisibilityToggled(visible);
        }
      };
    }

    // If placementTf is undefined, we use the refPointTransform of aecModelData.
    // Note that this is correct when using applyRefPoint=true and a globalOffset with z=0
    // for the model load options.
  }, { key: "setAecModelData", value: function setAecModelData(aecModelData, placementTf) {

      if (aecModelData !== this.aecModelData) {

        this.aecModelData = aecModelData;

        if (aecModelData) {
          // init level data
          this.floorSelector.floorData = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["aecModelDataToLevels"])(aecModelData, placementTf);
        } else {
          this.floorSelector.floorData = [];
        }

        var levels = this.floorSelector.floorData;
        var items = [];
        for (var i = 0; i < levels.length; i++) {
          var level = levels[i];
          items.push({
            text: level.name,
            index: i });

        }

        // list items in reverse order, because aecModelData levels are sorted by increasing z
        items.reverse();
        this.levelsPanel.setItems(items);

        this._updateOccluderData();
      }
    } }, { key: "_updateOccluderData", value: function _updateOccluderData()

    {
      // Make sure that occluder data is known if a main model is specified
      var occludersPerModel = this.aecModelData ? Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["modelDataOccluders"])(this.viewer) : undefined;
      this.floorSelector.floorFilterData = occludersPerModel;
    } }, { key: "load", value: function load()

    {var _this3 = this;
      this.floorSelector = new _FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer);

      this.updateFloorSelector = function () {
        // auto-detect main model if not disabled
        var autoDetect = _this3.options.autoDetectAecModelData !== false;
        if (autoDetect) {
          var model = Object(_LevelUtils__WEBPACK_IMPORTED_MODULE_1__["chooseMainModel"])(_this3.viewer);
          var bubbleNode = model && model.getDocumentNode();
          var aecModelData = bubbleNode && bubbleNode.getAecModelData();

          // provde placement matrix as well.
          var placementTf = model && model.myData.placementWithOffset;
          _this3.setAecModelData(aecModelData, placementTf);
        }

        _this3._updateOccluderData();

        // Make sure that cutplanes are disabled when in 2d views and reactivated in 3d
        // Todo: Check if we can move the MODEL_ADDED event at the end of addModel, so that we could simply use viewer.is2d here.
        var is3d = _this3.viewer.getVisibleModels().some(function (model) {return model.is3d();});
        _this3.floorSelector.setEnabled(is3d);
      };

      this.viewer.addEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
      this.viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
      this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);

      this._createUI();
      this.updateFloorSelector();

      return true;
    } }, { key: "unload", value: function unload()

    {
      if (!this.container) {
        this.viewer.removePanel && this.viewer.removePanel(this.levelsPanel);
      }
      this.floorSelector.selectFloor(undefined, false);
      this.levelsPanel = null;

      if (this.updateFloorSelector) {
        this.viewer.removeEventListener(av.MODEL_ROOT_LOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this.updateFloorSelector);
        this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this.updateFloorSelector);
        this.updateFloorSelector = null;
      }

      if (this._subscribedForLocationUpdates) {
        this.viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, this._onCameraMoved);
        this._onMove = null;
        this._currentLevel = null;
      }

      this.floorSelector = null;

      return true;
    }

    /**
       * Gets the extension state as a plain object. Invoked automatically by viewer.getState()
       * @param {object} viewerState - Object to inject extension values.
       */ }, { key: "getState", value: function getState(
    viewerState) {
      if (!this.viewer.model || this.viewer.model.is2d()) {
        return;
      }

      var floor = this.floorSelector.currentFloor;
      viewerState.floorGuid = floor ? this.floorSelector.floorData[floor].guid : null;
    } }, { key: "restoreState",

    /**
                                 * Restores the extension state from a given object. Invoked automatically by viewer.restoreState()
                                 * @param {object} viewerState - Viewer state.
                                 * @param {boolean} immediate - Whether the new view is applied with (true) or without transition (false).
                                 * @returns {boolean} True if restore operation was successful.
                                 */value: function restoreState(
    viewerState, immediate) {
      if (viewerState.floorGuid) {
        var floor = this.floorSelector.floorData.find(function (data) {return data.guid === viewerState.floorGuid;});

        if (floor) {
          this.floorSelector.selectFloor(floor.index, false);
        }
      } else {
        this.floorSelector.selectFloor(_FloorSelector__WEBPACK_IMPORTED_MODULE_0__["default"].NoFloor, false);
      }

      return true;
    } }]);return LevelsExtension;}(av.Extension);


var createLevelsIcon = function createLevelsIcon() {
  return [
  '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">',
  '<g stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">',
  '<path d="M4 8 L12 3 L 20 8 L12 13Z"/>',
  '<path d="M4 12 L12 17 L 20 12"/>',
  '<path d="M4 16 L12 21 L 20 16"/>',
  '</g>',
  '</svg>'].
  join('');
};

namespace.LevelsExtension = LevelsExtension; // Makes it easier to get e.g. the version

// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, LevelsExtension);

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.css":
/*!*****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!../../../node_modules/sass-loader/dist/cjs.js!./ListPanel.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/AEC/ui/ListPanel.js":
/*!****************************************!*\
  !*** ./extensions/AEC/ui/ListPanel.js ***!
  \****************************************/
/*! exports provided: ListPanelEvents, ListPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanelEvents", function() { return ListPanelEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListPanel", function() { return ListPanel; });

var av = Autodesk.Viewing;
var avu = Autodesk.Viewing.UI;


var ListPanelEvents = {

  /**
                                * Fired when clicking on an item. (not fired when setting current item per code)
                                *  @property {Object} item  - data item being selected.
                                */
  ITEM_SELECT: 'itemSelect',

  /**
                              * @property {Object} item - data item being selected.
                              */
  ITEM_MOUSE_ENTER: 'itemMouseEnter',
  ITEM_MOUSE_LEAVE: 'itemMouseLeave' };


function ListPanel(parentContainer, id, title, options) {

  avu.DockingPanel.call(this, parentContainer, id, title, options);

  av.EventDispatcher.prototype.apply(this);

  this.container.classList.add('list-panel');
  this.container.dockRight = true;
  this.createScrollContainer({ left: false, heightAdjustment: 65, marginTop: 0 });
}

ListPanel.prototype = Object.create(avu.DockingPanel.prototype);

// @param {Object[]} items - Array order defines display order top-down.
ListPanel.prototype.setItems = function (items) {

  this.buttons = [];
  this.items = items;

  // remove old list
  if (this.listDiv) {
    this.scrollContainer.removeChild(this.listDiv);
  }
  var _document = this.getDocument();
  this.listDiv = _document.createElement('div');
  this.listDiv.classList.add('itemList');

  this.scrollContainer.appendChild(this.listDiv);

  var scope = this;

  var createButton = function createButton(item) {

    var itemText = scope._getItemText ? scope._getItemText(item) : '<no item text>';

    var button = _document.createElement('div');
    button.classList.add('listItem');
    button.item = item;
    button.setAttribute('title', itemText);

    button.addEventListener('click', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_SELECT,
        item: item });

    });
    button.addEventListener('mouseenter', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_ENTER,
        item: item });

    });
    button.addEventListener('mouseleave', function () {
      scope.fireEvent({
        type: ListPanelEvents.ITEM_MOUSE_LEAVE,
        item: item });

    });

    var textSpan = _document.createElement('span');
    textSpan.innerHTML = itemText;
    textSpan.classList.add("text");

    // This container DIV is required to enable proper text fade-out for long texts.
    var textContainerDiv = _document.createElement('div');
    textContainerDiv.classList.add("textContainer");
    textContainerDiv.appendChild(textSpan);
    button.appendChild(textContainerDiv);

    var warnSpan = _document.createElement('span');
    warnSpan.classList.add("list-panel-item-warning");
    button.appendChild(warnSpan);
    button.warnSpan = warnSpan;

    var checkSpan = _document.createElement('span');
    checkSpan.classList.add("icon");
    button.appendChild(checkSpan);

    return button;
  };

  for (var index = 0; index < items.length; index++) {

    var item = items[index];
    var button = createButton(item);

    this.listDiv.appendChild(button);
    this.buttons.push(button);
  }

  this.updateItemStates();
};

ListPanel.prototype.updateItemStates = function () {

  if (!this.buttons) {
    return;
  }
  for (var i = 0; i < this.buttons.length; i++) {

    // set/unset checkmark
    var button = this.buttons[i];
    button.classList.remove("selected");
    if (this._isSelected && this._isSelected(button.item)) {
      button.classList.add("selected");
    }

    // set/unset warning symbol
    var warnText = this._getWarningText && this._getWarningText(button.item);
    button.warnSpan.style.visibility = warnText ? 'visible' : 'hidden';
    button.warnSpan.setAttribute('title', warnText || '');
  }
};

// Set functions to define how to handle each item
//  @param {function(item)} isSelected       - takes a list item (see setItems) and returns true for 'selected state'
//  @param {function(item)} getItemText      - returns the text to be displayed
//  @param {function(item)} [getWarningText] - Optional: Display a warning symbol. Function defines tooltip text.
ListPanel.prototype.setItemHandlers = function (isSelected, getItemText, getWarningText) {
  this._isSelected = isSelected;
  this._getItemText = getItemText;
  this._getWarningText = getWarningText;
  this.updateItemStates();
};

avu.ListPanelEvents = ListPanelEvents;
avu.ListPanel = ListPanel;

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/CanvasBookmark/CanvasBookmark.css ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.canvas-bookmark.adsk-button, .clustered-canvas-bookmark.adsk-button, .declustered-canvas-bookmark.adsk-button {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  border-style: none !important;\n  /* Avoid border on button-hover */\n  color: white;\n  margin: none;\n  padding: 0px;\n  transition: visibility 0.5s, opacity 0.5s;\n  opacity: 0;\n  visibility: hidden; }\n\n.canvas-bookmark.adsk-button {\n  width: 22px;\n  height: 22px; }\n\n.clustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px; }\n\n.declustered-canvas-bookmark.adsk-button {\n  width: 29px;\n  height: 29px;\n  color: lightgrey; }\n\n.canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n\n.clustered-canvas-bookmark.visible {\n  opacity: 1;\n  visibility: visible; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/DropMe/DropMe.css ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".camera-selector {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid #0696D7;\n  border-radius: 50%;\n  transform-origin: bottom center;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1; }\n\n.camera-selector-position {\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  background-color: #0696D7;\n  position: absolute;\n  opacity: 0.8;\n  pointer-events: none;\n  z-index: 1;\n  transform: scale(1, 1);\n  transition: transform 3s ease-in; }\n\n.camera-selector-position--teleporting {\n  transform: scale(0, 0); }\n\n.camera-selector-background {\n  width: 200px;\n  height: 200px;\n  background-color: #0696D7;\n  opacity: 0.2;\n  position: absolute;\n  pointer-events: none;\n  z-index: 0;\n  transform: translate(-100px, -100px);\n  border-radius: 50%; }\n\n/* mimic issues UI guidance for now as it was the only extension, featuring guidance so far */\n.dropme-guidenace-ui {\n  display: flex;\n  position: absolute;\n  left: 50%;\n  top: 20px;\n  padding: 10px 20px;\n  transform: translate(-50%, 0);\n  align-items: center;\n  border: 1px solid #9ec8f6;\n  border-radius: 4px;\n  background-color: #edf5fd;\n  color: #039be5;\n  font-size: 12px;\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.25);\n  opacity: 1;\n  z-index: 999;\n  overflow-y: hidden; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/Minimap3D/Minimap3D.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*\nhttps://stackoverflow.com/questions/27900053/css-transition-with-visibility-not-working\n\nVisibility is an animatable property according to the spec, but transitions on visibility do not work gradually, as one might expect.\nInstead transitions on visibility delay hiding an element. On the other hand making an element visible works immediately.\nThis is as it is defined by the spec (in the case of the default timing function) and as it is implemented in the browsers.\n\n    ==> transition: visibility 0.7s, opacity 0.7s;\n*/\n.minimap3D {\n  width: 0px;\n  height: 0px;\n  right: 10px;\n  top: 10px;\n  position: absolute;\n  transition: visibility 0.7s, opacity 0.7s;\n  opacity: 0;\n  visibility: hidden;\n  background: rgba(255, 255, 255, 0.4);\n  /* For side-by-side mode: Make sure that text selection highlighting is disabled on Minimap. Otherwise, fast dragging of the player will\n       color the whole map in blue */\n  user-select: none; }\n\n.minimapScrollArea {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  /* important for scrolling: the map image contains the whole map but is cropped to the visible area by the parent widget */\n  position: absolute;\n  /* Without this, 'overflow: hidden' has no effect. */ }\n\n/* Show map left-aligned and without margin */\n.minimap3D.side-by-side {\n  right: 0px;\n  top: 0px;\n  box-sizing: border-box;\n  border-right: none;\n  border-left: solid 2px #979797; }\n\n.minimap3D.side-by-side.left-2d-view {\n  border-left: none;\n  border-right: solid 2px #979797;\n  left: 0px; }\n\n.minimap3D.visible {\n  opacity: 1;\n  visibility: visible; }\n\n/* Note that border changes require to update the anchor point in Minimap.js too */\n.player-widget {\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  transition: opacity 0.7s;\n  opacity: 0;\n  z-index: 2; }\n\n.player-frustum {\n  border-left: 20px solid transparent;\n  border-right: 20px solid transparent;\n  border-top: 40px solid #3590e9;\n  border-radius: 50%;\n  opacity: 0.4;\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  transform-origin: bottom center;\n  cursor: crosshair; }\n\n.player-frustum.touch {\n  border-left: 40px solid transparent;\n  border-right: 40px solid transparent;\n  border-top: 80px solid #3590e9; }\n\n.player-widget.visible {\n  opacity: 0.7; }\n\n.player-position-fill {\n  width: 10px;\n  height: 10px;\n  /* Move circle center to the tip of the frustum shape */\n  left: 15px;\n  /* = (playerFrustum.border-left - width/2)  */\n  top: 35px;\n  /* = (playerFrustum.border-top  - height/2) */\n  position: absolute;\n  border-radius: 50%;\n  background-color: #3590e9;\n  box-shadow: 0px 0px 0px 2px #fff; }\n\n.player-position-fill.touch {\n  /* Move circle center to the tip of the frustum shape */\n  left: 35px;\n  /* = (playerFrustum.border-left - width/2)  */\n  top: 75px;\n  /* = (playerFrustum.border-top  - height/2) */ }\n\n.player-position-hitarea {\n  position: absolute;\n  width: 15px;\n  height: 15px;\n  left: 5px;\n  /* player-position-fill.width/2 */\n  top: 5px;\n  /* player-position-fill.height/2 */\n  border-radius: 50px;\n  transform: translate(-50%, -50%);\n  cursor: grab; }\n\n.player-position-hitarea.touch {\n  width: 50px;\n  height: 50px; }\n\n/* Container for floor image + floor name */\n.mapContainer {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  opacity: 1; }\n\n.mapImage {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  pointer-events: none; }\n\n/* Display floor name at top left */\n.floorNameLabel {\n  z-index: 2;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  opacity: 0.99;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin: 4px;\n  border-radius: 5px; }\n\n.floorNameLabel.dark {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(50, 50, 50, 0.8); }\n\n.floorNameLabel.light {\n  margin-top: 10px;\n  left: 50%;\n  transform: translate(-50%);\n  border-radius: 28px;\n  background-color: rgba(255, 255, 255, 0.85);\n  box-shadow: none; }\n\n.floorText {\n  margin: 5px 5px 5px 5px;\n  color: black;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden; }\n\n.floorText.dark {\n  padding: 0px 15px;\n  color: #FFFFFF;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n.floorText.light {\n  padding: 0px 15px;\n  color: #000;\n  font-family: \"Artifakt Element\", Helvetica, Arial;\n  font-size: 14px; }\n\n/* Div with text and progressbar - replaces the map image if map computation is running */\n.minimap-placeholder {\n  left: 0px;\n  top: 0px;\n  position: absolute;\n  background-color: rgba(255, 255, 255, 0.5);\n  opacity: 1; }\n\n.minimap-progressWidget {\n  transform: translate(0, -50%);\n  left: 0px;\n  top: 50%;\n  position: relative;\n  height: fit-content;\n  width: calc(100% - 60px);\n  margin-left: 30px;\n  margin-right: 30px; }\n\n.minimap-progressText {\n  color: black;\n  text-align: left;\n  position: relative; }\n\n.minimap-progress {\n  z-index: 10;\n  width: 100%; }\n\n.map-button-bar {\n  z-Index: 2;\n  right: 0px;\n  top: 0px;\n  position: absolute;\n  right: 100%;\n  /* Dock left to mapWidget */\n  display: flex;\n  flex-direction: column;\n  background-color: whitesmoke;\n  box-shadow: 1px 3px 10px 0 rgba(0, 0, 0, 0.5);\n  margin-right: 4px;\n  margin-top: 0px;\n  /* Toolbar is vertically aligned to the upper mapWidget boundary. This is okay, because the mapWidget already has some margin from the canvas boundary. */\n  border-radius: 5px; }\n\n/* In side-by-side, the upper mapWidget edge is matched with the upper canvas edge. So, we add some marigin - otherwise the toolbar would be \"glued\" to the upper canvas edge. */\n.map-button-bar.side-by-side {\n  margin-top: 4px; }\n\n.map-button-bar.side-by-side.left-2d-view {\n  right: 0px; }\n\n.sheetmap-thumbnail {\n  position: absolute;\n  overflow: hidden; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/AEC/ui/ListPanel.css ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".list-panel {\n  width: 260px;\n  min-width: 260px;\n  height: 260px;\n  min-height: 260px;\n  top: 180px;\n  left: 220px;\n  border-color: transparent; }\n\n.list-panel .itemList {\n  width: 100%;\n  display: flex;\n  flex-direction: column; }\n\n.list-panel .listItem {\n  display: flex;\n  justify-content: space-between;\n  text-align: left;\n  line-height: 35px;\n  background-color: rgba(0, 0, 0, 0);\n  border-style: none;\n  font-family: \"ArtifaktElement\", \"Helvetica Neue\", \"Segoe UI Semilight\", sans-serif;\n  padding: 0 15px; }\n\n.adsk-viewing-viewer.dark-theme .listItem {\n  color: #f3f7fb; }\n\n.adsk-viewing-viewer.light-theme .list-panel .listItem:hover {\n  background-color: rgba(10, 19, 28, 0.2); }\n\n.adsk-viewing-viewer.dark-theme .list-panel .listItem:hover {\n  background-color: #4a555b; }\n\n.list-panel .listItem:focus {\n  outline: none; }\n\n.list-panel .listItem.selected {\n  color: deepskyblue;\n  border-style: none; }\n\n.list-panel .listItem .textContainer {\n  -webkit-mask-image: linear-gradient(to left, transparent, black 1em);\n  mask-image: linear-gradient(to left, transparent, black 1em);\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%; }\n\n.list-panel .listItem .icon {\n  width: 24px; }\n\n.list-panel .listItem.selected .icon::before {\n  content: '\\2713';\n  margin-left: 8px; }\n\n.list-panel-item-warning {\n  background-image: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScyNCcgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDggOCc+PHBhdGggZmlsbD0nIzZiNzg3ZicgZD0nTTMuMDkgMGMtLjA2IDAtLjEuMDQtLjEzLjA5bC0yLjk0IDYuODFjLS4wMi4wNS0uMDMuMTMtLjAzLjE5di44MWMwIC4wNS4wNC4wOS4wOS4wOWg2LjgxYy4wNSAwIC4wOS0uMDQuMDktLjA5di0uODFjMC0uMDUtLjAxLS4xNC0uMDMtLjE5bC0yLjk0LTYuODFjLS4wMi0uMDUtLjA3LS4wOS0uMTMtLjA5aC0uODF6bS0uMDkgM2gxdjJoLTF2LTJ6bTAgM2gxdjFoLTF2LTF6JyAvPjwvc3ZnPg==\");\n  width: 24px;\n  height: 24px;\n  margin-left: auto;\n  margin-top: auto;\n  margin-bottom: auto; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=AEC.js.map