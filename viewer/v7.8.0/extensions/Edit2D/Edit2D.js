/*!
 * LMV v7.8.0
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Edit2D =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Edit2D/Edit2D.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Edit2D/Actions.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Actions.js ***!
  \**************************************/
/*! exports provided: Actions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return Actions; });
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.
//
// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. 
// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)
var
Action = /*#__PURE__*/function () {
  function Action(layer) {_classCallCheck(this, Action);
    this.layer = layer;
  }_createClass(Action, [{ key: "undo", value: function undo()

    {
      throw new Error('Abstract method invoked');
    } }, { key: "redo", value: function redo()

    {
      throw new Error('Abstract method invoked');
    } }]);return Action;}();var


AddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);
  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddShape).call(this, layer));
    _this.shape = shape;return _this;
  }_createClass(AddShape, [{ key: "undo", value: function undo()

    {
      this.layer.removeShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.addShape(this.shape);
    } }]);return AddShape;}(Action);var


AddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);

  // @param {Shape[]} shapes
  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddShapes).call(this, layer));
    _this2.shapes = shapes;return _this2;
  }_createClass(AddShapes, [{ key: "undo", value: function undo()

    {var _this3 = this;
      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this4 = this;
      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});
    } }]);return AddShapes;}(Action);var


MoveShape = /*#__PURE__*/function (_Action3) {_inherits(MoveShape, _Action3);
  function MoveShape(layer, shape, dx, dy) {var _this5;_classCallCheck(this, MoveShape);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MoveShape).call(this, layer));
    _this5.shape = shape;
    _this5.delta = { x: dx, y: dy };

    // Note that transforming back and forth is not always exactly 1:1. 
    _this5.beforeState = _this5.shape.clone();
    _this5.afterState = _this5.shape.clone();

    _this5.afterState.move(dx, dy);return _this5;
  }_createClass(MoveShape, [{ key: "undo", value: function undo()

    {
      this.shape.copy(this.beforeState);
    } }, { key: "redo", value: function redo()

    {
      this.shape.copy(this.afterState);
    } }]);return MoveShape;}(Action);var


RemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);
  function RemoveShape(layer, shape) {var _this6;_classCallCheck(this, RemoveShape);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShape).call(this, layer));
    _this6.shape = shape;return _this6;
  }_createClass(RemoveShape, [{ key: "undo", value: function undo()

    {
      this.layer.addShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.removeShape(this.shape);
    } }]);return RemoveShape;}(Action);var



RemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);
  function RemoveShapes(layer, shapes) {var _this7;_classCallCheck(this, RemoveShapes);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShapes).call(this, layer));
    _this7.shapes = shapes;return _this7;
  }_createClass(RemoveShapes, [{ key: "undo", value: function undo()

    {var _this8 = this;
      this.shapes.forEach(function (s) {return _this8.layer.addShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this9 = this;
      this.shapes.forEach(function (s) {return _this9.layer.removeShape(s);});
    } }]);return RemoveShapes;}(Action);var


AddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);
  function AddVertex(layer, poly, vIndex, p) {var _this10;_classCallCheck(this, AddVertex);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(AddVertex).call(this, layer));
    _this10.poly = poly;
    _this10.vIndex = vIndex;
    _this10.point = p.clone();return _this10;
  }_createClass(AddVertex, [{ key: "undo", value: function undo()

    {
      this.poly.removePoint(this.vIndex);
    } }, { key: "redo", value: function redo()

    {
      this.poly.insertPoint(this.vIndex, this.point);
    } }]);return AddVertex;}(Action);


// Only for polygons and polylines
var MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);
  function MoveVertex(layer, poly, vIndex, newPos) {var _this11;_classCallCheck(this, MoveVertex);
    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(MoveVertex).call(this, layer));
    _this11.poly = poly;
    _this11.vIndex = vIndex;
    _this11.posBefore = poly.getPoint(vIndex);
    _this11.posAfter = newPos.clone();return _this11;
  }_createClass(MoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.vIndex, this.posBefore.x, this.posBefore.y);
    } }, { key: "redo", value: function redo()
    {
      this.poly.updatePoint(this.vIndex, this.posAfter.x, this.posAfter.y);
    } }]);return MoveVertex;}(Action);var


RemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);
  function RemoveVertex(layer, poly, vIndex) {var _this12;_classCallCheck(this, RemoveVertex);
    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveVertex).call(this, layer));
    _this12.poly = poly;
    _this12.vIndex = vIndex;
    _this12.point = poly.getPoint(vIndex);return _this12;
  }_createClass(RemoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.insertPoint(this.vIndex, this.point);
    } }, { key: "redo", value: function redo()

    {
      this.poly.removePoint(this.vIndex);
    } }]);return RemoveVertex;}(Action);var


MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);
  function MoveEdge(layer, poly, edgeIndex, newPosA, newPosB) {var _this13;_classCallCheck(this, MoveEdge);
    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(MoveEdge).call(this, layer));
    _this13.poly = poly;

    // store edge indices
    _this13.ia = edgeIndex;
    _this13.ib = (edgeIndex + 1) % poly.length;

    // get edge 
    var a = poly.getPoint(_this13.ia);
    var b = poly.getPoint(_this13.ib);

    _this13.edgeBefore = {
      a: a,
      b: b };

    _this13.edgeAfter = {
      a: newPosA.clone(),
      b: newPosB.clone() };return _this13;

  }_createClass(MoveEdge, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.ia, this.edgeBefore.a.x, this.edgeBefore.a.y);
      this.poly.updatePoint(this.ib, this.edgeBefore.b.x, this.edgeBefore.b.y);
    } }, { key: "redo", value: function redo()

    {
      this.poly.updatePoint(this.ia, this.edgeAfter.a.x, this.edgeAfter.a.y);
      this.poly.updatePoint(this.ib, this.edgeAfter.b.x, this.edgeAfter.b.y);
    } }]);return MoveEdge;}(Action);


var Actions = {
  Action: Action,
  AddShape: AddShape,
  AddShapes: AddShapes,
  MoveShape: MoveShape,
  RemoveShape: RemoveShape,
  RemoveShapes: RemoveShapes,
  AddVertex: AddVertex,
  MoveVertex: MoveVertex,
  RemoveVertex: RemoveVertex,
  MoveEdge: MoveEdge };

/***/ }),

/***/ "./extensions/Edit2D/AngleSnapper.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleSnapper.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleSnapper; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. 
//
// If pMov is the vertex being moved, the snapping behavior includes:
//
//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.
//
//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.
//
//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.
//
//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.
//

// A SnapLine is a line that we consider for snapping. 
var SnapLine = /*#__PURE__*/function () {

  function SnapLine(a, b) {_classCallCheck(this, SnapLine);

    // start and end point
    this.a = a.clone();
    this.b = b.clone();

    // normalized edge direction
    this.dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);
  }

  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.
  // @returns {bool} true on success
  _createClass(SnapLine, [{ key: "intersect", value: function intersect(line, outPoint) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(this.a, this.dir, line.a, line.dir, outPoint);
    }

    // project point to SnapLine
  }, { key: "snapToLine", value: function snapToLine(p) {
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(p, this.a, this.dir);
    }

    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.
  }, { key: "isUsable", value: function isUsable(p, snapRadius) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointLineDistance(p, this.a, this.dir) < snapRadius;
    }

    // Checks if a SnapLine is (approx.) identical with another one
  }, { key: "isEqual", value: function isEqual(snapLine, precision) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].collinear(this.a, this.dir, snapLine.a, snapLine.dir, precision);
    } }]);return SnapLine;}();
;

// Snap position based on 1 or 2 SnapLines.
//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place
//  @param {SnapLine} snapLine1   - First line to snap to
//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.
// Preconditions:
//  - SnapLine1: Is close to pos (wrt. to snap tolerance)
//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  
var snapToLines = function snapToLines(pos, snapLine1, snapLine2) {

  // No snaplines => keep original pos
  if (!snapLine1 && !snapLine2) {
    return;
  }

  // If only SnapLine1 exists
  if (!snapLine2) {
    // project pos to snapLine1
    snapLine1.snapToLine(pos);
    return;
  }

  // If only snapLine2 exists
  if (!snapLine1) {
    // project pos to snapLine2
    snapLine2.snapToLine(pos);
    return;
  }

  // Snap pos to line intersection.
  snapLine1.intersect(snapLine2, pos);
};

// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.
// Accepts negative indices up to -this.poly.length.
var getPointMod = function getPointMod(poly, index) {
  index = (index + poly.length) % poly.length;
  return poly.getPoint(index);
};

// Returns an array of SnapLines used to align with each edge of the given polygon.
//  @param {Polygon} poly
//  @param {vIndex}  vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.
var findSnapLines = function findSnapLines(poly, vIndex) {

  // tmp vectors
  var normal = new THREE.Vector2();
  var center = new THREE.Vector2();
  var pEnd = new THREE.Vector2();

  var snapLines = [];

  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.
  // and adds it to snapLines.
  // Generated snapLines are:
  //  - Line spanned by the edge
  //  - Orthogonal lines at start, center, and end point.
  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {

    // add line spanned by the edge
    snapLines.push(new SnapLine(a, b));

    // get edge normal and center point
    normal = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b, normal));
    center = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeCenter(a, b, center);

    // add orthogonal line add edge start
    pEnd.copy(a).add(normal); // pEnd = p1 + normal
    snapLines.push(new SnapLine(a, pEnd));

    // add orthogonal line at edge center
    pEnd.copy(center).add(normal); // pEnd = center + normal
    snapLines.push(new SnapLine(center, pEnd));

    // add orthogonal line at edge end
    pEnd.copy(b).add(normal); // pEnd = p2 + normal
    snapLines.push(new SnapLine(b, pEnd));
  };

  poly.enumEdges(function (a, b, ia, ib) {

    // Exclude edges containing the moved vertex: These edges are not fixed yet and should not
    // be used for alignment.
    if (ia == vIndex || ib == vIndex) {
      return;
    }

    // skip edge if degenerate
    if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(a, b)) {
      return;
    }

    addEdgeSnapLines(a, b);
  });
  return snapLines;
};

// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.
// A candidate is only suitable if...
//  1. The intersection with snapLine1 is within snapping tolerance
//  2. The angle formed with snapLine1 is as closer to 90Â° than all other candidates. This makes sure that we rather 
//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.
// 
//  @param {SnapLine} candidate       - SnapLine candidates to be compared    
//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)
//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.
//  @param {Vector2}  pos             - position to be snapped
//  @param {number}   snapRadius      - in layer coords
//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate
var checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {

  // If candidate does not intersect snapLine1, we cannot use it.
  var pIntersect = new THREE.Vector2();
  if (!snapLine1.intersect(candidate, pIntersect)) {
    return bestCandidate;
  }

  // If intersection point is outside snapRadius, discard candidate
  if (pIntersect.distanceTo(pos) > snapRadius) {
    return bestCandidate;
  }

  // If there is no competitor, the candidate made it.
  if (!bestCandidate) {
    return candidate;
  }

  // Check which of the candidates is "less parallel" to snapLine1
  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));
  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));
  return dp1 > dp2 ? candidate : bestCandidate;
};

var xAxis = new THREE.Vector2(1, 0);

var av = Autodesk.Viewing;
// AngleSnapper helps to draw right angles, parallel lines etc.
var AngleSnapper = /*#__PURE__*/function () {

  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);
    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.
    this.poly = null;

    // Index of the vertex in this.poly that is beging moved.
    this.vIndex = -1;

    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle
    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];

    // We consider an angle "close to" another one if they differ by this value or less.
    this.snapAngleTolerance = 2; // in degrees

    // Allow snapping to lines within x pixels.
    this.snapRadius = 10;

    this.gizmoLayer = gizmoLayer;
    this.setGlobalManager(gizmoLayer.globalManager);

    // reused tmp points
    this.movedPoint = new THREE.Vector2(); // the vertex being moved
    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint
    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint

    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint
    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis

    // Array of snapLines to align a vertex position with other edges
    this.edgeSnapLines = [];

    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.
    this.snapLine1 = null;
    this.snapLine2 = null;

    // Optional: External line constraint. This is used if we already snapped to a line geometry and
    //           want to combine the snap with angle snapping.
    this.snapLineExt = null;

    // Gizmos to display the lines considered for snapping
    this.snapLineStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineColor: 'rgb(255, 0, 0)',
      lineWidth: 1.0,
      lineStyle: 10 });

    this.snapLineGizmos = [];
    this.snapLineGizmosUsed = 0;
  }_createClass(AngleSnapper, [{ key: "onSetGlobalManager", value: function onSetGlobalManager(

    globalManager) {
      this.globalManager = globalManager;
      this.snapLineGizmos.forEach(function (g) {return g.setGloblaManager(globalManager);});
    } }, { key: "acquireSnapLineGizmo", value: function acquireSnapLineGizmo()

    {
      var gizmo = this.snapLineGizmos[this.snapLineGizmosUsed];
      if (!gizmo) {
        // Create new line gizmo
        gizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
        gizmo.setGlobalManager(this.globalManager);
        this.snapLineGizmos[this.snapLineGizmosUsed] = gizmo;
      }
      this.snapLineGizmosUsed++;
      return gizmo;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {var _this = this;
      var removeGizmo = function removeGizmo(g) {return _this.gizmoLayer.removeShape(g);};
      this.snapLineGizmos.forEach(removeGizmo);
      this.snapLineGizmosUsed = 0;
    }

    // Configures snapping to align to edges of the given polygon/polyline
    //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.
    //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.
  }, { key: "startSnapping", value: function startSnapping(poly, vIndex) {
      this.poly = poly;
      this.vIndex = vIndex;

      // precompute snapLines for alignment. These don't change while moving a vertex.
      this.edgeSnapLines = findSnapLines(poly, vIndex);
    } }, { key: "stopSnapping", value: function stopSnapping()

    {

      this.poly = null;
      this.vIndex = -1;

      // Discard any outdated results and hide gizmos
      this.snapLine1 = null;
      this.snapLine2 = null;
      this.clearSnappingGizmos();
    }

    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when
    // snapping while snapping is bypassed.
  }, { key: "clearSnappingResult", value: function clearSnappingResult() {
      this.snapLine1 = null;
      this.snapLine2 = null;
    } }, { key: "getPrevSnapLine",





    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the previous edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
    value: function getPrevSnapLine(pMov) {

      // Get vertices one and two indices before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1);
      var pPrev2 = getPointMod(this.poly, this.vIndex - 2);

      // Check angle between (pPrev, pMov) and its predecessor edge (pPrev2, pPrev)
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pPrev2, pPrev);
      return this.computeAngleSnapLine(pMov, pPrev, alignAxis);
    }

    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the next edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
  }, { key: "getNextSnapLine", value: function getNextSnapLine(pMov) {

      // When moving one of the last two vertices of a polyline, there is actually no "next edge", because start and end
      // vertex are not connected. Therefore, we skip snapping to "next edge" for this case.
      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.length - 2;
      if (ignoreNextEdge) {
        return null;
      }

      var pNext = getPointMod(this.poly, this.vIndex + 1);
      var pNext2 = getPointMod(this.poly, this.vIndex + 2);

      // Snap to angle wrt. to next edge: (only for polygons)
      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pNext, pNext2, alignAxis);
      return this.computeAngleSnapLine(pMov, pNext, alignAxis);
    }

    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved
    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.
    //  @param {Vector2} pMov - Position to be snapped
    //  @param {Object}  [lineConstraint] - Optional: External line-constraint {a,b}. If specified, we only allow snapping to
    //                                                intersections with angle snapLines and the line (lineConstraint.a, lineConstraint.b).
  }, { key: "snapToAngle", value: function snapToAngle(pMov, lineConstraint) {var _this2 = this;

      // Reset the two lines that we consider for snapping.
      this.snapLine1 = null;
      this.snapLine2 = null;

      // Create snapLine from external line constraint (if specified)
      this.snapLineExt = lineConstraint && new SnapLine(lineConstraint.a, lineConstraint.b);

      if (!this.active || this.poly.length <= 1) {
        return;
      }

      // Get point before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1);

      // If we just have a single edge, we can only snap to angles relative to x-axis
      var isFirstEdge = this.poly.length == 2;
      if (isFirstEdge) {
        // Get closest angle-snap line relative to mainAxis (or null if no snapAngle is close enough)
        var snapAxis = this.computeAngleSnapLine(pMov, pPrev, xAxis);

        if (snapAxis && this.snapLineExt) {
          // If an external line constraint is set, snapAxis can only be considered as a secondary snap.
          // This means, we can only consider if it intersects with the costraint line and the intersection is close to pMov
          this.snapLine1 = checkSecondSnapCandidate(snapAxis, null, this.snapLineExt, pMov, snapRadiusLC);
        } else {
          // No other constraints. Just use the snapAxis (or no axis at all if snapAxis is null)
          this.snapLine1 = snapAxis;
        }

        snapToLines(pMov, this.snapLine1, this.snapLineExt);
        return;
      }

      var prevSnapLine = this.getPrevSnapLine(pMov);
      var nextSnapLine = this.getNextSnapLine(pMov);

      // get snapRadius in layer-coords. This is the maximum distance that we allow
      // between mouse pos and the final snap position that we obtain by projecting
      // to a SnapLine or by intersecting two SnapLines.
      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();

      // Filter to lines that are close enough to pMov
      var snapLineUsable = function snapLineUsable(snapLine) {

        if (!snapLine) {
          return false;
        }

        if (_this2.snapLineExt) {
          // Consider line-constraint: Only accept snapLine if...
          //  1. ...it intersects constraint line
          //  2. ...intersection point is within snapRadius.
          return Boolean(checkSecondSnapCandidate(snapLine, null, _this2.snapLineExt, pMov, snapRadiusLC));
        }

        // No constraint: Accept any snapLines within snapRadius
        return snapLine.isUsable(pMov, snapRadiusLC);
      };

      var candidates = this.edgeSnapLines.filter(snapLineUsable);

      // Reject prevSnapLine/nextSnapLine if they are not usable
      prevSnapLine = snapLineUsable(prevSnapLine) && prevSnapLine;
      nextSnapLine = snapLineUsable(nextSnapLine) && nextSnapLine;

      // choose first snapLine
      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];

      // Stop here if there is no snapping candidate at all
      if (!this.snapLine1) {
        return;
      }

      // If we have an external line constraint, we can only choose a single snapLine, because we already
      // have to intersect it with the external constraint line.
      if (this.snapLineExt) {
        return snapToLines(pMov, this.snapLine1, this.snapLineExt);
      }

      // If prev and next edge allow angle snapping, check if we can snap to both
      if (prevSnapLine && nextSnapLine) {
        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);
      }

      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,
      // check if we can snap to another edge to be aligned with other edges.
      if (!this.snapLine2) {
        for (var i = 0; i < candidates.length; i++) {
          var c = candidates[i];
          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);
        }
      }

      // We selected one or two SnapLines. Now, use them to decide snapped position
      return snapToLines(pMov, this.snapLine1, this.snapLine2);
    } }, { key: "isSnapped", value: function isSnapped()

    {
      return Boolean(this.snapLine1 || this.snapLine2);
    } }, { key: "updateSnapLineGizmos", value: function updateSnapLineGizmos(

    snappedPos) {var _this3 = this;

      // First, clear any outdated gizmos
      this.clearSnappingGizmos();

      if (!this.poly) {
        return;
      }

      // Collect all snapLines that we want to display
      //
      // Note that we don't just want to indicate SnapLines that actively affected the position,
      // but also the "accidentally" matched ones. E.g., if we snapped to a geometry intersection,
      // the actual snapping was not affected by angle snapping, but the resulting position may still
      // match with angle snapLines as well.
      var snapLinesToShow = [];

      // We consider the snapped position p to be "on a snapLine L" if the distance d(p,L) is within the tolerance below.
      var tolerance = 0.0001;
      var shouldBeShown = function shouldBeShown(sl) {return sl && sl.isUsable(snappedPos, tolerance);}; // Decides whether a SnapLine should be displayed

      // If we only have a single edge, angle snapping is only possible wrt. to main axes
      var isFirstEdge = this.poly.length == 2;

      // Collect SnapLines to display
      if (isFirstEdge) {
        // Just a single edge: Only snap if this first edge forms a snapping angle with x- or y-axis.
        var pPrev = getPointMod(this.poly, this.vIndex - 1);
        var snapAxis = this.computeAngleSnapLine(snappedPos, pPrev, xAxis);

        // Display snapAxis if the p is on this line
        if (snapAxis && shouldBeShown(snapAxis)) {
          snapLinesToShow.push(snapAxis);
        }
      } else {
        // Consider all edge snaplines that contain pSnappedPos
        snapLinesToShow = this.edgeSnapLines.filter(shouldBeShown);

        // Consider angles to previous and next edge
        var prevSnapLine = this.getPrevSnapLine(snappedPos);
        var nextSnapLine = this.getNextSnapLine(snappedPos);
        shouldBeShown(prevSnapLine) && snapLinesToShow.push(prevSnapLine);
        shouldBeShown(nextSnapLine) && snapLinesToShow.push(nextSnapLine);
      }

      // Eliminate duplicates: If a SnapLine is collinear with another one, displaying it would just cause artifacts.
      // Note: This is a brute-force n^2 loop. The number of SnapLines to display is usually small, so that this shouldn't be a problem.
      var isRelevant = function isRelevant(sl, index) {
        // Check if sl is a duplicate of any previous SnapLine
        var isDuplicate = false;
        for (var i = 0; i < index; i++) {
          var sl2 = snapLinesToShow[i];
          if (sl.isEqual(sl2, tolerance)) {
            isDuplicate = true;
            break;
          }
        }
        return !isDuplicate;
      };
      snapLinesToShow = snapLinesToShow.filter(isRelevant);

      // A SnapLine indicator is constructed as follows:
      //  - It starts at the snapLine start point, which "explains where the SnapLine comes from". 
      //    This may be start/center/end of another edge.
      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)
      //  - It is enlarged to overshoot pMov 

      // Get diagonal of the whole document - we choose this as line length to make sure that 
      // the line doesn't end somewhere within the screen.
      var w = this.gizmoLayer.viewport.width;
      var h = this.gizmoLayer.viewport.height;
      var diag = Math.sqrt(w * w + h * h);

      var showSnapLine = function showSnapLine(line, gizmo) {
        if (!line) {
          return;
        }

        var a = line.a;

        // Choose direction so that it points towards moved vertex
        //const dir = snappedPos.clone().sub(a).normalize();

        // Let line start at a, point towards dir, and be long enough to leave screen
        gizmo.makeLine(
        a.x - diag * line.dir.x,
        a.y - diag * line.dir.y,
        a.x + diag * line.dir.x,
        a.y + diag * line.dir.y);

        _this3.gizmoLayer.addShape(gizmo);
      };

      // Add lineGizmo for each SnapLine to be displayed
      for (var i = 0; i < snapLinesToShow.length; i++) {
        var snapLine = snapLinesToShow[i];
        var gizmo = this.acquireSnapLineGizmo();
        showSnapLine(snapLine, gizmo);
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.clearSnapping();
    }

    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.
    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.
    //  @param {Vector2} p              - vertex being moved
    //  @param {Vector2} pPrev          - vertex connected to p
    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.
  }, { key: "computeAngleSnapLine", value: function computeAngleSnapLine(p, pPrev, alignAxis) {

      // Don't try angle snapping with degenerated edges
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(pPrev, p)) {
        return null;
      }

      // get direction of new edge (ending at pMov)
      var edgeDir = p.clone().sub(pPrev);

      // Compute angle between new edge and alignment direction
      var angle = THREE.Math.radToDeg(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(edgeDir, alignAxis));

      // Check if angle matches with any index in snapAngles array
      var snapIndex = -1;
      for (var i = 0; i < this.snapAngles.length; i++) {
        var _snapAngle = this.snapAngles[i];

        var dif = Math.abs(_snapAngle - angle);
        if (dif < this.snapAngleTolerance) {
          snapIndex = i;
          break;
        }
      }

      // Stop here if no snapAngle is found
      if (snapIndex == -1) {
        return null;
      }

      // Rotate alignment axis by selected snapAngle
      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);
      var snapDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].rotateAround(alignAxis.clone(), snapAngle);

      // scale snapLine direction to the same length as (pPrev, p)
      var dist = pPrev.distanceTo(p);
      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);

      // Return snapline from pPrev pointing towards snapped direction
      return new SnapLine(pPrev, snapLineEnd);
    } }, { key: "active", get: function get() {return this.poly;} }]);return AngleSnapper;}();


av.GlobalManagerMixin.call(AngleSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/CanvasGizmo.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/CanvasGizmo.js ***!
  \******************************************/
/*! exports provided: AlignX, AlignY, CanvasGizmoBase, CanvasGizmo, ShapeLabel, LengthLabel, AreaLabel, EdgeGizmo, EdgeMoveGizmo, EdgeLabel, VertexGizmo, LabelFilter, DefaultLabelFilter, LabelStyleRule, FadeOutStyleRule, ShapeLabelRule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignX", function() { return AlignX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignY", function() { return AlignY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmoBase", function() { return CanvasGizmoBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmo", function() { return CanvasGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabel", function() { return ShapeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LengthLabel", function() { return LengthLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLabel", function() { return AreaLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeGizmo", function() { return EdgeGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeMoveGizmo", function() { return EdgeMoveGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeLabel", function() { return EdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexGizmo", function() { return VertexGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelFilter", function() { return LabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLabelFilter", function() { return DefaultLabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelStyleRule", function() { return LabelStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FadeOutStyleRule", function() { return FadeOutStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabelRule", function() { return ShapeLabelRule; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var AlignX = {
  Left: 1,
  Center: 2,
  Right: 3 };


var AlignY = {
  Top: 1,
  Center: 2,
  Bottom: 3 };


var av = Autodesk.Viewing;

// Base class for any gizmo that needs to be synchronized with the shapes of an EditLayer.
var CanvasGizmoBase = /*#__PURE__*/function () {
  function CanvasGizmoBase() {_classCallCheck(this, CanvasGizmoBase);}

  // Called whenever the layer or camera changes.
  _createClass(CanvasGizmoBase, [{ key: "update", value: function update() {} }]);return CanvasGizmoBase;}();


av.GlobalManagerMixin.call(CanvasGizmoBase.prototype);

// A CanvasGizmo is an html div anchored at a position in layer-coords
var CanvasGizmo = /*#__PURE__*/function (_CanvasGizmoBase) {_inherits(CanvasGizmo, _CanvasGizmoBase);
  function CanvasGizmo(layer) {var _this;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, CanvasGizmo);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasGizmo).call(this));

    _this.layer = layer;
    _this.setGlobalManager(layer.globalManager);

    // position in layer-coords. The transform origin of the div will appear at this position.
    _this.layerPos = new THREE.Vector2();

    // position in canvas-coords (updated based on this.layerPos and camera)
    _this.canvasPos = new THREE.Vector2();

    // html content to be shown
    var _document = _this.getDocument();
    _this.container = _document.createElement('div');

    // Make sure that label is displayed on top of the canvas and not "pushed away" by it.
    _this.container.style.position = 'absolute';

    // Rotate around gizmo center
    _this.container.style.transformOrigin = '50% 50%';

    // Show immediately if wanted
    _this.visible = false;

    _this.alignX = AlignX.Center;
    _this.alignY = AlignY.Center;

    // Clockwise rotation angle in degrees. Rotates around center.
    _this.angle = 0;

    if (visible) {
      _this.setVisible(true, false);
    }

    // Allow checking if the mouse is currently on this gizmo
    _this.isUnderMouse = false;
    _this.container.addEventListener('mouseenter', function () {return _this.isUnderMouse = true;});
    _this.container.addEventListener('mouseleave', function () {return _this.isUnderMouse = false;});return _this;
  }_createClass(CanvasGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
    } }, { key: "setVisible", value: function setVisible(

    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (visible == this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:
        //       ToolController listens to events on canvasWrap. Therefore, if we would add
        //       it to viewer.container, all mouse events captured would never reach the ToolController
        //       no matter whether the gizmo handles them or not.
        this.layer.viewer.canvasWrap.appendChild(this.container);
        this.layer.addCanvasGizmo(this);

        // Make sure that position is correct
        if (autoUpdate) {
          this.update();
        }
      } else
      {
        this.layer.viewer.canvasWrap.removeChild(this.container);
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "setAlignX", value: function setAlignX(

    alignX) {
      this.alignX = alignX;
      this.update();
    } }, { key: "setAlignY", value: function setAlignY(

    alignY) {
      this.alignY = alignY;
      this.update();
    }

    // @param {number} angle - Clockwise angle in degrees
    // 
    // Note: Do not use 'position:absolute' in child html elements.
    //       Otherwise, the content box will be empty and it will not rotate around anymore.
  }, { key: "setRotation", value: function setRotation(angle) {
      this.angle = angle;
      this.update();
    } }, { key: "update", value: function update()

    {
      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));

      var p = this.canvasPos;
      var style = this.container.style;

      // set left/top to gizmo position
      style.left = toPixels(p.x);
      style.top = toPixels(p.y);

      // Choose translation offset in % based on X-alignment
      var tx;
      switch (this.alignX) {
        case AlignX.Left:tx = '0%';break;
        case AlignX.Center:tx = '-50%';break;
        case AlignX.Right:tx = '-100%';break;}


      var ty;
      switch (this.alignY) {
        case AlignY.Top:ty = '0%';break;
        case AlignY.Center:ty = '-50%';break;
        case AlignY.Bottom:ty = '-100%';break;}


      // Update transform based on rotation angle and alignment
      style.transform = "translate(".concat(tx, ", ").concat(ty, ") rotate(").concat(this.angle, "deg)");
    }

    // Set position in layer coords
  }, { key: "setPosition", value: function setPosition(x, y) {
      this.layerPos.set(x, y);
      this.update();
    } }, { key: "setClassEnabled", value: function setClassEnabled(

    className, enabled) {
      if (enabled) {
        this.container.classList.add(className);
      } else {
        this.container.classList.remove(className);
      }
    }

    // Selection state is managed using a css-class 'selected'. 
    // Note that this only has an effect if the css style used for the gizmo supports it.
  }, { key: "setSelected", value: function setSelected(selected) {
      this.setClassEnabled('selected', selected);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.container.classList.contains('selected');
    }

    // Optional: Hover-effect for gizmos that can be clicked or dragged.
  }, { key: "setHoverEnabled", value: function setHoverEnabled(enabled) {
      this.setClassEnabled('enable-hover', enabled);
    }

    // Optional: Assign a name to gizmo and div element to facilitate debugging and testing.
  }, { key: "setName", value: function setName(name) {
      this.name = name;
      this.container.id = name ? name : '';
    } }]);return CanvasGizmo;}(CanvasGizmoBase);


// Configure CanvasGizmo as a text label.
var initTextLabel = function initTextLabel(gizmo) {

  // Use measure-tool styles by default
  gizmo.container.classList.add('measure-length');
  gizmo.container.classList.add('visible');

  // Create textDiv child div
  var _document = gizmo.getDocument();
  gizmo.textDiv = _document.createElement('div');
  gizmo.textDiv.classList.add('measure-length-text');
  gizmo.container.appendChild(gizmo.textDiv);

  // Add setText convenience function
  gizmo.setText = function (str) {
    this.textDiv.textContent = str;
  }.bind(gizmo);
};

// A ShapeLabel is a text label whose anchor position is synchronized with the bbox center of a shape in a layer.
var ShapeLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(ShapeLabel, _CanvasGizmo);

  function ShapeLabel(shape, layer) {var _this2;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, ShapeLabel);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeLabel).call(this, layer, visible));

    initTextLabel(_assertThisInitialized(_this2));

    _this2.shape = shape;

    // Can be set to hidden to temporarily hide the label
    _this2.valueValid = true;

    _this2.update();return _this2;
  }_createClass(ShapeLabel, [{ key: "update", value: function update()

    {
      if (this.shape && this.valueValid) {
        // Set it to visible (in case polygon was null before)
        this.container.style.visibility = 'visible';

        if (this.shape.isPolyline()) {
          var edgeCount = this.shape.getEdgeCount();
          // For a start, simply position the label on the segment roughly in the middle of the polyline
          var edgeToLabel = Math.floor(edgeCount / 2);
          if (this.shape.edgeIndexValid(edgeToLabel)) {
            var posA = new THREE.Vector2();
            var posB = new THREE.Vector2();
            this.shape.getEdge(edgeToLabel, posA, posB);
            this.layerPos.set(0.5 * (posA.x + posB.x), 0.5 * (posA.y + posB.y));
          }
        } else
        {
          // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the
          // polygon, so we may consider something smarter later.
          this.shape.computeBBox();
          this.shape.bbox.center(this.layerPos);
        }
        _get(_getPrototypeOf(ShapeLabel.prototype), "update", this).call(this);
      } else {
        this.container.style.visibility = 'hidden';
      }
    } }, { key: "setShape", value: function setShape(

    shape) {
      this.shape = shape;
      this.update();
    } }]);return ShapeLabel;}(CanvasGizmo);


// Only works for shapes with getLength() function
var LengthLabel = /*#__PURE__*/function (_ShapeLabel) {_inherits(LengthLabel, _ShapeLabel);

  // @param {Polyline}    polyline
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function LengthLabel(polyline, layer, unitHandler) {var _this3;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, LengthLabel);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(LengthLabel).call(this, polyline, layer, visible));
    _this3.unitHandler = unitHandler;return _this3;
  }_createClass(LengthLabel, [{ key: "update", value: function update()

    {
      // Get shape length (if shape supports it)
      var hasLength = this.shape && this.shape.getLength;
      var length = hasLength && this.shape.getLength(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined length.
      // We also hide it if length is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(length);

      if (this.valueValid) {
        var text = this.unitHandler.lengthToString(length);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(LengthLabel.prototype), "update", this).call(this);
    } }]);return LengthLabel;}(ShapeLabel);


// Only works for shapes with getArea() function
var AreaLabel = /*#__PURE__*/function (_ShapeLabel2) {_inherits(AreaLabel, _ShapeLabel2);

  // @param {Polygon}     polygon
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function AreaLabel(polygon, layer, unitHandler) {var _this4;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(AreaLabel).call(this, polygon, layer, visible));
    _this4.unitHandler = unitHandler;return _this4;
  }_createClass(AreaLabel, [{ key: "update", value: function update()

    {
      // Get shape area (if shape supports it)
      var hasArea = this.shape && this.shape.getArea;
      var area = hasArea && this.shape.getArea(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined area.
      // We also hide it if area is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(area);

      if (this.valueValid) {
        var text = this.unitHandler.areaToString(area);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);
    } }]);return AreaLabel;}(ShapeLabel);


// A html element for which position and rotation is aligned with an edge
var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(EdgeGizmo, _CanvasGizmo2);

  // @param {EditLayer} layer
  // @param {bool} visible
  function EdgeGizmo(layer) {var _this5;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeGizmo);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeGizmo).call(this, layer, visible));

    _this5.posA = new THREE.Vector2();
    _this5.posB = new THREE.Vector2();

    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is
    // attached to an edge, this flag is set automatically.
    _this5.posValid = false;

    // Temp vectors used in update
    _this5.edgeDir = new THREE.Vector2();

    // Optional: Positions can be synchronized with an edge of a polygon or polyline
    _this5.poly = null;
    _this5.edgeIndex = 0;

    // Use measure-length css style by default
    _this5.container.classList.add('edge-gizmo');

    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:
    // We hide the gizmo if it exceeds x * edgeLength on screen.
    _this5.maxRelativeLength = undefined; // in [0,1]
    return _this5;}

  // If a poly is set, the gizmo is automatically synchronized with the edge.
  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.
  //
  //  @param {PolyBase} poly     - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.
  //  @param {number} edgeIndex  - edgeIndex in poly. If not valid, gizmo is hidden.
  //  @param {bool} [autoUpdate] - update position immediately
  _createClass(EdgeGizmo, [{ key: "attachToEdge", value: function attachToEdge(poly, edgeIndex) {
      this.poly = poly;
      this.edgeIndex = edgeIndex;
      this.update();
    } }, { key: "detachFromEdge", value: function detachFromEdge()

    {
      this.poly = null;
      this.edgeIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "update", value: function update()

    {

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore
      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex)) {
        this.poly.getEdge(this.edgeIndex, this.posA, this.posB);
        this.posValid = true;
      }

      // If edge is invalid or too small on screen, just hide the gizmo
      var show = this._shouldBeShown();
      this.container.style.visibility = show ? 'visible' : 'hidden';
      if (!show) {
        return;
      }

      // Center gizmo at edge center
      this.layerPos.set(0.5 * (this.posA.x + this.posB.x), 0.5 * (this.posA.y + this.posB.y));

      // Set rotation angle
      this._updateRotation();

      _get(_getPrototypeOf(EdgeGizmo.prototype), "update", this).call(this);
    }

    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.
  }, { key: "_shouldBeShown", value: function _shouldBeShown() {

      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()
      if (!this.posValid) {
        return false;
      }

      // Show/Hide gizmo depending on zoom:
      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.
      if (this.maxRelativeLength) {
        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);
        var edgeLengthScreen = aScreen.distanceTo(bScreen);
        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;
        var _window = this.getWindow();
        var width = parseFloat(_window.getComputedStyle(this.container).width);
        return width < maxAllowedPixels;
      }
      return true;
    }

    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge
  }, { key: "_updateRotation", value: function _updateRotation() {

      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b
      var dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(this.posA, this.posB, this.edgeDir);
      var angle = Math.atan2(dir.y, dir.x);

      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.
      if (dir.x < 0) {
        angle += Math.PI;
      }

      // Convert angle to clockwise degrees and apply it to style
      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.
      this.angle = -THREE.Math.radToDeg(angle);
    } }]);return EdgeGizmo;}(CanvasGizmo);


var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);

  function EdgeMoveGizmo(layer, name) {var _this6;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, EdgeMoveGizmo);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeMoveGizmo).call(this, layer, visible));

    _this6.setName(name);
    _this6.container.classList.add('edge-move-gizmo');

    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength
    _this6.maxRelativeLength = 0.3; // in [0,1]
    return _this6;}return EdgeMoveGizmo;}(EdgeGizmo);


// An EdgeGizmo to display text
var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);

  function EdgeLabel(layer) {var _this7;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeLabel).call(this, layer, visible));
    initTextLabel(_assertThisInitialized(_this7));

    // Hide label if it would exceed the edge length
    _this7.maxRelativeLength = 1.0;return _this7;
  }return EdgeLabel;}(EdgeGizmo);


var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(VertexGizmo, _CanvasGizmo3);

  // @param {number}  x,y       - Position in layer coords
  // @param {string}  id        - id string used to tag shapes that represent this gizmo
  function VertexGizmo(layer, x, y, name) {var _this8;_classCallCheck(this, VertexGizmo);
    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(VertexGizmo).call(this, layer, true));
    _this8.setPosition(x, y);
    _this8.setName(name);

    _this8.container.classList.add('vertex-gizmo');return _this8;
  }return VertexGizmo;}(CanvasGizmo);


// A Label filter decides for which shapes we display a label
var LabelFilter = /*#__PURE__*/function () {

  function LabelFilter() {_classCallCheck(this, LabelFilter);}

  // If false, we don't need to acquire a label at all.
  _createClass(LabelFilter, [{ key: "accepts", value: function accepts(shape, text) {
      return true;
    } }]);return LabelFilter;}();
;

// Get shape width in screen-pixels
var getShapeWidth = function getShapeWidth(shape, layer) {
  // get shape size in screen-pixels
  shape.updateBBox();
  var bbox = shape.bbox;
  var shapeWidth = bbox.max.x - bbox.min.x;
  return shapeWidth * layer.getPixelsPerUnit() * shapeWidth;
};

// By default, we hide labels if text is empty or if the shape size on screen falls beyond a pixel threshold
var DefaultLabelFilter = /*#__PURE__*/function (_LabelFilter) {_inherits(DefaultLabelFilter, _LabelFilter);

  // @param {number} minWidth - minimum pixel width a shape must have to receive a label
  function DefaultLabelFilter() {var _this9;var minWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;_classCallCheck(this, DefaultLabelFilter);
    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(DefaultLabelFilter).call(this));
    _this9.minWidth = minWidth;return _this9;
  }

  // Accept shape if text is not empty and its screen-width is big enough.
  _createClass(DefaultLabelFilter, [{ key: "accepts", value: function accepts(shape, text, layer) {
      var width = getShapeWidth(shape, layer);
      return Boolean(text) && width >= this.minWidth;
    } }]);return DefaultLabelFilter;}(LabelFilter);


// A LabelStyle rule allows to apply css style modifications on a label, e.g., depending on screen size
var LabelStyleRule = /*#__PURE__*/function () {

  function LabelStyleRule() {_classCallCheck(this, LabelStyleRule);}

  // Note: Labels may be reused for different shapes. So, make sure that the style parameters are 
  //       not just modified for some subset of shapes, but reset for others.
  _createClass(LabelStyleRule, [{ key: "apply", value: function apply(label, shape, text, layer) {} }]);return LabelStyleRule;}();
;

// Fades out based on label size
var FadeOutStyleRule = /*#__PURE__*/function (_LabelStyleRule) {_inherits(FadeOutStyleRule, _LabelStyleRule);

  // @param {number} rangeStart - shape width in screen-pixels at which the label starts to fade-in
  // @param {number} rangeEnd   - shape width in screen-pixels at which the label is fully opaque.
  function FadeOutStyleRule() {var _this10;var rangeStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;var rangeEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;_classCallCheck(this, FadeOutStyleRule);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(FadeOutStyleRule).call(this));
    _this10.rangeStart = rangeStart;
    _this10.rangeEnd = rangeEnd;return _this10;
  }_createClass(FadeOutStyleRule, [{ key: "apply", value: function apply(

    label, shape, layer) {

      // compute opacity from shape screen-width
      var width = getShapeWidth(shape, layer);
      var t = (width - this.rangeStart) / (this.rangeEnd - this.rangeStart);
      var opacity = THREE.Math.clamp(t, 0, 1);

      label.container.style.opacity = opacity;
    } }]);return FadeOutStyleRule;}(LabelStyleRule);
;

// A ShapeLabelRule maintains a set of labels that is automatically synced with the shapes in a layer.
// It implements the CanvasGizmoBase to update the set of maintained labels.
var ShapeLabelRule = /*#__PURE__*/function () {

  // @param {EditLayer}               layer            - Labels are shown (and synchronized) with the content of this layer.
  // @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  // @param {LabelFilter}             [filter]         - Defines which labels to show. See DefaultLabelFilter for default behavior.
  // @param {LabelStyleRule}          [styleRule]      - Defines how label style is modified dynamically. (By default, we fade-out based on label size)
  function ShapeLabelRule(layer, shapeToLabelText) {var labelFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DefaultLabelFilter();var styleRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FadeOutStyleRule();_classCallCheck(this, ShapeLabelRule);
    this.layer = layer;
    this.shapeToLabelText = shapeToLabelText;

    // All labels that we created. 
    this.labels = []; // {ShapeLabel[]}
    this.labelsUsed = 0; // All remaining labels in this.labels are hidden and just cached for later reuse.

    this.layer.addCanvasGizmo(this);
    this.visible = true;
    this.layer.update();

    this.filter = labelFilter;
    this.styleRule = styleRule;
  }

  // Replace the rule to define label texts.
  //   @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  _createClass(ShapeLabelRule, [{ key: "setTextRule", value: function setTextRule(shapeToLabelText) {
      this.shapeToLabelText = shapeToLabelText;
      this.update();
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible === this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add 'this' first and all maintained labels behind. In this way, this gizmo is updated first to
        //       configure all labels - followed by the update calls for all active labels in use.
        this.layer.addCanvasGizmo(this);
        this.update();
      } else {
        this.clearLabels();
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "dtor", value: function dtor()

    {
      // Make sure that we don't leave any of our labels in the layer
      this.setVisible(false);
    }

    // Hide + release all current labels, so that we can re-acquire them based on latest Layer state.
  }, { key: "clearLabels", value: function clearLabels() {
      for (var i = 0; i < this.labelsUsed; i++) {
        this.labels[i].setShape(null);
        this.labels[i].setVisible(false);
      }
      this.labelsUsed = 0;
    }

    // Create new label or get it from cache
  }, { key: "acquireLabel", value: function acquireLabel() {
      // create new label if necessary
      if (this.labelsUsed === this.labels.length) {
        this.labels.push(new ShapeLabel(null, this.layer));
      }

      return this.labels[this.labelsUsed++];
    } }, { key: "update", value: function update()

    {

      this.clearLabels();

      var shapes = this.layer.shapes;
      for (var i = 0; i < shapes.length; i++) {

        var shape = shapes[i];

        // Get label text 
        var text = this.shapeToLabelText(shape);

        // Check if we want to display a label for this shape
        if (this.filter && !this.filter.accepts(shape, text, this.layer)) {
          continue;
        }

        // Configure label
        var label = this.acquireLabel();
        label.setShape(shape);
        label.setText(text);
        label.setVisible(true);

        // Apply optional custom style rule
        this.styleRule && this.styleRule.apply(label, shape, this.layer);
      }
    } }]);return ShapeLabelRule;}();

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.css":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Edit2D.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Edit2D.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DExtension; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Edit2DSnapper.js */ "./extensions/Edit2D/Edit2DSnapper.js");
/* harmony import */ var _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UnitHandler.js */ "./extensions/Edit2D/UnitHandler.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
/* harmony import */ var _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/PolygonTool.js */ "./extensions/Edit2D/tools/PolygonTool.js");
/* harmony import */ var _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tools/PolygonEditTool.js */ "./extensions/Edit2D/tools/PolygonEditTool.js");
/* harmony import */ var _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tools/InsertSymbolTool.js */ "./extensions/Edit2D/tools/InsertSymbolTool.js");
/* harmony import */ var _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tools/RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tools/UndoTool.js */ "./extensions/Edit2D/tools/UndoTool.js");
/* harmony import */ var _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tools/CopyTool.js */ "./extensions/Edit2D/tools/CopyTool.js");
/* harmony import */ var _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./tools/LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Edit2D.css */ "./extensions/Edit2D/Edit2D.css");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_Edit2D_css__WEBPACK_IMPORTED_MODULE_20__);
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}





















 // IMPORTANT!!

var myExtensionName = 'Autodesk.Edit2D';
var namespace = AutodeskNamespace('Autodesk.Edit2D');
var av = Autodesk.Viewing;

var OverlayName = 'Edit2D';var

ToolSet =
function ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);
  this.name = name;
  this.autoReactivate = autoReactivate;
  this.context = null;
  this.tools = {};
};


/** 
    * Edit2D extension provides API for implementing 2D vector editing. 
    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only
    * to provide a basis for other extensions and client applications.
    * 
    * The extension id is: `Autodesk.Edit2D`
    * 
    * @example
    *   viewer.loadExtension('Autodesk.Edit2D')
    *
    * @memberof Autodesk.Viewing.Extensions
    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
    * @alias Autodesk.Viewing.Extensions.Edit2DExtension
    * @class
    */var
Edit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);
  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Edit2DExtension).call(this, viewer, options));

    _this.undoStack = new _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__["default"]();

    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)
    _this._registeredTools = new Map();
    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_this));
    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_this));
    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(Edit2DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:



                // The overlay "Edit2D" contains subscenes for each edit layer.
                this.viewer.impl.createOverlayScene(OverlayName);

                // We require Snapping and Autodesk.CompGeom (already a dependency of Autodesk.Snapping)
                _context.next = 3;return this.viewer.loadExtension('Autodesk.Snapping');case 3:

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools
                this.undoTool = new _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_16__["default"](this.undoStack);
                this.viewer.toolController.registerTool(this.undoTool);
                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
        for (var _iterator = this._registeredTools.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var toolSetName = _step.value;
          this.unregisterTools(toolSetName);
        }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator["return"] != null) {_iterator["return"]();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

      this.viewer.toolController.deregisterTool(this.undoTool);
      this.undoTool = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

      return true;
    } }, { key: "_onModelAdded", value: function _onModelAdded()

    {var _this2 = this;
      if (this.viewer.getVisibleModels().length !== 1) {
        // Do the reactivation only when the first model got loaded.
        return;
      }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {

        for (var _iterator2 = this._registeredTools.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var toolSet = _step2.value;
          if (toolSet.autoReactivate) {
            toolSet.toolsToReactivate.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});
          }
        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {_iterator2["return"]();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
    } }, { key: "_onModelRemoved", value: function _onModelRemoved()

    {
      if (this.viewer.getVisibleModels().length !== 0) {
        // Only deactivate tools when no model is active anymore.
        return;
      }

      var controller = this.viewer.toolController;var _iteratorNormalCompletion3 = true;var _didIteratorError3 = false;var _iteratorError3 = undefined;try {
        for (var _iterator3 = this._registeredTools.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {var toolSet = _step3.value;
          if (toolSet.autoReactivate) {
            // The next statement gets all possible names of all tools of a toolSet,
            // flatten the resulting array
            // and returns a list tool names that are active.
            toolSet.toolsToReactivate = Object.values(toolSet.tools).
            map(function (t) {return t.getNames();}).
            reduce(function (res, names) {return res.concat(names);}, []) // flatten
            .filter(function (name) {return controller.isToolActivated(name);});

            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});
          }
        }} catch (err) {_didIteratorError3 = true;_iteratorError3 = err;} finally {try {if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {_iterator3["return"]();}} finally {if (_didIteratorError3) {throw _iteratorError3;}}}
    }

    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.
  }, { key: "_onSelectionChanged", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iteratorNormalCompletion4 = true;var _didIteratorError4 = false;var _iteratorError4 = undefined;try {
        for (var _iterator4 = this._registeredTools.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {var toolSet = _step4.value;
          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {
            toolSet.context.selection.clear();
          }
        }} catch (err) {_didIteratorError4 = true;_iteratorError4 = err;} finally {try {if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {_iterator4["return"]();}} finally {if (_didIteratorError4) {throw _iteratorError4;}}}
    } }, { key: "registerDefaultTools", value: function registerDefaultTools()

    {
      this.defaultContext = this.registerTools('default');
    }

    // Get default tools. registerDefaultTools() must be called first, otherwise it returns null.
  }, { key: "registerTools", value: function registerTools(




    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var toolSet = this._registeredTools.get(toolSetName);
      if (toolSet) {
        console.warn("Edit 2D tools are already registered for tool set '".concat(toolSetName, "'"));
        return toolSet.context;
      }

      toolSet = new ToolSet(toolSetName, autoReactivate);
      this._registeredTools.set(toolSetName, toolSet);

      // create context
      var context = toolSet.context = new Edit2DContext(this, toolSetName);
      context.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // create tools
      toolSet.tools.polygonTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__["default"].Mode.Polygon);
      toolSet.tools.polylineTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__["default"].Mode.Polyline);
      toolSet.tools.moveTool = new _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_11__["default"](context);
      toolSet.tools.polygonEditTool = new _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_13__["default"](context);
      toolSet.tools.insertSymbolTool = new _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_14__["default"](context);
      toolSet.tools.copyTool = new _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_17__["default"](context);

      // register them
      var controller = this.viewer.toolController;
      controller.registerTool(toolSet.tools.polygonTool);
      controller.registerTool(toolSet.tools.polylineTool);
      controller.registerTool(toolSet.tools.moveTool);
      controller.registerTool(toolSet.tools.polygonEditTool);
      controller.registerTool(toolSet.tools.insertSymbolTool);
      controller.registerTool(toolSet.tools.copyTool);

      // activate CopyTool immediately, because they run parallel to other tools
      controller.activateTool(toolSet.tools.copyTool.getName());

      return context;
    } }, { key: "unregisterDefaultTools", value: function unregisterDefaultTools()

    {
      this.unregisterTools('default');
      this.defaultContext = null;
    } }, { key: "unregisterTools", value: function unregisterTools(

    toolSetName) {
      var toolSet = this._registeredTools.get(toolSetName);
      if (!toolSet) {
        return;
      }

      var controller = this.viewer.toolController;
      controller.deregisterTool(toolSet.tools.polygonTool);
      controller.deregisterTool(toolSet.tools.polylineTool);
      controller.deregisterTool(toolSet.tools.moveTool);
      controller.deregisterTool(toolSet.tools.polygonEditTool);
      controller.deregisterTool(toolSet.tools.insertSymbolTool);
      controller.deregisterTool(toolSet.tools.copyTool);

      toolSet.context.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      this._registeredTools["delete"](toolSetName);
    } }, { key: "createLayer", value: function createLayer()

    {

      var model = this.viewer.model;
      if (!model || !model.is2d()) {
        console.error("A 2D model is needed to adjust viewport");
      }

      // determine drawing viewport from model bbox
      var box = model.getBoundingBox();
      var width = box.max.x - box.min.x;
      var height = box.max.y - box.min.y;

      // create new overlay scene to show
      var layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](width, height, this.viewer);

      // add layer scene to our overlay scene
      this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);

      return layer;
    } }, { key: "defaultTools", get: function get() {var toolSet = this._registeredTools.get('default');return toolSet && toolSet.tools;} }]);return Edit2DExtension;}(av.Extension);


// Common set of objects usually needed by tools
var Edit2DContext =

// @param {Edit2D} ext - Edit2d extension
function Edit2DContext(ext, toolSetName) {var _this3 = this;_classCallCheck(this, Edit2DContext);
  this.toolSetName = toolSetName;
  this.viewer = ext.viewer;
  this.layer = ext.createLayer();
  this.gizmoLayer = ext.createLayer();
  this.undoStack = ext.undoStack;
  this.selection = new _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.layer, this.undoStack);
  this.snapper = new _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.viewer, this.layer, this.gizmoLayer);
  this.unitHandler = new _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["DefaultUnitHandler"](this.viewer);

  // Update all visible labels if display units are changed
  var onUnitChange = function onUnitChange() {
    _this3.layer.updateCanvasGizmos();
    _this3.gizmoLayer.updateCanvasGizmos();
  };
  this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, onUnitChange);
};


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);

namespace.Shape = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Shape"];
namespace.Polygon = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polygon"];
namespace.Polyline = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"];
namespace.PolyBase = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"];
namespace.Path = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Path"];
namespace.Circle = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Circle"];
namespace.Style = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Style"];
namespace.PolygonTool = _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_12__["default"];
namespace.Selection = _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.MoveTool = _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_11__["default"];
namespace.PolygonEditTool = _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_13__["default"];
namespace.InsertSymbolTool = _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_14__["default"];
namespace.Math2D = _Math2D_js__WEBPACK_IMPORTED_MODULE_3__["Math2D"];
namespace.VertexGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["VertexGizmo"];
namespace.RectangleTool = _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_15__["default"];
namespace.LineTool = _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_18__["default"];
namespace.CopyTool = _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_17__["default"];
namespace.Actions = _Actions_js__WEBPACK_IMPORTED_MODULE_4__["Actions"];
namespace.UndoStack = _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__["default"];
namespace.UndoTool = _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_16__["default"];
namespace.Edit2DContext = Edit2DContext;
namespace.CanvasGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["CanvasGizmo"];
namespace.CanvasGizmoBase = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["CanvasGizmoBase"];
namespace.ShapeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["ShapeLabel"];
namespace.AlignX = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AlignX"];
namespace.AlignY = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AlignY"];
namespace.AreaLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AreaLabel"];
namespace.EdgeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["EdgeLabel"];
namespace.UnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["UnitHandler"];
namespace.DefaultUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["DefaultUnitHandler"];
namespace.ShapeLabelRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["ShapeLabelRule"];
namespace.ShapeWrapper = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["ShapeWrapper"];
namespace.SegmentTree = _SegmentTree_js__WEBPACK_IMPORTED_MODULE_10__["default"];
namespace.TangentGizmo = _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_9__["default"];
namespace.MeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_19__["MeasureTransform"];
namespace.DefaultMeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_19__["DefaultMeasureTransform"];

/***/ }),

/***/ "./extensions/Edit2D/Edit2DSnapper.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/Edit2DSnapper.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DSnapper; });
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var SnapType = Autodesk.Viewing.MeasureCommon.SnapType;

// Edit2DSnapper combines 3 different types of snapping:
//  1. Snapping to sheet geometry
//  2. Snapping to other geometry in the same layer
//  3. Snapping to angles and alignments

var av = Autodesk.Viewing;var

Edit2DSnapper = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {Layer} layer
  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)
  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);
    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // Used for sheet geometry
    this.sheetSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);

    // Used for layer geometry
    this.layerSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);

    // Used for snapping to angles and alignments
    this.angleSnapper = new _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__["default"](gizmoLayer);

    // tmp box reused for snapping
    this.snapBox = new THREE.Box2();

    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.
    this.sheetSnapper.activate();
    this.layerSnapper.activate();

    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)
    this.onCameraChangeCb = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);

    // If there is a model already, compute SegmentTree right now
    this.initSegmentTrees();
  }_createClass(Edit2DSnapper, [{ key: "dtor", value: function dtor()

    {
      this.sheetSnapper.deactivate();
      this.layerSnapper.deactivate();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updateSnapperIndicators();
    }

    // Make sure that all visible models have a SegmentTree
  }, { key: "initSegmentTrees", value: function initSegmentTrees() {var _this = this;
      var models = this.viewer.getVisibleModels();
      models.forEach(function (model) {
        // Note: We have to wait until the model finished loading. Otherwise, we may end up with a segmentTree that only
        //       contains a subset of the segments.
        //       In addition, make sure to skip the segment building in case it's a leaflet (e.g. a raster PDF).
        var isLeaflet = !!(model.myData && model.myData.isLeaflet);
        if (model.is2d() && !isLeaflet && !model.segmentTree && model.isLoadDone()) {
          model.segmentTree = new _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__["default"](_this.viewer.impl.use2dInstancing);
          model.segmentTree.buildFromModel(model);
        }
      });
    } }, { key: "updateSnapperIndicators", value: function updateSnapperIndicators()

    {
      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper
      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear 
      // the sheet-snapping indicator again.
      if (this.sheetSnapper.isSnapped()) {
        this.sheetSnapper.indicator.render();
      } else {
        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.
        this.layerSnapper.indicator.render();
      }
    }

    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.
    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.
  }, { key: "getSnapPosition", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);

      // keep snapping gizmos up to date
      this.angleSnapper.updateSnapLineGizmos(p);

      this.updateSnapperIndicators();

      return p;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.angleSnapper.clearSnappingGizmos();
      this.sheetSnapper.clearSnapped();
      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();
      this.layerSnapper.clearSnapped();
      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();
    }

    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.
    // Otherwise, it has no effect.
  }, { key: "startAngleSnapping", value: function startAngleSnapping(poly, draggedVertex) {
      this.angleSnapper.startSnapping(poly, draggedVertex);
    }

    // Stop snapping to angles. (No effect if angleSnapping is already off).
  }, { key: "stopAngleSnapping", value: function stopAngleSnapping() {
      this.angleSnapper.stopSnapping();
    }

    // Like getSnapPosition, but excluding Snapping gizmo updates.
  }, { key: "_getSnapPosition", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {

      // Discard any outdated snapping results
      this.angleSnapper.clearSnappingResult();
      this.sheetSnapper.clearSnapped();
      this.layerSnapper.clearSnapped();

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Check if geom-snapping is possible (pGeom is in layer-coords)
      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);

      // Check if we snapped to line geometry. If so, we can still allow angle-snapping - as long as we constrain it to the geometry snapLine.
      var geomSnapLine = this._getGeomSnapLine();

      if (pGeom && !geomSnapLine) {
        // We snapped to geometry and the snapType does not allow us to combine it with angle snapping
        // => Just return result of geometry snapping
        return pGeom;
      }

      // Apply angle-snapping. If we snapped to line geometry already, constrain angleSnapping to this line.
      this.angleSnapper.snapToAngle(p, geomSnapLine);

      // If there is no angle-snap, just apply the geometry snap
      if (geomSnapLine && !this.angleSnapper.isSnapped()) {
        return pGeom;
      }

      // By default, SnapperIndicator only considers the geometry snapping result. If we corrected the snap point and used the intersection with an
      // angle snapLine, we have to update the SnapResult so that the snapPoint is correctly reflected by the SnapperIndicator.
      if (geomSnapLine && this.angleSnapper.isSnapped()) {
        var result = this._getGeomSnapResult();
        result.geomType = SnapType.SNAP_INTERSECTION;
        result.snapPoint = p.clone();
        result.geomVertex = result.snapPoint; // Otherwise, snapResult.isEmpty() returns true
      }

      return p;
    }

    // Gets snap position from mouse event. 
    //  @returns {Vector2|null} Snapped position or null if not snapped.
  }, { key: "_getGeomSnapPosition", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Compute snap position for model geom and edit layer. 
      // Both may be undefined if there was nothing to snap to.
      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);
      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);

      // If nothing is snapped, don't snap
      if (!pSheet && !pLayer) {
        return null;
      }

      // If only one snap point was found, use it
      if (!pLayer) {
        return pSheet;
      } else if (!pSheet) {
        return pLayer;
      }

      // Get distances of snapPoints to accurate position
      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);
      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);

      // Choose the closer snap. If equal, prefer edit layer snap.
      // We discard unused snap results here, so that snapper indicator keeps correct
      if (distSheet < distLayer) {
        // Use sheet snap and discard the other snap result
        this.layerSnapper.clearSnapped();
        return pSheet;
      } else {
        // Use layer snap and discard the other snap result
        this.sheetSnapper.clearSnapped();
        return pLayer;
      }
    }

    // Returns the SnapResult of sheetSnapper or layerSnapper if any of them is currently snapped. Returns null otherwise.
  }, { key: "_getGeomSnapResult", value: function _getGeomSnapResult() {

      // Check which of the snappers has snapped
      var sheetSnap = this.sheetSnapper.isSnapped();
      var layerSnap = this.layerSnapper.isSnapped();
      if (!sheetSnap && !layerSnap) {
        return null;
      }

      // Get latest SnapResult
      var geomSnapper = sheetSnap ? this.sheetSnapper : this.layerSnapper;
      return geomSnapper.getSnapResult();
    }

    // If the last geometry snapping successfully snapped to a line segment, this function returns this line segment. 
    //  @returns {Object} - If we snapped to a line segment, we return r={a, b} where r.a and r.b are line start/end as Vector2.
  }, { key: "_getGeomSnapLine", value: function _getGeomSnapLine() {

      var result = this._getGeomSnapResult();
      if (!result) {
        return null;
      }

      // If we snapped to an edge, return this edge. Note that SnapType may be SNAP_EDGE, but may also be SNAP_VERTEX
      var edgeGeom = result.geomEdge;
      if (edgeGeom) {
        var verts = result.geomEdge.vertices;
        return {
          a: verts[0],
          b: verts[1] };

      }

      // Another SnapType => No line constraint.
      return null;
    }

    // If the last geometry snapping successfully snapped to a line segment, this function returns
    // this line segment.
    //  @returns {Object} - If we snapped to a line segment, we return {a, b} where result.a/result.b are line start/end as Vector2.

    // Snaps to 2D edit layer geometry. Returns the snapped point in world coordinates or undefined if not snapped.
  }, { key: "_getEditLayerSnapPosition", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {

      // get world position. 
      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var point = this.viewer.impl.intersectGround(canvasX, canvasY);

      // compute snap radius in world (=layer) coords
      var radius = this.layerSnapper.setDetectRadius(point);

      // create bbox centered at the point and expanded by snapRadius in each direction
      this.snapBox.min.set(point.x - radius, point.y - radius);
      this.snapBox.max.set(point.x + radius, point.y + radius);

      // Build dictionary of dbIds of all shapes intersecting the snapBox
      var dbIds = {};
      this.layer.enumShapes(this.snapBox, function (shape) {
        // Collect dbId - unless shape is excluded from snapping
        if (!snappingFilter || snappingFilter(shape)) {
          dbIds[shape.id] = true;
        }
      });

      // Collect all triangulated meshes intersecting the snapBox
      var meshes = [];
      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});

      // Only consider edges/arcs/vertices within snapRadius
      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};

      // Run snapper on the given meshes/dbIds
      this.layerSnapper.clearSnapped();
      this.layerSnapper.snapping2DOverlay(point, meshes, filter);

      // Stop here if nothing was snapped
      if (!this.layerSnapper.isSnapped()) {
        return undefined;
      }

      // return snapped 2d world position
      var res = this.layerSnapper.getSnapResult();
      return Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);
    }

    // Snaps to sheet geometry. Returns the snapped point in world coordinates or undefined if not snapped.
  }, { key: "_getSheetSnapPosition", value: function _getSheetSnapPosition(canvasX, canvasY) {var _this2 = this;

      // Make sure that SegmentTree exists for all visible 2D models
      this.initSegmentTrees();

      // Callback to enum segments of all visible models
      var enumSegments = function enumSegments() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        var models = _this2.viewer.getVisibleModels();
        models.forEach(function (model) {
          // NOTE: SegmentTree may not be available yet if a model is still loading.
          //       In this case, we exclude it from snapping until loading is done.
          if (model.is2d() && model.segmentTree) {var _model$segmentTree;
            (_model$segmentTree = model.segmentTree).enumSegments.apply(_model$segmentTree, args);
          }
        });
      };

      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var pos = this.viewer.impl.intersectGround(canvasX, canvasY);
      this.sheetSnapper.snapping2DWithSegmentEnum(pos, enumSegments);

      // If not snapped, just return current position
      if (!this.sheetSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position
      var res = this.sheetSnapper.getSnapResult();
      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3

      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()
      return new THREE.Vector2().copy(p3D);
    } }]);return Edit2DSnapper;}();


av.GlobalManagerMixin.call(Edit2DSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/EditLayer.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/EditLayer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditLayer; });
/* harmony import */ var _PDF_LmvCanvasContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDF/LmvCanvasContext.js */ "./extensions/PDF/LmvCanvasContext.js");
/* harmony import */ var _PDF_test_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PDF/test-pattern.js */ "./extensions/PDF/test-pattern.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var nextLayerId = 1;

// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.
var DefaultLineHitRadius = 10;

var av = Autodesk.Viewing;

// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.
var EditLayer = /*#__PURE__*/function () {

  // @param {LmvCanvasContext} ctx  - LmvCanvasContext used for converting the polygons into renderable 2d geometry    
  // @param {number} width, height  - Extents of the drawable area
  // @param {number} toPageUnit     - Scale factor applied to all generated geometry.
  // @param {Viewer3D} viewer       - Viewer instance needed to create materials
  function EditLayer(width, height, viewer) {var _this = this;_classCallCheck(this, EditLayer);

    // Contains the triangulated geometry ready for rendering.
    this.scene = new THREE.Scene();

    // @param {Shape[]}
    this.shapes = [];

    // @param {CanvasGizmoBase[]}
    this.canvasGizmos = [];

    this.id = nextLayerId++;

    // We don't use font rendering so far
    var fontEngine = null;

    this.viewport = {
      width: width,
      height: height };


    // Always use client coords for drawing
    var toPageUnits = 1.0;

    this.context = new _PDF_LmvCanvasContext_js__WEBPACK_IMPORTED_MODULE_0__["LmvCanvasContext"](this.viewport, toPageUnits, this._processMesh.bind(this), fontEngine);

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);

    // By default, we always update on modification operations. But it can (and should) be temporarily disabled 
    // for batch operations. 
    this.autoUpdate = true;

    this.toPageUnits = toPageUnits;

    this.styleModifiers = [];

    Object(_PDF_test_pattern_js__WEBPACK_IMPORTED_MODULE_1__["addContextCurrentTransform"])(this.context.canvasContext);

    // Update gizmo positions on camera changes
    this.onCameraChange = function () {return _this.updateCanvasGizmos();};
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // Use custom tesselation accuracy for Bezier arcs. We use a bit finer values than PDF does right now.
    this.context.setTessParams({
      numIterations: 100,
      minSegLenFraction: 0.01 });

  }_createClass(EditLayer, [{ key: "dtor", value: function dtor()

    {
      this._clearScene();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    }

    // @param {Shape} shape
    // @returns {number} - The id of the shape. Used to access this shape later.
  }, { key: "addShape", value: function addShape(shape) {
      this.shapes.push(shape);

      this._onModified();
    }

    // Removes the given shape. 
    //  @returns {bool} true if shape was found and removed, otherwise false.
  }, { key: "removeShape", value: function removeShape(shape) {
      var index = this.shapes.indexOf(shape);
      if (index === -1) {
        return false;
      }
      this.shapes.splice(index, 1);

      this._onModified();
      return true;
    } }, { key: "clear", value: function clear()

    {
      this.shapes.length = 0;

      this._onModified();
    }

    // Must be called after modifications to update the scene.
  }, { key: "update", value: function update() {

      // clear scene
      this._clearScene();

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // apply override style if specified
        var overrideStyle = this._getOverrideStyle(shape);

        shape.draw(this.context, overrideStyle);
      }

      // Make sure that all shapes are processed
      this.context.flushBuffer(0, true);

      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.
      this.viewer.impl.invalidate(false, false, true);

      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed
      this.updateCanvasGizmos();
    } }, { key: "updateCanvasGizmos", value: function updateCanvasGizmos()

    {
      for (var i = 0; i < this.canvasGizmos.length; i++) {
        this.canvasGizmos[i].update();
      }
    }

    // @param {CanvasGizmoBase} gizmo - Must implement gizmo.update() to respond to changes.
  }, { key: "addCanvasGizmo", value: function addCanvasGizmo(gizmo) {
      this.canvasGizmos.push(gizmo);
    }

    // @param {CanvasGizmoBase} gizmo
  }, { key: "removeCanvasGizmo", value: function removeCanvasGizmo(gizmo) {
      var index = this.canvasGizmos.indexOf(gizmo);
      if (index === -1) {
        return false;
      }
      this.canvasGizmos.splice(index, 1);
      return true;
    } }, { key: "getViewport", value: function getViewport()

    {
      return this.viewport;
    }

    // Returns the topmost shape containing the point (x,y)
    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.
  }, { key: "hitTest", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;

      // process shapes backwards to find topmost first
      for (var i = this.shapes.length - 1; i >= 0; i--) {
        var shape = this.shapes[i];
        var radiusLC = this.getLineHitRadius(shape, hitRadius);

        if (shape.hitTest(x, y, radiusLC)) {
          return shape;
        }
      }
    }

    // Used for line-feature hit tests: 
    // We consider a point p to be "on edge e" if p is within a certain radius around e.
    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.
  }, { key: "getLineHitRadius", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;

      var unitsPerPixel = this.getUnitsPerPixel();

      // Get line-width in layer coords
      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;

      // For thin lines, consider hits as long as they are within minPixels radius
      return Math.max(lineWidth, hitRadius * unitsPerPixel);
    }

    // Optional: Sets a callback to override the style for either all or a subset of shapes.
    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.
  }, { key: "addStyleModifier", value: function addStyleModifier(modifier) {
      this.styleModifiers.push(modifier);
      this._onModified();
    } }, { key: "removeStyleModifier", value: function removeStyleModifier(

    modifier) {
      var index = this.styleModifiers.indexOf(modifier);
      if (index == -1) {
        return false;
      }
      this.styleModifiers.splice(index, 1);
      this._onModified();
      return true;
    }

    // Convert layer coordinates to canvas coords.
  }, { key: "layerToCanvas", value: function layerToCanvas(x, y) {
      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.
      var res = this.viewer.impl.worldToClient(new THREE.Vector3(x, y, 0));
      return new THREE.Vector2(res.x, res.y);
    } }, { key: "getPixelsPerUnit", value: function getPixelsPerUnit()

    {
      if (!this.viewer.model) {
        console.warn('Accessing EditLayer.getPixelsPerUnit is impossible when no model is loaded.');
        return 1.0;
      }

      var camera = this.viewer.impl.camera;
      var worldBox = this.viewer.impl.getVisibleBounds();
      var _window = this.getWindow();
      return this.viewer.impl.getPixelsPerUnit(camera, worldBox) / _window.devicePixelRatio;
    } }, { key: "getUnitsPerPixel", value: function getUnitsPerPixel()

    {
      return 1.0 / this.getPixelsPerUnit();
    }

    // Convert canvas coordinates (from input events) to layer viewport coordinates
  }, { key: "canvasToLayer", value: function canvasToLayer(canvasX, canvasY)
    {
      // We use intersectGround, because clientToWorld returns null when clicking outside of the sheet
      var res = this.viewer.impl.intersectGround(canvasX, canvasY);
      return new THREE.Vector2(res.x, res.y);
    }

    // Runs the callback for all shapes in the layer that overlap the given bbox
    //  @param {Box2} bbox
    //  @param {function(Shape)} cb
  }, { key: "enumShapes", value: function enumShapes(bbox, cb) {
      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Make sure that bbox is up-to-date
        shape.updateBBox();

        if (bbox.isIntersectionBox(shape.bbox)) {
          cb(shape);
        }
      }
    }

    // Runs the callback for all triangulated 2D meshes created in the last update() call.
  }, { key: "enumMeshes", value: function enumMeshes(bbox, cb) {
      for (var i = 0; i < this.scene.children.length; i++) {
        var mesh = this.scene.children[i];
        var meshBox = mesh.geometry.boundingBox;

        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,
        //       we would need to compute a world-box using applyMatrixWorld() here.

        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,
        // it's important to call intersectsBox on the input box and not on the mesh.
        if (bbox.isIntersectionBox(meshBox)) {
          cb(mesh);
        }
      }
    } }, { key: "findShapeById", value: function findShapeById(

    id) {
      return this.shapes.find(function (s) {return s.id == id;});
    }

    // 
    // --- Internal functions ---
    //

    // process meshData produced by LmvCanvasContext
  }, { key: "_processMesh", value: function _processMesh(meshData) {

      // create GeometryBuffer
      var mdata = { mesh: meshData, is2d: true, packId: "0", meshIndex: 0 };
      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      // create 2D material
      // Note that it is essential not to associate the material witha model. Otherwise,
      // the EditShapes will disappear if model layer 0 is switched off.
      var matman = this.viewer.impl.getMaterials();
      var matName = matman.create2DMaterial(null, meshData.material);
      var material = matman.findMaterial(null, matName);

      // collect mesh
      var mesh = new THREE.Mesh(geom, material);
      this.scene.children.push(mesh);
    } }, { key: "_onModified", value: function _onModified()

    {
      if (this.autoUpdate) {
        this.update();
      }
    }

    // Apply one or more style modifiers
  }, { key: "_getOverrideStyle", value: function _getOverrideStyle(shape) {
      var style = shape.style;
      for (var i = 0; i < this.styleModifiers.length; i++) {
        var mod = this.styleModifiers[i];
        style = mod(shape, style) || style;
      }
      return style;
    }

    // Dispose all shapes generated by this layer.
  }, { key: "_clearScene", value: function _clearScene() {

      // Dispose any GPU resources for previous output geometry
      // Note that we construct the scene as a flat list of meshes (see _processMesh). So, we don't need a generic traversal here.
      var meshes = this.scene.children;
      for (var i = 0; i < meshes.length; i++) {
        var mesh = meshes[i];
        mesh.geometry.dispose();

        // TODO: We have to take care to dispose materials here as well. However, just disposing materials here as well would produce a couple of issues:
        //
        //  1. MaterialManager caches materials based on properties. So, we cannot safely assume that the materials are solely used by ourselves.
        //     => MaterialManager currently only allows models to own 2D materials. We have to generalize it to support "ownerIDs" so
        //        that we can ensure that the materials are owned by this layer.
        //  2. Recompiling shaders on each update would be a waste. So we will need some caching.
      }
      this.scene.children.length = 0;
    } }]);return EditLayer;}();



av.GlobalManagerMixin.call(EditLayer.prototype);

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, PolyBase, Polygon, Polyline, Path, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var nextShapeId = 1;

var av = Autodesk.Viewing;
var domParser = new DOMParser();

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,64)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,64)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Set dstBox to bbox of all points
var pointArrayBBox = function pointArrayBBox(points, dstBox) {
  dstBox.makeEmpty();
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function () {
  function Shape() {var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    this.style = style;

    // assign unique id
    this.id = nextShapeId++;

    this.bbox = new THREE.Box2();
    this.bboxDirty = true;

    // Should be set by creator by something more descriptive.
    this.name = this.id.toString();
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.

    // Todo: Clarify whether Shapes should have an own matrix or always modified in-place
  }, { key: "move", value: function move() /*dx, dy*/{return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "toSVG", value: function toSVG()

    {var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var path = this.toSVGPath(precision, digits);
      if (!path) {
        return;
      }
      return "<svg xmlns=\"http://www.w3.org/2000/svg\"><path d=\"".concat(path.join(' '), "\"/></svg>");
    } }, { key: "toSVGPath", value: function toSVGPath()

    {var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      console.error("Must be implemented by derived class.");
    } }, { key: "computeBBox", value: function computeBBox()






























    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    } }], [{ key: "fromSVG", value: function fromSVG(svg) {if (!svg) {return;}var dom = domParser.parseFromString(svg, 'application/xml');var svgDom = dom.firstChild;if (!svgDom) {throw 'svg node was not found';}if (svgDom.nodeName !== 'svg') {throw 'Function does only support svg';}if (svgDom.childNodes.length !== 1) {throw 'Function does only support svg with a single element: path, circle';}var node = svgDom.firstChild;if (node.nodeName === 'circle') {return Circle._fromDOMNode(node);} else if (node.nodeName === 'path') {return Path._fromDOMNode(node);}throw "Unsupported svg node type: ".concat(node.nodeName);} }]);return Shape;}();


av.GlobalManagerMixin.call(Shape.prototype);

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);

  function PolyBase() {var _this;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolyBase).call(this, style));

    // Array of points, each represented as an object {x, y}
    _this.points = points;return _this;
  }_createClass(PolyBase, [{ key: "isPolygon", value: function isPolygon()

    {
      return this instanceof Polygon;
    } }, { key: "isPolyline", value: function isPolyline()

    {
      return this instanceof Polyline;
    } }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {
      var point = { x: x, y: y };
      this.points.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index, target) {
      target = target || new THREE.Vector2();
      return target.copy(this.points[index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {
      this.points.splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {
      var p = this.points[index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {
      this.points.splice(index, 0, p);
    } }, { key: "clear", value: function clear()





    {
      this.points.length = 0;
      this.modified();
    }

    // Enumerate all edges (a,b). 
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {

      // get edge count
      var edgeCount = this.isPolygon() ? this.length : this.length - 1;

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = (i + 1) % this.length;

        // get points
        var a = this.getPoint(ai);
        var b = this.getPoint(bi);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb);
      return edgeIndex;
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var i = 0; i < this.points.length; i++) {
        this.points[i].x += dx;
        this.points[i].y += dy;
      }
      this.modified();
      return this;
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, from);
      this.points = cloneVectorArray(from.points);
      this.modified();
      return this;
    } }, { key: "toSVGPath", value: function toSVGPath()

    {var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!this.length) {
        return;
      }

      var previousIndex = 0;
      var reduceToPath = function reduceToPath(result, current, index, list) {
        if (!index) {
          result.push("M ".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits)));
          return result;
        }

        var prefix, value;
        var previous = list[previousIndex];
        var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].pointDelta(previous, current, digits);
        // skip empty/duplicate points
        if (!delta) {
          return result;
        }
        if (Math.abs(delta.x) <= precision) {
          prefix = 'V';
          value = limitDigits(current.y, digits);
        } else if (Math.abs(delta.y) <= precision) {
          prefix = 'H';
          value = limitDigits(current.x, digits);
        } else {
          prefix = 'L';
          value = "".concat(limitDigits(current.x, digits), ",").concat(limitDigits(current.y, digits));
        }
        result.push("".concat(prefix, " ").concat(value));
        previousIndex = index;
        return result;
      };

      var path = this.points.reduce(reduceToPath, []);
      if (this.isPolygon()) {
        path.push('Z');
      }
      return path;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      pointArrayBBox(this.points, this.bbox);
    } }, { key: "nextIndex", value: function nextIndex(

    index) {return (index + 1) % this.length;} }, { key: "prevIndex", value: function prevIndex(
    index) {return (index + this.length - 1) % this.length;} }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {
      var edgeCount = this.getEdgeCount();
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      this.getPoint(ia, outA);
      this.getPoint(ib, outB);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {
      return this.isPolygon() ? this.length : this.length - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    // 
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(); i++) {
        this.getEdge(i, a, b);

        // apply optional measure transform
        measureTransform && measureTransform.apply(a);
        measureTransform && measureTransform.apply(b);

        sum += a.distanceTo(b);
      }
      return sum;
    } }, { key: "length", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);


var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);

  function Polygon() {var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this,
    points, style));
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {

      if (!this.length) {
        return;
      }

      var style = overrideStyle || this.style;

      ctx.dbId = this.id;
      ctx.lineStyle = style.lineStyle;
      ctx.isScreenSpace = style.isScreenSpace;

      ctx.beginPath();

      ctx.moveTo(this.points[0].x, this.points[0].y);

      for (var i = 1; i < this.points.length; i += 1) {
        ctx.lineTo(this.points[i].x, this.points[i].y);
      }

      ctx.closePath();

      var c = ctx.canvasContext;

      c.fillStyle = style.fillColor;
      c.globalAlpha = style.fillAlpha;

      ctx.fill();

      c.strokeStyle = style.lineColor;
      c.globalAlpha = style.lineAlpha;
      c.lineWidth = style.lineWidth;

      // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
      // For human eyes the line width is then the same width.
      var _window = this.getWindow();
      if (style.isScreenSpace) c.lineWidth *= _window.devicePixelRatio;

      ctx.stroke();

      // restore default values
      ctx.dbId = -1;
      ctx.lineStyle = 0;
      ctx.isScreenSpace = false;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(this.points);

      // create dummy contour
      // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
      var contour = [];
      for (var i = 0; i < this.length; i++) {
        contour.push(i);
      }

      return cp.pointInContour(x, y, contour);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (this.points.length < 3) {
        return 0.0;
      }

      var area = 0.0;
      this.enumEdges(function (a, b) {
        // apply optional transform
        measureTransform && measureTransform.apply(a);
        measureTransform && measureTransform.apply(b);

        // sum up signed areas
        area += a.x * b.y - b.x * a.y;
      });

      return Math.abs(0.5 * area);
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);

  function Polyline() {var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this,
    points, style));
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.length !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {

      if (!this.length) {
        return;
      }

      var style = overrideStyle || this.style;

      ctx.dbId = this.id;
      ctx.lineStyle = style.lineStyle;
      ctx.isScreenSpace = style.isScreenSpace;

      ctx.beginPath();

      ctx.moveTo(this.points[0].x, this.points[0].y);

      for (var i = 1; i < this.points.length; i++) {
        ctx.lineTo(this.points[i].x, this.points[i].y);
      }

      var c = ctx.canvasContext;

      c.strokeStyle = style.lineColor;
      c.globalAlpha = style.lineAlpha;
      c.lineWidth = style.lineWidth;

      // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
      // For human eyes the line width is then the same width.
      var _window = this.getWindow();
      if (style.isScreenSpace) c.lineWidth *= _window.devicePixelRatio;

      ctx.stroke();

      // restore default values
      ctx.dbId = -1;
      ctx.lineStyle = 0;
      ctx.isScreenSpace = false;
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    } }, { key: "computeBBox", value: function computeBBox()

    {
      pointArrayBBox(this.points, this.bbox);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var ArcType = {
  Bezier: 1 };


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);

  function Path(points) {var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Path);return _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this,
    points, style));
  }_createClass(Path, [{ key: "updatePoint", value: function updatePoint(

    index, x, y) {

      var p = this.points[index];

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Control point for the end tangent of the arc segment ending at p
      if (this.length > 1) {
        var prevIndex = this.prevIndex(index);
        if (this.isBezierArc(prevIndex)) {
          var pPrev = this.points[prevIndex];
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    }

    // Change segment into BezierArc
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y) {

      var p = this.points[segmentIndex];

      p.arcType = ArcType.Bezier;
      p.cp1x = cp1x;
      p.cp1y = cp1y;
      p.cp2x = cp2x;
      p.cp2y = cp2y;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {
      return this.points[segmentIndex].arcType === ArcType.Bezier;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by 
    //                                  current vertex position
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex, optionalTarget) {
      var result = optionalTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];

      if (ctrlPointIndex === 1) {
        result.x = p.cp1x;
        result.y = p.cp1y;
      } else {
        result.x = p.cp2x;
        result.y = p.cp2y;
      }
      return result;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by 
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {
      var p = this.points[segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {

      if (!this.length) {
        return;
      }

      var style = overrideStyle || this.style;

      ctx.dbId = this.id;
      ctx.lineStyle = style.lineStyle;
      ctx.isScreenSpace = style.isScreenSpace;

      ctx.beginPath();

      ctx.moveTo(this.points[0].x, this.points[0].y);

      for (var i = 1; i < this.points.length; i += 1) {
        // The segment start point defines the type (line or arc)
        var prev = this.points[i - 1];
        var p = this.points[i];

        if (prev.arcType === ArcType.Bezier) {
          ctx.bezierCurveTo(prev.cp1x, prev.cp1y, prev.cp2x, prev.cp2y, p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
      }

      // close path
      var pLast = this.points[this.points.length - 1];
      var pFirst = this.points[0];
      if (pLast.arcType === ArcType.Bezier) {
        ctx.bezierCurveTo(pLast.cp1x, pLast.cp1y, pLast.cp2x, pLast.cp2y, pFirst.x, pFirst.y);
      } else {
        ctx.lineTo(pFirst.x, pFirst.y);
      }

      ctx.closePath();

      var c = ctx.canvasContext;

      c.fillStyle = style.fillColor;
      c.globalAlpha = style.fillAlpha;

      ctx.fill();

      c.strokeStyle = style.lineColor;
      c.globalAlpha = style.lineAlpha;
      c.lineWidth = style.lineWidth;

      // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
      // For human eyes the line width is then the same width.
      if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

      ctx.stroke();

      // restore default values
      ctx.dbId = -1;
      ctx.lineStyle = 0;
      ctx.isScreenSpace = false;
    }

    // TODO: Consider arcs properly
  }, { key: "hitTest", value: function hitTest(x, y) {
      var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(this.points);

      // create dummy contour
      // TODO: Consider generalizing pointInContour() to make it usable for non-indexed polygons
      var contour = [];
      for (var i = 0; i < this.length; i++) {
        contour.push(i);
      }

      return cp.pointInContour(x, y, contour);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Path.prototype), "copy", this).call(this, from);

      // Copy extra information for arcs
      for (var i = 0; i < from.points.length; i++) {
        if (from.isBezierArc(i)) {
          var src = from.points[i];
          var dst = this.points[i];

          dst.arcType = src.arcType;
          dst.cp1x = src.cp1x;
          dst.cp1y = src.cp1y;
          dst.cp2x = src.cp2x;
          dst.cp2y = src.cp2y;
        }
      }
      return this;
    } }, { key: "toSVGPath", value: function toSVGPath()

    {var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!this.length) {
        return [];
      }

      var path = [];
      path.push("M ".concat(limitDigits(this.points[0].x, digits), ",").concat(limitDigits(this.points[0].y, digits)));
      for (var i = 1; i < this.points.length; i += 1) {
        // The segment start point defines the type (line or arc)
        var prev = this.points[i - 1];
        var p = this.points[i];
        var value = void 0;
        if (prev.arcType === ArcType.Bezier) {
          value = "C ".concat(limitDigits(prev.cp1x, digits), ",").concat(limitDigits(prev.cp1y, digits), ",").concat(limitDigits(prev.cp2x, digits), ",").concat(limitDigits(prev.cp2y, digits), ",").concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
        } else {
          var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].pointDelta(prev, p, digits);
          // skip empty/duplicate points
          if (!delta) {
            continue;
          }
          if (Math.abs(delta.x) <= precision) {
            value = "V ".concat(limitDigits(p.y, digits));
          } else if (Math.abs(delta.y) <= precision) {
            value = "H ".concat(limitDigits(p.x, digits));
          } else {
            value = "L ".concat(limitDigits(p.x, digits), ",").concat(limitDigits(p.y, digits));
          }
        }
        path.push(value);
      }

      // close path
      var pLast = this.points[this.points.length - 1];
      if (pLast.arcType === ArcType.Bezier) {
        var pFirst = this.points[0];
        var _value = "C ".concat(limitDigits(pLast.cp1x, digits), ",").concat(limitDigits(pLast.cp1y, digits), ",").concat(limitDigits(pLast.cp2x, digits), ",").concat(limitDigits(pLast.cp2y, digits), ",").concat(limitDigits(pFirst.x, digits), ",").concat(limitDigits(pFirst.y, digits));
        path.push(_value);
      }
      path.push('Z');

      return path;
    } }, { key: "move", value: function move(




















































































    dx, dy) {
      _get(_getPrototypeOf(Path.prototype), "move", this).call(this, dx, dy);

      // Move affected control points as well
      for (var i = 0; i < this.points.length; i++) {

        if (!this.isBezierArc(i)) {
          continue;
        }

        var p = this.points[i];
        p.cp1x += dx;
        p.cp1y += dy;
        p.cp2x += dx;
        p.cp2y += dy;
      }

      this.modified();
      return this;
    } }], [{ key: "_fromDOMNode", value: function _fromDOMNode(pathNode) {var d = pathNode.getAttribute('d');if (!d) {return;}var _Path$_parsePath = Path._parsePath(d),points = _Path$_parsePath.points,isPolygon = _Path$_parsePath.isPolygon;if (points.find(function (p) {return p.arcType !== undefined;})) {return new Path(points);} else if (isPolygon) {return new Polygon(points);}return new Polyline(points);} }, { key: "_parsePath", value: function _parsePath(svgPath) {// split at all chars but keep the char using positive look ahead
      // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
      // results into list with glyph with position array:
      // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
      var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);var validChars = "MLHVCZ";var previousPoint = { x: 0, y: 0 };var newPoint;var points = [];var isPolygon = false;for (var i = 0; i < pointStrings.length; i++) {var pointString = pointStrings[i];if (!validChars.contains(pointString[0])) {throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);}var value = pointString.substring(1);switch (pointString[0]) {case 'M':case 'L':var coords = value.split(',');newPoint = { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };if (pointString[0] === 'M') {// remove the initial 0,0 point
              points.shift();}break;case 'H':newPoint = { x: parseFloat(value), y: previousPoint.y };break;case 'V':newPoint = { x: previousPoint.x, y: parseFloat(value) };break;case 'C':var bezierCoords = value.split(',');newPoint = { x: parseFloat(bezierCoords[4]), y: parseFloat(bezierCoords[5]) };previousPoint.arcType = ArcType.Bezier;previousPoint.cp1x = parseFloat(bezierCoords[0]);previousPoint.cp1y = parseFloat(bezierCoords[1]);previousPoint.cp2x = parseFloat(bezierCoords[2]);previousPoint.cp2y = parseFloat(bezierCoords[3]);break;case 'Z': // we are done
            isPolygon = true;continue;}previousPoint = newPoint;points.push(newPoint);} // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
      // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
      var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].pointDelta(points[0], points[points.length - 1], 0);if (!delta) {points.pop(); // remove the duplicate last point which the same as the first point.
      }return { points: points, isPolygon: isPolygon };} }]);return Path;}(PolyBase);var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2); // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this2;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, style));_this2.polygon = new Polygon([], style);
    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this2.polygon.id = _this2.id;

    _this2.centerX = centerX;
    _this2.centerY = centerY;
    _this2.radius = radius;
    _this2.tessSegments = tessSegments;

    _this2.needsUpdate = true;return _this2;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "toSVG", value: function toSVG()

    {var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return "<svg xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"".concat(limitDigits(this.centerX, digits), "\" cy=\"").concat(limitDigits(this.centerY, digits), "\" r=\"").concat(limitDigits(this.radius, digits), "\"/></svg>");
    } }, { key: "computeBBox", value: function computeBBox()
























    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }], [{ key: "_fromDOMNode", value: function _fromDOMNode(circleNode) {if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {throw 'No attributes available on the <circle/> node';}var circle = new Circle();for (var i = circleNode.attributes.length - 1; i >= 0; i--) {var attr = circleNode.attributes[i];switch (attr.name) {case 'cx':circle.centerX = parseFloat(attr.value);break;case 'cy':circle.centerY = parseFloat(attr.value);break;case 'r':circle.radius = parseFloat(attr.value);break;}}return circle;} }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this3;_classCallCheck(this, ShapeWrapper);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ShapeWrapper).call(this));
    _this3.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this3), 'bbox', {
      get: function get() {return _this3.shape.bbox;},
      set: function set(bbox) {_this3.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this3), 'id', {
      get: function get() {return _this3.shape.id;},
      set: function set(id) {_this3.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this3), 'bboxDirty', {
      get: function get() {return _this3.shape.bboxDirty;},
      set: function set(dirty) {_this3.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this3), 'name', {
      get: function get() {return _this3.shape.name;},
      set: function set(name) {_this3.shape.name = name;} });return _this3;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

// Returns angle in radians formed by two direction vectors. No normalization required.
//  @param {Vector2} dir1, dir2
//  @returns {number} result in [0, 2*Pi]
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, true, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear };

/***/ }),

/***/ "./extensions/Edit2D/MeasureTransform.js":
/*!***********************************************!*\
  !*** ./extensions/Edit2D/MeasureTransform.js ***!
  \***********************************************/
/*! exports provided: MeasureTransform, DefaultMeasureTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeasureTransform", function() { return MeasureTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMeasureTransform", function() { return DefaultMeasureTransform; });
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// Workaround to choose a viewport for a given 2d sheet.
// 
// Actually, we should choose it based on 2d-position. But, F2D doesn't give us proper data to 
// do this. Also, even with proper viewport outlines, it wouldn't always unique as viewports may overlap.
// Therefore, we have to use a workaround here to make it use for simple single-viewport sheets at least.
//
// @returns {number|-1} Either -1 or a valid viewportId.
var chooseViewportId = function chooseViewportId(model) {

  var data = model.getData();
  var viewports = data.viewports;
  if (!viewports) {
    return -1;
  }

  // find viewport with maximum number of dbIds    
  var vpIndex = -1;
  var maxDbIds = -1;
  for (var i = 0; i < viewports.length; i++) {

    // Skip viewports without transform
    var vp = viewports[i];
    if (!vp.transform) {
      continue;
    }

    // Use current vp if it has most dbIds
    var numDbIds = vp.geom_metrics.db_ids;
    if (numDbIds > maxDbIds) {
      vpIndex = i;
      maxDbIds = numDbIds;
    }
  }

  return vpIndex;
};

// A MeasureTransform allows for doing length/area measurements in another coordinate system than the actual shape geometry.
// The transform is applied to all points before doing calculations.
var MeasureTransform = /*#__PURE__*/function () {function MeasureTransform() {_classCallCheck(this, MeasureTransform);}_createClass(MeasureTransform, [{ key: "apply",

    // @param {Vector2} p - Point to be transformed in-place.
    value: function apply(p) {} }]);return MeasureTransform;}();
;


// Sets the pageToModel transform in LMV as MeasureTransform to make measurements consistent with Measure extension.
var DefaultMeasureTransform = /*#__PURE__*/function (_MeasureTransform) {_inherits(DefaultMeasureTransform, _MeasureTransform);

  function DefaultMeasureTransform(viewer) {var _this;_classCallCheck(this, DefaultMeasureTransform);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(DefaultMeasureTransform).call(this));
    _this.viewer = viewer;return _this;
  }

  // Transform geometry point to the coordinate system in which measurements should be computed and displayed.
  //
  // @param {vector2} p
  //
  // Note: Currently, we do some simplifying assumptions here that may need additional
  //       work to support scenarios with multiple viewports or multiple 2d models.
  _createClass(DefaultMeasureTransform, [{ key: "apply", value: function apply(p) {
      // Get viewportId
      var model = this.viewer.model;
      if (!model) {
        return;
      }

      var vpId = chooseViewportId(model);

      // In case there are no viewports, there still might be a pageToModelTransform,
      // which we need to take into account. This is the case for raster PDF.
      model.pageToModel(p, null, vpId);
    } }]);return DefaultMeasureTransform;}(MeasureTransform);

/***/ }),

/***/ "./extensions/Edit2D/SegmentTree.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/SegmentTree.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SegmentTree; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // 
// SegmentTree is a spatial datastructure that helps to quickly find all segments (lines, arcs) within a given 2d bbox.
//

var SegmentType = {
  Line: 1,
  CircularArc: 2,
  EllipticalArc: 3 };


// A segment is an object that describes a single line or arc segment.
// Properties depend on segment type (see functions below)
var createLineSegment = function createLineSegment(x1, y1, x2, y2, vpId) {return { type: SegmentType.Line, x1: x1, y1: y1, x2: x2, y2: y2, vpId: vpId };};
var createCircularArcSegment = function createCircularArcSegment(cx, cy, start, end, radius, vpId) {return { type: SegmentType.CirularArc, cx: cx, cy: cy, start: start, end: end, radius: radius, vpId: vpId };};
var createEllipticalArcSegment = function createEllipticalArcSegment(cx, cy, start, end, major, minor, tilt, vpId) {return { type: SegmentType.EllipticalArc, cx: cx, cy: cy, start: start, end: end, major: major, minor: minor, tilt: tilt, vpId: vpId };};

// Triggers the corresponding callbacks (onLineSegment, onCircularArc...) from a given segment object.
//  @param {Object} s             - Segment object whose data are sent to geomCb
//  @param {Object} geomCallbacks - Provides handlers for different segments. Same as used by VertexBufferReader.
var processSegment = function processSegment(s, geomCallbacks) {
  switch (s.type) {
    case SegmentType.Line:geomCallbacks.onLineSegment(s.x1, s.y1, s.x2, s.y2, s.vpId);break;
    case SegmentType.CirularArc:geomCallbacks.onCircularArc(s.cx, s.cy, s.start, s.end, s.radius, s.vpId);break;
    case SegmentType.EllipticalArc:geomCallbacks.onEllipticalArc(s.cx, s.cy, s.tart, s.end, s.major, s.minor, s.tilt, s.vpId);break;}

};

// Implements required functions to allow organizing segments in a quadtree
var SegmentHandler = /*#__PURE__*/function () {

  function SegmentHandler() {_classCallCheck(this, SegmentHandler);

    // Used BoundsCallback to get segment bboxes
    this.boundsCb = new Autodesk.Viewing.Private.BoundsCallback(new THREE.Box2());

    // Reused tmp values
    this.queryBox = new THREE.Box2();
    this.tmpPoint = new THREE.Vector2();
  }_createClass(SegmentHandler, [{ key: "getSegmentBox", value: function getSegmentBox(

    segment) {
      this.boundsCb.bounds.makeEmpty();
      processSegment(segment, this.boundsCb);
      return this.boundsCb.bounds;
    } }, { key: "getQueryBox", value: function getQueryBox(

    minx, miny, maxx, maxy) {
      // get query box
      this.queryBox.min.set(minx, miny);
      this.queryBox.max.set(maxx, maxy);
      return this.queryBox;
    } }, { key: "intersectsBox", value: function intersectsBox(

    segment, minx, miny, maxx, maxy) {
      var queryBox = this.getQueryBox(minx, miny, maxx, maxy);
      var segmentBox = this.getSegmentBox(segment);
      return queryBox.isIntersectionBox(segmentBox);
    }

    // Note that outPoint is just an {x,y} pair, not a Vector2
  }, { key: "getPoint", value: function getPoint(segment, outPoint) {
      // Just use bbox center for all segment types
      var center = this.getSegmentBox(segment).center(this.tmpPoint);
      outPoint.x = center.x;
      outPoint.y = center.y;
    } }]);return SegmentHandler;}();var


SegmentTree = /*#__PURE__*/function () {function SegmentTree() {_classCallCheck(this, SegmentTree);}_createClass(SegmentTree, [{ key: "buildFromModel",

    // Build SegmentTree from 2D vector-data model (PDF or F2D).
    // Note: Make sure that the model is fully loaded - otherwise, the tree will be incomplete.
    value: function buildFromModel(model) {

      // The quadtree must know the extents in advance.
      var box = model.getBoundingBox();

      // Init quadtree that manages segments
      this.tree = new Autodesk.Extensions.CompGeom.QuadTree(box.min.x, box.min.y, box.max.x, box.max.y, 0.0, new SegmentHandler());

      // Add geomtry for all fragments
      var frags = model.getFragmentList();
      var count = frags.getCount();
      for (var i = 0; i < count; i++) {
        var geom = frags.getGeometry(i);
        this.addGeometry(geom);
      }
    }

    // Adds all segments from a given 2D LineShader geometry.
    //  @param {BufferGeometry} geom
    //
    // Precondition: Can only be called if tree has been initialized and geom is within the bbox used to initialize the tree
  }, { key: "addGeometry", value: function addGeometry(geom) {var _this = this;

      // GeometryCallback that just collects all segments as objects and adds them to the tree
      var collectSegment = {
        onLineSegment: function onLineSegment() {return _this.tree.addItem(createLineSegment.apply(void 0, arguments));},
        onCircularArc: function onCircularArc() {return _this.tree.addItem(createCircularArcSegment.apply(void 0, arguments));},
        onEllipticalArc: function onEllipticalArc() {return _this.tree.addItem(createEllipticalArcSegment.apply(void 0, arguments));} };


      var vbr = new Autodesk.Viewing.Private.VertexBufferReader(geom);
      vbr.enumGeoms(null, collectSegment);
    }

    //  @param {Object} geomCallbacks - Visitor that provides callbacks to handle different segments. Same as used by VertexBufferReader.
  }, { key: "enumSegments", value: function enumSegments(minx, miny, maxx, maxy, geomCallbacks) {

      // Find all segments in the tree and invoke corresponding call on GeometryCallback
      this.tree.enumInBox(minx, miny, maxx, maxy, function (s) {return processSegment(s, geomCallbacks);});
    } }]);return SegmentTree;}();

/***/ }),

/***/ "./extensions/Edit2D/Selection.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Selection.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;var

Selection = /*#__PURE__*/function () {

  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);

    av.EventDispatcher.prototype.apply(this);

    // Keys: shapeIds, Values: shapes
    this.isSelected = {};

    // Reused as temporary override style for shapes
    this.tmpStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();

    // Callback function that controls how to modify the style on selected shapes
    this.modifier = function (shape, style) {
      // only modify style for selected shapes
      if (!_this.isSelected[shape.id]) {
        return undefined;
      }

      // Create a tmp copy of the initial shape style that is modified to indicate highlighting
      _this.tmpStyle.copy(style);

      _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);
      _this.tmpStyle.lineWidth *= 1.5;

      return _this.tmpStyle;
    };

    this.layer = layer;

    this.layer.addStyleModifier(this.modifier);

    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone
    // or a RemoveShape action happened.
    this.undoStack = undoStack;
    this.onActionCb = function (a) {return _this.onAction(a);};
    this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
  }_createClass(Selection, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeStyleModifier(this.modifier);
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    }

    // @param {Shape[]) shapes
  }, { key: "setSelection", value: function setSelection(shapes) {

      // This works for null as well (unlike ES6 default params)
      shapes = shapes || [];

      var selected = this.getSelectedShapes();

      // Check if the set of ids changed
      var changed = false;
      if (selected.length != shapes.length) {
        changed = true;
      } else {
        // Check if any new shape was not selected before
        for (var i = 0; i < shapes.length; i++) {
          var shape = shapes[i];
          if (!this.isSelected[shape.id]) {
            changed = true;
          }
        }
      }

      if (!changed) {
        return;
      }

      // Add all shapes to this.isSelected
      this.isSelected = {};
      for (var _i = 0; _i < shapes.length; _i++) {
        var _shape = shapes[_i];
        this.isSelected[_shape.id] = _shape;
      }
      this.modified();
    } }, { key: "empty", value: function empty()

    {
      return !Object.keys(this.isSelected).length;
    }

    // Set selection to a single shape. Calling with null clears the selection.
  }, { key: "selectOnly", value: function selectOnly(shape) {
      this.setSelection(shape && [shape]);
    } }, { key: "clear", value: function clear()

    {
      this.setSelection([]);
    }

    // Passes all selected shapes to the callback
  }, { key: "getSelectedShapes", value: function getSelectedShapes() {
      return Object.values(this.isSelected);
    } }, { key: "getSelectedIds", value: function getSelectedIds()

    {
      return Object.keys(this.isSelected);
    } }, { key: "modified", value: function modified()

    {
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });
    } }, { key: "onAction", value: function onAction()

    {

      if (this.empty()) {
        return;
      }

      // Single-selection: Clear selection if selected shape has gone
      var selected = this.getSelectedShapes();
      if (selected.length == 1) {
        var exists = this.layer.findShapeById(selected[0].id);
        if (!exists) {
          this.clear();
        }
        return;
      }

      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections

      // Create dictionary of all shapes in the layer
      var shapeIdExists = {};
      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});

      // Clear all shapes from selection that don't exist anymore
      selected = selected.filter(function (s) {return shapeIdExists[s.id];});
      this.setSelection(selected);
    } }]);return Selection;}();


Selection.Events = {
  SELECTION_CHANGED: 'selectionChanged' };

/***/ }),

/***/ "./extensions/Edit2D/TangentGizmo.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/TangentGizmo.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TangentGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // A tangent gizmo is a dashed line with two vertex gizmos at the end.
// It is used to control tangents for Bezier arcs.





var tangentGizmoName = function tangentGizmoName(vertexIndex, sideIndex) {
  return "TangentGizmo-$vertexIndex-$sideIndex";
};

// Indicates which endpoint of the tangent is being dragged
var DragIndex = {
  None: -1, // Nothing dragged
  Start: 0, // Dragging start point
  End: 1 // Dragging end point
};var

TangentGizmo = /*#__PURE__*/function () {

  function TangentGizmo(path, index, layer, gizmoLayer) {_classCallCheck(this, TangentGizmo);

    this.path = path;
    this.gizmoLayer = gizmoLayer;
    this.layer = layer;

    // index of the vertex whose tangent we control
    this.index = index;

    // dashed tangent line
    this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]();
    this.lineVisible = false;

    // configure style of dashed line
    this.line.style.isScreenSpace = true;
    this.line.style.lineColor = 'rgb(255, 0, 255)',
    this.line.style.lineWidth = 1.0,
    this.line.style.lineStyle = 10;
    this.line.style.lineAlpha = 1.0;

    // VertexGizmos at both ends of the tangent line
    this.vertexGizmo1 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, 1));
    this.vertexGizmo2 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, 2));

    // Hide vertex gizmos until we have proper positions
    this.vertexGizmo1.setVisible(false);
    this.vertexGizmo2.setVisible(false);

    // Start/end vertex of tangent Gizmo
    this.pStart = new THREE.Vector2();
    this.pEnd = new THREE.Vector2();

    // Add this to main layer. This triggers this.update() on layer updates to respond to
    // vertex position changes.
    this.layer.addCanvasGizmo(this);

    // 0: dragging startPoint, 1: dragging endPoint, 2: nothing dragged
    this.dragIndex = DragIndex.None;

    // Last tracked dragging position for currently dragged vertex
    this.lastDragPos = new THREE.Vector2(); // in layer coords

    // When dragging vertices, we store the offset (in layer-coords) between 
    // the accurate click position and the center of the clicked vertex gizmo
    this.dragOffset = new THREE.Vector2(0, 0); // in pixels

    this.update();
  }_createClass(TangentGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
      this.layer.removeCanvasGizmo(this);
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      this.vertexGizmo1.setVisible(visible);
      this.vertexGizmo2.setVisible(visible);

      // Show/Hide tangent line gizmo
      if (visible !== this.lineVisible) {
        if (visible) {
          this.gizmoLayer.addShape(this.line);
        } else {
          this.gizmoLayer.removeShape(this.line);
        }
      }
      this.lineVisible = visible;
    } }, { key: "update", value: function update()

    {

      // get index of previous edge (ending at the vertex)
      var prevIndex = this.path.prevIndex(this.index);

      // Check which of the adjacent edges are arcs
      var prevIsArc = this.path.isBezierArc(prevIndex);
      var nextIsArc = this.path.isBezierArc(this.index);

      // If none of the edges is an Arc, just hide all gizmos
      if (!prevIsArc && !nextIsArc) {
        this.setVisible(false);
        return;
      }

      // Compute both endpoints of tangent gizmo
      var p = this.path.points[this.index];
      if (nextIsArc) {

        // End point is first control point of the arc starting at p            
        this.pEnd.set(p.cp1x, p.cp1y);

        // In general, the start point would be cp2 of the previous arc. 
        // But, we enforce tangents to be identical for previous edge and next edge.
        // Therefore, we obtain the other endpoint by mirroring the tangent of the leaving edge
        // on point p
        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pEnd, p, this.pStart);
      } else {
        // Only previous edge is an arc: We have to obtain the tangent from
        // control point 2 of the previous edge.
        var pPrev = this.path.points[prevIndex];
        this.pStart.set(pPrev.cp2x, pPrev.cp2y);

        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pStart, p, this.pEnd);
      }

      // update vertex gizmos
      this.vertexGizmo1.setPosition(this.pStart.x, this.pStart.y);
      this.vertexGizmo2.setPosition(this.pEnd.x, this.pEnd.y);

      // update line gizmo
      this.line.makeLine(this.pStart.x, this.pStart.y, this.pEnd.x, this.pEnd.y);
      this.gizmoLayer.update();

      this.setVisible(true);
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "setTangentEndPoints", value: function setTangentEndPoints(pStart, pEnd) {

      // Set start point: This is cp2 of previous arc segment (if any)
      var prevIndex = this.path.prevIndex(this.index);
      if (this.path.isBezierArc(prevIndex)) {
        this.path.updateControlPoint(prevIndex, 2, pStart.x, pStart.y);
      }

      // Set end point: This is cp1 of current segment
      if (this.path.isBezierArc(this.index)) {
        this.path.updateControlPoint(this.index, 1, pEnd.x, pEnd.y);
      }

      // update gizmos
      this.update();
    }

    // @param {Vector2} newPos - new position in layer coords
  }, { key: "onStartVertexMoved", value: function onStartVertexMoved(startPos) {
      // get new tangent end point by mirroring on vertex position
      var center = this.path.getPoint(this.index);
      var endPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(startPos, center);

      this.setTangentEndPoints(startPos, endPos);
    }

    // @param {Vector2} startPos - new position in layer coords
  }, { key: "onEndVertexMoved", value: function onEndVertexMoved(endPos) {
      // get new tangent start point by mirroring on vertex position
      var center = this.path.getPoint(this.index);
      var startPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(endPos, center);

      this.setTangentEndPoints(startPos, endPos);
    }

    // @param {DragIndex} dragIndex
  }, { key: "startDrag", value: function startDrag(canvasX, canvasY, dragIndex) {

      this.dragIndex = dragIndex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = dragIndex === DragIndex.Start ? this.pStart : this.pEnd;
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - canvasX, vposScreen.y - canvasY);

      this.lastDragPos.copy(vpos);
    }

    // process last position and finish dragging
  }, { key: "endDrag", value: function endDrag(canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);
      this.dragIndex = DragIndex.None;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      // Compute canvas position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Move tangent vertex by dx/dy
      if (this.dragIndex === DragIndex.Start) {
        this.onStartVertexMoved(p);
      } else if (this.dragIndex === DragIndex.End) {
        this.onEndVertexMoved(p);
      }

      this.layer.update();
    }

    // @returns {bool} true if dragging started
  }, { key: "onButtonDown", value: function onButtonDown(canvasX, canvasY) {

      var startDragged = this.vertexGizmo1.isUnderMouse;
      var endDragged = this.vertexGizmo2.isUnderMouse;

      if (!startDragged && !endDragged) {
        return false;
      }

      var dragIndex = startDragged ? DragIndex.Start : DragIndex.End;
      this.startDrag(canvasX, canvasY, dragIndex);

      return true;
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.dragIndex !== DragIndex.None;
    } }]);return TangentGizmo;}();
;

/***/ }),

/***/ "./extensions/Edit2D/UndoStack.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/UndoStack.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoStack; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;var

UndoStack = /*#__PURE__*/function () {

  function UndoStack() {_classCallCheck(this, UndoStack);

    av.EventDispatcher.prototype.apply(this);

    // Array of action objects
    this.stack = [];

    // By default, this simply points to the end of this.stack. Only if undo has been called, 
    // it points to the next operation to be run on a redo() call
    this.current = 0;
  }

  // Executes an action and pushes it to the undo stack
  _createClass(UndoStack, [{ key: "run", value: function run(action) {
      // If we did a couple of undos before, a new operation will clear all redo steps
      this.stack.length = this.current;

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });

      this.stack.push(action);
      this.current = this.stack.length;
    } }, { key: "undo", value: function undo()

    {
      if (!this.current) {
        // We reached the beginning of the stack
        return false;
      }
      this.current--;

      var action = this.stack[this.current];

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });

      action.undo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });

      action.layer.update();

      return true;
    } }, { key: "redo", value: function redo()

    {
      var action = this.stack[this.current];
      if (!action) {
        // Nothing to redo
        return false;
      }

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });

      this.current++;

      action.layer.update();

      return true;
    } }, { key: "clear", value: function clear()

    {
      this.stack.length = 0;
      this.current = 0;
    } }]);return UndoStack;}();


// Events sent before/after any action is executed by UndoStack
UndoStack.BEFORE_ACTION = 'beforeAction';
UndoStack.AFTER_ACTION = 'afterAction';

/***/ }),

/***/ "./extensions/Edit2D/UnitHandler.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/UnitHandler.js ***!
  \******************************************/
/*! exports provided: UnitHandler, SimpleUnitHandler, DefaultUnitHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitHandler", function() { return UnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleUnitHandler", function() { return SimpleUnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUnitHandler", function() { return DefaultUnitHandler; });
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var avp = Autodesk.Viewing.Private;

// Interface to control display of length/area units.
var UnitHandler = /*#__PURE__*/function () {

  function UnitHandler() {_classCallCheck(this, UnitHandler);
    // Optional: Returns a transform that is applied to all points for length/area calculations.
    //  @returns {MeasureTransform}
    this.measureTransform = null;
  }

  // @param   {number} val - length in layer coords
  // @returns {string} String to display, including units.
  _createClass(UnitHandler, [{ key: "lengthToString", value: function lengthToString(val) {
      console.error('Not implemented');
    }

    // @param   {number} val - area in layer coords
    // @returns {string} String to display - including units.
  }, { key: "areaToString", value: function areaToString(val) {
      console.error('Not implemented');
    } }]);return UnitHandler;}();
;

// If nothing is specified, we display with 2 digits and assume all unit in inches.
var DefaultPrecision = 2;
var DefaultUnits = "inch";

// Format length / area strings based on:
//  - layerUnits:  We assume the layer to be specified in these units.
//  - displayUnit: Values are converted from layerUnits to displayUnits for display
//  - precision:   Number of digits shown
//  - scaleFactor: Optional scale factor applied to all values
var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);

  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleUnitHandler).call(this));

    _this.viewer = viewer;

    _this.config = {
      // {string} We assume layers to be in these units (in GNU units format)
      layerUnits: DefaultUnits,

      // {string} Units in which we display lengths/areas (in GNU units format)
      displayUnits: DefaultUnits,

      // {number} Number of digits that we display
      precision: DefaultPrecision,

      // {number} Optional scale factor applied to all values
      scaleFactor: 1.0 };return _this;

  }_createClass(SimpleUnitHandler, [{ key: "lengthToString", value: function lengthToString(

    val) {
      var cfg = this.config;

      // Convert length units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);

      // Format length value with unit string
      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      var cfg = this.config;

      // Convert area units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');

      // Format length value with unit string
      var units = cfg.displayUnits ? "".concat(cfg.displayUnits, "^2") : null;
      return avp.formatValueWithUnits(val, units, 3, cfg.precision);
    } }]);return SimpleUnitHandler;}(UnitHandler);


// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model 
// and current settings from MeasureToolExtension:
//  - If MeasureExtension is loaded, it displays in the same way as Measure tools
//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.
//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)
var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);

  function DefaultUnitHandler(viewer) {var _this2;_classCallCheck(this, DefaultUnitHandler);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DefaultUnitHandler).call(this, viewer));

    _this2.measureTransform = new _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__["DefaultMeasureTransform"](viewer);return _this2;
  }_createClass(DefaultUnitHandler, [{ key: "updateConfig", value: function updateConfig()

    {
      var cfg = this.config;

      // Assume values to be in model units or default units
      var model = this.viewer.model;
      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;

      // Set other configuration values
      var ext = this.viewer.getExtension('Autodesk.Measure');
      var msrCfg = ext && ext.sharedMeasureConfig;
      if (msrCfg) {
        // get from measure extension
        cfg.displayUnits = msrCfg.units;
        cfg.precision = msrCfg.precision;
        cfg.scaleFactor = msrCfg.calibrationFactor;
      } else {
        // No Measure extension available => use defaults
        cfg.displayUnits = this.config.layerUnits;
        cfg.precision = DefaultPrecision;
        cfg.scaleFactor = 1.0;
      }
    } }, { key: "lengthToString", value: function lengthToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "areaToString", this).call(this, val);
    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);

/***/ }),

/***/ "./extensions/Edit2D/tools/CopyTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/CopyTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var CopyToolName = 'Edit2_CopyTool';

var av = Autodesk.Viewing;

// Apply constant offset in x/y for each paste step, so that shape copies are not exactly on top of the src shapes.
var PasteOffset = 30;var

CopyTool = /*#__PURE__*/function () {

  function CopyTool(ctx) {_classCallCheck(this, CopyTool);

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // {Shape[]}
    this.clipBoard = [];

    // After copying some shapes, this counts the number of times that we paste those.
    this.pasteCounter = 0;
  }_createClass(CopyTool, [{ key: "copy", value: function copy()

    {
      this.clipBoard.length = 0;

      var shapes = this.selection.getSelectedShapes();

      // Store the original shapes that get copied for event handlers
      this.originalShapes = shapes;

      // Remember selected shapes
      this.clipBoard = shapes.slice();

      // Reset paste counter
      this.pasteCounter = 0;
    } }, { key: "paste", value: function paste()

    {

      // Track how often we pasted the same clipboard content
      this.pasteCounter++;

      // Compute how far we want to shift the copy that we create.
      // On first paste, we shift by 30pixels, then by 60 etc.
      var offset = this.pasteCounter * PasteOffset * this.layer.getUnitsPerPixel();

      // Insert copies of shapes in the clipboard (+ add offset per paste steps)
      var shapes = [];

      var eventArgs = { type: CopyTool.BEFORE_PASTE, originalShapes: this.originalShapes, veto: false };
      this.dispatchEvent(eventArgs);
      if (eventArgs.veto) {
        return;
      }

      for (var i = 0; i < this.clipBoard.length; i++) {
        var newShape = this.clipBoard[i].clone();

        // Apply offset before cloning, so that another paste will add another offset
        newShape.move(offset, offset);

        // Insert copy
        shapes.push(newShape);
      }

      // Change selection to new shapes
      this.selection.setSelection(shapes);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].AddShapes(this.layer, shapes));

      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, originalShapes: this.originalShapes, shapes: shapes });
    }

    // delete all selected shapes
  }, { key: "delete", value: function _delete() {
      var shapes = this.selection.getSelectedShapes();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
      this.selection.clear();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (!this.selection.empty()) {
        if (keyCode === av.KeyCode.DELETE) {
          this["delete"]();
          return true;
        }

        if (event.ctrlKey && keyCode === av.KeyCode.c) {
          this.copy();
          return true;
        }
      }

      if (this.clipBoard.length !== 0) {
        if (event.ctrlKey && keyCode === av.KeyCode.v) {
          this.paste();
          return true;
        }
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return CopyToolName + this.nameSuffix;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return CopyTool;}();
;

CopyTool.BEFORE_PASTE = "BEFORE_PASTE";
CopyTool.AFTER_PASTE = "AFTER_PASTE";

/***/ }),

/***/ "./extensions/Edit2D/tools/EditToolBase.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EditToolBase.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditToolBase; });
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var av = Autodesk.Viewing;


// Utility class shared by Edit2D tools to facilitate snapping
var EditToolBase = /*#__PURE__*/function () {

  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);

    this.viewer = ctx.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.snapper = ctx.snapper;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.unitHandler = ctx.unitHandler;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.
    this.ignoreDragging = false;

    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.
    this.ignoreActions = false;

    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.
    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.
    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. 
    this.onActionCb = function (a) {
      if (!_this.ignoreActions) {
        _this.handleExternalAction(a);
      }
    };

    // indicates if snapping is currently suppressed by hold modifier key
    this.suppressSnapping = false;

    this.keyMap = {
      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping
      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in
    };

    // When using selection, register a handler to notify about selection changed
    if (this.selection) {
      this.selectionCb = function () {

        // Only respond if tool is activated
        if (!_this.active) {
          return;
        }

        // Call handler if derived class defines one
        _this.onSelectionChanged && _this.onSelectionChanged();
      };

      this.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
    }

    this.active = false;

    // Track last mouse position in canvas coords. Note that derived classes must call
    // the base class mouse handlers to keep this value valid.
    this.canvasPos = new THREE.Vector2();

    // Track which keys are currently hold down
    this.keyState = {
      ctrl: false,
      shift: false,
      alt: false };

  }_createClass(EditToolBase, [{ key: "getSnapPosition", value: function getSnapPosition(

    canvasX, canvasY) {var _this2 = this;
      var useSnapper = this.snapper && !this.suppressSnapping;
      if (useSnapper) {
        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});
      } else {
        // Make sure that we don't keep outdated snapping gizmos
        this.snapper.clearSnappingGizmos();

        // Just convert canvas pos to layer pos
        return this.layer.canvasToLayer(canvasX, canvasY);
      }
    } }, { key: "dtor", value: function dtor()

    {
      if (this.selectionCb) {
        this.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
      }
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      this.keyState[keyCode] = true;

      // Hold key to suppress snapping
      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {
        this.suppressSnapping = true;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise
      // the customer might lose his drawings when he's in an editing session, does a invalid selection and
      // hits backspace.
      if (keyCode === av.KeyCode.BACKSPACE) {
        return true;
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = true;
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {

      this.keyState[keyCode] = false;

      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {
        this.suppressSnapping = false;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = false;
      }
    }

    // Invoked whenever another tool triggered 
  }, { key: "handleExternalAction", value: function handleExternalAction(action) {}

    // Run an action without triggering handleExternalAction
  }, { key: "runAction", value: function runAction(action) {
      this.ignoreActions = true;
      this.undoStack.run(action);
      this.ignoreActions = false;
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

      // Make sure we don't keep outdated snapping indicators
      this.snapper && this.snapper.clearSnappingGizmos();
    } }, { key: "register", value: function register()

    {}

    // Maps a key event to a function key in the key-map.
  }, { key: "mapKey", value: function mapKey(event, keyMap) {

      for (var key in keyMap) {
        var assigned = keyMap[key];

        // If a single key is assigned to this function and it matches, return the function key
        if (event.keyCode == assigned) {
          return key;
        }

        // If multiple keys are assigned, check if one matches.
        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {
          return key;
        }
      }
      // event does not match any assigned keyCode
      return null;
    } }, { key: "snappingFilter",

    // By default, we consider all EditShapes for snapping
    value: function snappingFilter() {
      return true;
    }

    // Remember last mouse position
  }, { key: "trackMousePos", value: function trackMousePos(e) {
      this.canvasPos.set(e.canvasX, e.canvasY);
    } }, { key: "handleMouseMove", value: function handleMouseMove(
    e) {this.trackMousePos(e);} }, { key: "handleSingleClick", value: function handleSingleClick(
    e) {this.trackMousePos(e);} }, { key: "handleDoubleClick", value: function handleDoubleClick(
    e) {this.trackMousePos(e);} }, { key: "handleButtonUp", value: function handleButtonUp(
    e) {this.trackMousePos(e);} }, { key: "handleButtonDown", value: function handleButtonDown(
    e) {this.trackMousePos(e);} }]);return EditToolBase;}();
;

av.GlobalManagerMixin.call(EditToolBase.prototype);

/***/ }),

/***/ "./extensions/Edit2D/tools/InsertSymbolTool.js":
/*!*****************************************************!*\
  !*** ./extensions/Edit2D/tools/InsertSymbolTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InsertSymbolTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}



var InsertSymbolToolName = "Edit2_InsertSymbolTool";var

InsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);

  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(InsertSymbolTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.symbol = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"](0, 0,
    0.2,
    new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      fillAlpha: 1.0,
      lineWidth: 0.01,
      fillColor: 'rgb(255, 255, 0)' }));return _this;

  }_createClass(InsertSymbolTool, [{ key: "getName", value: function getName()

    {
      return InsertSymbolToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "setSymbol", value: function setSymbol(

    symbol) {
      this.symbol = symbol;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event) {

      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var symbol = this.symbol.clone();
      symbol.move(res.x, res.y);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, symbol));

      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });

      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      return true;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return InsertSymbolTool;}(_EditToolBase__WEBPACK_IMPORTED_MODULE_2__["default"]);


InsertSymbolTool.SYMBOL_INSERTED = "symbolInserted";

/***/ }),

/***/ "./extensions/Edit2D/tools/LineTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/LineTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CanvasGizmo */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var LineToolName = "Edit2_LineTool";

var av = Autodesk.Viewing;

// Draws lines with single drag
var LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);

  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, LineTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineTool).call(this, ctx));

    _this.style = style;

    // New polyline created by dragging
    _this.line = null;

    // Start/Endpoint of the line being dragged
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);return _this;
  }

  // Enable the length labels (public API)
  _createClass(LineTool, [{ key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return LineToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Make sure that we consider latest end-coords
      this.handleMouseMove(event);

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.line) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([startPos.clone(), startPos.clone()], this.style.clone());
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.line);
    } }, { key: "updateLine", value: function updateLine()

    {

      if (!this.isDragging()) {
        return;
      }

      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);
      this.gizmoLayer.update();

      this.lengthLabel.setShape(this.line);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateLine();
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.line) {
        return false;
      }

      // Remove temporary gizmo shape
      this.gizmoLayer.removeShape(this.line);

      // Add line shape if valid
      var lineValid = !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].edgeIsDegenerated(this.startPoint, this.endPoint);
      if (lineValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.line));
      }

      this.line = null;

      this.lengthLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.line) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.line);
        this.line = null;

        this.dragCanceled = true;

        this.lengthLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.line);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(false);
      }
    } }]);return LineTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/MoveTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/MoveTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var MoveToolName = "Edit2_MoveTool";

var av = Autodesk.Viewing;var

MoveTool = /*#__PURE__*/function () {

  function MoveTool(ctx) {_classCallCheck(this, MoveTool);

    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // Only set during dragging
    this.shape = null;

    // drag-start position in layer coords
    this.dragStartPoint = new THREE.Vector2();

    // backup original shape on drag-start as long as we are modifying it on-hover
    this.backupShape = null;

    this.keyMap = {
      CancelEdit: av.KeyCode.ESCAPE };


    // Remember last mouse-pos on mouse-move events
    this.lastMousePos = new THREE.Vector2(); // in layer coords
  }_createClass(MoveTool, [{ key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return MoveToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var hitShape = this.layer.hitTest(p.x, p.y);

      if (hitShape) {
        this.startDrag(hitShape, p);
      }

      // Set selection to the shape that we picked
      if (this.shape) {
        this.selection.selectOnly(this.shape);
      } else {
        this.selection.clear();
      }

      return Boolean(this.shape);
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(shape, startPos) {
      this.shape = shape;
      this.dragStartPoint.copy(startPos);
      this.backupShape = shape.clone();
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p) {
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      // Apply this offset to shape. We always start with the original shape as a reference 
      // to avoid accumulating delta inaccuracies.
      this.shape.copy(this.backupShape);
      this.shape.move(dx, dy);
      this.layer.update();
    }

    // Clean up data hold during a drag interaction
  }, { key: "resetDragging", value: function resetDragging() {
      this.shape = null;
      this.backupShape = null;
    } }, { key: "endDrag", value: function endDrag(

    p) {
      // No drag active
      if (!this.shape) {
        return;
      }

      // Revert any temporary modifications done during mouse move
      this.shape.copy(this.backupShape);

      // Apply move operation
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveShape(this.layer, this.shape, dx, dy));

      if (this.shape) {
        this.shape = null;
        return true;
      }
      return false;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.isDragging()) {

        // Revert shape o state when dragging was started
        this.shape.copy(this.backupShape);
        this.layer.update();

        this.resetDragging();
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.shape);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get and store latest mouse position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.lastMousePos.copy(p);

      if (!this.shape) {
        return false;
      }

      // get delta between last and current position        
      this.moveDrag(p);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.endDrag(p);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
      }
    }

    // Display move cursor if a shape is under mouse or if we are dragging
  }, { key: "getCursor", value: function getCursor() {
      if (this.shape) {
        return 'move';
      }

      // Show move cursor if a shape is under mouse
      var shapeAtMouse = this.layer.hitTest(this.lastMousePos.x, this.lastMousePos.y);
      return shapeAtMouse ? 'move' : undefined;
    } }]);return MoveTool;}();

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonEditTool.js":
/*!****************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonEditTool.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonEditTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _MoveTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}








var PolygonEditToolName = 'Edit2_PolygonEditTool';

var av = Autodesk.Viewing;

// Allow to pick an edge within 
var EdgeSelectTolerance = 17;

var vertexGizmoName = function vertexGizmoName(index) {
  return 'PolygonEditTool_vertexGizmo_' + index.toString();
};

var edgeGizmoName = function edgeGizmoName(index) {
  return 'PolygonEditTool_edgeGizmo_' + index.toString();
};

var updateVertexGizmoNames = function updateVertexGizmoNames(vertexGizmos) {
  for (var i = 0; i < vertexGizmos.length; i++) {
    var gizmo = vertexGizmos[i];
    gizmo.name = vertexGizmoName(i);
    gizmo.update(false); // Make sure that the shapes get the name immediately - we don't need a layer update for this.
  }
};

// Return 2D edge normal
var getLeftEdgeNormal = function getLeftEdgeNormal(poly, edgeIndex, target) {
  // get start/end point of the edge
  var vi1 = edgeIndex;
  var vi2 = (edgeIndex + 1) % poly.length;
  var v1 = poly.getPoint(vi1);
  var v2 = poly.getPoint(vi2);

  // get edge direction
  target.subVectors(v2, v1).normalize();

  // rotate by 90 degrees
  var tmp = target.x;
  target.x = -target.y;
  target.y = tmp;

  return target;
};var

PolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);

  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonEditTool).call(this, ctx));

    _this.moveTool = new _MoveTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx);

    // Only set during dragging
    _this.poly = null;

    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();

    // Circles around each vertex
    _this.vertexGizmos = [];

    // Index of the vertex currently being dragged (or -1 if no dragging is active)
    _this.draggedVertex = -1;

    // When dragging a vertex, this stores a copy of its original position
    _this.dragVertexStartPos = new THREE.Vector2();

    // When dragging an edge, this stores a copy of its original position
    _this.dragEdgeStartPos = {
      a: new THREE.Vector2(),
      b: new THREE.Vector2() };


    // Index of the edge being dragged or -1
    _this.draggedEdge = -1;

    // Reused to store edge normal of dragged edge
    _this.draggedEdgeNormal = new THREE.Vector2();

    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex, 
    // but (unlike draggedVertex) keeps the same after dragEnd.
    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.
    _this.selectedVertex = -1;

    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.
    _this.edgeGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]();
    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer

    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;
    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // {EdgeGizmo[]} Array of Gizmos used for moving edges. 
    _this.edgeGizmos = [];

    // {TangentGizmo[]} Array of TangentGizmos for BezierArcs
    _this.tangentGizmos = [];return _this;
  }

  // Enable the area labels (public API)
  _createClass(PolygonEditTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return PolygonEditToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "deactivate", this).call(this);
      this.reset();
    } }, { key: "createVertexGizmos", value: function createVertexGizmos()

    {
      for (var i = 0; i < this.poly.points.length; i++) {
        // create new vertex gizmo
        var p = this.poly.points[i];
        var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, vertexGizmoName(i), this.poly.style);
        this.vertexGizmos.push(vertex);

        // We implement drag-behavior, so we want hover-highlight
        vertex.setHoverEnabled(true);
      }
    }

    // Make sure that VertexGizmos reflect latest state of the shape
  }, { key: "updateVertexGizmos", value: function updateVertexGizmos() {
      var vertexCount = this.poly ? this.poly.length : 0;

      // If just the positions changed (e.g. while moving the shape), we just update the positions.
      var p = new THREE.Vector2();
      if (vertexCount == this.vertexGizmos.length) {
        for (var i = 0; i < vertexCount; i++) {
          this.poly.getPoint(i, p);
          this.vertexGizmos[i].setPosition(p.x, p.y);
        }
      } else {
        // just re-create all VertexGizmos
        this.clearVertexGizmos();
        this.createVertexGizmos();
      }
    } }, { key: "clearVertexGizmos", value: function clearVertexGizmos()

    {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    } }, { key: "clearEdgeGizmos", value: function clearEdgeGizmos()

    {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        this.edgeGizmos[i].dtor();
      }
      this.edgeGizmos.length = 0;
    }

    // Update edgeGizmos to this.poly or hide all if poly is null
  }, { key: "createEdgeGizmos", value: function createEdgeGizmos() {
      // Make sure that we don't leak outdated ones
      this.clearEdgeGizmos();

      // Create gizmo per edge
      var edgeCount = this.poly ? this.poly.getEdgeCount() : 0;
      for (var i = 0; i < edgeCount; i++) {
        var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["EdgeMoveGizmo"](this.layer, edgeGizmoName(i));
        gizmo.attachToEdge(this.poly, i);
        this.edgeGizmos.push(gizmo);
      }
    }

    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)
  }, { key: "updateVertexHighlighting", value: function updateVertexHighlighting() {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].setSelected(i === this.selectedVertex);
      }
    } }, { key: "setSelectedVertex", value: function setSelectedVertex(

    index) {
      this.selectedVertex = this.poly ? index : -1;
      this.updateVertexHighlighting();
    }

    // Returns the index of the vertex gizmo at the given position (or -1 if no vertexGizmo is hit)
  }, { key: "getVertexIndex", value: function getVertexIndex(x, y) {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        var gizmo = this.vertexGizmos[i];
        if (gizmo.isUnderMouse) {
          return i;
        }
      }
      return -1;
    }

    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)
    // (x,y) are in layer-coords
  }, { key: "getEdgeIndex", value: function getEdgeIndex(x, y) {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        if (this.edgeGizmos[i].isUnderMouse) {
          return i;
        }
      }
      return -1;
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      // Clear any gizmos from previous polygon
      this.clearVertexGizmos();
      this.clearEdgeGizmos();
      this.clearTangentGizmos();

      // Cleanup area and length labels
      this.areaLabel.setShape(null);
      this.lengthLabel.setShape(null);

      this.poly = null;
      this.draggedVertex = -1;
      this.selectedVertex = -1;

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.createVertexGizmos();
        this.createEdgeGizmos();
        this.createTangentGizmos();
      }

      // Sync label with polygon or polyline. If this.poly is null, it will be hidden
      var polygon = poly && poly.isPolygon() ? poly : null;
      this.areaLabel.setShape(polygon);
      var polyline = poly && poly.isPolyline() ? poly : null;
      this.lengthLabel.setShape(polyline);
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddVertex(this.layer, this.poly, index, p));

      // insert new VertexGizmo
      var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, undefined, this.poly.style);

      // update vertex gizmos
      this.vertexGizmos.splice(index, 0, gizmo);
      updateVertexGizmoNames(this.vertexGizmos);

      // removeupdate edge gizmos and tangent gizmos
      this.createEdgeGizmos();
      this.createTangentGizmos();

      // Display polygon change and new gizmo
      this.layer.update();
    } }, { key: "removePoint", value: function removePoint(

    index) {

      // If removing a vertex would make the shape degenerate, remove it completely
      var minVerts = this.poly.isPolygon() ? 3 : 2;
      if (this.poly.length <= minVerts) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShape(this.layer, this.poly));
        this.reset();
        return;
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveVertex(this.layer, this.poly, index));

      // update vertex gizmos
      var gizmo = this.vertexGizmos.splice(index, 1)[0];
      updateVertexGizmoNames(this.vertexGizmos);

      // update edge gizmos and tangent gizmos
      this.createEdgeGizmos();
      this.createTangentGizmos();

      // Display changed polygon and removed vertex gizmo
      gizmo.dtor();

      // Make sure that this vertex is not selected anymore
      if (this.selectedVertex === index) {
        this.setSelectedVertex(-1);
      }

      this.layer.update();
    } }, { key: "startDragVertex", value: function startDragVertex(

    event, draggedVertex) {

      // Configure angle snapping to consider latest state of the polygon
      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex);

      this.draggedVertex = draggedVertex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = this.poly.points[this.draggedVertex];
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);

      // highlight the vertex we clicked on
      this.setSelectedVertex(this.draggedVertex);

      this.lastDragPoint.copy(vpos);
      this.dragVertexStartPos.copy(vpos);
    } }, { key: "moveDragVertex", value: function moveDragVertex(

    canvasX, canvasY) {
      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;

      // get delta between last and current position
      var p = this.getSnapPosition(x, y);
      var dx = p.x - this.lastDragPoint.x;
      var dy = p.y - this.lastDragPoint.y;

      // apply this offset to polygon point
      var point = this.poly.points[this.draggedVertex];
      this.poly.updatePoint(this.draggedVertex, point.x + dx, point.y + dy);

      // re-center gizmo at new point position
      var vertexGizmo = this.vertexGizmos[this.draggedVertex];
      vertexGizmo.setPosition(point.x, point.y);

      this.gizmoLayer.update(); // we moved the vertex gizmo
      this.layer.update(); // we changed the main polygon

      this.lastDragPoint.copy(p);
    } }, { key: "restoreDragVertex", value: function restoreDragVertex()

    {
      this.poly.updatePoint(this.draggedVertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y);
    } }, { key: "endDragVertex", value: function endDragVertex()

    {

      // First, restore "before move" position of the vertex
      this.restoreDragVertex();

      var pBefore = this.dragVertexStartPos;
      var pAfter = this.lastDragPoint;

      // don't add extra undo-operation if the vertex was hardly moved at all
      var minDist = this.layer.getUnitsPerPixel() * 0.5;
      var moved = pBefore.distanceTo(pAfter) > minDist;

      if (moved) {
        // Finalize vertex-move
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));
      }

      this.draggedVertex = -1;
      this.snapper.clearSnappingGizmos();
    } }, { key: "startDragEdge", value: function startDragEdge(

    event, draggedEdge) {

      this.setSelectedEdge(draggedEdge);

      // store edge normal for the edge being dragged
      this.draggedEdgeNormal = getLeftEdgeNormal(this.poly, draggedEdge, this.draggedEdgeNormal);
      this.lastDragPoint.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));

      // store original position of the two edge vertices
      var ia = this.draggedEdge;
      var ib = (this.draggedEdge + 1) % this.poly.length;
      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia));
      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib));
    } }, { key: "moveDragEdge", value: function moveDragEdge(

    event) {

      // get delta between last and current position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var delta = p.clone().sub(this.lastDragPoint);

      // get indices of prev and next edge
      var prevEdgeIndex = this.poly.prevIndex(this.draggedEdge);
      var nextEdgeIndex = this.poly.nextIndex(this.draggedEdge);

      // get previous, current, and next edge vertices
      var prevEdgeA = new THREE.Vector2();
      var prevEdgeB = new THREE.Vector2();
      var curEdgeA = new THREE.Vector2();
      var curEdgeB = new THREE.Vector2();
      var nextEdgeA = new THREE.Vector2();
      var nextEdgeB = new THREE.Vector2();
      this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB);
      this.poly.getEdge(this.draggedEdge, curEdgeA, curEdgeB);
      this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB);

      // Compute line after applying edge move offset
      curEdgeA.add(delta);
      curEdgeB.add(delta);

      // Compute directions for each edge to intersect
      var prevEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(prevEdgeA, prevEdgeB);
      var curEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(curEdgeA, curEdgeB);
      var nextEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(nextEdgeA, nextEdgeB);

      // Compute new edge endpoints as intersection of prev/next edge with the moved line
      var newEdgeA = new THREE.Vector2();
      var newEdgeB = new THREE.Vector2();

      if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||
      !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {
        return;
      }

      // get indices of the points to modify
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      // The intersections gives us the new position for the edge vertices
      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y);
      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y);

      // update affected vertex gizmos
      this.vertexGizmos[ia].setPosition(newEdgeA.x, newEdgeA.y);
      this.vertexGizmos[ib].setPosition(newEdgeB.x, newEdgeB.y);

      this.gizmoLayer.update();
      this.layer.update();

      this.lastDragPoint.copy(p);

      // We moved the edge => Keep gizmo in-sync
      this.updateEdgeGizmo();
    }

    // While dragging an edge, this function restores the original position at drag start
  }, { key: "restoreDragEdge", value: function restoreDragEdge() {
      var a = this.dragEdgeStartPos.a;
      var b = this.dragEdgeStartPos.b;

      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      this.poly.updatePoint(ia, a.x, a.y);
      this.poly.updatePoint(ib, b.x, b.y);
    } }, { key: "endDragEdge", value: function endDragEdge()

    {
      // get final position of the edge vertices
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      var newPos1 = this.poly.getPoint(ia);
      var newPos2 = this.poly.getPoint(ib);

      this.restoreDragEdge();

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge(this.layer, this.poly, ia, newPos1, newPos2));
      this.setSelectedEdge(-1);
    } }, { key: "edgeMovePossible", value: function edgeMovePossible()

    {
      return this.poly && this.poly.length > 2;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      // If we hit an existing vertex, start dragging it
      var draggedVertex = this.getVertexIndex(p.x, p.y);
      if (draggedVertex != -1) {
        this.startDragVertex(event, draggedVertex);
        return true;
      }

      // Handle Vertex-Add: Check if we hold ctrl and hit an edge
      var newVertex = -1;
      if (event.ctrlKey) {
        var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
        var edgeIndex = this.poly ? this.poly.findEdgeIndex(this.mousePos, precision) : -1;
        if (edgeIndex !== -1) {
          // insert new vertex after edge starting point
          newVertex = edgeIndex + 1;
          this.insertPoint(newVertex, p);

          // Allow to drag the new vertex immediately
          this.startDragVertex(event, newVertex);

          return true;
        }
      }

      // Reset vertex-highlighting: No vertex is selected anymore.
      this.setSelectedVertex(-1);

      // Handle dragging of TangentGizmo control points for Bezier arcs.
      for (var i = 0; i < this.tangentGizmos.length; i++) {
        var gizmo = this.tangentGizmos[i];
        if (gizmo.onButtonDown(event.canvasX, event.canvasY)) {
          // We started dragging of a Bezier control point
          return true;
        }
      }

      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it
      var selectedEdgeGizmo = this.getEdgeIndex(p.x, p.y);
      if (this.edgeMovePossible() && selectedEdgeGizmo !== -1) {
        this.startDragEdge(event, selectedEdgeGizmo);
        return true;
      }

      // If we just clicked inside the already active polygon, delegate to MoveTool
      if (this.poly) {
        // Note: this.poly may be a Polyline. To allow moving it, it's essential to use a hitRadius for picking.
        var hitRadius = this.layer.getLineHitRadius(this.poly);
        if (this.poly.hitTest(p.x, p.y, hitRadius)) {
          this.moveTool.startDrag(this.poly, p);
          return true;
        }
      }

      // Check if we selected a new polygon
      var newPolygon = this.layer.hitTest(p.x, p.y);

      // If the clicked object is neither polygon nor polyline, ignore it.
      var isPolygon = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
      var isPolyline = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"];
      var isPath = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];
      if (!isPolygon && !isPolyline && !isPath) {
        newPolygon = null;
      }

      // Set selection to current polygon. This will also trigger setEditPoly() 
      // via selectionChanged event.
      this.selection.selectOnly(newPolygon);

      return Boolean(this.poly);
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    e) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleSingleClick", this).call(this, e);

      return Boolean(this.poly);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));
      this.updateMouseOverHighlights();

      if (!this.poly) {
        return false;
      }

      if (this.draggedVertex != -1) {
        this.moveDragVertex(event.canvasX, event.canvasY);
        return true;
      }

      if (this.draggedEdge != -1) {
        this.moveDragEdge(event);
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.moveDrag(this.mousePos);

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonUp", this).call(this, event, button);

      if (this.draggedVertex !== -1) {
        this.endDragVertex();
        return true;
      }

      if (this.draggedEdge !== -1) {
        this.endDragEdge();
        return true;
      }

      if (this.moveTool.isDragging()) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);

        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves
        this.ignoreActions = true;
        this.moveTool.endDrag(p);
        this.ignoreActions = false;

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.endDrag(event.canvasX, event.canvasY);
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && this.poly && button == 0;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();
      var shape = selected[0];
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.DeleteSelectedVertex) {
        if (this.poly && this.selectedVertex !== -1) {
          this.removePoint(this.selectedVertex);
          handled = true;
        }
      }

      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
        return true;
      }

      return handled;
    } }, { key: "onSnappingToggled",

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
    value: function onSnappingToggled(canvasX, canvasY) {

      // If we are dragging a vertex, toggling snapping will affect the result and 
      // we should update line gizmos and snapping lines.
      if (this.draggedVertex !== -1) {
        this.moveDragVertex(canvasX, canvasY);
      }
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedVertex !== -1) {
        this.restoreDragVertex();
        this.draggedVertex = -1;
        needsUpdate = true;
      }

      if (this.draggedEdge !== -1) {
        this.restoreDragEdge();
        this.draggedEdge = -1;
        needsUpdate = true;
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.cancelDrag();
        this.updateVertexGizmos();
      }

      if (needsUpdate) {
        this.layer.update();
        this.updateVertexGizmos();
      }

      this.snapper.clearSnappingGizmos();
    } }, { key: "handleExternalAction", value: function handleExternalAction()

    {
      // If nothing is active, we don't need to care
      if (!this.poly) {
        return;
      }

      // If shape was removed, reset state
      var shapeFound = Boolean(this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // Sync gizmos in case vertices were modified
      this.updateVertexGizmos();

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      this.snapper.clearSnappingGizmos();
    }

    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.
  }, { key: "updateEdgeGizmo", value: function updateEdgeGizmo() {

      // Check if mouse is on an edge gizmo
      var edgeUnderMouse = this.getEdgeIndex(this.mousePos.x, this.mousePos.y);

      // Check if a vertex gizmo is under mouse or being dragged. If so, it has precedence, so that we don't highlight the edge anymore
      var vertexUnderMouse = this.getVertexIndex(this.mousePos.x, this.mousePos.y);
      var vertexHighlighted = vertexUnderMouse != -1 || this.draggedVertex != -1;
      var edgeMovePossible = this.edgeMovePossible();

      // Check if we need any highlight
      var edgeSelected = this.poly && this.draggedEdge != -1;
      var edgeHovered = edgeMovePossible && edgeUnderMouse != -1 && !vertexHighlighted;
      var gizmoNeeded = edgeSelected || edgeHovered;

      // Make sure that edge gizmo is shown if needed
      if (gizmoNeeded && !this.edgeGizmoShown) {
        this.gizmoLayer.addShape(this.edgeGizmo);
        this.edgeGizmoShown = true;
      } else
      if (!gizmoNeeded && this.edgeGizmoShown) {
        this.gizmoLayer.removeShape(this.edgeGizmo);
        this.edgeGizmoShown = false;
      }

      // If we just had to hide it, we are done here
      if (!gizmoNeeded) {
        return;
      }

      // Update edge gizmo position
      var edgeToHighlight = edgeSelected ? this.draggedEdge : edgeUnderMouse;

      // get the two vertex positions of the edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeToHighlight, a, b);

      // copy values to edge gizmo
      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);

      // Adopt lineWidth from selected polygon
      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;
      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;

      if (edgeSelected) {
        // Override color by green
        this.edgeGizmo.style.lineColor = 'rgb(0, 255, 0)';
        this.edgeGizmo.style.lineAlpha = 1.0;
      } else {
        // Just make it a bit brighter using a semitransparent white overlay
        this.edgeGizmo.style.lineColor = 'rgb(0, 255, 0)';
        this.edgeGizmo.style.lineAlpha = 0.5;
      }

      this.gizmoLayer.update();
    } }, { key: "setSelectedEdge", value: function setSelectedEdge(

    edgeIndex) {
      this.draggedEdge = edgeIndex;
      this.updateEdgeGizmo();

      // Update selection state for edge gizmos
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        var gizmo = this.edgeGizmos[i];
        gizmo.setSelected(i == this.draggedEdge);
      }
    } }, { key: "updateMouseOverHighlights", value: function updateMouseOverHighlights()

    {
      this.updateEdgeGizmo();
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.

      var p = this.mousePos;

      // Indicate: "Moving whole shape"
      // While dragging, keep the move-cursor, even if the mouse is temporarily leaving polygon and gizmos
      if (this.moveTool.isDragging()) {
        return 'move';
      }

      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedVertex != -1 || this.draggedEdge != -1) {
        return 'move';
      }

      // Indicate: "Click to insert new vertex"
      //
      // If we are holding down Ctrl and hover over an edge, clicking would insert a vertex.
      var ctrlHold = this.keyState[av.KeyCode.CONTROL];
      if (ctrlHold) {
        var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
        var edgeIndex = this.poly ? this.poly.findEdgeIndex(this.mousePos, precision) : -1;
        if (edgeIndex !== -1) {
          return 'copy';
        }
      }

      // Are we about to move a shape?
      var hitRadius = this.layer.getLineHitRadius(this.poly);
      var moveShape = this.poly.hitTest(p.x, p.y, hitRadius);
      if (moveShape) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }, { key: "clearTangentGizmos", value: function clearTangentGizmos()

    {
      this.tangentGizmos.forEach(function (g) {return g.dtor();});
      this.tangentGizmos.length = 0;
    } }, { key: "createTangentGizmos", value: function createTangentGizmos()

    {

      // Clear any previous gizmos (if any)
      this.clearTangentGizmos();

      if (!this.poly || !this.poly.isPath()) {
        return;
      }

      // For simplicity, we create a TangentGizmo for every vertex.
      // If a vertex has no adjacent arcs, it will be hidden anyway.   
      for (var i = 0; i < this.poly.points.length; i++) {
        this.tangentGizmos.push(new _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.poly, i, this.layer, this.gizmoLayer));
      }
    }

    // If any tangent gizmo is being dragged, it is returned.
    // Result is null if nothing is dragged.
  }, { key: "findDraggedTangentGizmo", value: function findDraggedTangentGizmo() {
      return this.tangentGizmos.find(function (gizmo) {return gizmo.isDragging();});
    } }]);return PolygonEditTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonTool.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonTool.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _LineTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var Mode = {
  Polyline: 1,
  Polygon: 2 };


var PolygonToolName = "Edit2_PolygonTool";
var PolylineToolName = "Edit2_PolylineTool";

var av = Autodesk.Viewing;
var DefaultStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();var

PolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);

  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, PolygonTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonTool).call(this, ctx));

    // Delegate single-drag interactions: 
    _this.lineRectTool = mode === Mode.Polygon ?
    new _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx, style) : // PolygonMode: Draw rect/quad on drag
    new _LineTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx, style) // PolylineMode: Draw simple line on drag
    ;

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    // Circle shapes per vertex
    _this.vertexGizmos = [];

    // The polygon/polyline we are currently creating (if tool is active)
    _this.poly = undefined;

    // Style used for polygon creation
    _this.style = style;

    // Style used to display the thin line to connect last added vertex with current mouse position.        
    _this.edgePreviewStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineWidth: 2,
      isScreenSpace: true,
      lineStyle: 11 // dashed line
    });

    // whether editing Polylines or Polygons
    _this.mode = mode;

    // last canvas position where we added a vertex
    _this.lastClickX = undefined;
    _this.lastClickY = undefined;

    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;
    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;
    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];

    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos
    _this.fillGizmo = null;

    // OutlineGizmo: Polyline that connects all added vertices
    _this.outlineGizmo = null;

    // Line to connect last added vertex with mouse position
    _this.edgePreviewGizmo = null;

    // Last tracked mouse-pos in layer-coords (after considering snapping)
    _this.mousePos = new THREE.Vector2();

    // Label to display polygon area - hidden by default
    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["AreaLabel"](null, _this.gizmoLayer, _this.unitHandler, false);

    // Label to display polyline length
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeLabel"](_this.gizmoLayer, false);return _this;
  }

  // Enable the area labels (public API)
  _createClass(PolygonTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(

    visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonTool.prototype), "deactivate", this).call(this);
      this.cancelEdit();
    }

    // Returns true when editing a Polygon, false when editing a Polyline or nothing.
  }, { key: "isPolygon", value: function isPolygon() {
      return this.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
    }

    /**
       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines
       * that appear during drawing. Style.isScreenSpace won't be considered.
       * @param {Style} style         - a Style instance
       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style
       */ }, { key: "setStyles", value: function setStyles(
    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {
        this.style.lineColor = style.lineColor;
      }
      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {
        this.style.lineAlpha = style.lineAlpha;
      }
      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {
        this.style.lineWidth = style.lineWidth;
        this.lineRectTool.style.lineWidth = style.lineWidth;
        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;
      }
      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {
        this.style.lineStyle = style.lineStyle;
        this.lineRectTool.style.lineStyle = style.lineStyle;
        // skip this.edgePreviewStyle.lineStyle
      }

      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {
        this.style.fillColor = style.fillColor;
      }
      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {
        this.style.fillAlpha = style.fillAlpha;
      }

      // skip isScreenSpace
    }

    // Initialize all gizmos when starting to edit a Polygon/Polyline
  }, { key: "initGizmos", value: function initGizmos() {

      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos
      if (this.isPolygon()) {
        this.fillGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        this.fillGizmo.style.lineAlpha = 0;
        this.gizmoLayer.addShape(this.fillGizmo);
      }

      // OutlineGizmo: Connect added vertices
      this.outlineGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      this.gizmoLayer.addShape(this.outlineGizmo);

      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.
      this.edgePreviewGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.edgePreviewStyle);
      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;
      this.gizmoLayer.addShape(this.edgePreviewGizmo);

      this.areaLabel.setShape(this.fillGizmo);

      // For Polylines, attach label to preview edge that displays the summed length
      if (this.poly && this.poly.isPolyline()) {
        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);
      }
    } }, { key: "clearGizmos", value: function clearGizmos()

    {
      if (this.fillGizmo) {
        this.gizmoLayer.removeShape(this.fillGizmo);
        this.fillGizmo = null;
      }

      this.areaLabel.setShape(null);
      this.lengthLabel.detachFromEdge();

      if (this.outlineGizmo) {
        this.gizmoLayer.removeShape(this.outlineGizmo);
        this.outlineGizmo = null;
      }

      if (this.edgePreviewGizmo) {
        this.gizmoLayer.removeShape(this.edgePreviewGizmo);
        this.edgePreviewGizmo = null;
      }

      // clear vertex gizmos
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    }

    // Update gizmos and snapping if polygon was modified
  }, { key: "polyModified", value: function polyModified() {
      this.updateGizmos();

      // Configure angle snapping to consider latest state of the polygon
      // Note that angleSnapper requires the shape including "vertex under mouse", while
      // this.poly only contains the already added/clicked vertices.
      // Note that we cannot use fillGizmo here, because it does not exist for polylines.
      var snapGeom = this.poly.clone();
      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);
      this.snapper.startAngleSnapping(snapGeom, this.poly.length);
    }

    // Update gizmos if vertices of current polygon/polyline have changed
  }, { key: "updateGizmos", value: function updateGizmos() {

      // FillGizmo: Show fill without outline for the polygon formed by all added
      // vertices + current mousePos
      if (this.fillGizmo) {
        // copy vertices of main polygon (not geom, not style)
        this.fillGizmo.clear();
        for (var i = 0; i < this.poly.length; i++) {
          var p = this.poly.getPoint(i);
          this.fillGizmo.addPoint(p.x, p.y);
        }
        // add additional point that traces mouse-pos
        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);
      }

      // OutlineGizmo: Solid polyline that connects all added vertices
      this.outlineGizmo.clear();
      if (this.poly.length >= 2) {
        for (var _i = 0; _i < this.poly.length; _i++) {
          var _p = this.poly.getPoint(_i);
          this.outlineGizmo.addPoint(_p.x, _p.y);
        }
      }

      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position
      this.edgePreviewGizmo.clear();
      if (this.poly.length >= 1) {
        var pLast = this.poly.getPoint(this.poly.length - 1);
        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);
        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);

        this.updateLengthLabel();
      }

      this.gizmoLayer.update();
    } }, { key: "updateLengthLabel", value: function updateLengthLabel()

    {
      // Compute resulting length of polyline including previewEdge
      if (this.poly && this.poly.isPolyline()) {
        // get transform from geometry coords to measure coordinate system
        var transform = this.unitHandler.measureTransform;

        var length = this.poly.getLength(transform) + this.edgePreviewGizmo.getLength(transform);
        var lengthStr = this.unitHandler.lengthToString(length);
        this.lengthLabel.setText(lengthStr);
      }
    } }, { key: "getName", value: function getName()

    {
      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleMouseMove", this).call(this, event);

      if (!event.buttons) {
        // When not dragging, we always return false here. Otherwise, the event will not propagated
        // to navigation tools, so that the zoom focus is not updated properly.
        this.onHover(event.canvasX, event.canvasY);
        return false;
      }
      return this.lineRectTool.handleMouseMove(event);
    } }, { key: "onHover", value: function onHover(

    canvasX, canvasY) {
      // Check if shape editing is already in progress
      if (!this.poly) {

        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.
        this.getSnapPosition(canvasX, canvasY);
        return;
      }

      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);

      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators
      var closingAllowed = this.poly.length >= 3;
      var startVertexHit = closingAllowed && this.vertexGizmos[0].isUnderMouse;
      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex
      if (startVertexHit) {
        // Remove snapping indicators
        this.snapper.clearSnappingGizmos();

        // snap position to vertex center
        pLayer.copy(this.vertexGizmos[0].layerPos);
      } else {
        // Standard case: If mouse is not on start vertex, allow standard snapping
        pLayer = this.getSnapPosition(canvasX, canvasY);
      }

      // track last mouse pos
      this.mousePos.copy(pLayer);

      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo
      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);
      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.length - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline
      this.gizmoLayer.update();
      this.updateLengthLabel();
    }

    // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.
  }, { key: "handleStartVertexClicked", value: function handleStartVertexClicked(event) {

      if (!this.poly && this.poly.length < 3) {
        return;
      }

      // For polylines, we have to repeat the first vertex to close it
      if (this.poly.isPolyline()) {
        var pStart = this.poly.getPoint(0);
        this.addVertex(pStart.x, pStart.y);
      }

      // Finish editing
      this.finishPolygon();

      // Make sure that the event is not passed on to ToolManager. Otherwise,
      // we would evaluate it a second time in handleSingleClick()
      event.stopPropagation();
    }

    // Add vertex on single-click
  }, { key: "handleSingleClick", value: function handleSingleClick(event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleSingleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      // Avoid duplicate vertices on double-clicks
      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {
        return true;
      }

      this.lastClickX = event.canvasX;
      this.lastClickY = event.canvasY;

      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));

      // Init polygon on first click
      if (!this.poly) {
        this.startPoly(this.mousePos.x, this.mousePos.y);
      }

      this.addVertex(this.mousePos.x, this.mousePos.y);
      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.
      if (this.ignoreDragging) {
        return false;
      }

      // If no clicks have been made so far, allow to drag line/rectangle.
      if (!this.poly) {
        // Clear the selection, this will make sure all other gizmos get removed
        this.selection.clear();

        return this.lineRectTool.handleButtonDown(event, button);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return this.lineRectTool.handleButtonUp(event, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleDoubleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      this.finishPolygon();
      return true;
    }

    // Start new polyline or polygon
  }, { key: "startPoly", value: function startPoly(x, y) {

      if (this.mode === Mode.Polygon) {
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
      } else {
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      }

      this.initGizmos();
    } }, { key: "addVertex", value: function addVertex(

    x, y) {var _this2 = this;

      // add "next" point - which will follow the mouse motion 
      // until next click
      this.poly.addPoint(x, y);

      // add vertex-gizmo
      var name = 'PolygonTool_vertexGizmo_' + this.vertexGizmos.length;
      var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["VertexGizmo"](this.gizmoLayer, x, y, name);
      this.vertexGizmos.push(vertex);

      // For the start vertex-gizmo, we register a handler to finish the polygon when clicking it again
      var isStartVertex = this.vertexGizmos.length === 1;
      if (isStartVertex) {
        vertex.container.addEventListener('click', function (e) {return _this2.handleStartVertexClicked(e);});
      }

      this.polyModified();
    } }, { key: "removeLastVertex", value: function removeLastVertex()

    {
      if (!this.poly || !this.poly.length) {
        return;
      }

      // Cancel edit if there was only the starting point.
      if (this.poly.length <= 1) {
        this.cancelEdit();
        return;
      }

      this.poly.removePoint(this.poly.length - 1);

      // remove last added vertex gizmo
      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];
      lastGizmo.dtor();
      this.vertexGizmos.pop();

      this.polyModified();
    } }, { key: "finishPolygon", value: function finishPolygon()

    {

      // remove all vertex gizmos
      this.clearGizmos();

      // Stop snapping to edges of this polygon
      this.snapper.stopAngleSnapping();

      // move polygon to main layer
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].AddShape(this.layer, this.poly));

      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });

      // Start another polygon on next click
      this.poly = null;
    } }, { key: "cancelEdit", value: function cancelEdit()

    {

      if (this.lineRectTool.isDragging()) {
        this.lineRectTool.cancelDrag();
      }

      if (this.poly) {
        this.gizmoLayer.removeShape(this.poly);
        this.poly = null;
      }

      this.clearGizmos();
      this.snapper.stopAngleSnapping();
    } }, { key: "handleFinishKey", value: function handleFinishKey(

    event) {
      if (!this.poly) {
        return false;
      }

      // Avoid closing if it would result in a polygon that is degenerated to a line.
      if (this.isPolygon() && this.poly.length < 3) {
        return false;
      }

      this.finishPolygon();
      return true;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // delegate to rectTool
      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;

      // Map event to any known key in this.keyMap
      var funcKey = this.mapKey(event, this.keyMap);
      switch (funcKey) {
        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;
        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;
        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyUp", this).call(this, event, keyCode);
      this.lineRectTool.handleKeyUp(event, keyCode);
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.onHover(canvasX, canvasY);
    } }, { key: "mouseOnStartVertex", value: function mouseOnStartVertex(

    event) {
      if (!this.vertexGizmos[0]) {
        return false;
      }

      // Check if start vertex was clicked
      var pLayer = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.vertexGizmos[0].isUnderMouse;
    } }, { key: "setStartVertexHighlighted", value: function setStartVertexHighlighted(

    enable) {
      if (this.vertexGizmos[0]) {
        this.vertexGizmos[0].setSelected(enable);
      }
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return PolygonTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


PolygonTool.POLYGON_ADDED = "polygonAdded";
PolygonTool.Mode = Mode;

/***/ }),

/***/ "./extensions/Edit2D/tools/RectangleTool.js":
/*!**************************************************!*\
  !*** ./extensions/Edit2D/tools/RectangleTool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var RectangleToolName = "Edit2_RectangleTool";

var av = Autodesk.Viewing;

// Creates rectangles by dragging
var RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);

  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, RectangleTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RectangleTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.style = style;

    // New polygon created by dragging
    _this.rect = null;

    // First corner of the new rectangle
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);return _this;
  }

  // Enable the area labels (public API)
  _createClass(RectangleTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return RectangleToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return false;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      // Make sure that we consider latest mouse position
      this.handleMouseMove(event);

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.rect) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      this.rect = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()], this.style.clone());
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.rect);
    } }, { key: "updateRect", value: function updateRect(

    forceQuad) {

      if (!this.isDragging()) {
        return;
      }

      var p0 = this.startPoint;
      var p1 = this.endPoint;

      if (forceQuad) {

        // Use maximum of dx/dy as edge length
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));

        // Consider drag direction to span quad right/left resp. up/down
        var sx = Math.sign(dx);
        var sy = Math.sign(dy);

        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);
        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);
        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);

      } else {
        this.rect.updatePoint(1, p1.x, p0.y);
        this.rect.updatePoint(2, p1.x, p1.y);
        this.rect.updatePoint(3, p0.x, p1.y);
      }

      this.gizmoLayer.update();

      this.areaLabel.setShape(this.rect);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateRect(forceQuad);
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.rect) {
        return false;
      }

      // Check if rect is valid
      var dx = this.endPoint.x - this.startPoint.x;
      var dy = this.endPoint.y - this.startPoint.y;
      var Eps = 1.e-10;
      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;

      // Move shape to main layer (or just remove if invalid)
      this.gizmoLayer.removeShape(this.rect);
      if (rectValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.rect));
      }

      this.rect = null;

      this.areaLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.rect) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.rect);
        this.rect = null;

        this.dragCanceled = true;

        this.areaLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.rect);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(false);
      }
    } }]);return RectangleTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/UndoTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/UndoTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolname = 'Edit2_UndoTool';

var av = Autodesk.Viewing;

// Simple tool that triggers undo/redo on ctrl-z/ctrl-shift-z
var UndoTool = /*#__PURE__*/function () {

  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);
    this.undoStack = undoStack;
  }_createClass(UndoTool, [{ key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      if (keyCode !== av.KeyCode.z || !event.ctrlKey) {
        return false;
      }

      if (event.shiftKey) {
        this.undoStack.redo();
      } else {
        this.undoStack.undo();
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return UndoToolname;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return UndoTool;}();
;

/***/ }),

/***/ "./extensions/PDF/LmvCanvasContext.js":
/*!********************************************!*\
  !*** ./extensions/PDF/LmvCanvasContext.js ***!
  \********************************************/
/*! exports provided: hijackContextAPI, LmvCanvasContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hijackContextAPI", function() { return hijackContextAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LmvCanvasContext", function() { return LmvCanvasContext; });
/* harmony import */ var _path2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path2d */ "./extensions/PDF/path2d.js");
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing,
avp = av.Private;

var VertexBufferBuilder = avp.VertexBufferBuilder;




var _document = av.getGlobal().document;
//Custom implementation of HTML Canvas API used for rendering PDF geometry using the WebGL accelerated F2D renderer


//A custom context object that overloads standard HMTL Canvas 2D context to intercept draw
//calls and pipe them into LMV vertex buffers
function hijackContextAPI(inContext, lmvContext) {

  var fnList = [
  "fillRect",
  "strokeRect",
  "clearRect",
  "beginPath",
  "closePath",
  "moveTo",
  "lineTo",
  "arc",
  "arcTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "rect",
  "fill",
  "stroke",
  "clip",
  "strokeText",
  "fillText",
  "drawImage",
  "save",
  "restore",
  "setLineDash",

  // OCG related
  "beginMarkedContent",
  "beginMarkedContentProps",
  "endMarkedContent",
  "setCurrentOperatorIndex"];


  fnList.forEach(function (fn) {
    inContext["_original" + fn] = inContext[fn];
    inContext[fn] = lmvContext[fn].bind(lmvContext);
  });

}


var _tmpXform = new Array(6);
var _tmpVec = new THREE.Vector2();
var _tmpBox = new THREE.Box2();


//Used for matrix decomposition in drawImage
var _offset = new THREE.Vector3();
var _quat = new THREE.Quaternion();
var _scale = new THREE.Vector3();
var _axis = new THREE.Vector3();
var _mtx4 = new THREE.Matrix4();

var LmvCanvasContext = /*#__PURE__*/function () {_createClass(LmvCanvasContext, null, [{ key: "isRef",

    /**
                                                                                                               * Check is a PDF Ref object
                                                                                                               * @param {PDF.Ref} obj 
                                                                                                               */value: function isRef(
    obj) {
      return obj != null && typeof obj.num === "number" && typeof obj.gen === "number";
    }

    /**
       * generate a simple string works as a key for the ref.
       * @param {PDF.Ref} ref 
       */ }, { key: "refKey", value: function refKey(
    ref) {
      return "".concat(ref.num, "-").concat(ref.gen);
    } }]);

  function LmvCanvasContext(viewport, toPageUnits, meshCallback, fontEngine, usingTextLayer, fontAtlas, pdfRefMap) {_classCallCheck(this, LmvCanvasContext);

    //
    // Prepare canvas using PDF page dimensions
    //
    //TODO: Do we need that or can we just overload the entire CanvasContext API and skip the HTML element creation completely?
    var canvas = _document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    this.canvasContext = context; //REQUIRED for PDF.js interface
    this.viewport = viewport; //REQUIRED for PDF.js interface
    this.toPageUnits = toPageUnits;

    this.meshCallback = meshCallback;
    // only set bounds for PDF, because edit2d and 
    if (viewport.clipToViewport == true) {
      var offsetX = viewport.offsetX || 0;
      var offsetY = viewport.offsetY || 0;
      this.bounds = new THREE.Vector4(offsetX * toPageUnits, offsetY * toPageUnits,
      (viewport.width + offsetX) * toPageUnits, (viewport.height + offsetY) * toPageUnits);
    }

    this.currentMeshIndex = 0;
    this.imageNumber = 0;
    this.currentVbb = new VertexBufferBuilder(false);
    this._curPath = null;
    this._curClip = null;
    this.first = true;
    this.states = [];
    this.glyphCache = {};
    this.usingTextLayer = usingTextLayer;

    //Fixed precision tolerance assuming the input is in typographic "point" units.
    this.precisionTolerance = 0.1;

    this.dbId = -1;

    // If true, dbId is automatically increased on each beginPath call.
    this.consecutiveIds = false;

    if (av.isMobileDevice()) {
      Object(_bezier__WEBPACK_IMPORTED_MODULE_1__["SetTesselationParams"])(undefined, 0.1);
    }

    this.fontEngine = fontEngine;

    // Use solid lines by default. See LineStyleDef.js for other line types (dashed etc.)
    this.lineStyle = 0;

    // If true, lines widths are applied in screen-space
    this.isScreenSpace = false;

    hijackContextAPI(context, this);

    this.layers = {};
    this.defaultLayerId = 0;
    this.currentLayerId = this.defaultLayerId;
    this.sequencedDbId = -1;
    this.taggedId = null;
    this.defaultVPId = 0;
    this.currentVpId = this.defaultVPId;
    this.viewports = [this.createViewPortData(new THREE.Matrix4().elements)];
    this.viewportMap = {};

    this.ocgStack = [];
    // Revit dbID is larger then 4096, id remap is needed
    this.idRemap = [];
    this.idIndexMap = {};

    this.msdfRender = true;
    this.fontAtlas = fontAtlas;
    this.pdfRefMap = pdfRefMap || {};
  }_createClass(LmvCanvasContext, [{ key: "updateDBId", value: function updateDBId()

    {
      if (this.taggedId != null) {
        if (this.idIndexMap[this.taggedId] != undefined) {
          this.dbId = this.idIndexMap[this.taggedId];
        } else {
          this.sequencedDbId++;
          this.dbId = this.sequencedDbId;
          this.idRemap[this.dbId] = this.taggedId;
          this.idIndexMap[this.taggedId] = this.dbId;
        }
      } else {
        if (this.consecutiveIds) {
          this.sequencedDbId++;
          this.dbId = this.sequencedDbId;
        }
        this.idRemap[this.dbId] = this.dbId;
      }
    } }, { key: "save", value: function save()

    {
      //console.log("save");
      this.states.push({
        clip: this._curClip,
        consecutiveIds: this.consecutiveIds,
        dbId: this.dbId,
        lineDashedDef: this.lineDashedDef,
        lineStyle: this.lineStyle });


      this.canvasContext._originalsave();
    } }, { key: "restore", value: function restore()

    {

      var state = this.states.pop();

      if (state) {
        this._curClip = state.clip;
        this.consecutiveIds = state.consecutiveIds;
        this.dbId = state.dbId;
        this.lineDashedDef = state.lineDashedDef;
        this.lineStyle = state.lineStyle;
      }

      //console.log("restore");
      this.canvasContext._originalrestore();
    } }, { key: "flushBuffer", value: function flushBuffer(

    addCount, finalFlush)
    {var hasMSDFText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (!this.currentVbb.vcount && !finalFlush)
      {
        return;
      }

      var flush = finalFlush;
      flush = flush || this.currentVbb.isFull(addCount);

      if (flush) {
        if (this.currentVbb.vcount) {
          var mesh = this.currentVbb.toMesh();
          mesh.material = {
            skipEllipticals: !this.currentVbb.numEllipticals,
            skipCircles: !this.currentVbb.numCirculars,
            skipTriangleGeoms: !this.currentVbb.numTriangleGeoms,
            useInstancing: this.currentVbb.useInstancing,
            isScreenSpace: !this.currentImage,
            hasLineStyles: this.currentVbb.hasLineStyles,
            msdfFontTexture: !!hasMSDFText,
            viewportBounds: this.bounds };


          if (this.currentImage) {
            mesh.material.image = this.currentImage;
            mesh.material.image.name = this.currentImage.cacheKey || this.imageNumber++;
            mesh.material.opacity = this.canvasContext.globalAlpha;
            this.currentImage = null;
          }

          this.meshCallback(mesh, this.currentMeshIndex++);
          this.currentVbb.reset(0);
          this.currentVbb.expandStride();
        }
      }
    }

    //Polytriangle requires some post-processing depending on wheter instancing is used or not
    //TODO: This is copy-pasted from the same function in F2D.js. It's purely used to
    //add half width outline to polytriangles so that they look antialiased.
  }, { key: "addPolyTriangle", value: function addPolyTriangle(points, inds, color, dbId, layer, antialiasEdges) {
      var me = this;
      var edgeMap = null;

      var currentVpId = this.currentVpId;

      var aaLineWeight = -0.5; //negative = in pixel units

      function processEdge(iFrom, iTo) {
        if (iFrom > iTo) {
          var tmp = iFrom;
          iFrom = iTo;
          iTo = tmp;
        }

        if (!edgeMap[iFrom])
        edgeMap[iFrom] = [iTo];else
        {
          var adjacentVerts = edgeMap[iFrom];
          var idx = adjacentVerts.lastIndexOf(iTo);
          if (idx == -1)
          adjacentVerts.push(iTo); //first time we see this edge, so remember it as exterior edge
          else
            adjacentVerts[idx] = -1; //the second time we see an edge mark it as interior edge
        }
      }


      function addAllAntialiasEdges() {

        for (var i = 0, iEnd = edgeMap.length; i < iEnd; i++) {

          var adjacentVerts = edgeMap[i];
          if (!adjacentVerts)
          continue;

          for (var j = 0; j < adjacentVerts.length; j++) {
            var iTo = adjacentVerts[j];
            if (iTo == -1)
            continue; //an interior edge was here -- skip
            else {
                //exterior edge -- add an antialiasing line for it
                me.flushBuffer(4);
                me.currentVbb.addSegment(points[2 * i], points[2 * i + 1],
                points[2 * iTo], points[2 * iTo + 1],
                me.currentLayerId,
                aaLineWeight,
                color,
                dbId, layer, currentVpId, me.lineStyle);
              }
          }
        }
      }

      function antialiasOneEdge(iFrom, iTo) {
        if (iFrom > iTo) {
          var tmp = iFrom;
          iFrom = iTo;
          iTo = tmp;
        }

        var adjacentVerts = edgeMap[iFrom];
        if (!adjacentVerts)
        return;

        var idx = adjacentVerts.indexOf(iTo);
        if (idx != -1) {
          //exterior edge -- add an antialiasing line for it
          me.flushBuffer(4);
          me.currentVbb.addSegment(points[2 * iFrom], points[2 * iFrom + 1],
          points[2 * iTo], points[2 * iTo + 1],
          me.currentLayerId,
          aaLineWeight,
          color,
          dbId, layer, currentVpId, me.lineStyle);
        }
      }

      if (antialiasEdges) {
        edgeMap = new Array(points.length / 2);

        for (var i = 0, iEnd = inds.length; i < iEnd; i += 3) {
          var i0 = inds[i];
          var i1 = inds[i + 1];
          var i2 = inds[i + 2];

          processEdge(i0, i1);
          processEdge(i1, i2);
          processEdge(i2, i0);
        }
      }

      if (this.currentVbb.useInstancing) {
        var count = inds.length;
        for (var i = 0; i < count; i += 3) {
          var i0 = inds[i];
          var i1 = inds[i + 1];
          var i2 = inds[i + 2];

          this.flushBuffer(4);

          this.currentVbb.addTriangleGeom(points[2 * i0], points[2 * i0 + 1],
          points[2 * i1], points[2 * i1 + 1],
          points[2 * i2], points[2 * i2 + 1],
          color, dbId, layer, currentVpId);

          if (antialiasEdges) {
            antialiasOneEdge(i0, i1);
            antialiasOneEdge(i1, i2);
            antialiasOneEdge(i2, i0);
          }
        }
      } else
      {
        var count = points.length / 2; // number of vertices

        this.flushBuffer(count);
        var vbb = this.currentVbb;
        var vbase = vbb.vcount;

        for (var i = 0; i < count; ++i) {
          var x = points[2 * i];
          var y = points[2 * i + 1];
          vbb.addVertexPolytriangle(x, y, color, dbId, layer, currentVpId);
        }

        vbb.addIndices(inds, vbase);

        if (antialiasEdges) {
          addAllAntialiasEdges();
        }

      }
    }

    //Extract colors from HTML Canvas state
  }, { key: "getFillColor", value: function getFillColor() {
      if (typeof this.canvasContext.fillStyle !== "string") {
        console.warn("Unsupported fill style.");
        return 0x00000000;
      }

      var rgb = parseInt(this.canvasContext.fillStyle.slice(1), 16);
      var a = 255 * this.canvasContext.globalAlpha << 24;
      var c = a | (rgb & 0xff) << 16 | rgb & 0xff00 | rgb >> 16 & 0xff;
      return c;
    } }, { key: "getStrokeColor", value: function getStrokeColor()

    {

      var ctx = this.canvasContext;

      if (this.lastStrokeStyle === ctx.strokeStyle && ctx.globalAlpha === this.lastAlpha) {
        return this.lastRgb;
      } else {
        var rgb = parseInt(ctx.strokeStyle.slice(1), 16);
        var a = 255 * ctx.globalAlpha << 24;
        var c = a | (rgb & 0xff) << 16 | rgb & 0xff00 | rgb >> 16 & 0xff;

        this.lastRgb = c;
        this.lastStrokeStyle = ctx.strokeStyle;
        this.lastAlpha = ctx.globalAlpha;

        return c;
      }

    } }, { key: "getCurrentTransform", value: function getCurrentTransform()

    {
      var xform = this.canvasContext.mozCurrentTransform;

      //Pay attention here: In case we are processing the path of a character and we want to
      //cache it for later use, we have to neutralize the part of the canvas transform that positions
      //the character in the page, but we need to keep the rest of the transform (that positions parts
      //of the character in its own em-box). This is what the inverse transform multiplication here does.
      //TODO: we can optimize this to only compute the multiplication in case mozCurrentTransform changes.
      if (this.isFontChar) {
        var m = this.invXform;
        var a = xform[0],b = xform[1],c = xform[2],d = xform[3],e = xform[4],f = xform[5];
        _tmpXform[0] = m[0] * a + m[2] * b;
        _tmpXform[1] = m[1] * a + m[3] * b;
        _tmpXform[2] = m[0] * c + m[2] * d;
        _tmpXform[3] = m[1] * c + m[3] * d;
        _tmpXform[4] = m[0] * e + m[2] * f + m[4];
        _tmpXform[5] = m[1] * e + m[3] * f + m[5];
        return _tmpXform;
      }

      return xform;
    } }, { key: "tx", value: function tx(

    x, y, xform) {
      xform = xform || this.getCurrentTransform();
      return (x * xform[0] + y * xform[2] + xform[4]) * (this.isFontChar ? 1 : this.toPageUnits);
    } }, { key: "ty", value: function ty(

    x, y, xform) {
      xform = xform || this.getCurrentTransform();
      return (x * xform[1] + y * xform[3] + xform[5]) * (this.isFontChar ? 1 : this.toPageUnits);
    } }, { key: "scaleValue", value: function scaleValue(

    v, xform) {
      xform = xform || this.getCurrentTransform();
      return this.toPageUnits * Math.sqrt(Math.abs(xform[0] * xform[3] - xform[1] * xform[2])) * v; //assumes uniform;
    } }, { key: "transformBox", value: function transformBox(

    bbox, xform, dst) {
      xform = xform || this.getCurrentTransform();

      _tmpBox.makeEmpty();

      _tmpVec.set(this.tx(bbox.min.x, bbox.min.y, xform), this.ty(bbox.min.x, bbox.min.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.max.x, bbox.min.y, xform), this.ty(bbox.max.x, bbox.min.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.max.x, bbox.max.y, xform), this.ty(bbox.max.x, bbox.max.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.min.x, bbox.max.y, xform), this.ty(bbox.min.x, bbox.max.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      if (dst) {
        dst.copy(_tmpBox);
        return dst;
      } else {
        return _tmpBox.clone();
      }
    } }, { key: "fillRect", value: function fillRect(


    x, y, w, h) {

      this.updateDBId();

      var xform = this.getCurrentTransform();

      var points = [
      this.tx(x, y, xform), this.ty(x, y, xform),
      this.tx(x + w, y, xform), this.ty(x + w, y, xform),
      this.tx(x + w, y + h, xform), this.ty(x + w, y + h, xform),
      this.tx(x, y + h, xform), this.ty(x, y + h, xform)];


      var c = this.getFillColor();

      var indices = [0, 1, 2, 0, 2, 3];

      // Hack: Assumption here is that the first fillRect call is for the white background quad.
      //       For this, we don't want a dbI and use -1 instead. Unfortunately, this fillRect call happens
      //       inside PDF.js (see beginDrawing in display/canvas.js), so we cannot easily set this id from outside.
      var dbId = this.first ? -1 : this.dbId;

      this.addPolyTriangle(points, indices, c, dbId, this.currentLayerId, false);

      this.first = false;
    } }, { key: "strokeRect", value: function strokeRect(

    x, y, w, h) {
      //TODO:
      console.log("strokeRect");
    } }, { key: "clearRect", value: function clearRect(

    x, y, w, h) {
      console.log("clearRect");
      //TODO:
    } }, { key: "_beginTextChar", value: function _beginTextChar(

    character, x, y, font, fontSize) {
      if (this.usingTextLayer === true) {
        this.skipPath = true;
        return;
      }

      this.isFontChar = true;
      this.invXform = this.canvasContext.mozCurrentTransformInverse;
      this.hashKey = character.charCodeAt(0) + "/" + font.loadedName + "/" + fontSize;
      this.cachedGlyph = this.glyphCache[this.hashKey];

      if (this.cachedGlyph) {
        this.skipPath = true;
      } else {
        this.skipPath = false;
      }
      //console.log(character, x, y, font, fontSize);
    } }, { key: "drawMSDFText", value: function drawMSDFText(

    character, scaleX, scaleY, font, fontSize) {
      scaleX = 0;
      var fontName = font.name;

      if (this.fontAtlas && this.fontAtlas.charsMap && this.fontAtlas.charsMap[fontName]) {
        var charIndex = this.fontAtlas.charsMap[fontName][character.charCodeAt(0)];
        if (charIndex == undefined) {
          return false;
        } else {
          if (this.currentVbb.isFull(4)) {
            this.flushBuffer(0, true);
          }

          var _char = this.fontAtlas.chars[charIndex];
          if (_char.page > 0) {
            // Now only support 1 page of font texture, need to add extra logic for multiple font texture in the shader pipeline
            return false;
          }
          var common = this.fontAtlas.common[_char.common];
          var info = this.fontAtlas.info[_char.info];

          // need to consider the font size
          var scale = fontSize / info.size;
          var w = _char.width * (scale + scaleX);
          var flag = _char.inverseYAxis ? -1 : 1;
          var h = _char.height * (scale + scaleY) * flag;
          var x = _char.txoffset * (scale + scaleX),
          y = _char.tyoffset * (scale + scaleY) * -flag;

          var points = [
          x, y,
          x, y + h,
          x + w, y + h,
          x + w, y];


          var ps = [];
          for (var i = 0; i < points.length; i += 2) {
            ps.push(this.tx(points[i], points[i + 1]));
            ps.push(this.ty(points[i], points[i + 1]));
          }

          if (_char.inverseYAxis) {
            var uv = [
            _char.x / common.scaleW, 1 - _char.y / common.scaleH,
            _char.x / common.scaleW, 1 - (_char.y + _char.height) / common.scaleH,
            // char.x/common.scaleW, 1- char.y/common.scaleH,
            // (char.x + char.width)/common.scaleW, 1- char.y/common.scaleH,
            (_char.x + _char.width) / common.scaleW, 1 - (_char.y + _char.height) / common.scaleH,
            (_char.x + _char.width) / common.scaleW, 1 - _char.y / common.scaleH];

          } else {
            var uv = [
            _char.x / common.scaleW, 1 - (_char.y + _char.height) / common.scaleH,
            _char.x / common.scaleW, 1 - _char.y / common.scaleH,
            (_char.x + _char.width) / common.scaleW, 1 - _char.y / common.scaleH,
            (_char.x + _char.width) / common.scaleW, 1 - (_char.y + _char.height) / common.scaleH];

          }


          var vbase = this.currentVbb.vcount;
          var count = points.length / 2;
          for (var _i = 0; _i < count; _i++) {
            this.currentVbb.addVertexMSDFPolytriangle(ps[_i * 2], ps[_i * 2 + 1], uv[_i * 2], uv[_i * 2 + 1], this.getFillColor(), this.dbId, this.currentLayerId, 0);
          }

          this.currentVbb.addIndices([0, 2, 1, 0, 2, 3], vbase);
          this.currentImage = this.fontAtlas.pages[_char.page];

          return true;
        }

      } else {
        return false;
      }
    } }, { key: "beginPath", value: function beginPath(

    character, x, y, font, fontSize) {
      this.updateDBId();

      if (typeof character === "string" && font && fontSize) {
        if (this.fontAtlas && this.drawMSDFText(character, x, y, font, fontSize)) {
          this.skipPath = true;
        } else {
          this._beginTextChar(character, x, y, font, fontSize);
          this.skipPath = false;
        }
      } else {
        this.skipPath = false;
        this.isFontChar = false;
        this.cachedGlyph = null;
      }

      if (this.skipPath)
      this._curPath = null;else
      {
        this._curPath = new _path2d__WEBPACK_IMPORTED_MODULE_0__["Path2D"](this.isFontChar ? 0.0001 : this.precisionTolerance);

        // Apply custom tess params (if specified)
        this._curPath.setTessParams(this.tessParams);
      }
    } }, { key: "closePath", value: function closePath()

    {

      if (this.skipPath)
      return;

      this._curPath.closePath();
      this.cachedGlyph = null;
    } }, { key: "moveTo", value: function moveTo(

    x, y) {

      if (this.skipPath)
      return;

      if (!this._curPath)
      this.beginPath();

      var xform = this.getCurrentTransform();

      this._curPath.moveTo(this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "lineTo", value: function lineTo(

    x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.lineTo(this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "arc", value: function arc(

    x, y, radius, startAngle, endAngle, anticlockwise) {

      if (this.skipPath)
      return;

      //TODO: transform

      this._curPath.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    } }, { key: "arcTo", value: function arcTo(

    x1, y1, x2, y2, radius) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.arcTo(this.tx(x1, y1, xform), this.ty(x1, y1, xform),
      this.tx(x2, y2, xform), this.ty(x2, y2, xform),
      this.scaleValue(radius, xform));
    } }, { key: "quadraticCurveTo", value: function quadraticCurveTo(

    cp1x, cp1y, x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.quadraticCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),
      this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "bezierCurveTo", value: function bezierCurveTo(

    cp1x, cp1y, cp2x, cp2y, x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.bezierCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),
      this.tx(cp2x, cp2y, xform), this.ty(cp2x, cp2y, xform),
      this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "rect", value: function rect(

    x, y, w, h) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      if (!this._curPath)
      this.beginPath();

      this._curPath.moveTo(this.tx(x, y, xform), this.ty(x, y, xform));
      this._curPath.lineTo(this.tx(x + w, y, xform), this.ty(x + w, y, xform));
      this._curPath.lineTo(this.tx(x + w, y + h, xform), this.ty(x + w, y + h, xform));
      this._curPath.lineTo(this.tx(x + w, y, xform), this.ty(x + w, y, xform));
      this._curPath.closePath();
    } }, { key: "fill", value: function fill()

    {
      if (this.isFontChar && !this.cachedGlyph) {
        this.glyphCache[this.hashKey] = this._curPath;
        this.cachedGlyph = this._curPath;
        this.cachedGlyph.cacheTriangulation();
      }

      this.isFontChar = false;

      if (this.cachedGlyph) {
        this.cachedGlyph.fill(this, this.getFillColor(), this.dbId, this.currentLayerId, this._curClip, true);
      } else {
        this._curPath && this._curPath.fill(this, this.getFillColor(), this.dbId, this.currentLayerId, this._curClip, false);
      }

      this.skipPath = false;

      //this._curClip = null;
      //lmvContext._curPath = null;
    } }, { key: "stroke", value: function stroke()

    {
      if (this.isFontChar && !this.cachedGlyph) {
        this.glyphCache[this.hashKey] = this._curPath;
        this.cachedGlyph = this._curPath;
        this.cachedGlyph.cacheTriangulation();
      }

      this.updateLineDashStyle();
      this.isFontChar = false;

      // LineShader uses negative lineWidths to indicate screen-space line widths. Note that this.canvasContext.lineWidth does not allow negative values.
      // Therefore, we apply the sign separately.
      var sign = this.isScreenSpace ? -1.0 : 1.0;

      if (this.cachedGlyph) {
        this.cachedGlyph.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth), this.getStrokeColor(), this.dbId, this.currentLayerId, this._curClip, true, this.lineStyle);
      } else {
        this._curPath && this._curPath.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth), this.getStrokeColor(), this.dbId, this.currentLayerId, this._curClip, false, this.lineStyle);
      }

      this.skipPath = false;

      //lmvContext._curPath = null;
    } }, { key: "clip", value: function clip(

    param1, param2) {

      if (param2 !== undefined && param1 !== undefined) {
        this._curClip = param1;
        console.log("Probably unsupported use case");
      } else {

        //The clip region is also affected by any existing clip region,
        //i.e. we have to clip the clip.
        if (this._curClip) {
          this._curClip = this._curClip.clip(this._curPath, param1);
        } else {
          this._curClip = this._curPath;
        }

        this._curPath = null;
      }

      //console.log("CLIP", param1, param2);
    } }, { key: "strokeText", value: function strokeText(

    text, x, y, maxWidth, font, fontSize) {

      var ctx = this.canvasContext;
      ctx.save();
      ctx.translate(x, y);

      this.fontEngine.drawText(this, text, 0, 0, font, fontSize);
      this.stroke();

      ctx.restore();
    } }, { key: "fillText", value: function fillText(

    text, x, y, maxWidth, font, fontSize) {

      var ctx = this.canvasContext;
      ctx.save();
      ctx.translate(x, y);

      this.fontEngine.drawText(this, text, 0, 0, font, fontSize);
      this.fill();
      //this.stroke();

      ctx.restore();
    } }, { key: "drawImage", value: function drawImage(

    image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {


      if (image.width === 0 || image.height === 0) {
        console.warn("Zero size image, skipping");
        return;
      }

      if (dx === undefined) {
        dx = sx;
        dy = sy;
        dWidth = sWidth;
        dHeight = sHeight;
      }

      if (dWidth === undefined) {
        dWidth = image.width;
        dHeight = image.height;
      }

      if (!dWidth) {
        console.warn("Zero size image, skipping");
        return;
      }

      //console.log("Draw image", dWidth, dHeight);

      var xform = this.getCurrentTransform();

      //Get the transformed page space image center
      var cx = this.tx(dx + dWidth / 2, dy + dHeight / 2);
      var cy = this.ty(dx + dWidth / 2, dy + dHeight / 2);

      _mtx4.elements[0] = xform[0];
      _mtx4.elements[1] = xform[1];
      _mtx4.elements[4] = xform[2];
      _mtx4.elements[5] = xform[3];
      _mtx4.elements[12] = xform[4];
      _mtx4.elements[13] = xform[5];
      _mtx4.decompose(_offset, _quat, _scale);

      //Get scaled width/height. Note these scalings can result in negative numbers
      var w = dWidth * _scale.x * this.toPageUnits;
      var h = -dHeight * _scale.y * this.toPageUnits; //Image input is y-down, so we build in a y-inversion

      //Derive the rotation angle by converting the quaternion to axis-angle.
      var s = Math.sqrt(1.0 - _quat.w * _quat.w);
      _axis.set(_quat.x / s, _quat.y / s, _quat.z / s);
      var angle = 2.0 * Math.acos(Math.max(Math.min(1, _quat.w), -1));
      //Take care to negate the angle if the rotation axis is into the page.
      if (_quat.z < 0) {
        angle = -angle;
      }

      //Angle needs to be in the range 0-2pi for use by addTextureQuad below,
      //while input has domain [-pi, pi].
      if (angle < 0) {
        angle += 2 * Math.PI;
      }

      this.flushBuffer(0, true);
      this.currentVbb.addTexturedQuad(cx, cy, w, h, angle, 0xffff00ff, 0, this.currentLayerId, 0);
      this.currentImage = image;
      this.flushBuffer(0, true, false);

      //        console.log("draw Image", sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    }

    /**
       * Mapping back the reference object to its value, and loop 1 level in
       * @param {Object} properties 
       */ }, { key: "_processProperties", value: function _processProperties(
    properties) {
      if (LmvCanvasContext.isRef(properties)) {
        properties = this.pdfRefMap[LmvCanvasContext.refKey(properties)];
      }

      for (var key in properties) {
        if (LmvCanvasContext.isRef(properties[key])) {
          properties[key] = this.pdfRefMap[LmvCanvasContext.refKey(properties[key])];
        }
      }
      return properties;
    } }, { key: "beginMarkedContent", value: function beginMarkedContent(

    properties) {
      if (properties) {
        properties = this._processProperties(properties);
      }

      // Revit will provided tag as number
      var tag = properties.name || properties.DBID;
      if (!isNaN(tag)) {
        this.taggedId = parseInt(tag);
      } else {
        this.taggedId = null;
      }

      if (this.taggedId != null && this.dbId != this.taggedId) {
        this.updateDBId();
      }

      if (properties.VP) {
        this.currentVpId = this.viewports.length;
        this.viewports.push(this.createViewPortData(JSON.parse(properties.VP), properties.UNITS));
      }

      this.ocgStack.push({
        taggedId: this.taggedId,
        viewPortId: this.currentVpId });

    } }, { key: "beginMarkedContentProps", value: function beginMarkedContentProps(

    tag, properties) {
      if (properties) {
        properties = this._processProperties(properties);
      }

      if (tag === "OC") {
        var ocgId = properties.ocgId;
        var layerId = this.layers[ocgId];
        if (layerId == undefined) {
          layerId = this.defaultLayerId;
        }
        this.currentLayerId = layerId;

        this.ocgStack.push({
          layerId: this.currentLayerId });

      } else {
        if (!isNaN(tag)) {
          this.taggedId = parseInt(tag);
          if (this.dbId != this.taggedId) {
            this.updateDBId();
          }
        }
        if (properties) {
          if (properties.VP) {
            this.currentVpId = this.viewports.length;
            this.viewports.push(this.createViewPortData(JSON.parse(properties.VP), properties.UNITS));
          }

          this.ocgStack.push({
            viewPortId: this.currentVpId,
            taggedId: this.taggedId });

        } else {
          this.ocgStack.push({});

        }
      }
    } }, { key: "endMarkedContent", value: function endMarkedContent()

    {
      var previousState = this.ocgStack.pop();
      var previousTagId = this.taggedId;
      if (previousState) {
        // reset the state
        if (previousState.taggedId != null) {
          this.taggedId = null;
        }
        if (previousState.layerId) {
          this.currentLayerId = this.defaultLayerId;
        }
        if (previousState.viewPortId) {
          this.currentVpId = this.defaultVPId;
        }
      }

      if (this.ocgStack.length > 0) {
        var state = this.ocgStack[this.ocgStack.length - 1];
        if (state.taggedId != null) {
          this.taggedId = state.taggedId;
        }
        if (state.currentLayerId != null) {
          this.currentLayerId = state.currentLayerId;
        }
        if (state.viewPortId != null) {
          this.currentVpId = state.viewPortId;
        }
      } else {
        this.currentLayerId = this.defaultLayerId;
        this.taggedId = null;
        this.currentVpId = this.defaultVPId;
      }

      if (previousTagId != this.taggedId) {
        this.updateDBId();
      }
    } }, { key: "setLineStyleParam", value: function setLineStyleParam(

    param) {
      if (!this.lineStyleInitialized) {
        // Add those default definition in, to keep the app constent.
        var exH = avp.LineStyleDefs.length;
        var exW = 1;
        for (var i = 0; i < avp.LineStyleDefs.length; i++) {
          exW = Math.max(avp.LineStyleDefs[i].def.length, exW);
        }var _avp$createLinePatter =

        avp.createLinePatternTextureData(Math.max(param.width, exW), param.height + exH + 1),tex = _avp$createLinePatter.tex,pw = _avp$createLinePatter.pw,lineStyleTex = _avp$createLinePatter.lineStyleTex;
        this.lineStyleIndex = 0;
        this.lineStylePw = pw;
        this.lineStyleTexData = tex;
        this.lineStyleTexture = lineStyleTex;
        this.lineStyleIndexMap = {};

        for (var i = 0; i < avp.LineStyleDefs.length; i++) {
          this.addNewDashedLineStyle(avp.LineStyleDefs[i], 96);
        }

        // set the default value
        this.lineStyle = 0;
        this.lineStyleInitialized = true;
      }
    } }, { key: "addNewDashedLineStyle", value: function addNewDashedLineStyle(

    ls, dpi) {
      var key = ls.def.join("/");
      if (this.lineStyleIndexMap[key] != undefined) {
        return this.lineStyleIndexMap[key];
      } else {
        avp.createLinePatternForDef(ls, this.lineStyleTexData, this.lineStyleIndex, this.lineStylePw, dpi);
        var index = this.lineStyleIndex;
        this.lineStyleIndexMap[key] = index;
        this.lineStyleIndex++;

        return index;
      }
    } }, { key: "setLineDash", value: function setLineDash(

    def) {
      if (!this.lineStyleInitialized) {
        this.setLineStyleParam({ width: 5, height: 4 });
      }

      this.lineDashedDef = def;
    } }, { key: "updateLineDashStyle", value: function updateLineDashStyle()

    {
      // need apply the transformation matrix to the dashed value
      var def = this.lineDashedDef;

      if (def) {
        if (def.length > 0) {
          var xform = this.getCurrentTransform();
          var def1 = [];
          for (var i = 0; i < def.length; i++) {
            var x = (def[i] * xform[0] + def[i] * xform[2]) * this.toPageUnits;
            x = parseFloat(x.toFixed(6));
            def1.push(x);
          }
          // 96 DPI was defined for lineStyleDef.js, and shader were expecting that value
          // when we parse the pdf, the effective dpi need to be ==> 96 / 72 / this.toPageUnits
          this.lineStyle = this.addNewDashedLineStyle({ def: def1 }, 96 / 72 / this.toPageUnits);
        } else {
          this.lineStyle = 0;
        }
      }
      // In case of user directly controlled the line style
      // Do not set lineStyle to 0 here.
    } }, { key: "setCircleInfo", value: function setCircleInfo(

    circleInfo) {
      this.circleInfo = circleInfo;
    } }, { key: "setCurrentOperatorIndex", value: function setCurrentOperatorIndex(

    index) {
      if (this.circleInfo && this.circleInfo[index]) {
        var xform = this.getCurrentTransform();
        var x = this.tx(this.circleInfo[index][0], this.circleInfo[index][1], xform);
        var y = this.ty(this.circleInfo[index][0], this.circleInfo[index][1], xform);

        // Inject the center of the circle
        var c = this.currentVbb.addVertexLine(x, y, 0, 0.0001, 0, 0, 1, this.dbId, this.currentLayerId, this.currentVpId);
        this.currentVbb.finalizeQuad(c);
      }
    }

    // Set custom tesselation params for bezier arcs (see Bezier.h)
    // If undefined, we use the default settings.
  }, { key: "setTessParams", value: function setTessParams(tessParams) {
      this.tessParams = tessParams;
    } }, { key: "finish", value: function finish()

    {
      this.flushBuffer(0, true);
      this.fontAtlas = null;
    } }, { key: "createViewPortData", value: function createViewPortData(

    matrix, units) {
      return {
        "units": units || "feet and inches",
        "transform": matrix,
        "geom_metrics": this.initGeomMetrics() };

    }

    //Initializes a structure of counters used for statistical purposes and sheet content hash
  }, { key: "initGeomMetrics", value: function initGeomMetrics() {
      return {
        "arcs": 0,
        "circles": 0,
        "circ_arcs": 0,
        "viewports": 0,
        "clips": 0,
        "colors": 0,
        "db_ids": 0,
        "dots": 0,
        "fills": 0,
        "layers": 0,
        "line_caps": 0,
        "line_joins": 0,
        "line_patterns": 0,
        "line_pat_refs": 0,
        "plines": 0,
        "pline_points": 0,
        "line_weights": 0,
        "links": 0,
        "miters": 0,
        "ptris": 0,
        "ptri_indices": 0,
        "ptri_points": 0,
        "rasters": 0,
        "texts": 0,
        "strings": [] };

    } }]);return LmvCanvasContext;}();

/***/ }),

/***/ "./extensions/PDF/bezier.js":
/*!**********************************!*\
  !*** ./extensions/PDF/bezier.js ***!
  \**********************************/
/*! exports provided: SetTesselationParams, TesselateCubic, TesselateQuad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTesselationParams", function() { return SetTesselationParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateCubic", function() { return TesselateCubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateQuad", function() { return TesselateQuad; });


var TessParams = {
  //How many forward iterations to use when approximating Bezier curves
  //More iterations are needed in case the min_seg_len setting below is smaller
  //relative to mesh size. However, the two numbers need to be tuned together
  //so that NUM_ITERATIONS is enough to result in segment lengths desired.

  //Note that those values are tuned for PDF rendering, where text characters
  //are drawn one by one. If a long piece of text is drawn all at once, then
  //its bounding box will be quite large, so the relative min_seg_len will also
  //be too large and the characters will look coarse. In such cases, we will need
  //to better estimate this by using e.g. the font height only.
  numIterations: 100,

  //What fraction of the bounding sbox should be the minimum length of
  //a segment
  minSegLenFraction: 0.05 };


function SetTesselationParams(num_iterations, min_seg_len_fraction) {
  if (num_iterations)
  TessParams.numIterations = num_iterations;

  if (min_seg_len_fraction)
  TessParams.minSegLenFraction = min_seg_len_fraction;
}


function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams)
{
  tessParams = tessParams || TessParams;

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to 1/100 of the bounds
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  //double dt2 = dt*dt;
  var dt3 = dt * dt * dt;

  var pre1 = 3.0 * dt;
  var pre2 = pre1 * dt;
  var pre3 = pre2 + pre2;
  var pre4 = 6.0 * dt3;

  var temp1x = px1 - 2.0 * px2 + px3;
  var temp1y = py1 - 2.0 * py2 + py3;
  var temp2x = 3.0 * (px2 - px3) - px1 + px4;
  var temp2y = 3.0 * (py2 - py3) - py1 + py4;

  var fx = px1;
  var fy = py1;
  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;
  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;
  var ddfx = temp1x * pre3 + temp2x * pre4;
  var ddfy = temp1y * pre3 + temp2y * pre4;
  var dddfx = temp2x * pre4;
  var dddfy = temp2y * pre4;

  var error = 0.0;

  // forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;
    ddfy += dddfy;
    ddfx += dddfx;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) //add segment only if we have reached treshold length
      {
        // line to current
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px4, py4);
}

function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams)
{
  tessParams = tessParams || TessParams;

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  var dt2 = dt * dt;

  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?
  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?

  var bx = 2.0 * (px2 - px1);
  var by = 2.0 * (py2 - py1);

  var fx = px1;
  var fy = py1;
  var dfx = bx * dt + ax * dt2;
  var dfy = by * dt + ay * dt2;
  var ddfx = 2.0 * ax * dt2;
  var ddfy = 2.0 * ay * dt2;

  var error = 0.0;

  //forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) // how many pixels should each line be?)
      {
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px3, py3);
}

/***/ }),

/***/ "./extensions/PDF/path2d.js":
/*!**********************************!*\
  !*** ./extensions/PDF/path2d.js ***!
  \**********************************/
/*! exports provided: Path2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path2D", function() { return Path2D; });
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");




//Helper for converting complex HTML Canvas paths to simple polylines / polygons


var MOVETO = 0,
LINETO = 1,
ARC = 2,
ARCTO = 3,
QUADTO = 4,
CUBICTO = 5,
CLOSE = 7;


var _v2 = new THREE.Vector2();
var _tmpBox = new THREE.Box2();

function Path2D(precisionTolerance) {
  this.segTypes = [];
  this.segData = [];
  this.hasCurves = false;
  this.bbox = new THREE.Box2();
  this.precisionTolerance = precisionTolerance;
}

// Optional: Use custom tesselation params for bezier arcs. Undefined sets to default.
Path2D.prototype.setTessParams = function (tessParams) {
  this.tessParams = tessParams;
};

Path2D.prototype.closePath = function () {
  if (this.segTypes.length && this.segTypes[this.segTypes.length - 1] === CLOSE)
  return;
  this.segTypes.push(CLOSE);
};


Path2D.prototype.moveTo = function (x, y) {
  this.segTypes.push(MOVETO);
  this.segData.push(x, y);

  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.lineTo = function (x, y) {
  this.segTypes.push(LINETO);
  this.segData.push(x, y);

  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
  this.hasCurves = true;
  this.segTypes.push(ARC);
  this.segData.push(x, y, radius, startAngle, endAngle, anticlockwise);

  this.bbox.expandByPoint(_v2.set(x, y)); //TODO: all corners
};

Path2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {
  this.hasCurves = true;
  this.segTypes.push(ARCTO);
  this.segData.push(x1, y1, x2, y2, radius);

  this.bbox.expandByPoint(_v2.set(x1, y1));
  this.bbox.expandByPoint(_v2.set(x2, y2));
};

Path2D.prototype.quadraticCurveTo = function (cp1x, cp1y, x, y) {
  this.hasCurves = true;
  this.segTypes.push(QUADTO);
  this.segData.push(cp1x, cp1y, x, y);

  this.bbox.expandByPoint(_v2.set(cp1x, cp1y));
  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
  this.hasCurves = true;
  this.segTypes.push(CUBICTO);
  this.segData.push(cp1x, cp1y, cp2x, cp2y, x, y);
  this.bbox.expandByPoint(_v2.set(cp1x, cp1y));
  this.bbox.expandByPoint(_v2.set(cp2x, cp2y));
  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.flatten = function (forceCloseContours) {

  var ret = new Path2D(this.precisionTolerance);

  var dataOffset = 0;
  var lastX = 0;
  var lastY = 0;
  var contourStartX = lastX;
  var contourStartY = lastY;

  var segTypes = this.segTypes;
  var segData = this.segData;

  var sz = this.bbox.size().length();

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          if (forceCloseContours) {
            if (lastX !== contourStartX || lastY !== contourStartY) {
              ret.closePath();
            }
          }

          lastX = segData[dataOffset++];
          lastY = segData[dataOffset++];
          contourStartX = lastX;
          contourStartY = lastY;
          ret.moveTo(lastX, lastY);
        }
        break;
      case CLOSE:
        ret.closePath();
        break;
      case LINETO:{
          var x = segData[dataOffset++];
          var y = segData[dataOffset++];

          if (x !== lastX || y !== lastY) {
            ret.lineTo(x, y);

            lastX = x;
            lastY = y;
          }
        }
        break;
      case QUADTO:{
          var cp1x = segData[dataOffset++],cp1y = segData[dataOffset++],
          x = segData[dataOffset++],y = segData[dataOffset++];
          Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["TesselateQuad"])(ret, lastX, lastY, cp1x, cp1y, x, y, sz, this.tessParams);
          //ret.lineTo(cp1x, cp1y);ret.lineTo(x.y);

          lastX = x;
          lastY = y;
        }
        break;
      case CUBICTO:{
          var cp1x = segData[dataOffset++],cp1y = segData[dataOffset++],
          cp2x = segData[dataOffset++],cp2y = segData[dataOffset++],
          x = segData[dataOffset++],y = segData[dataOffset++];
          Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["TesselateCubic"])(ret, lastX, lastY, cp1x, cp1y, cp2x, cp2y, x, y, sz, this.tessParams);
          //ret.lineTo(cp1x, cp1y);ret.lineTo(cp2x,cp2y);ret.lineTo(x.y);

          lastX = x;
          lastY = y;
        }
        break;
      case ARC:
        console.warn("not implemented: arc");
        dataOffset += 6;
        break;
      case ARCTO:
        console.warn("not implemented: arcto");
        dataOffset += 4;
        break;}

  }

  if (forceCloseContours) {
    if (lastX !== contourStartX || lastY !== contourStartY) {
      ret.closePath();
    }
  }

  return ret;
};


Path2D.prototype.stroke = function (loader, lineWidth, color, dbId, layerId, clipPath, applyTransform, lineStyle) {

  if (clipPath) {
    var outCode = clipPath.isAABBContain(this.bbox);
    if (outCode === OUTSIDE)
    return;
  }

  var p = this;
  if (applyTransform || this.hasCurves) {
    p = this.flatten(false);
  }

  var xform;
  if (applyTransform) {
    xform = loader.getCurrentTransform();
  }

  var dataOffset = 0;
  var lastX = 0;
  var lastY = 0;
  var contourStartX = 0;
  var contourStartY = 0;

  var segTypes = p.segTypes;
  var segData = p.segData;

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          lastX = segData[dataOffset++];
          lastY = segData[dataOffset++];
          contourStartX = lastX;
          contourStartY = lastY;
        }
        break;
      case CLOSE:
      case LINETO:{
          var x = st === CLOSE ? contourStartX : segData[dataOffset++];
          var y = st === CLOSE ? contourStartY : segData[dataOffset++];

          if (x !== lastX || y !== lastY) {
            loader.flushBuffer(4);

            if (applyTransform) {
              loader.currentVbb.addSegment(
              loader.tx(lastX, lastY, xform), loader.ty(lastX, lastY, xform),
              loader.tx(x, y, xform), loader.ty(x, y, xform),
              /*totalDistance*/0, lineWidth, color, dbId, layerId, loader.currentVpId || 0, lineStyle);

            } else {
              loader.currentVbb.addSegment(
              lastX, lastY,
              x, y,
              /*totalDistance*/0, lineWidth, color, dbId, layerId, loader.currentVpId || 0, lineStyle);

            }

            lastX = x;
            lastY = y;
          }
        }
        break;
      default:{
          console.error("Path must be flattened before rendering");
        }}



  }

};


//Checks if the path is a simple AABB.
//Used to speed up polygon clipping operations.
Path2D.prototype.isAABB = function () {

  var EPS = 1e-10;
  var ANGLE_EPS = 1e-3;

  var st = this.segTypes;

  if (st.length !== 6 && st.length !== 5)
  return false;

  if (st[0] !== MOVETO)
  return false;

  if (st.length === 6 && st[5] !== CLOSE)
  return false;else
  if (st.length === 5 && st[4] !== CLOSE && st[4] !== LINETO)
  return false;

  for (var i = 1; i < st.length - 1; i++) {
    if (st[i] !== LINETO)
    return false;}


  var seg = this.segData;

  //check segments 1 and 3 for parallel and same length
  var dxA = seg[2] - seg[0];
  var dyA = seg[3] - seg[1];
  var dxC = seg[6] - seg[4];
  var dyC = seg[7] - seg[5];
  var lenA = Math.sqrt(dxA * dxA + dyA * dyA);
  var lenC = Math.sqrt(dxC * dxC + dyC * dyC);

  if (Math.abs(lenA - lenC) > EPS)
  return false;

  dxA /= lenA;dyA /= lenA;
  dxC /= lenC;dyC /= lenC;
  var dot = dxA * dxC + dyA * dyC;

  if (Math.abs(1 + dot) > ANGLE_EPS)
  return false;

  //check segments 2 and 4 for parallel and same length
  var dxB = seg[4] - seg[2];
  var dyB = seg[5] - seg[3];
  var dxD = seg[8] - seg[6];
  var dyD = seg[9] - seg[7];
  var lenB = Math.sqrt(dxB * dxB + dyB * dyB);
  var lenD = Math.sqrt(dxD * dxD + dyD * dyD);

  if (Math.abs(lenB - lenD) > EPS)
  return false;

  dxB /= lenB;dyB /= lenB;
  dxD /= lenD;dyD /= lenD;
  dot = dxB * dxD + dyB * dyD;

  if (Math.abs(1 + dot) > ANGLE_EPS)
  return false;

  //make sure there is a right angle
  dot = dxA * dxB + dyA * dyB;

  if (Math.abs(dot) > ANGLE_EPS)
  return false;

  //make sure segments are vertical/horizontal
  if (Math.abs(dxA) > EPS && Math.abs(dyA))
  return false;

  return true;
};

var INSIDE = 1;
var OUTSIDE = 2;
var UNKNOWN = 4;

function bboxOverlap(clipBox, pathBox, precisionTolerance) {

  if (clipBox.containsBox(pathBox))
  return INSIDE;

  //The above AABB containment check is exact
  //and sometimes misses cases where the bboxes are
  //almost exactly equal, with very slight numeric noise in the values
  //(which happens quite often with Revit PDFs)

  //So now do another check if our bbox contains the input bbox within a tolerance
  var EPS = precisionTolerance;

  if (EPS === undefined) {
    EPS = 1e-3 / clipBox.size().length();
  }

  if (pathBox.min.x - clipBox.max.x > EPS)
  return OUTSIDE;
  if (pathBox.min.y - clipBox.min.y > EPS)
  return OUTSIDE;

  if (pathBox.max.x - clipBox.max.x < -EPS)
  return OUTSIDE;
  if (pathBox.max.y - clipBox.max.y < -EPS)
  return OUTSIDE;

  if (pathBox.min.x - clipBox.min.x < -EPS)
  return UNKNOWN;
  if (pathBox.min.y - clipBox.min.y < -EPS)
  return UNKNOWN;

  if (pathBox.max.x - clipBox.max.x > EPS)
  return UNKNOWN;
  if (pathBox.max.y - clipBox.max.y > EPS)
  return UNKNOWN;

  return INSIDE;
}

Path2D.prototype.isAABBContain = function (bbox) {

  if (!this.isAABB())
  return UNKNOWN;

  return bboxOverlap(this.bbox, bbox, this.precisionTolerance);
};


Path2D.prototype._addToDCEL = function (dcel, dbId, skipClipping) {
  var segTypes = this.segTypes;
  var segData = this.segData;
  var dataOffset = 0;

  var startX = 0,startY = 0,lastX = 0,lastY = 0;

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          //Force close the contour if it's not closed.
          if (lastX !== startX || lastY !== startY) {
            dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
          }

          lastX = startX = segData[dataOffset++];
          lastY = startY = segData[dataOffset++];
        }
        break;
      case CLOSE:{
          dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
        }
        break;
      case LINETO:{
          var x = segData[dataOffset++];
          var y = segData[dataOffset++];
          dcel.addDirectedEdge(lastX, lastY, x, y, skipClipping, dbId);
          lastX = x;
          lastY = y;
        }
        break;}

  }

  //Force close the contour if it's not closed.
  if (lastX !== startX || lastY !== startY) {
    dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
  }
};

//Attempts to triangulate a closed path using the simplest ComplexPolygon way
//assuming there are no self-intersecting edges (but there could be holes or multiple closed regions)
//Attempts to eliminate coincident points
function triangulateEasy(path) {

  if (!path.segTypes.length)
  return null;

  var ContourSet = Autodesk.Viewing.Extensions.CompGeom.ContourSet;
  var UniquePointList = Autodesk.Viewing.Extensions.CompGeom.UniquePointList;

  var cset = new ContourSet();
  var verts = new UniquePointList(path.bbox);

  var segTypes = path.segTypes;
  var segData = path.segData;
  var dataOffset = 0;

  var last;
  var curcntr = [];

  function addContour(c) {

    if (!c.length)
    return;

    //Detect degenerate contours which we sometimes get from opentype.js fonts
    var isDegenerate = false;
    var isClosed = c[0] === c[c.length - 1];

    //TODO: this needs to be extended to check for something like zero area
    //that will catch more degenerate cases.
    if (isClosed && c.length <= 3)
    isDegenerate = true;

    if (!isClosed)
    console.log("Unexpected non-closed polygon contour");

    if (!isDegenerate)
    cset.addContour(c, true);
  }

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          addContour(curcntr);
          last = verts.findOrAddPoint(segData[dataOffset], segData[dataOffset + 1]);
          dataOffset += 2;
          curcntr = [last];
        }
        break;
      case CLOSE:{
          if (curcntr[0] !== curcntr[curcntr.length - 1])
          curcntr.push(curcntr[0]);

          addContour(curcntr);
          curcntr = [];
        }
        break;
      case LINETO:{
          last = verts.findOrAddPoint(segData[dataOffset], segData[dataOffset + 1]);
          dataOffset += 2;

          if (last !== curcntr[curcntr.length - 1])
          curcntr.push(last);
        }
        break;
      default:{
          console.warn("Path must be flattened before triangulating.");
          break;
        }}

  }


  addContour(curcntr);

  cset.triangulate();

  return cset;
}

//Triangulates a closed path using the DCEL structure, which allows self-intersecting polygons
function triangulateComplex(path) {

  //CompGeom extension is delay loaded, so we have to get the namespace later.
  var DCEL = Autodesk.Viewing.Extensions.CompGeom.DCEL;

  var dcel = new DCEL(path.bbox);

  path._addToDCEL(dcel, 1, false);

  dcel.finalize(true);

  return dcel.closedAreas;
}

function triangulateComplexBoolean(pathA, pathB, booleanOp) {

  //CompGeom extension is delay loaded, so we have to get the namespace later.
  var DCEL = Autodesk.Viewing.Extensions.CompGeom.DCEL;

  if (!booleanOp)
  booleanOp = "AND";

  //Polygon - polygon clip.
  //This way of performing the polygon intersection leaves a lot
  //to be optimized -- in particularm, we can make do with a single
  //DCEL structure, or remember the starting DCEL for the clip region in case it's used multiple times, etc.

  //Get a DCEL containing edges and split edges
  //from both polygons
  var totalBox = pathA.bbox.clone().union(pathB.bbox);
  var dcel = new DCEL(totalBox, Math.min(pathA.precisionTolerance, pathB.precisionTolerance));
  pathA._addToDCEL(dcel, 1);
  pathB._addToDCEL(dcel, 2);

  //TODO: here we can try the easier way of only creating
  //and edge list or quad tree of edges for containment checks
  //without explicitly triangulating
  var csetA = triangulateEasy(pathA);
  var csetB = triangulateEasy(pathB);

  if (!csetA) {
    return csetB;
  }
  if (!csetB) {
    return csetA;
  }

  //Is it a degenerate polygon (e.g. line segment)
  if (!csetA.contours.length) {
    return booleanOp === "AND" ? csetA : csetB;
  }
  if (!csetB.contours.length) {
    return booleanOp === "AND" ? csetB : csetA;
  }


  var pA = csetA.polygon;
  var pB = csetB.polygon;

  var getPolygonOp = function getPolygonOp() {
    switch (booleanOp) {
      case "AND":
        return function (cx, cy) {
          return pA.pointInPolygon(cx, cy) && pB.pointInPolygon(cx, cy);
        };
      case "XOR":
        return function (cx, cy) {
          return pA.quadTreeEdges.pointInPolygon(cx, cy) ^ pB.quadTreeEdges.pointInPolygon(cx, cy);
        };
      case "OR":
        return function (cx, cy) {
          return pA.pointInPolygon(cx, cy) || pB.pointInPolygon(cx, cy);
        };
      default:
        return undefined;}

  };

  var customInsideChecker = {
    pointInPolygon: getPolygonOp() };


  dcel.finalize(true, customInsideChecker);

  return dcel.closedAreas;
}


//Used for caching triangulates font characters
Path2D.prototype.cacheTriangulation = function () {

  //Unfortunately we cannot skip the flattening
  //for text glyphs when hasCurves is false, because
  //we need to check that all the contour are closed.
  //Not all fonts are disciplined about explicitly closing
  //their glyph outlines.
  this.flattened = this.flatten(true);

  var cset;

  cset = triangulateEasy(this.flattened);

  //convert to a contour set and triangulate

  var polygon = cset ? cset.polygon : null;

  this.polygon = [polygon];
  if (polygon) {
    this.flattened.polygon = this.polygon;
  }
};


Path2D.prototype.clip = function (clipPath, mode) {

  var p = this;
  var clipBox = p.bbox;

  var clipOut = false;
  var nonClippedOutline;

  //Check usual simple cases where one of the clips is the whole page rectangle and completely
  //contains the other.
  if (clipPath.isAABB()) {

    var outCode = bboxOverlap(clipPath.bbox, clipBox, this.precisionTolerance);

    if (outCode === OUTSIDE) {
      clipOut = true;
    } else if (outCode === INSIDE) {
      nonClippedOutline = p;
    }

  } else if (p.isAABB()) {

    var _outCode = bboxOverlap(clipBox, clipPath.bbox, this.precisionTolerance);

    if (_outCode === OUTSIDE) {
      clipOut = true;
    } else if (_outCode === INSIDE) {
      nonClippedOutline = clipPath;
    }
  }

  if (clipOut) {
    //TODO: actually here the clip region should be an empty region,
    //that clips out everything, but I'd rather leave it like this
    //to see if this ever happens.
    return null;
  }

  if (nonClippedOutline) {
    return nonClippedOutline;
  }

  //Catch-all complex clip case
  if (!clipOut && !nonClippedOutline) {

    console.log("Complex clipped clip.");

    var closedAreas = triangulateComplexBoolean(clipPath, p, "AND");

    //convert the contour set back to Path2D so we can return a clip path
    var res = new Path2D(this.precisionTolerance);

    for (var i = 0; i < closedAreas.length; i++) {

      var subp = closedAreas[i];

      for (var j = 0; j < subp.contours.length; j++) {

        var pts = subp.contours[j];

        for (var _i = 0; _i < pts.length; _i++) {
          var x = pts[_i].x;
          var y = pts[_i].y;

          if (_i === 0)
          res.lineTo(x, y);else

          res.moveTo(x, y);
        }

        res.closePath();
      }
    }

    return res;
  }

};


Path2D.prototype.fill = function (loader, color, dbId, layerId, clipPathIn, applyTransform) {

  //Unfortunately we cannot skip the flattening
  //for text glyphs when hasCurves is false, because
  //we need to check that all the contour are closed.
  //Not all fonts are disciplined about explicitly closing
  //their glyph outlines.
  var p = this.flattened || this.flatten(true);
  var clipPath;
  if (clipPathIn) {
    clipPath = clipPathIn.flattened || clipPathIn.flatten(true);
    clipPathIn.flattened = clipPath;
  }


  var polygon = p.polygon; //did we already cache the triangulation?

  //If the path is from a glyph cache, we need to transform its bbox
  //to current model space for clipping purposes
  var myClipBox = this.bbox;
  var xform;
  if (applyTransform) {
    xform = loader.getCurrentTransform();
    //TODO: This will not work if there is a rotation and the path to
    //be drawn has a transform.
    myClipBox = loader.transformBox(myClipBox, xform, _tmpBox);
  }

  var cset;
  var nonClippedOutline;
  var clipOut = false;

  var flagged = false;

  //TODO: in case of complex clip we would have to apply the transform (if any) before
  //clipping the polygons with each other.
  var ignoreClip = false;
  if (applyTransform && clipPath) {
    // do a simple check
    var outCode = bboxOverlap(clipPath.bbox, myClipBox, this.precisionTolerance);
    if (outCode === OUTSIDE) {
      ignoreClip = false;
    } else {
      ignoreClip = true;
    }
  }


  if (!ignoreClip && clipPath) {

    //Special cases -- in PDFs, the path is often a simple AABB
    //used to color-fill a complicated region polygon that is set as clip.
    //It's possible that the path being draw is a simple rectangle and the clip
    //region is super complex (as opposed to simple rect clip and a complex path),
    //so we have to check both cases.

    //TODO: This is kind of a copy of Path2D.clip(), but not exactly. It might be
    //possible to unify the logic.
    if (clipPath.isAABB()) {

      var _outCode2 = bboxOverlap(clipPath.bbox, myClipBox, this.precisionTolerance);

      if (_outCode2 === OUTSIDE) {
        clipOut = true;
      } else if (_outCode2 === INSIDE) {

        if (!polygon) {
          cset = triangulateEasy(p);

          if (!cset.triangulationFailed) {
            nonClippedOutline = p;
          }
        }
      }

    } else if (p.isAABB()) {

      var _outCode3 = bboxOverlap(myClipBox, clipPath.bbox, this.precisionTolerance);

      if (_outCode3 === OUTSIDE) {
        clipOut = true;
      } else if (_outCode3 === INSIDE) {

        if (!polygon)
        cset = triangulateEasy(clipPath);

        if (cset && !cset.triangulationFailed) {
          nonClippedOutline = clipPath;
        }
      }
    }

    //Catch-all complex clip case or when triangulation
    //fails above
    if (!clipOut && !nonClippedOutline) {

      //console.log("Complex clip");

      //flagged = true;

      cset = triangulateComplexBoolean(clipPath, p, "AND");

      //DEBUG:
      //clipPath.stroke(loader, -2.0, /*color*/0xff00ffff, -2, layerId);
      //p.stroke(loader, -2.0, /*color*/0xffffff00, -2, layerId);
    }

  } else {

    if (!polygon)
    cset = triangulateEasy(p);

    if (cset && cset.triangulationFailed) {
      cset = triangulateComplex(p);
    }

    nonClippedOutline = p;
  }

  //convert to a contour set and triangulate
  if (cset) {
    if (Array.isArray(cset))
    polygon = cset.map(function (c) {return c.polygon;});else

    polygon = [cset.polygon];
  }

  if (clipOut || !polygon) {
    return;
  }

  for (var i = 0; i < polygon.length; i++) {

    var subp = polygon[i];

    if (subp && subp.indices && subp.indices.length) {

      var pts = subp.pts;

      var pts2d = [];
      for (var _i2 = 0; _i2 < pts.length; _i2++) {
        var x = pts[_i2].x;
        var y = pts[_i2].y;

        if (applyTransform)
        pts2d.push(loader.tx(x, y, xform), loader.ty(x, y, xform));else

        pts2d.push(x, y);
      }

      loader.addPolyTriangle(pts2d, subp.indices, color, dbId, layerId, !nonClippedOutline);

      //Add thin outline to achieve an antialias effect
      if (nonClippedOutline)
      nonClippedOutline.stroke(loader, -0.5, color, dbId, layerId, null, applyTransform);

    }

  }

  //Debug only
  if (flagged) {
    //This code path highlights failed triangulations
    if (clipPath) {
      clipPath.stroke(loader, -3.0, 0xff00ff00, dbId, layerId, applyTransform);
      p.stroke(loader, -3.0, 0xff0000ff, dbId, layerId, applyTransform);
    } else {
      p.stroke(loader, -3.0, 0xffff00ff, dbId, layerId, applyTransform);
    }
  }

};

/***/ }),

/***/ "./extensions/PDF/test-pattern.js":
/*!****************************************!*\
  !*** ./extensions/PDF/test-pattern.js ***!
  \****************************************/
/*! exports provided: addContextCurrentTransform, generateTestPattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addContextCurrentTransform", function() { return addContextCurrentTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateTestPattern", function() { return generateTestPattern; });
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");



//Copied from pdf.js, because our 2D renderer relies on mozCurrentTransform being available
function addContextCurrentTransform(ctx) {
  if (!ctx.mozCurrentTransform) {
    ctx._originalSave = ctx.save;
    ctx._originalRestore = ctx.restore;
    ctx._originalRotate = ctx.rotate;
    ctx._originalScale = ctx.scale;
    ctx._originalTranslate = ctx.translate;
    ctx._originalTransform = ctx.transform;
    ctx._originalSetTransform = ctx.setTransform;
    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
    ctx._transformStack = [];
    Object.defineProperty(ctx, 'mozCurrentTransform', {
      get: function getCurrentTransform() {
        return this._transformMatrix;
      } });

    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
      get: function getCurrentTransformInverse() {
        var m = this._transformMatrix;
        var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        e = m[4],
        f = m[5];
        var ad_bc = a * d - b * c;
        var bc_ad = b * c - a * d;
        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
      } });

    ctx.save = function ctxSave() {
      var old = this._transformMatrix;
      this._transformStack.push(old);
      this._transformMatrix = old.slice(0, 6);
      this._originalSave();
    };
    ctx.restore = function ctxRestore() {
      var prev = this._transformStack.pop();
      if (prev) {
        this._transformMatrix = prev;
        this._originalRestore();
      }
    };
    ctx.translate = function ctxTranslate(x, y) {
      var m = this._transformMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
      this._originalTranslate(x, y);
    };
    ctx.scale = function ctxScale(x, y) {
      var m = this._transformMatrix;
      m[0] = m[0] * x;
      m[1] = m[1] * x;
      m[2] = m[2] * y;
      m[3] = m[3] * y;
      this._originalScale(x, y);
    };
    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
      ctx._originalTransform(a, b, c, d, e, f);
    };
    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
      this._transformMatrix = [a, b, c, d, e, f];
      ctx._originalSetTransform(a, b, c, d, e, f);
    };
    ctx.rotate = function ctxRotate(angle) {
      var cosValue = Math.cos(angle);
      var sinValue = Math.sin(angle);
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
      this._originalRotate(angle);
    };
  }
}


function polygonVerts(N, radius, phase) {

  var res = [];
  radius = radius || 1;
  phase = phase || 0;

  for (var angle = phase; angle < 360 + phase; angle += 360 / N) {

    var a = angle * Math.PI / 180;
    var x = radius * Math.cos(a);
    var y = radius * Math.sin(a);

    res.push(x);
    res.push(y);

  }

  return res;
}


function drawPolygon(ctx, x, y, N, R, phase) {
  var pts = polygonVerts(N, R, phase);

  ctx.beginPath();
  ctx.moveTo(pts[0] + x, pts[1] + y);

  for (var i = 2; i < pts.length; i += 2) {
    ctx.lineTo(pts[i] + x, pts[i + 1] + y);
  }

  ctx.closePath();
}

function drawStarPolygon(ctx, x, y, N, R, phase) {

  var pts = polygonVerts(N, R, phase);

  ctx.beginPath();
  ctx.moveTo(pts[0] + x, pts[1] + y);

  var count = 0;
  var next = 2;
  var total = pts.length / 2;
  while (count < total) {

    ctx.lineTo(pts[2 * next] + x, pts[2 * next + 1] + y);

    next += 2;
    next = next % total;
    count++;
  }

  ctx.closePath();

}


function generateTestPattern(ctx) {

  //Long text strings used in this test need dense tesselation setting compared to their bounding box
  Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["SetTesselationParams"])(300, 0.005);

  var c = ctx.canvasContext;

  addContextCurrentTransform(c);

  //1. Draw the page
  c.fillStyle = "rgba(255, 255, 255, 1)";
  var vp = ctx.viewport;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(vp.width, 0);
  ctx.lineTo(vp.width, vp.height);
  ctx.lineTo(0, vp.height);
  ctx.closePath();
  ctx.fill();

  c.strokeStyle = "rgba(0, 0, 0, 1)";

  //Simple polygon
  c.fillStyle = "rgba(3, 137, 255, 1)";
  drawPolygon(ctx, 120, 50, 5, 30, 90);
  ctx.fill();
  ctx.stroke();

  //Self-intersecting polygon
  c.fillStyle = "rgba(255, 95, 3, 1)";
  drawStarPolygon(ctx, 190, 50, 5, 30, 90);
  ctx.fill();
  ctx.stroke();

  //Simple polygon
  c.fillStyle = "rgba(255, 255, 0, 1)";
  drawPolygon(ctx, 240, 350, 7, 30, 0);
  ctx.fill();
  ctx.stroke();

  //Self-intersecting polygon
  c.fillStyle = "rgba(90, 255, 123, 1)";
  drawStarPolygon(ctx, 310, 350, 7, 30, 0);
  ctx.fill();

  ctx.stroke();

  //Text
  c.fillStyle = "rgba(66, 66, 66, 1)";
  c.save();
  c.translate(50, 150);
  c.scale(1, -1);
  ctx.fillText("The quick brown", 0, 0, 800, { name: "Arial" }, 24);
  c.restore();

  c.save();
  c.translate(50, 186);
  c.scale(1, -1);
  ctx.fillText("fox jumps", 0, 0, 800, { name: "Courier" }, 72);
  c.restore();

  c.save();
  c.translate(50, 350);
  c.scale(1, -1);
  c.rotate(13);
  ctx.fillText("over the lazy dog.", 0, 0, 800, { name: "Times" }, 36);
  c.restore();

  //Polygon clipping
  c.fillStyle = "rgba(91, 167, 255, 1)";
  c.save();

  //Draw a pentagon and use it as clip region also
  drawPolygon(ctx, 150, 450, 5, 30, 90);
  ctx.fill();
  ctx.stroke();
  ctx.clip();

  //Fill a hexagon, taking into account the clip region
  c.fillStyle = "rgba(255, 167, 91, 1)";
  drawPolygon(ctx, 170, 450, 6, 30, 90);
  ctx.fill();

  //Stroke the hexagon -- currently this will not work (i.e. it will draw the outline unclipped)
  c.strokeStyle = "rgba(255, 0, 0, 1)";
  ctx.stroke();

  c.restore();


}

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".adsk-viewing-viewer .edge-gizmo:hover {\n  background-color: lime; }\n\n.adsk-viewing-viewer .edge-gizmo {\n  position: absolute;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  cursor: move;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edge-gizmo.selected {\n  background-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover {\n  border-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 7px;\n  height: 7px;\n  left: -2px;\n  top: -2px;\n  background-color: #009bff;\n  border-style: solid;\n  border-width: 2px;\n  border-color: #FFFFFF;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  cursor: move; }\n\n.adsk-viewing-viewer .vertex-gizmo.selected {\n  border-color: lime; }\n\n.adsk-viewing-viewer .edge-move-gizmo {\n  width: 20px;\n  /* width along the edge */\n  height: 6px;\n  /* height vertical to the edge */ }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Edit2D.js.map